s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if s == u : <NEWLINE> <INDENT> print ( s - 1 t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s t - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> A , B = int ( input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> elif U == T : <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
S , T = map ( input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> A = A - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B = B - 1 <NEWLINE> <DEDENT> print ( A , B ) <NEWLINE>
S , T = input ( ) . split ( ) <NEWLINE> A , B = input ( ) . split ( ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) , split ( ) <NEWLINE> A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> s , t = input ( ) . split ( ) <NEWLINE> a , b = int ( input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if s == u : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b -= 1 <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = str ( input ( ) ) <NEWLINE> <NL> if u = s : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = int ( input ( ) ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> B -= 1 <NEWLINE> <NL> <DEDENT> print ( str ( A ) + <STRING> + str ( B ) ) <NEWLINE>
S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> A , B = map ( str , input ( ) . split ( ) ) <NEWLINE> U = str ( input ( ) ) <NEWLINE> if U == S : <NEWLINE> <INDENT> A -= 1 <NEWLINE> <DEDENT> elif U == T : <NEWLINE> <INDENT> B -= 1 <NEWLINE> <DEDENT> print ( A , B ) <NEWLINE>
S = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> U = int ( input ( ) ) <NEWLINE> <NL> ind = S . index ( U ) <NEWLINE> <NL> A [ ind ] -= 1 <NEWLINE> <NL> print ( <STRING> . join ( A ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if u == s : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> if u == t : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> <NL> if u == s : <NEWLINE> <INDENT> a = a - 1 <NEWLINE> <DEDENT> if u == t : <NEWLINE> <INDENT> b = b - 1 <NEWLINE> <NL> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT>
s , t = map ( input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> t = input ( ) <NEWLINE> if s == t : <NEWLINE> <INDENT> print ( str ( a - 1 ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b - 1 ) ) <NEWLINE> <DEDENT>
S , T = map ( input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if U == S : <NEWLINE> <INDENT> print ( A - 1 ) <NEWLINE> print ( B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A ) <NEWLINE> print ( B - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> if U == S : <NEWLINE> <INDENT> print ( A - 1 , B ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( A , B - 1 ) <NEWLINE> <DEDENT>
S , T = map ( str , input ( ) . split ( ) ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = str ( input ( ) ) <NEWLINE> if U == S : <NEWLINE> <INDENT> A = A - 1 <NEWLINE> <DEDENT> elif U == T : <NEWLINE> <INDENT> B = B - 1 <NEWLINE> <DEDENT> print ( { } { } . format ( A , B ) ) <NEWLINE>
s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> u = str ( input ( ) ) <NEWLINE> if ( u == s ) : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> elif ( u == t ) : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> s , t = map ( input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> if s == u : <NEWLINE> <INDENT> a = a - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = b - 1 <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> print ( a - ( s == u ) , b - ( t == u ) ) <NEWLINE> <DEDENT> reoslve ( ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> <NL> if u == s : <NEWLINE> <INDENT> print ( s - 1 , t ) <NEWLINE> <DEDENT> elif u == t : <NEWLINE> <INDENT> print ( s , t - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split <NEWLINE> A , B = map ( int , input ( ) . split ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> print ( A - 1 ) <NEWLINE> <DEDENT> elif T == U : <NEWLINE> <INDENT> print ( B - 1 ) <NEWLINE> <DEDENT>
S , T = input ( ) . split ( ) <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> U = input ( ) <NEWLINE> print ( A - 1 B if S == U else A B - 1 ) <NEWLINE>
s , t = map ( input ( ) . split ( ) ) <NEWLINE> <NL> a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> u = input ( ) <NEWLINE> <NL> if s == u : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> elif t == u : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
[ H , A ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> t = 0 <NEWLINE> if H / A != int ( H / A ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> <DEDENT> print ( int ( H / A ) + t ) <NEWLINE>
str = input ( ) . split ( <STRING> ) <NEWLINE> S = str [ 0 ] <NEWLINE> T = str [ 1 ] <NEWLINE> num = input ( ) . split ( <STRING> ) <NEWLINE> NS = int ( num [ 0 ] ) <NEWLINE> NT = int ( num [ 1 ] ) <NEWLINE> U = input ( ) <NEWLINE> <NL> if S == U : <NEWLINE> <INDENT> print ( str ( NS - 1 ) + <STRING> + str ( NT ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( NS ) + <STRING> + str ( NT - 1 ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = set ( a ) <NEWLINE> print ( <STRING> if n == len ( b ) , else <STRING> ) <NEWLINE>
s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> u = int ( input ( ) ) <NEWLINE> if s == u : <NEWLINE> <INDENT> print ( a - 1 , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b - 1 ) <NEWLINE> <DEDENT>
s , t = input ( ) . split ( ) <NEWLINE> a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> u = input ( ) <NEWLINE> print ( a - 1 , b ) if s == u else print ( a , b - 1 ) <NEWLINE>
a , b = input ( ) . split <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e = input ( ) <NEWLINE> <NL> if a == e : <NEWLINE> <INDENT> print ( <STRING> . format ( c - 1 , d ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( c , d - 1 ) ) <NEWLINE> <DEDENT>
a = str ( input ( ) ) <NEWLINE> print ( str ( x ) * len ( a ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( x * len ( s ) ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
S = len ( input ( ) ) <NEWLINE> print ( x * S ) <NEWLINE>
print ( x * len ( input ( ) ) ) <NEWLINE>
S = input ( ) <NEWLINE> print ( <STRING> * count ( S ) ) <NEWLINE>
print ( <STRING> * len ( input ( ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( x * len ( s ) ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> l = len ( s ) <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> print ( s ) <NEWLINE>
s = input ( ) <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> T = <STRING> <NEWLINE> for _ in len ( S ) : <NEWLINE> <INDENT> T += <STRING> <NEWLINE> <DEDENT> print ( T ) <NEWLINE>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
S = input ( ) <NEWLINE> L = len [ S ] <NEWLINE> for i in rnage ( L ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> print ( <STRING> ** len ( s ) ) <NEWLINE>
S = input ( ) <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> S [ i ] = <STRING> <NEWLINE> <DEDENT> print ( S ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> an . sort ( ) <NEWLINE> <NL> for x in range ( n - 1 ) : <NEWLINE> <INDENT> if an [ i + 1 ] - an [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def check ( seq ) : <NEWLINE> <INDENT> return len ( seq ) != len ( set ( seq ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> ans = check ( A ) <NEWLINE> if ans : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A . sort ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ( A [ i ] == A [ i + 1 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> cc = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dic = set ( ) <NEWLINE> for i in cc : <NEWLINE> <INDENT> if i in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) ) ) <NEWLINE> S = set ( A ) <NEWLINE> print ( <STRING> if len ( A ) == len ( S ) else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * ( 10 ** 9 + 1 ) <NEWLINE> <NL> for i in a : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> if cnt [ i ] > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> Set = set ( ) <NEWLINE> for i in List : <NEWLINE> <INDENT> if i in Set : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> Set . add ( i ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
m = int ( input ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . split ) ) <NEWLINE> print ( <STRING> if len ( set ( n ) ) == m else <STRING> ) <NEWLINE>
from collections import Counter <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> dic = Counter ( a ) <NEWLINE> for val in dic . values ( ) : <NEWLINE> <INDENT> if val >= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if set ( a ) == len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if n == len ( set ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n = len ( set ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> if N == len ( set ( A ) ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
for p in P : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> exp += ( 1 + p ) / 2 <NEWLINE> p_e . append ( exp ) <NEWLINE> <DEDENT> if n == k : <NEWLINE> <INDENT> print ( p_e [ - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> maxv = p_e [ k - 1 ] - 0 <NEWLINE> for i in range ( 1 , n - k ) : <NEWLINE> <COMMENT> <NL> <INDENT> p_sum = p_e [ k + i ] - p_e [ i ] <NEWLINE> maxv = max ( maxv , p_sum ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> S = [ ] <NEWLINE> sum_ = 0 <NEWLINE> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> sum_ += p <NEWLINE> S . append ( sum_ ) <NEWLINE> <NL> <NL> <DEDENT> max_sum = 0 <NEWLINE> for i in range ( N - K + 1 ) : <NEWLINE> <INDENT> max_sum = max ( max_sum , S [ i + K ] - S [ i ] ) <NEWLINE> <NL> <DEDENT> res = ( max_sum + K ) / 2 <NEWLINE> <NL> print ( res ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + ( ps [ i ] + 1 ) / 2 <NEWLINE> <NL> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( len ( res ) - k ) : <NEWLINE> <INDENT> tmp = max ( tmp , s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( tmp ) ) <NEWLINE>
import numpy <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> s = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s [ i + 1 ] = s [ i ] + ( ps [ i ] + 1 ) / 2 <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> tmp = 0 <NEWLINE> for i in range ( len ( res ) - k ) : <NEWLINE> <INDENT> tmp = max ( tmp , s [ i + k ] - s [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( tmp ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ sum ( p [ : K ] ) ] <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> ans . append ( ans [ - 1 ] - p [ i ] + p [ i + k ] ) <NEWLINE> <DEDENT> print ( max ( ans ) / 2 + K / 2 ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = [ ] <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> q . append ( p [ i ] ) <NEWLINE> <DEDENT> maxi = q [ K ] - q [ 0 ] <NEWLINE> for i in range ( 1 , N - K + 1 ) : <NEWLINE> <INDENT> sub = q [ K + i ] - q [ i ] <NEWLINE> if sub >= maxi : <NEWLINE> <INDENT> maxi = sub <NEWLINE> <DEDENT> <DEDENT> print ( ( maxi + K ) / 2 ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> b = [ 0 ] * k <NEWLINE> c = 0 <NEWLINE> v [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v [ i + 1 ] = v [ i ] + a [ i + 1 ] <NEWLINE> <DEDENT> mx = v [ 2 ] <NEWLINE> for i in range ( 3 , n ) : <NEWLINE> <INDENT> g = v [ i ] - v [ i - 2 ] <NEWLINE> mx = max ( mx , g ) <NEWLINE> <NL> <DEDENT> print ( ( mx + 1 ) / 2 ) <NEWLINE>
import numpy as np <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( ( 1 + p [ i ] ) / 2 ) <NEWLINE> <NL> <DEDENT> a = [ 0 ] * N + 1 <NEWLINE> a [ 0 ] = l [ 0 ] <NEWLINE> for i in range ( 1 , len ( l ) ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + l [ i ] <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( K , len ( l ) ) : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] - a [ i - K ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> m = len ( N ) <NEWLINE> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> l = int ( N [ i - 1 ] ) <NEWLINE> for k in range ( K + 1 ) : <COMMENT> <NEWLINE> <INDENT> if k - 1 >= 0 : <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + dp [ i - 1 ] [ 0 ] [ k ] <COMMENT> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <COMMENT> <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp ) <NEWLINE> print ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] ) <NEWLINE> <NL> N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> m = len ( N ) <NEWLINE> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> l = int ( N [ i - 1 ] ) <NEWLINE> for k in range ( K + 1 ) : <COMMENT> <NEWLINE> <INDENT> if k - 1 >= 0 : <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = 0 <COMMENT> <NEWLINE> dp [ i ] [ 1 ] [ k ] = 1 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] ) <NEWLINE>
N = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> m = len ( N ) <NEWLINE> dp = [ [ [ 0 ] * ( K + 1 ) for _ in range ( 2 ) ] for _ in range ( m + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] [ 0 ] = 1 <COMMENT> <NEWLINE> <NL> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> l = int ( N [ i - 1 ] ) <NEWLINE> for k in range ( K + 1 ) : <COMMENT> <NEWLINE> <INDENT> if k == 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = 0 <COMMENT> <NEWLINE> dp [ i ] [ 1 ] [ k ] = 1 <COMMENT> <NEWLINE> <DEDENT> else k - 1 >= 0 : <NEWLINE> <INDENT> if l != 0 : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] + dp [ i - 1 ] [ 0 ] [ k ] + ( l - 1 ) * dp [ i - 1 ] [ 0 ] [ k - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ 0 ] [ k ] = dp [ i - 1 ] [ 0 ] [ k ] <NEWLINE> dp [ i ] [ 1 ] [ k ] = dp [ i - 1 ] [ 1 ] [ k ] + 9 * dp [ i - 1 ] [ 1 ] [ k - 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ m ] [ 0 ] [ K ] + dp [ m ] [ 1 ] [ K ] ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> N = int ( readline ( ) ) <NEWLINE> K = int ( readline ( ) ) <NEWLINE> @ lru_cache ( None ) <NEWLINE> def f ( N , K ) : <NEWLINE> <INDENT> if K == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if N < 10 : <NEWLINE> <INDENT> if K == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif K == 1 : <NEWLINE> <INDENT> return N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> q , mod = divmod ( N , 10 ) <NEWLINE> ans += f ( q , K ) + mod * f ( q , K - 1 ) + ( 9 - mod ) * f ( q - 1 , K - 1 ) <NEWLINE> return ans <NEWLINE> <DEDENT> print ( f ( N , K ) ) <NEWLINE>
n = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> l = len ( n ) <NEWLINE> dp = [ [ [ 0 for _ in range ( 2 ) ] for _ in range ( 5 ) ] for _ in range ( l + 1 ) ] <NEWLINE> dp [ 0 ] [ 1 ] [ 1 ] = int ( n [ 0 ] ) - 1 <NEWLINE> dp [ 0 ] [ 1 ] [ 0 ] = 1 <NEWLINE> for i in range ( 1 , L ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> b = i - 1 <NEWLINE> now = int ( n [ i ] ) <NEWLINE> if now = 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += dp [ b ] [ j ] [ 0 ] * ( now - 1 ) <NEWLINE> dp [ i ] [ j + 1 ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 1 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += dp [ b ] [ j ] [ 1 ] * 9 <NEWLINE> <DEDENT> dp [ i ] [ 1 ] [ 1 ] += 9 <NEWLINE> <DEDENT> print ( dp [ l - 1 ] [ k ] [ 0 ] + dp [ l - 1 ] [ k ] [ 1 ] ) <NEWLINE>
dp [ 0 ] [ 1 ] [ 1 ] = int ( n [ 0 ] ) - 1 <NEWLINE> dp [ 0 ] [ 1 ] [ 0 ] = 1 <NEWLINE> dp [ 0 ] [ 0 ] [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 1 , l ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> b = i - 1 <NEWLINE> now = int ( n [ i ] ) <NEWLINE> if now == 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += dp [ b ] [ j ] [ 0 ] * ( now - 1 ) <NEWLINE> dp [ i ] [ j + 1 ] [ 0 ] += dp [ b ] [ j ] [ 0 ] <NEWLINE> <DEDENT> dp [ i ] [ j ] [ 1 ] += dp [ b ] [ j ] [ 1 ] <NEWLINE> dp [ i ] [ j + 1 ] [ 1 ] += 9 * dp [ b ] [ j ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( dp [ l - 1 ] [ k ] [ 0 ] + dp [ l - 1 ] [ k ] [ 1 ] ) <NEWLINE>
MOD = 10 ** 9 + 7 <NEWLINE> MOD_t_MAX = 2 * 10 ** 6 + 100 <NEWLINE> <NL> fac = [ None ] * MOD_t_MAX <NEWLINE> finv = [ None ] * MOD_t_MAX <NEWLINE> inv = [ None ] * MOD_t_MAX <NEWLINE> def MOD_COM_init ( ) : <NEWLINE> <INDENT> fac [ 0 ] = fac [ 1 ] = 1 <NEWLINE> finv [ 0 ] = finv [ 1 ] = 1 <NEWLINE> inv [ 1 ] = 1 <NEWLINE> for i in range ( 2 , MOD_t_MAX ) : <NEWLINE> <INDENT> fac [ i ] = fac [ i - 1 ] * i % MOD <NEWLINE> inv [ i ] = MOD - inv [ MOD % i ] * ( MOD // i ) % MOD <NEWLINE> finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD <NEWLINE> <DEDENT> <DEDENT> def MOD_COM ( n , k ) : <NEWLINE> <INDENT> if n < k : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if n < 0 or k < 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ n ] * ( finv [ k ] * finv [ n - k ] % MOD ) % MOD <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> r1 , c1 , r2 , c2 = map ( int , input ( ) . split ( ) ) <NEWLINE> MOD_COM_init ( ) <NEWLINE> a = MOD_COM ( r2 + 1 + c2 + 1 , r2 + 1 ) - 1 <NEWLINE> b = MOD_COM ( r2 + 1 + c1 , c1 ) - 1 <NEWLINE> c = MOD_COM ( r1 + c2 + 1 , r1 ) - 1 <NEWLINE> d = MOD_COM ( r1 + c1 , c1 ) - 1 <NEWLINE> ans = a - b - c + d <NEWLINE> print ( ans % MOD ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
h , a = map ( int , input ( ) . split ( ) <NEWLINE> ans = h // a + 1 <NEWLINE> if h % a == 0 : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
H , A = input ( ) . split ( ) <NEWLINE> <NL> import math <NEWLINE> <NL> print ( math . ceil ( H / A ) ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> while h > : <NEWLINE> <INDENT> h = h - a <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
H , A = input ( ) . split ( ) <NEWLINE> print ( int ( H ) // int ( A ) + 1 if 1 <= H <= 10000 and 1 <= A <= 10000 ) <NEWLINE>
INPUT = list ( input ( ) . split ( ) ) <NEWLINE> H = INT ( INPUT [ 0 ] ) <NEWLINE> A = INT ( INPUT [ 1 ] ) <NEWLINE> if H % A == 0 : <NEWLINE> <INDENT> print ( H // A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( H // A + 1 ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) ) ) <NEWLINE> count = 0 <NEWLINE> while ( a < 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> a -= b <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( h // a + map ( h % a != 0 ) ) <NEWLINE>
h , a = int ( input ( ) ) <NEWLINE> if ( h % a == 0 ) : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h // a + 1 ) <NEWLINE> <DEDENT>
h , a = map ( int , input . split ( ) ) <NEWLINE> if h % a == 0 : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h // a + 1 ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = sum ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( <STRING> if h - a <= 0 else <STRING> ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if h % a = 0 : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( h // a + 1 ) <NEWLINE> <DEDENT>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> <NL> HP = int ( tmp [ 0 ] ) <NEWLINE> attack = int ( tmp [ 1 ] ) <NEWLINE> <NL> print ( math . ceil ( HP / attack ) ) <NEWLINE>
H , A = map ( int , input . split ( ) ) <NEWLINE> ans = H // A <NEWLINE> if H % A != 0 : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , a = map ( int , input . split ( ) ) <NEWLINE> if h > a : <NEWLINE> <INDENT> print ( h // a ) <NEWLINE> <DEDENT> if h <= a : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
ri = lambda S : [ int ( v ) for v in S . split ( ) ] <NEWLINE> def rii ( ) : return ri ( input ( ) ) <NEWLINE> <NL> H , A = rii ( ) <NEWLINE> <NL> print ( ( H // A ) <NEWLINE>
H , A = map ( int , intput ( ) . split ( ) ) <NEWLINE> res = H // A <NEWLINE> if H % A > 0 : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
h , a = map ( int , input . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> h -= a <NEWLINE> cnt += 1 <NEWLINE> if h <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
H , A = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( H / A ) ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for h > 0 : <NEWLINE> <INDENT> h -= a <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = h // a <NEWLINE> if h % a == 0 : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> esle : <NEWLINE> <INDENT> print ( ans + 1 ) <NEWLINE> <DEDENT>
H , A = map ( int ( ) , input ( ) . split ) <NEWLINE> print ( H // A if H % A == 0 else H // A + 1 ) <NEWLINE>
h , a = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( h // a + ( 1 - int ( h % a == 0 ) ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> if sum ( a ) >= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> T = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> T += A [ i ] <NEWLINE> <DEDENT> if H - T <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = list ( map ( int , input ( ) . split ) ) <NEWLINE> c = sum ( lis ) <NEWLINE> print ( <STRING> if a > c else <STRING> ) <NEWLINE>
<COMMENT> <NL> monster_hp , quantity_of_skills = map ( int , input ( ) . split ( ) ) <NEWLINE> skills = map ( int , input ( ) . split ( ) ) <NEWLINE> skills_list = [ skills ] <NEWLINE> <NL> <COMMENT> <NL> total_damage = 0 <NEWLINE> for i in skills_list : <NEWLINE> <INDENT> total_damage += i <NEWLINE> <NL> <DEDENT> if monster_hp <= total_damage : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> if s >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( int ( input ( ) ) ) <NEWLINE> if sum ( A ) >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , innput ( ) . split ( ) ) ) <NEWLINE> <NL> if sum ( a ) >= h : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <COMMENT> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = sum ( a ) <NEWLINE> if a <= s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , inout ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if sum ( a ) >= h else <STRING> ) <NEWLINE>
<NL> H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> damege = map ( int , input ( ) . split ( ) ) <NEWLINE> damege_list = [ damege ] <NEWLINE> <NL> damege . sort ( ) <NEWLINE> <NL> if H - ( damege [ - 1 ] + damege [ - 2 ] ) <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> lists = [ ] lists . append ( int , input ( ) . split ( ) ) <NEWLINE> lists = lists . sort ( ) <NEWLINE> if N >= 2 and lists [ N - 1 ] + lists [ N - 2 ] >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> If N == 1 and lists [ 0 ] >= H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if N == 1 and lists [ 0 ] < H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if sum ( A ) = > H : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Damage = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Ai = map ( int , input ( ) . split ( ) ) <NEWLINE> Damage . append ( Ai ) <NEWLINE> <DEDENT> Total_Damage = sum ( Damage ) <NEWLINE> <NL> if H <= Total_Damage : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
210 5 <NEWLINE> 31 41 59 26 53 <NEWLINE>
h , n = map ( int , input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] <NEWLINE> <DEDENT> if ( ans >= h ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
H , N , = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> Damage = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> Ai = int ( input ( ) ) <NEWLINE> Damage . append ( Ai ) <NEWLINE> <DEDENT> Total_Damage = sum ( Damage ) <NEWLINE> <NL> if H <= Total_Damage : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h . sort ( reverce = True ) <NEWLINE> ans = 0 <NEWLINE> if ( k >= n ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k , n ) : <NEWLINE> <INDENT> ans += h [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> enemys = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> enemys = sorted ( enemys , reversed = True ) <NEWLINE> if K >= len ( enemys ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> enemys = enemys [ K + 1 : ] <NEWLINE> print ( sum ( enemys ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> N , K = map ( int , next ( sys . stdin . buffer ) . split ( ) ) <NEWLINE> H = sorted ( map ( int , next ( sys . stdin . buffer ) . split ( ) ) ) <NEWLINE> <NL> print ( sum ( H [ : K ] ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> H = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if k >= n : ans = 0 <NEWLINE> elif k == 0 : ans = sum ( H ) <NEWLINE> else : ans = sum ( H [ - k ] ) <NEWLINE> print ( ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> h_s = sorted ( h ) <NEWLINE> if len ( h_s ) <= k : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for _ in range ( k ) : <NEWLINE> <INDENT> h_s . pop ( ) <NEWLINE> <DEDENT> ans = sum ( h_s ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( <NEWLINE> <DEDENT>
h = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( i >= h ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += <NEWLINE> <DEDENT> if ( i = 0 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 2 ** ( i + 1 ) - 1 ) <NEWLINE> <DEDENT>
h = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> h //= 2 <NEWLINE> i = 2 <NEWLINE> while h > 0 : <NEWLINE> <INDENT> ans += i <NEWLINE> i *= 2 <NEWLINE> h //= 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> pow ( 2 , n ) - 1 <NEWLINE>
H = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> while H > 1 : <NEWLINE> <INDENT> H = H // 2 <NEWLINE> ans += 2 ** i <NEWLINE> count += 1 <NEWLINE> <DEDENT> ans += 2 ** i <NEWLINE> print ( ans ) <NEWLINE>
n = int ( log2 ( int ( input ( ) ) ) ) <NEWLINE> <NL> print ( 2 ** ( n + 1 ) - 1 ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> import pdb ; pdb . set_trace ( ) <NEWLINE> def atk ( n ) : <NEWLINE> <INDENT> if n == 1 : return 1 <NEWLINE> return 1 + 2 * ( atk ( n // 2 ) ) <NEWLINE> <NL> <DEDENT> print ( atk ( H ) ) <NEWLINE>
h = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> while h >= 1 : <NEWLINE> <INDENT> a . append ( h ) <NEWLINE> h // 2 <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> while a [ i ] >= 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> a [ i ] // 2 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> while H > 0 : <NEWLINE> <INDENT> if H == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> e = H // 2 <NEWLINE> ans += e <NEWLINE> H -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H = int ( input ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def attack_num ( x ) : <NEWLINE> <INDENT> if x == 1 : return 1 <NEWLINE> else : return 2 * f ( x // 2 ) + 1 <NEWLINE> <NL> <DEDENT> print ( attack_num ( H ) ) <NEWLINE>
( h , n ) , * t = [ map ( int , o . split ( ) ) for o in open ( 0 ) ] <NEWLINE> dp = [ 0 ] * ( h + 10100 ) <NEWLINE> for i in range ( 1 , h + 1 ) : dp [ i ] = min ( dp [ i - a ] + b for a , b in t ) <NEWLINE> print ( dp [ h ] ) <NEWLINE>
import numpy as np <NEWLINE> h , n = map ( int , input ( ) . split ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> m = max ( p [ : , 0 ] ) <NEWLINE> dp = [ 0 ] * ( h + m + 1 ) <NEWLINE> for i in range ( m + 1 , h + m + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in p ) <NEWLINE> <DEDENT> print ( dp [ h + m ] ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> m = 10 ** 4 <NEWLINE> dp = [ 0 ] * ( h + m + 1 ) <NEWLINE> for i in range ( m + 1 , h + m + 1 ) : <NEWLINE> <INDENT> dp [ i ] = min ( dp [ i - a ] + b for a , b in p ) <NEWLINE> <DEDENT> print ( dp [ h + m + ] ) <NEWLINE>
from numba import jit <NEWLINE> from sys import stdin <NEWLINE> <NL> @ jit ( nopython = True ) <NEWLINE> def num ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> magic = [ list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> INF = float ( <STRING> ) <NEWLINE> ans = [ INF ] * ( h + 1 ) <NEWLINE> ans [ - 1 ] = 0 <NEWLINE> <NL> for i in range ( h , 0 , - 1 ) : <NEWLINE> <INDENT> if ans [ i ] != INF : <NEWLINE> <INDENT> for j in magic : <NEWLINE> <INDENT> if i - j [ 0 ] < 0 : <NEWLINE> <INDENT> num = ans [ i ] + j [ 1 ] <NEWLINE> if ans [ 0 ] > num : <NEWLINE> <INDENT> ans [ 0 ] = num <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> num = ans [ i ] + j [ 1 ] <NEWLINE> if ans [ i - j [ 0 ] ] > num : <NEWLINE> <INDENT> ans [ i - j [ 0 ] ] = num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ans [ 0 ] <NEWLINE> <DEDENT> print ( num ( ) ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> import numpy as np <NEWLINE> def main ( ) : <NEWLINE> <INDENT> h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = np . array ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] ) <NEWLINE> a_max = np . max ( lis [ : , 0 ] ) <NEWLINE> dp = np . full ( h + a_max + 1 , 10 ** 10 ) <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for l in lis : <NEWLINE> <INDENT> dp [ i : i + l [ 0 ] + 1 ] = np . minimum ( dp [ i : i + l [ 0 ] + 1 ] , dp [ i ] + l [ 1 ] ) <NEWLINE> <DEDENT> print ( dp ) <NEWLINE> print ( dp [ h ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> xh = [ map ( int , input ( ) . split ( ) ) for _ in range ( n ) ] <NEWLINE> xh . sort ( ) <NEWLINE> D = 2 * D <NEWLINE> ans = 0 <NEWLINE> total = 0 <NEWLINE> q = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , h = xh [ i ] <NEWLINE> while len ( q ) >= 1 and x > q [ 0 ] [ 0 ] : <NEWLINE> <INDENT> total -= q . popleft ( ) [ 1 ] <NEWLINE> <DEDENT> h -= total <NEWLINE> if h > 0 : <NEWLINE> <INDENT> num = ( h - h % a ) // a <NEWLINE> damage = a * nim <NEWLINE> ans += num <NEWLINE> total += damage <NEWLINE> q . append ( [ x + D , damage ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> from math import ceil <NEWLINE> <NL> <COMMENT> <NL> n , d , a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ms = sorted ( [ ( pos , ceil ( hp / a ) ) for pos , hp in [ map ( int , input ( ) . split ( ) ) for i in range ( n ) ] ) <NEWLINE> <NL> bombs = deque ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> valid_bomb = 0 <NEWLINE> for pos , hp in ms : <NEWLINE> <COMMENT> <NL> <INDENT> while que and que [ 0 ] [ 0 ] < pos : <NEWLINE> <INDENT> bomb_border , bomb_cnt = bombs . popleft ( ) <NEWLINE> valid_bomb -= bomb_cnt <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> bomb_cnt = max ( 0 , hp - valid_bomb ) <NEWLINE> valid_bomb += bomb_cnt <NEWLINE> ans += bomb_cnt <NEWLINE> <NL> <COMMENT> <NL> if bomb_cnt > 0 : <NEWLINE> <INDENT> que . append ( [ pos + d * 2 , bomb_cnt ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , M = map ( int , input . split ( ) ) <NEWLINE> print ( <STRING> ) if N == M else print ( <STRING> ) <NEWLINE>
N = int ( input ( <STRING> ) ) <NEWLINE> M = int ( input ( <STRING> ) ) <NEWLINE> if ( N == M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = int ( input ( ) ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ( <STRING> ) <NEWLINE>
n , m = list ( map ( int , input ( ) ) ) <NEWLINE> if n * n == m * n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == m <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x , y , z = input ( ) . split ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> <NL> <NL> if x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) ) <NEWLINE> if ( N == M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = int ( input ( ) ) <NEWLINE> if ( n == m ) print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
a , b = list ( map ( int , input ( ) . splilt ( ) ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . spit ( ) ) <NEWLINE> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n == m ) : <NEWLINE> <INDENT> print ( yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( no ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) ) <NEWLINE> <NL> print ( <STRING> ) if N == M else print ( <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> m = input ( ) <NEWLINE> <NL> if n == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( N = M ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m >= n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elses : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> input = sys . stdin . buffer . readline <NEWLINE> def MAP ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n , m = MAP ( ) <NEWLINE> print ( <STRING> ) if n == m else print ( <STRING> ) <NEWLINE>
a , b = input ( ) <NEWLINE> A = int ( a * b ) <NEWLINE> B = int ( b * a ) <NEWLINE> print ( min ( A , B ) ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> res = <STRING> <NEWLINE> if a < b : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> res += a <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> res += b <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
a_str , b_str = input . split ( ) <NEWLINE> a , b = int ( a_str ) , int ( b_str ) <NEWLINE> <NL> A = a_str * b <NEWLINE> B = b_str * a <NEWLINE> <NL> print ( min ( A , B ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( str ( b ) * a ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( str ( a ) * b ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> ls = [ str ( a ) * b , str ( b ) * a ] <NEWLINE> ls . sort ( ) <NEWLINE> print ( ls [ 0 ] ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> c = str ( a ) ** b <NEWLINE> d = str ( b ) ** a <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> min_a = str ( a ) * b <NEWLINE> min_b = str ( b ) * a <NEWLINE> print ( min ( min_a , min_b ) <NEWLINE>
input_line = input ( ) . rstrip ( ) . slpit ( ) <NEWLINE> num1 = int ( input_line [ 0 ] ) <NEWLINE> num2 = int ( input_line [ 1 ] ) <NEWLINE> <NL> if ( num1 > num2 ) : <NEWLINE> <INDENT> print ( str ( num2 ) * num1 ) <NEWLINE> <DEDENT> elif ( num1 < num2 ) : <NEWLINE> <INDENT> print ( str ( num1 ) * num2 ) <NEWLINE> <DEDENT> elif ( num1 == num2 ) : <NEWLINE> <INDENT> print ( str ( num1 ) * num2 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a = ( <STRING> . join ( a ) ) * b <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if B < A : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> for i in range B ; <NEWLINE> <INDENT> print ( A , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a <= b : <NEWLINE> <INDENT> for i in range ( b ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> print ( b ) <NEWLINE> <DEDENT>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> if int ( a ) <= int ( b ) : <NEWLINE> <INDENT> s = a <NEWLINE> for i in range ( b - 1 ) : <NEWLINE> <INDENT> s += a <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = b <NEWLINE> for j in range ( a - 1 ) : <NEWLINE> <INDENT> s += b <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = p [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( m <= p [ i ] ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> a = p [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 1 <NEWLINE> if n >= 2 : <NEWLINE> <INDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a = min ( x ( range ( 0 , i , 1 ) ) ) <NEWLINE> if a >= x [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> premin = lst [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for x in lst : <NEWLINE> <INDENT> if min_list >= x : <NEWLINE> <INDENT> ans += 1 <NEWLINE> premin = x <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans , m = 0 , p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = min ( m , p [ i ] ) <NEWLINE> if m == p [ i ] : ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 1 <NEWLINE> M = L [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if M >= L [ 1 ] : <NEWLINE> <INDENT> M = L [ 1 ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> num = P [ 0 ] <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if num >= P [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> num = P [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> if P [ 1 ] < P [ 0 ] : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = P [ i - 2 ] <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if P [ i ] < min ( P [ i - 1 ] , tmp ) : <NEWLINE> <INDENT> tmp = min ( P [ i - 1 ] , tmp ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = list ( map ( lambda p : int ( p ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> left_min = P [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( P ) : <NEWLINE> <INDENT> if left_min >= P [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> left_min = P [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ 0 ] * 10 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if str ( i [ 0 ] ) == str ( i [ - 1 ] ) : <NEWLINE> <INDENT> l [ int ( str ( i [ 0 ] ) ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> ans += i * i <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> num = [ [ 0 ] * 10 for _ in range ( 10 ) ] <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> top = int ( str ( i ) [ 0 ] ) <NEWLINE> end = int ( str ( i ) [ - 1 ] ) <NEWLINE> num [ top ] [ end ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> count += num [ i ] [ j ] * num [ j ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<INDENT> import math <NEWLINE> from functools import reduce <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> lcm = lcm_list ( A ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += lcm // A [ i ] <NEWLINE> <NL> <DEDENT> print ( ans % 1000000007 ) <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> <NL> <NL> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> MOD = 1000000007 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lcm_ = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> lcm_ = lcm ( lcm_ , a ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += lcm_ / a <NEWLINE> <NL> <DEDENT> ans %= MOD <NEWLINE> print ( int ( ans ) ) <NEWLINE>
h , w , m = map ( int , input ( ) . split ( ) ) <NEWLINE> total = 0 <NEWLINE> if h < w : <NEWLINE> <INDENT> h , w = w , h <NEWLINE> <DEDENT> for i in range ( w ) : <NEWLINE> <INDENT> total += h <NEWLINE> if total >= m : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( n / max ( h , w ) ) ) <NEWLINE>
a , b , n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n // a + 1 if a >= b else n // b + 1 ) <NEWLINE>
<INDENT> p = sorted ( [ ( a + b , a - b ) for a , b in zip ( x , l ) ] ) <NEWLINE> _ , th = p [ 0 ] <NEWLINE> best = 0 <NEWLINE> for t , s in p : <NEWLINE> <INDENT> if th <= s : <NEWLINE> <INDENT> best += 1 <NEWLINE> th = t <NEWLINE> <DEDENT> <DEDENT> return best <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> l = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] , l [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( solve ( n , x , l ) ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> cou = n <NEWLINE> l_h = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> l_h . append ( [ x - l , x + l ] ) <NEWLINE> <DEDENT> l_h . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> d = deque ( l_h ) <NEWLINE> t = d . popleft ( ) <NEWLINE> a , b = t [ 0 ] , t [ 1 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> m = d . popleft ( ) <NEWLINE> c , e = m [ 0 ] , m [ 1 ] <NEWLINE> if b <= c : <NEWLINE> <INDENT> b = d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cou -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> se = [ ( ) ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , l = map ( int , input ( ) . split ( ) ) <NEWLINE> se [ i ] = ( x - l , x + l ) <NEWLINE> <DEDENT> se = sorted ( se , key = lambda x : x [ 1 ] ) <NEWLINE> ans = N <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if se [ i - 1 ] [ 1 ] > se [ i ] [ 0 ] : <NEWLINE> <INDENT> se [ i ] [ 1 ] = se [ i - 1 ] [ 1 ] <NEWLINE> ans -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> diff = [ 0 ] * N <NEWLINE> neg = [ ] <NEWLINE> pos = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> diff [ i ] = A [ i ] - B [ i ] <NEWLINE> if diff [ i ] < 0 : <NEWLINE> <INDENT> neg . append ( diff [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pos . append ( diff [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if sum ( diff ) < 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> tobe_supplied = sum ( neg ) <NEWLINE> pos . sort ( reverse = True ) <NEWLINE> <NL> cnt = len ( neg ) <NEWLINE> <NL> for p in pos : <NEWLINE> <INDENT> if tobe_supplied >= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> tobe_supplied += p <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ S if i <= K - 1 else 1 for i in range ( N ) ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ S ] * K <NEWLINE> for i in range ( N - K ) : <NEWLINE> <INDENT> if S < 10 ** 9 : <NEWLINE> <INDENT> L . append ( S + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( int , L ) ) ) <NEWLINE>
n , k , s = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ 0 ] * n <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> x [ i ] = s <NEWLINE> <DEDENT> if s == 1000000000 : <NEWLINE> <INDENT> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> x [ i ] = s - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( k , n + 1 ) : <NEWLINE> <INDENT> x [ i ] = s + 1 <NEWLINE> <DEDENT> <DEDENT> for i in x : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
N , K , S = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if i < K : <NEWLINE> <INDENT> ans . append ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( S + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
nput ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if x == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
alphabet = [ a , b , c , d , e , f , g , h , i , j , k , l , m , n , o , p , q , r , s , t , u , v , w , x , y , z ] <NEWLINE> C = input ( ) <NEWLINE> idx = alphabet . index ( C ) <NEWLINE> print ( alphabet [ idx + 1 ] ) <NEWLINE>
s = input ( ) <NEWLINE> st = <STRING> <NEWLINE> print ( st [ index ( s ) + 1 ] ) <NEWLINE>
letter = ord ( input ( ) ) <NEWLINE> print ( chr ( c + 1 ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a + 1 ) <NEWLINE>
C = input ( ) <NEWLINE> <NL> ary = <STRING> . split ( <STRING> ) <NEWLINE> <NL> print ( ary [ ary . index ( C ) + 1 ] ) <NEWLINE>
print ( chr ( ord ( ( input ( ) ) + 1 ) ) <NEWLINE>
c = input ( ) <NEWLINE> print ( c + 1 ) <NEWLINE>
c = input ( ) <NEWLINE> <NL> l = [ chi ( i ) for i in range ( 65 , 91 ) ] <NEWLINE> print ( l [ l . index ( c ) + 1 ] ) <NEWLINE>
C = input ( ) <NEWLINE> <NL> print ( char ( ord ( C ) + 1 ) ) <NEWLINE>
from strings import ascii_lowercase as lc <NEWLINE> given = input ( ) <NEWLINE> print ( lc [ lc . index ( given ) + 1 ] ) <NEWLINE>
c = input ( ) <NEWLINE> alp = <STRING> <NEWLINE> for i in range ( 25 ) : <NEWLINE> <INDENT> if c == alp [ i ] : <NEWLINE> <INDENT> print ( alh [ i + 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
print ( chr ( ord ( int ( input ( ) ) ) + 1 ) ) <NEWLINE>
print ( char ( ord ( input ( ) ) + 1 ) ) <NEWLINE>
I = <STRING> <NEWLINE> for i in range ( 25 ) : <NEWLINE> <INDENT> if I [ i ] == input ( ) : <NEWLINE> <INDENT> print ( I [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> list_S = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in list_s : <NEWLINE> <INDENT> if list_s [ i ] == s : <NEWLINE> <INDENT> print ( list_s [ i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
c = int ( input ( ) ) <NEWLINE> C = ord ( c ) <NEWLINE> print ( chr ( C ) ) <NEWLINE>
c = input ( ) <NEWLINE> s = list ( <STRING> ) <NEWLINE> <NL> for i in s : <NEWLINE> <INDENT> if c == s [ i ] : <NEWLINE> <INDENT> print ( s [ i + 1 ] ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> <NL> dir = [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] <NEWLINE> <NL> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> <NL> def BFS ( y , x ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> que = deque ( ) <NEWLINE> que . append ( ( y , x ) ) <NEWLINE> dist [ y ] [ x ] = 0 <NEWLINE> max_dist = 0 <NEWLINE> while que : <NEWLINE> <INDENT> sy , sx = que . popleft ( ) <COMMENT> <NEWLINE> for dy , dx in dir : <NEWLINE> <INDENT> ny = sy + dy <NEWLINE> nx = sx + dx <NEWLINE> if 0 <= ny < H and 0 <= nx < W and S [ ny ] [ nx ] != <STRING> and dist [ ny ] [ nx ] == - 1 : <NEWLINE> <INDENT> que . append ( ( ny , nx ) ) <NEWLINE> dist [ ny ] [ nx ] = dist [ sy ] [ sx ] + 1 <NEWLINE> max_dist = max ( max_dist , dist [ ny ] [ nx ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return max_dist <NEWLINE> <NL> <DEDENT> max_dist = 0 <NEWLINE> for sy in range ( H ) : <NEWLINE> <INDENT> for sx in range ( W ) : <NEWLINE> <INDENT> if S [ sy ] [ sx ] != <STRING> : <NEWLINE> <INDENT> dist = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> max_dist = max ( max_dist , BFS ( sy , sx ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_dist ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def resolve ( in_ ) : <NEWLINE> <INDENT> N , M = map ( int , next ( in_ ) . split ( ) ) <NEWLINE> PS = tuple ( line . strip ( ) . split ( ) for line in in_ ) <NEWLINE> <NL> ac = set ( ) <NEWLINE> wa = { } <NEWLINE> <NL> for p , s in PS : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac . add ( p ) <NEWLINE> <DEDENT> if s == <STRING> and p not in ac : <NEWLINE> <INDENT> wa [ p ] = wa . setdefault ( p , 0 ) + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> penalties = 0 <NEWLINE> for k , v in wa . items : <NEWLINE> <INDENT> if k in ac : <NEWLINE> <INDENT> penalties += v <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . format ( len ( ac ) , penalties ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> answer = resolve ( sys . stdin ) <NEWLINE> print ( answer ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l1 = [ 0 ] * n <NEWLINE> l2 = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if l2 [ p - 1 ] == 0 : <NEWLINE> <INDENT> l2 [ p - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if l2 [ p - 1 ] == 0 : <NEWLINE> <INDENT> l1 [ p - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if l2 [ i ] == 0 : <NEWLINE> <INDENT> l1 [ i ] == 0 : <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( l2 ) , sum ( l1 ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> AC_List = defaultdict ( int ) <NEWLINE> WA_List = defaultdict ( int ) <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> Num , Sta = map ( str , input ( ) . split ( ) ) <NEWLINE> if Num in AC_List : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if Sta == <STRING> : <NEWLINE> <INDENT> WA_List [ Num ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> AC_List [ Num ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ansct = 0 <NEWLINE> for k , v in WA_List : <NEWLINE> <INDENT> if k in AC_List : <NEWLINE> <INDENT> ansct += v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( len ( AC_List ) ) + <STRING> + str ( ansct ) ) <NEWLINE> <NL>
import collections <NEWLINE> <NL> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> list_ac = set ( ) <NEWLINE> dic = collections . defaultdict ( lambda : 0 ) <NEWLINE> <NL> ac = 0 <NEWLINE> wa = 0 <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if s == <STRING> and p not in list_ac : <NEWLINE> <INDENT> dic [ p ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> and p not in list_ac : <NEWLINE> <INDENT> list_ac . append ( p ) <NEWLINE> ac += 1 <NEWLINE> if p in dic : <NEWLINE> <INDENT> wa += dic [ p ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
import sys <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ list ( map ( str , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> box = [ ] <NEWLINE> acnt , wcnt , tmp = 0 , 0 , 0 <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> inx = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if p [ i ] [ 0 ] != inx <NEWLINE> <INDENT> if p [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> inx = p [ i ] [ 0 ] <NEWLINE> acnt += 1 <NEWLINE> wcnt += tmp <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( acnt , wcnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> L = [ list ( input ( ) . split ( ) ) for i in range ( M ) ] <NEWLINE> W = [ 0 ] * N <NEWLINE> A = [ 0 ] * N <NEWLINE> a = 0 <NEWLINE> w = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if L [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> A [ int ( L [ i ] [ 0 ] ) - 1 ] = 1 <NEWLINE> <NL> <DEDENT> elif L [ i ] [ 1 ] == <STRING> and A [ int ( L [ i ] [ 0 ] ) - 1 ] == 0 : <NEWLINE> <INDENT> W [ int ( L [ i ] [ 0 ] ) - 1 ] += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if A [ i ] > 0 : <NEWLINE> <INDENT> a += 1 <NEWLINE> w += W [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( a , w ) <NEWLINE> <NL>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = [ False ] * N <NEWLINE> wa_cnt = [ 0 ] * N <NEWLINE> ac_cnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p_i = int ( p ) - 1 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if not ac [ p_i ] : <NEWLINE> <INDENT> wa_cnt [ p_i ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not ac [ p_i ] : <NEWLINE> <INDENT> ac [ p_i ] = True <NEWLINE> ac_cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> wa_cnt_sum = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if ac_cnt [ i ] : <NEWLINE> <INDENT> wa_cnt_sum += wa_cnt [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac_cnt , wa_cnt_sum ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> miss = [ 0 ] * ( n + 1 ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if l [ p ] == 0 : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> l [ p ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> miss [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if l [ i ] == 0 and miss [ i ] != 0 : <NEWLINE> <INDENT> miss [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> a = l . count ( 1 ) <NEWLINE> b = sum ( miss ) <NEWLINE> print ( a , b ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ans_num_lis = [ 0 for i in range ( N ) ] <NEWLINE> pre_ans_lis = [ 0 for i in range ( N ) ] <NEWLINE> ans_lis = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> problem , result = input ( ) . split ( ) <NEWLINE> problem_num = int ( problem ) <NEWLINE> if result == <STRING> : <NEWLINE> <INDENT> pre_ans_lis [ problem_num ] += 1 <NEWLINE> <DEDENT> if result == <STRING> and not ans_num_lis [ problem_num ] : <NEWLINE> <INDENT> ans_num_lis [ problem_num ] = 1 <NEWLINE> ans_lis [ problem_num ] = pre_ans_lis [ problem_num ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( ans_num_lis ) , sum ( ans_lis ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ps = [ input ( ) . split ( ) for _ in range ( M ) ] <NEWLINE> <NL> correct = [ 0 ] * N <NEWLINE> penalty = [ 0 ] * N <NEWLINE> for p , s in ps : <NEWLINE> <INDENT> p = int ( p ) <NEWLINE> if correct [ p - 1 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> correct [ p - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> penalty [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( correct ) , sum ( [ p * c for p , c in zip ( penalty , correct ) ] ) ) ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = [ 0 ] * ( n + 1 ) <NEWLINE> wa = 0 <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> p , c = input ( ) . split ( ) <NEWLINE> if c == <STRING> and ac [ int ( p ) ] == 0 : <NEWLINE> <INDENT> ac [ int ( p ) ] = 1 <NEWLINE> <DEDENT> elif c == <STRING> and ac [ int ( p ) ] == 0 : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ac . count ( 1 ) , wa ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> wa = 0 <NEWLINE> ac = 0 <NEWLINE> check = [ 0 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> i = int ( a ) <NEWLINE> if check [ i ] == 0 : <NEWLINE> <INDENT> if b == <STRING> : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> ac += 1 <NEWLINE> check [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> lis = [ list ( input ( ) . split ( ) ) for _ in range ( m ) ] <NEWLINE> <NL> dp = [ [ 0 for _ in range ( 2 ) ] for _ in range ( n ) ] <COMMENT> <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if dp [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lis [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ int ( lis [ i ] [ 0 ] ) ] [ 1 ] += 1 <NEWLINE> <DEDENT> if lis [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> dp [ int ( lis [ i ] [ 0 ] ) ] [ 0 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ac = 0 <NEWLINE> wa = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if dp [ i ] [ 0 ] == 1 : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += dp [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <NL> acCount = 0 <NEWLINE> waCount = 0 <NEWLINE> check = [ 0 ] * n <NEWLINE> waCheck = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> p = int ( p ) <NEWLINE> if ( check [ p - 1 ] == 0 ) : <NEWLINE> <INDENT> if ( s == <STRING> ) : <NEWLINE> <INDENT> waCheck [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> acCount += 1 <NEWLINE> waCheck += waCheck [ p - 1 ] <NEWLINE> <NL> check [ p - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print ( acCount , waCount ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> AC = [ 0 ] * n + 1 <NEWLINE> WA = [ 0 ] * n + 1 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> p , s = map ( str , input ( ) . split ( ) ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> AC [ int ( p ) ] += 1 <NEWLINE> <DEDENT> elif s == <STRING> and AC [ int ( p ) ] == 0 : <NEWLINE> <INDENT> WA [ int ( p ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if AC [ i ] == 0 : <NEWLINE> <INDENT> WA [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = AC . count ( 0 ) <NEWLINE> answer = len ( AC ) - cnt <NEWLINE> ans = sum ( WA ) <NEWLINE> print ( answer , ans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> S = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> p . append ( int ( a ) ) <NEWLINE> S . append ( b ) <NEWLINE> <NL> <DEDENT> ans = [ [ ] for i in range ( N ) ] <NEWLINE> WA , AC = 0 , 0 <NEWLINE> for p , S in zip ( p , S ) : <NEWLINE> <INDENT> if ans [ p - 1 ] . count ( <STRING> ) != 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ p - 1 ] . append ( S ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> WA += 1 <NEWLINE> <DEDENT> if S == <STRING> <NEWLINE> <INDENT> AC += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( AC , WA ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ ] <NEWLINE> s = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p_i , s_i = input ( ) . split ( ) <NEWLINE> p . append ( int ( p_i ) ) <NEWLINE> s . append ( b ) <NEWLINE> <NL> <NL> <DEDENT> res = [ 0 ] * n <NEWLINE> correct = 0 <NEWLINE> penalty = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> no = p [ i ] - 1 <NEWLINE> if res [ no ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> penalty += 1 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> : <NEWLINE> <INDENT> correct += 1 <NEWLINE> res [ no ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( correct , penalty ) <NEWLINE>
<INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> AC = [ 0 ] * n <NEWLINE> WA = [ 0 ] * n <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> t = input ( ) . split ( ) <NEWLINE> p , s = int ( t [ 0 ] ) , t [ 1 ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> AC [ p - 1 ] = 1 <NEWLINE> <DEDENT> elif s == <STRING> and AC [ p - 1 ] == 0 : <NEWLINE> <INDENT> WA [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ac , wa = 0 , 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if AC [ i ] : <NEWLINE> <INDENT> ac += 1 <NEWLINE> wa += WA [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ac , wa ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ input ( ) . split for i in range ( M ) ] <NEWLINE> cac = 0 <NEWLINE> cwa = 0 <NEWLINE> <NL> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for a in A : <NEWLINE> <INDENT> while a [ 0 ] == str ( i ) : <NEWLINE> <INDENT> if a [ 1 ] == <STRING> : <NEWLINE> <INDENT> cwa += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cac += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> while a [ 0 ] == str ( i ) : <NEWLINE> <INDENT> A . remove ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cac , cwa ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ac_cnt = set ( ) <NEWLINE> wa_cnt = 0 <NEWLINE> penalty = [ 0 ] * n <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> num = p - 1 <NEWLINE> if num not in ac_cnt : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> ac_cnt . add ( num ) <NEWLINE> wa_cnt += penalty [ num ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> penalty [ num ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( set ( ac_cnt ) ) , wa_cnt ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ac_list = [ 1 ] * n <NEWLINE> ac = 0 <NEWLINE> wa = 0 <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> if s == <STRING> and ac_list [ int ( p ) - 1 ] == 1 : <NEWLINE> <INDENT> wa += 1 <NEWLINE> <DEDENT> elif s == <STRING> and ac_list [ int ( p ) - 1 ] == 1 : <NEWLINE> <INDENT> ac += 1 <NEWLINE> ac_list [ int ( p ) - 1 ] = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> resolve ( ) : <NEWLINE>
N , M , * PS = open ( 0 ) . read ( ) . split ( ) <NEWLINE> N , M = [ int ( _ ) for _ in [ N , M ] ] <NEWLINE> cor = [ 0 ] * ( N + 1 ) <NEWLINE> pen = [ 0 ] * ( N + 1 ) <NEWLINE> for p , s in PS : <NEWLINE> <INDENT> p = int ( p ) <NEWLINE> if cor [ p ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if s == <STRING> : <NEWLINE> <INDENT> cor [ p ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pen [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = [ 0 , 0 ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if cor [ p ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans [ 0 ] += 1 <NEWLINE> ans [ 1 ] += pen [ @ ] <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ list ( input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> cnt = 0 <NEWLINE> ans = [ 0 ] * n <NEWLINE> num = 0 <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> num = int ( l [ i ] [ 0 ] ) <NEWLINE> if l [ i ] [ 1 ] == <STRING> : <NEWLINE> <INDENT> ans [ num ] = 1 <NEWLINE> <DEDENT> elif ans [ num ] != 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) , cnt ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> acs = [ 0 for i in range ( N ) ] <NEWLINE> wa = [ 0 for i in range ( N ) ] <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> p , S = map ( str , input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> acs [ p - 1 ] = 1 <NEWLINE> <DEDENT> elif S == <STRING> and acs [ p - 1 ] == 0 : <NEWLINE> <INDENT> wa [ p - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> if acs [ i ] == 0 : <NEWLINE> <INDENT> wa [ i ] = 0 <NEWLINE> <DEDENT> <DEDENT> ans = [ sum ( acs ) , sum ( wa ) ] <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> judge = [ False ] * N <NEWLINE> WAcnt = [ 0 ] * N <NEWLINE> ACcnt = 0 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , S = ( x for x in input ( ) . split ( ) ) <NEWLINE> p = int ( p ) <NEWLINE> if judge [ p - 1 ] == False : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> judge [ p - 1 ] = True <NEWLINE> ACcnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> WAcnt [ p - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> WAans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if judge [ i ] == True : <NEWLINE> <INDENT> WAans += WAans [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ACcnt , WAans ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> ac = 0 <NEWLINE> is_AC = [ False ] * ( 10 ** 5 ) + 1 <NEWLINE> WA_cnt = [ 0 ] * ( 10 ** 5 ) + 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> p , s = input ( ) . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if is_AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> WA_cnt [ p ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if is_AC [ p ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_AC [ p ] = True <NEWLINE> ac += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ac , sum ( WA_cnt ) ) <NEWLINE> <NL>
from copy import deepcopy <NEWLINE> <COMMENT> <NL> import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> H , W = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> map_initial = [ [ <STRING> ] * ( W + 2 ) for i in range ( H + 2 ) ] <COMMENT> <NEWLINE> for h in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> map_initial [ h ] = [ <STRING> ] + list ( input ( ) . strip ( ) ) + [ <STRING> ] <NEWLINE> <NL> <DEDENT> def BSF ( x , y ) : <NEWLINE> <INDENT> dist = 0 <NEWLINE> map = deepcopy ( map_initial ) <NEWLINE> if map [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return dist <NEWLINE> <DEDENT> dq = deque ( ) <NEWLINE> dq . append ( ( x , y ) ) <NEWLINE> dq_sarch = deque ( ) <NEWLINE> while len ( dq ) > 0 : <NEWLINE> <INDENT> h , w = dq . popleft ( ) <NEWLINE> map [ h ] [ w ] = <STRING> <COMMENT> <NEWLINE> if map [ h + 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h + 1 , w ) ) <NEWLINE> <DEDENT> if map [ h - 1 ] [ w ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h - 1 , w ) ) <NEWLINE> <DEDENT> if map [ h ] [ w + 1 ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h , w + 1 ) ) <NEWLINE> <DEDENT> if map [ h ] [ w - 1 ] == <STRING> : <NEWLINE> <INDENT> dq_sarch . append ( ( h , w - 1 ) ) <NEWLINE> <DEDENT> if len ( dq ) == 0 : <NEWLINE> <INDENT> dq = deepcopy ( dq_sarch ) <NEWLINE> dq_sarch . clear ( ) <NEWLINE> dist += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return dist - 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dist_all = [ ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> dist_all . append ( BSF ( i , j ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( dist_all ) ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> from copy import deepcopy <NEWLINE> from collections import deque <NEWLINE> <NL> h , w = nii ( ) <NEWLINE> s = [ list ( input ( ) ) for i in range ( h ) ] <NEWLINE> <NL> def dfs ( cs , i , j ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> que . append ( [ i , j ] ) <NEWLINE> <NL> cs [ i ] [ j ] = <STRING> <NEWLINE> <NL> dist = [ [ - 1 for a in range ( w ) ] for b in range ( h ) ] <NEWLINE> dist [ i ] [ j ] = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> y , x = que . popleft ( ) <NEWLINE> for dy , dx in [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> ny = y + dy <NEWLINE> nx = x + dx <NEWLINE> if 0 <= ny < h and 0 <= nx < w and cs [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> que . append ( [ ny , nx ] ) <NEWLINE> cs [ ny ] [ nx ] = <STRING> <NEWLINE> dist [ ny ] [ nx ] = dist [ y ] [ x ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> t_ans = 0 <NEWLINE> for a in dist : <NEWLINE> <INDENT> t_ans = max ( t_ans , max ( a ) ) <NEWLINE> <NL> <DEDENT> return t_ans <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> cs = deepcopy ( s ) <NEWLINE> dist = dfs ( cs , i , j ) <NEWLINE> ans = max ( ans , dist ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> from collections import deque <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> def bfs ( sx , sy ) : <NEWLINE> <INDENT> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> d = [ [ - 1 ] * W for _ in range ( H ) ] <NEWLINE> q = deque ( [ ] ) <NEWLINE> q . append ( [ sx , sy ] ) <NEWLINE> d [ sx ] [ sy ] = 0 <NEWLINE> ans = 0 <NEWLINE> while q : <NEWLINE> <INDENT> x , y = q . popleft ( ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = x + dx [ i ] <NEWLINE> ny = y + dy [ i ] <NEWLINE> if 0 <= nx < H and 0 <= ny < W and S [ nx ] [ ny ] != <STRING> and d [ nx ] [ ny ] == - 1 : <NEWLINE> <INDENT> q . append ( [ nx , ny ] ) <NEWLINE> d [ nx ] [ ny ] = d [ x ] [ y ] + 1 <NEWLINE> ans = max ( ans , d [ nx ] [ ny ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> for sh in range ( H ) : <NEWLINE> <INDENT> if <STRING> in S [ sh ] : <NEWLINE> <INDENT> for sw in range ( W ) : <NEWLINE> <INDENT> if S [ sh ] [ sw ] == <STRING> : <NEWLINE> <INDENT> ans = max ( ans , bfs ( sh , sw ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <NL> <NL> <NL>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> def bfs ( start ) : <NEWLINE> <INDENT> already = { } <NEWLINE> queue = [ ] <NEWLINE> counter = 0 <NEWLINE> queue . append ( ( start [ 0 ] , start [ 1 ] , 0 ) ) <NEWLINE> already ( start ) = True <NEWLINE> max_depth = 0 <NEWLINE> while counter < len ( queue ) : <NEWLINE> <INDENT> y , x , depth = queue [ counter ] <NEWLINE> if depth > max_depth : <NEWLINE> <INDENT> max_depth = depth <NEWLINE> <DEDENT> for move in ( ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ) : <NEWLINE> <INDENT> new_y = y + move [ 0 ] <NEWLINE> new_x = x + move [ 1 ] <NEWLINE> if new_y >= 0 and new_y < H and new_x >= 0 and new_x < W and S [ new_y ] [ new_x ] == <STRING> and ( new_y , new_x ) not in already : <NEWLINE> <INDENT> already [ ( new_y , new_x ) ] = True <NEWLINE> queue . append ( ( new_y , new_x , depth + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> counter += 1 <NEWLINE> <DEDENT> return max_depth <NEWLINE> <NL> <DEDENT> answer = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> depth = bfs ( ( i , j ) ) <NEWLINE> if answer < depth : <NEWLINE> <INDENT> answer = depth <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
from collections import deque <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ list ( input ( ) ) for _ in range ( H ) ] <NEWLINE> A = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> ans = [ ] <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> sy = i <NEWLINE> sx = j <NEWLINE> A [ i ] [ j ] = 1 <NEWLINE> route = deque ( [ ( sy , sx , 0 ) ] ) <NEWLINE> while route : <NEWLINE> <INDENT> a , b , n = route . popleft ( ) <NEWLINE> c = n <NEWLINE> if 0 <= a <= H - 1 and 0 <= b <= W - 1 : <NEWLINE> <INDENT> if S [ a ] [ b ] == <STRING> : <NEWLINE> <INDENT> S [ a ] [ b ] == <STRING> <NEWLINE> route . append ( ( a + 1 , b , n + 1 ) ) <NEWLINE> route . append ( ( a - 1 , b , n + 1 ) ) <NEWLINE> route . append ( ( a , b + 1 , n + 1 ) ) <NEWLINE> route . append ( ( a , b - 1 , n + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans . append ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE>
from networkx import * <NEWLINE> _ , * s = open ( i : = 0 ) <NEWLINE> g = [ ] <NEWLINE> for t in s : <NEWLINE> <INDENT> i += 1 ; j = 0 <NEWLINE> for u in t : g += [ ( k : = i * 20 + j , k + 20 ) ] * ( u > <STRING> < ( s + [ <STRING> * k ] ) [ i ] [ j ] ) + [ ( k , k + 1 ) ] * ( u > <STRING> < t [ j : = j + 1 ] ) <NEWLINE> <DEDENT> print ( max ( t [ i ] for _ , t in shortest_path_length ( Graph ( g ) ) for i in t ) ) <NEWLINE>
def abc151d_maze_master ( ) : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ ] <NEWLINE> max_val = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> s . append ( input ( ) ) <NEWLINE> <DEDENT> for hi in range ( h ) : <NEWLINE> <INDENT> for wi in range ( w ) : <NEWLINE> <INDENT> if s [ hi ] [ wi ] == <STRING> : continue <NEWLINE> flg = [ [ - 1 ] * w for _ in range ( h ) ] <NEWLINE> flg [ hi ] [ wi ] = 0 <NEWLINE> q = [ ( 0 , hi , wi ) ] <NEWLINE> heapq . heapify ( q ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> d , hj , wj = heapq . heappop ( q ) <NEWLINE> for dh , dw in zip ( [ 0 , 0 , 1 , - 1 ] , [ 1 , - 1 , 0 , 0 ] ) : <NEWLINE> <INDENT> if 0 <= hj + dh < h and 0 <= wj + dw < w and s [ hj + dh ] [ wj + dw ] != <STRING> and ( flg [ hj + dh ] [ wj + dw ] == - 1 or flg [ hj + dh ] [ wj + dw ] > flg [ hj ] [ wj ] + 1 ) : <NEWLINE> <INDENT> heapq . heappush ( q , ( d + 1 , hj + dh , wj + dw ) ) <NEWLINE> flg [ hj + dh ] [ wj + dw ] = flg [ hj ] [ wj ] + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> max_val = max ( max_val , max ( [ max ( v ) for v in flg ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max_val ) <NEWLINE> <NL> <NL> <DEDENT> abc151d_maze_master ( ) <NEWLINE>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> Maze = [ list ( input ( ) ) for i in range ( H ) ] <NEWLINE> for hi in range ( 0 , H ) : <NEWLINE> <INDENT> for wi in range ( 0 , W ) : <NEWLINE> <INDENT> if Maze [ hi ] [ wi ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> maze1 = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> stack = deque ( [ [ hi , wi ] ] ) <NEWLINE> while stack : <NEWLINE> <INDENT> h , w = stack . popleft ( ) <NEWLINE> for i , j in [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> new_h , new_w = h + i , w + j <NEWLINE> if new_h < 0 or new_w < 0 or new_h >= H or new_w >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif Maze [ new_h ] [ new_w ] != <STRING> and maze1 [ new_h ] [ new_w ] == 0 : <NEWLINE> <INDENT> maze1 [ new_h ] [ new_w ] = maze1 [ h ] [ w ] + 1 <NEWLINE> stack . append ( [ new_h , new_w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> maze1 [ hi ] [ wi ] = 0 <NEWLINE> ans = max ( ans , np . max ( maze1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> grid = [ list ( input ( ) . split ( ) ) for _ in H ] <NEWLINE> res = 0 <NEWLINE> def bfs ( tup , visited ) : <NEWLINE> <INDENT> def helper ( tup , total ) : <NEWLINE> <INDENT> if tup in visited ( ) : <NEWLINE> <INDENT> res = max ( res , total ) <NEWLINE> <DEDENT> elif tup [ 0 ] >= H or tup [ 0 ] < 0 or tup [ 1 ] >= W or tup [ 1 ] < 0 or grid [ tup [ 0 ] ] [ tup [ 1 ] ] : <NEWLINE> <INDENT> res = max ( res , total ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> visited . add ( tup ) <NEWLINE> h , w = tup <NEWLINE> helper ( ( h + 1 , w ) , total + 1 ) <NEWLINE> helper ( ( h - 1 , w ) , total + 1 ) <NEWLINE> helper ( ( h , w - 1 ) , total + 1 ) <NEWLINE> helper ( ( h , w + 1 ) , total + 1 ) <NEWLINE> <DEDENT> <DEDENT> helper ( tup , 0 ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> for w in W : <NEWLINE> <INDENT> if grid [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ans = max ( ans , bfs ( ( h , w ) , set ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> S . append ( str ( input ( ) ) ) <NEWLINE> <DEDENT> d = [ [ float ( <STRING> ) for i in range ( V ) ] for j in range ( V ) ] <NEWLINE> <NL>
import numpy as np <NEWLINE> import queue <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> S = list ( ) <NEWLINE> for m in range ( H ) : <NEWLINE> <INDENT> S . append ( input ( ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> i , j = 7 , 6 <NEWLINE> if S [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> L = [ [ - 1 ] * W for i in range ( H ) ] <NEWLINE> L [ i ] [ j ] = 0 <NEWLINE> q = queue . Queue ( ) <NEWLINE> q . put ( [ i , j ] ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> r = q . get ( ) <NEWLINE> for k , l in [ [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] ] : <NEWLINE> <INDENT> if r [ 0 ] + k >= 0 and r [ 0 ] + k < H and r [ 1 ] + l >= 0 and r [ 1 ] + l < W and S [ r [ 0 ] + k ] [ r [ 1 ] + l ] == <STRING> and L [ r [ 0 ] + k ] [ r [ 1 ] + l ] == - 1 : <NEWLINE> <INDENT> L [ r [ 0 ] + k ] [ r [ 1 ] + l ] = L [ r [ 0 ] ] [ r [ 1 ] ] + 1 <NEWLINE> q . put ( [ r [ 0 ] + k , r [ 1 ] + l ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , max ( list ( map ( lambda x : max ( x ) , L ) ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> H , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> field = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> field . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> conn = [ [ [ ] for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for e in [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> h , w = i + e [ 0 ] , j + e [ 1 ] <NEWLINE> if 0 <= h < H and 0 <= w < W and field [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> conn [ i ] [ j ] . append ( [ h , w ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> d = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> q = deque ( [ [ i , j ] ] ) <NEWLINE> dist = [ [ - 1 for _ in range ( W ) ] for _ in range ( H ) ] <NEWLINE> dist [ i ] [ j ] = 0 <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> for w in conn [ v [ 0 ] ] [ v [ 1 ] ] : <NEWLINE> <INDENT> if dist [ w [ 0 ] ] [ w [ 1 ] ] == - 1 : <NEWLINE> <INDENT> q . append ( w ) <NEWLINE> dist [ w [ 0 ] ] [ w [ 1 ] ] = dist [ v [ 0 ] ] [ v [ 1 ] ] + 1 <NEWLINE> l = dist [ w [ 0 ] ] [ w [ 1 ] ] <NEWLINE> <NL> d = max ( d , l ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
def prepare ( n , MOD ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> factorials = [ 1 ] <NEWLINE> for m in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> f *= m <NEWLINE> f %= MOD <NEWLINE> factorials . append ( f ) <NEWLINE> <DEDENT> inv = pow ( f , MOD - 2 , MOD ) <NEWLINE> invs = [ 1 ] * ( n + 1 ) <NEWLINE> invs [ n ] = inv <NEWLINE> for m in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> inv *= m <NEWLINE> inv %= MOD <NEWLINE> invs [ m - 1 ] = inv <NEWLINE> <NL> <DEDENT> return factorials , invs <NEWLINE> <NL> <NL> <DEDENT> MOD = 10 ** 9 + 7 <NEWLINE> facts , invs = prepare ( n , MOD ) <NEWLINE> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> arr . sort ( ) <NEWLINE> <NL> ans_max = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> ans_max += ( arr [ i ] * facts [ i ] * invs [ k - 1 ] * invs [ i - k + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> arr . sort ( reverse = True ) <NEWLINE> <NL> ans_min = 0 <NEWLINE> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> ans_min += ( arr [ i ] * facts [ i ] * invs [ k - 1 ] * invs [ i - k + 1 ] ) % MOD <NEWLINE> <NL> <DEDENT> print ( ( ans_max - ans_min ) % MOD ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> p = [ 1 ] <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p . append ( p [ - 1 ] * ( i + 2 ) % mod ) <NEWLINE> <DEDENT> def comb ( n , k , mod ) : <NEWLINE> <INDENT> s = p [ n - 1 ] * pow ( fac ( k ) , mod - 2 , mod ) % mod <NEWLINE> s = s * pow ( fac ( n - k ) , mod - 2 , mod ) % mod <NEWLINE> return s <NEWLINE> <DEDENT> max_sum = 0 <NEWLINE> min_sum = 0 <NEWLINE> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> max_sum += a [ - ( i + 1 ) ] * comb ( n - 1 - i , k - 1 , mod ) <NEWLINE> max_sum = max_sum % mod <NEWLINE> min_sum += a [ i ] * comb ( n - 1 - i , k - 1 , mod ) <NEWLINE> min_sum = min_sum % mod <NEWLINE> <DEDENT> ans = max_sum - min_sum <NEWLINE> if ans < 0 : <NEWLINE> <INDENT> ans += mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> <NL> N = 1000000007 <NEWLINE> <NL> def combi ( n , r , N ) : <NEWLINE> <INDENT> if n < r or n < 0 or r < 0 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> return ans <NEWLINE> <DEDENT> if n == r : <NEWLINE> <INDENT> ans = 1 <NEWLINE> return ans <NEWLINE> <DEDENT> r = min ( r , n - r ) <NEWLINE> ans = f [ n ] * rf [ r ] * rf [ n - r ] % N <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> f = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> f [ 1 ] = 1 <NEWLINE> <NL> for i in range ( 2 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> f [ i ] = f [ i - 1 ] * i <NEWLINE> <NL> <DEDENT> rf = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> <NL> for i in range ( 1 , 10 ** 5 + 1 ) : <NEWLINE> <INDENT> rf [ i ] = pow ( f [ i ] , N - 2 , N ) <NEWLINE> <NL> <DEDENT> max_sum = 0 <NEWLINE> min_sum = 0 <NEWLINE> <NL> for i in range ( k - 1 , n ) : <NEWLINE> <INDENT> t = combi ( i , k - 1 , N ) <NEWLINE> max_sum += a [ i ] * t <NEWLINE> max_sum %= N <NEWLINE> min_sum += a [ n - i - 1 ] * t <NEWLINE> min_sum %= N <NEWLINE> <DEDENT> if max_sum - min_sum < 0 : <NEWLINE> <INDENT> max_sum += N <NEWLINE> <DEDENT> print ( max_sum - min_sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> sgm = pow ( 10. - 7 ) <NEWLINE> def func ( c ) : <NEWLINE> <INDENT> allp = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> xi , yi = xy [ i ] <NEWLINE> xj , yj = xy [ j ] <NEWLINE> dx = xi - xj <NEWLINE> dy = yi - yj <NEWLINE> d = ( ( xi - xj ) ** 2 + ( yi - yj ) ** 2 ) ** 0.5 <NEWLINE> if c ** 2 - ( d / 2 ) ** 2 < 0 : return False <NEWLINE> h = ( c ** 2 - ( d / 2 ) ** 2 ) ** 0.5 <NEWLINE> mx , my = ( xi + xj ) / 2 , ( yi + yj ) / 2 <NEWLINE> if dx == 0 : <NEWLINE> <INDENT> allp . append ( [ mx - h , my ] ) <NEWLINE> allp . append ( [ mx + h , my ] ) <NEWLINE> <DEDENT> elif dy == 0 : <NEWLINE> <INDENT> allp . append ( [ mx , my - h ] ) <NEWLINE> allp . append ( [ mx , my + h ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dx , dy = dy , - dx <NEWLINE> dh = ( dy ** 2 + dx ** 2 ) ** 0.5 <NEWLINE> dx *= h / dh <NEWLINE> dy *= h / dh <NEWLINE> allp . append ( [ mx + dx , my + dy ] ) <NEWLINE> allp . append ( [ mx - dx , my - dy ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for px , py in allp : <NEWLINE> <INDENT> flg = True <NEWLINE> for x , y in xy : <NEWLINE> <INDENT> if ( ( px - x ) ** 2 + ( py - y ) ** 2 ) ** 0.5 > c + sgm : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> r = 2 * max ( [ abs ( x ) for x , y in xy ] ) + max ( [ abs ( y ) for x , y in xy ] ) <NEWLINE> l , r = 0 , r <NEWLINE> for i in range ( 300 ) : <NEWLINE> <INDENT> c = ( l + r ) / 2 <NEWLINE> if func ( c ) : <NEWLINE> <INDENT> l , r = l , c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l , r = c , r <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
from math import sqrt <NEWLINE> N = int ( input ( ) ) <NEWLINE> XY = [ tuple ( map ( int , input ( ) . split ( ) for _ in range ( N ) ) ) ] <NEWLINE> <NL> def calc ( r ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> x1 = XY [ i ] [ 0 ] <NEWLINE> y1 = XY [ i ] [ 1 ] <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> x2 = XY [ j ] [ 0 ] <NEWLINE> y2 = XY [ j ] [ 1 ] <NEWLINE> diff = sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> if diff > 2 * r : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> h = sqrt ( r ** 2 - diff ** 2 / 4 ) <NEWLINE> if x1 == x2 : <NEWLINE> <INDENT> ny = ( y1 + y2 ) / 2 <NEWLINE> lst . append ( [ x1 - h , ny ] ) <NEWLINE> lst . append ( [ x1 + h , ny ] ) <NEWLINE> <DEDENT> elif y1 == y2 : <NEWLINE> <INDENT> nx = ( x1 + x2 ) / 2 <NEWLINE> lst . append ( [ nx , y1 - h ] ) <NEWLINE> lst . append ( [ nx , y1 + h ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = ( y2 - y1 ) / ( x2 - x1 ) <NEWLINE> b = - 1 / a <NEWLINE> size = sqrt ( 1 + b ** 2 ) <NEWLINE> dx = h / size <NEWLINE> dy = dx * b <NEWLINE> nx = ( x1 + x2 ) / 2 <NEWLINE> ny = ( y1 + y2 ) / 2 <NEWLINE> lst . append ( [ nx + dx , ny + dy ] ) <NEWLINE> lst . append ( [ nx - dx , ny - dy ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x , y in lst : <NEWLINE> <INDENT> flag = True <NEWLINE> for X , Y in XY : <NEWLINE> <INDENT> tmp = ( x - X ) ** 2 + ( y - Y ) ** 2 <NEWLINE> if tmp > r ** 2 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = 1000 <NEWLINE> for i in range ( 100 ) : <NEWLINE> <INDENT> mid = ( i + r ) / 2 <NEWLINE> if calc ( mid ) : <NEWLINE> <INDENT> r = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = mid <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S , T = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S [ i ] , T [ i ] = input ( ) . split ( ) <NEWLINE> <DEDENT> X = input ( ) <NEWLINE> <NL> print ( sum ( T [ S . index ( X ) + 1 : ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( list ( map ( int , input ( ) . split ( ) ) ) for _in range ( n ) ) <NEWLINE> x = input ( ) <NEWLINE> bit = 0 <NEWLINE> su = 0 <NEWLINE> for j , k in l : <NEWLINE> <INDENT> if j == x : <NEWLINE> <INDENT> bit = 1 <NEWLINE> <DEDENT> if bit == 1 : <NEWLINE> <INDENT> su += k <NEWLINE> <DEDENT> <DEDENT> print ( su ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s_temp , t_temp = map ( int , input ( ) . split ( ) ) <NEWLINE> s . append ( s_temp ) <NEWLINE> t . append ( t_temp ) <NEWLINE> <DEDENT> end = input ( ) <NEWLINE> print ( sum ( t [ s . index ( end ) + 1 : ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> s , t = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s [ i ] , t [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> X = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> flag = False <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> ans += t [ i ] <NEWLINE> <DEDENT> if s [ i ] == X : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st = list ( input ( ) ) <NEWLINE> s . append ( st [ 0 ] ) <NEWLINE> t . append ( st [ 1 ] ) <NEWLINE> <DEDENT> x = input ( ) <NEWLINE> <NL> print ( sum ( t [ s . index ( x ) : ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ ] <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> st , tt = map ( input ( ) . split ( ) ) <NEWLINE> s . append ( st ) <NEWLINE> t . append ( tt ) <NEWLINE> <DEDENT> x = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> if t [ i ] == x : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
b , c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 500 * b = > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if ( k * 500 >= x ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( <STRING> if 500 * k >= x else <STRING> ) <NEWLINE>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 500 * K >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> K = [ ] <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> X = [ ] <NEWLINE> X = int ( input ( ) ) <NEWLINE> <NL> if 500 * K < X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 500 * K == X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif 500 * K > X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> if n % 3 != 0 and n >= 3 : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif n % 3 == 0 and n >= 3 : <NEWLINE> <INDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if s [ i - 1 ] == <STRING> and s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if n == 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
4 2000 <NEWLINE>
k , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 500 * i >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K , X = map ( int , input ( ) . split ( ) ) <NEWLINE> if 500 * K >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) ) <NEWLINE> <NL> if 500 * k >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) . split ) <NEWLINE> print ( <STRING> if 500 * k >= x else <STRING> ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if 500 * n >= k : print ( <STRING> ) <NEWLINE> <INDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
N , X = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( <STRING> if 500 * N >= X else <STRING> ) <NEWLINE>
K , X = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> if K * 500 >= X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = map ( int , input ( ) ) <NEWLINE> if ( 500 * k ) >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
K = input ( ) <NEWLINE> X = input ( ) <NEWLINE> <NL> if ( X <= 500 * K ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = int ( input ( ) . split ( ) ) <NEWLINE> if 500 * k >= x : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
k , x = list ( map ( int , input ( ) . split ) ) <NEWLINE> print ( <STRING> ) if k * 500 <= x else print ( <STRING> ) <NEWLINE>
tmp = input ( ) <NEWLINE> <NL> N = int ( tmp [ 0 ] ) <NEWLINE> X = int ( tmp [ 1 ] ) <NEWLINE> <NL> if X <= 500 * N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> if a * 500 >= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> print ( s . count ( <STRING> ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> S = S . remove ( <STRING> ) <NEWLINE> if N == len ( S ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( N - len ( S ) ) // 3 <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and S [ i + 1 ] == <STRING> and S [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> print ( sum ( S [ i ] == A and S [ i + 1 ] == B and S [ i + 2 ] == C for i in range ( N - 2 ) ) ) <NEWLINE>
n , s = [ int ( input ( ) ) for _ in range ( 2 ) ) <NEWLINE> print ( s . count ( <STRING> ) ) <NEWLINE>
n = int ( input ) <NEWLINE> s = input ( ) <NEWLINE> s2 = s . replace ( <STRING> , <STRING> ) <NEWLINE> print ( int ( ( len ( s ) - len ( s2 ) ) / 3 ) ) <NEWLINE>
n = int ( intput ( ) ) <NEWLINE> str = input ( ) <NEWLINE> print ( str . count ( <STRING> ) ) <NEWLINE>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> print ( s . count ( <STRING> ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> permutations = list ( itertools . permutations ( range ( 1 , N + 1 ) ) ) <NEWLINE> p = permutations . index ( P ) <NEWLINE> q = permutations . index ( Q ) <NEWLINE> print ( abs ( p - q ) ) <NEWLINE>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> p = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = list ( itertools . parmutations ( range ( 1 , n + 1 ) ) ) <NEWLINE> print ( abs ( ls . index ( p ) - ls . index ( q ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt , a , b = 0 , 0 , 0 <NEWLINE> for i in itertools . permutations ( range ( 1 , N + 1 ) ) : <NEWLINE> <INDENT> if P == i : <NEWLINE> <INDENT> a = cnt <NEWLINE> if b != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if Q == i : <NEWLINE> <INDENT> b = cnt <NEWLINE> if a != 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( abs ( a - b ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = <STRING> . join ( l ) <NEWLINE> h = <STRING> . join ( t ) <NEWLINE> <NL> l1 = list ( ) <NEWLINE> <NL> for i in permutations ( s ) : <NEWLINE> <INDENT> l1 . append ( i ) <NEWLINE> <NL> <DEDENT> print ( abs ( l1 . find ( s ) - l1 . find ( h ) ) ) <NEWLINE>
import copy <NEWLINE> def func ( n ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> result . append ( [ 1 , 2 ] ) <NEWLINE> result . append ( [ 2 , 1 ] ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> return result <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> res_list = func ( n - 1 ) <NEWLINE> res = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for s in res_list : <NEWLINE> <INDENT> st = copy . copy ( s ) <NEWLINE> st . insert ( j , n ) <NEWLINE> res . append ( st ) <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = func ( n ) <NEWLINE> s . sort ( ) <NEWLINE> p_i = 0 <NEWLINE> q_i = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if s [ i ] == p : <NEWLINE> <INDENT> p_i = i <NEWLINE> <DEDENT> if s [ i ] == q : <NEWLINE> <INDENT> q_i = i <NEWLINE> <DEDENT> <DEDENT> print ( abs ( p_i , q_i ) ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> <NL> n = input ( ) <NEWLINE> p = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> q = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> p_no , q_no = 0 , 0 <NEWLINE> <NL> per = [ c + 1 for c in range ( n ) ] <NEWLINE> per_list = list ( itertools . permutations ( per ) ) <NEWLINE> <NL> for i in range ( math . factorial ( n ) ) : <NEWLINE> <INDENT> if p == per_list [ i ] : p_no = i <NEWLINE> if q == per_list [ i ] : q_no = i <NEWLINE> <NL> <DEDENT> print ( abs ( p_no - q_no ) ) <NEWLINE>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> import itertools as it <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> P = inpl ( ) <NEWLINE> Q = inpl ( ) <NEWLINE> ls = P . copy ( ) <NEWLINE> ls . sort ( ) <NEWLINE> cnt = 0 <NEWLINE> for l in it . permutations ( ls ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if P == l : <NEWLINE> <INDENT> a = cnt <NEWLINE> <DEDENT> if Q == l : <NEWLINE> <INDENT> b = cnt <NEWLINE> <DEDENT> <DEDENT> print ( abs ( a - b ) ) <NEWLINE> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
import itertools <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> Ns = list ( itertools . permutations ( range ( 1 , N + 1 ) ) ) <NEWLINE> PO = Ns . index ( P ) <NEWLINE> QO = Ns . index ( Q ) <NEWLINE> print ( abs ( PO - QO ) ) <NEWLINE>
def func ( x , y ) : <NEWLINE> <INDENT> if len ( y ) == 1 : <NEWLINE> <INDENT> dic . append ( i * 10 + int ( y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( len ( y ) ) : <NEWLINE> <INDENT> func ( i * 10 + int ( y [ j ] ) , y [ : j ] + y [ j + 1 : ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dic = [ ] <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> func ( 0 , <STRING> . join ( [ i in range ( 1 , N + 1 ) ] ) ) <NEWLINE> <NL> A = int ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> B = int ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> ans = abs ( dic . index ( A ) - dic . index ( B ) ) <NEWLINE> print ( ans ) <NEWLINE>
from itertools import permutations <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> o = { } <NEWLINE> for i , p in enumerate ( permutation ( range ( 1 , N + 1 ) ) ) : <NEWLINE> <INDENT> o [ p ] = i <NEWLINE> <DEDENT> P = tuple ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> Q = tuple ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> print ( abs ( o [ P ] - o [ Q ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> def pos_num ( l ) : <NEWLINE> <INDENT> l_sort = l . copy ( ) <NEWLINE> l_len = len ( l ) <NEWLINE> l_sort . sort ( ) <NEWLINE> if l_len == 1 : <NEWLINE> <INDENT> an = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> an = ( l_sort . index ( l [ 0 ] ) ) * math . factorial ( l_len - 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> return an <NEWLINE> <NL> <NL> <NL> <DEDENT> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> an = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = pos_num ( ls [ i : ] ) <NEWLINE> an += b <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( ) <NEWLINE> ll = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> bn = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> b = pos_num ( ll [ i : ] ) <NEWLINE> bn += b <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( abs ( an - bn ) ) <NEWLINE>
import itertools <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( i + 1 ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> for per in itertools . permutatiton ( a ) : <NEWLINE> <INDENT> b . append ( list ( per ) ) <NEWLINE> <DEDENT> c = b . index ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> d = b . index ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> print ( abs ( c - d ) ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> p = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> s = itertools . permutations ( range ( 1 , n + 1 ) ) <NEWLINE> l = [ ] <NEWLINE> for v in s : <NEWLINE> <INDENT> l . append ( v ) <NEWLINE> <DEDENT> p_index = l . index ( p ) <NEWLINE> q_index = l . index ( q ) <NEWLINE> <NL> print ( abs ( p_index - q_index ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = [ i for i in range ( 1 , N + 1 ) ] <NEWLINE> A = list ( permutations ( ls ) ) <NEWLINE> <NL> print ( abs ( A . index ( P ) - A . index ( Q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> n = int ( input ( ) ) <NEWLINE> p , q = = tuple ( map ( int , input ( ) . split ( ) ) ) , tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( range ( 1 , n + 1 ) ) <NEWLINE> x = [ i for i in permutations ( l , n ) ] <NEWLINE> print ( abs ( x . index ( p ) - x . index ( q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> l = permutations ( range ( 1 , N + 1 ) ) <NEWLINE> <NL> print ( abs ( l . index ( P ) - l . index ( Q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> n = 8 <NEWLINE> a = map ( str , range ( 1 , n + 1 ) ) <NEWLINE> a = <STRING> . join ( a ) <NEWLINE> l = list ( permutations ( a , n ) ) <NEWLINE> <NL> p = tuple ( input ( ) . split ( ) ) <NEWLINE> q = tuple ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( abs ( l . index ( p ) - l . index ( q ) ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from fractions import gcd <NEWLINE> from itertools import combinations , permutations , accumulate , product <COMMENT> <NEWLINE> <COMMENT> <NL> from collections import deque , defaultdict , Counter <NEWLINE> import decimal <NEWLINE> import re <NEWLINE> import math <NEWLINE> import bisect <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> def readInts ( ) : <NEWLINE> <INDENT> return list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def readTuples ( ) : <NEWLINE> <INDENT> return tuple ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def I ( ) : <NEWLINE> <INDENT> return int ( readline ( ) ) <NEWLINE> <DEDENT> n = I ( ) <NEWLINE> lis = list ( range ( 1 , n + 1 ) ) <NEWLINE> a , b = None , None <NEWLINE> P = readInts ( ) <NEWLINE> Q = readInts ( ) <NEWLINE> i = 0 <NEWLINE> for A in permutations ( lis , n ) : <NEWLINE> <INDENT> if list ( A ) == P : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> elif list ( A ) == Q : <NEWLINE> <INDENT> b = i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( abs ( a - b ) ) <NEWLINE>
import itertools <NEWLINE> N = int ( input ( ) ) <NEWLINE> P = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls = list ( itertools . permutations ( range ( 1 , N + 1 ) ) ) <NEWLINE> print ( abs ( ls . index ( P ) - ls . index ( Q ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> q = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> from itertools import permutations <NEWLINE> list = list ( permutations ( range ( 1 , n + 1 ) ) ) <NEWLINE> ans = abs ( list . index ( p ) - list . index ( q ) ) <NEWLINE>
import itertools as itool <NEWLINE> N = int ( input ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> qlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mylist = list ( itool . permutations ( range ( 1 , n + 1 ) ) ) <NEWLINE> print ( abs ( mylist . index ( p ) - mylist . index ( q ) ) ) <NEWLINE>
from itertools import permutations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> Nlist = [ i for i in range ( 1 , int ( input ( ) ) + 1 ) ] <NEWLINE> Nlist = list ( permutations ( Nlist ) ) <NEWLINE> <NL> P = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( abs ( X . index ( P ) - X . index ( Q ) ) ) <NEWLINE>
from math import gcd <NEWLINE> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ i // 2 for i in a ] <NEWLINE> l = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> lcd *= a // gcd ( lcd , a ) <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> if lcd // a % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( ( M // lcd + 1 ) // 2 ) <NEWLINE>
import math <NEWLINE> from functools import reduce <NEWLINE> <NL> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <NL> <DEDENT> def lcm ( * numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <NL> <DEDENT> def my_round ( val , digit = 0 ) : <NEWLINE> <INDENT> p = 10 ** digit <NEWLINE> return ( val * p * 2 + 1 ) // 2 / p <NEWLINE> <NL> <NL> <DEDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a_pr = [ i // 2 for i in list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> lcm_ = lcm_list ( a_pr ) <NEWLINE> res , div2 = 0 , None <NEWLINE> for ai in a_pr : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while a % 2 == 0 : <NEWLINE> <INDENT> a //= 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if div2 is None : <NEWLINE> <INDENT> div2 = cnt <NEWLINE> <DEDENT> elif cnt != div2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( int ( my_round ( m // lcm_ / 2 ) ) ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> from math import gcd <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> flag = False <NEWLINE> res = 1 <NEWLINE> for a in A : <NEWLINE> <INDENT> a /= 2 <NEWLINE> res *= a // gcd ( res , a ) <NEWLINE> if res > M : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> if int ( res / a ) == res / a : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> ans = 0 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans = ( M // res + 1 ) // 2 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
from functools import reduce <NEWLINE> import math <NEWLINE> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm ( * numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ i // 2 for i in list ( set ( a ) ) ] <NEWLINE> <NL> cnt_common = - 1 <NEWLINE> for i in a : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while i % 2 == 0 : <NEWLINE> <INDENT> i = i // 2 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if cnt_common == - 1 : <NEWLINE> <INDENT> cnt_common = cnt <NEWLINE> continue <NEWLINE> <DEDENT> if cnt_common != cnt : <NEWLINE> <INDENT> nothing = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> b = lcm_list ( a ) <NEWLINE> if nothing : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( m - b ) // ( 2 * b ) + 1 <NEWLINE> print ( max ( ans , 0 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> from functools import reduce <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def lcm_base ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <DEDENT> C = gcd_list ( A ) <NEWLINE> B = [ 0 for _ in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ i ] = C // A [ i ] <NEWLINE> if B [ i ] % 2 == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ( M // C + 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> sys . setrecursionlimit ( 10 ** 8 ) <NEWLINE> INF = float ( <STRING> ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> <NL> <NL> def lcm_base ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // gcd ( a , b ) <NEWLINE> <NL> <NL> <DEDENT> def lcm_list ( numbers ) : <NEWLINE> <INDENT> return reduce ( lcm_base , numbers , 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , readline ( ) . split ( ) ) <NEWLINE> a = np . array ( input ( ) . split ( ) , np . int64 ) <NEWLINE> a //= 2 <NEWLINE> b = np . copy ( a ) <NEWLINE> while True : <NEWLINE> <INDENT> c = b % 2 <NEWLINE> if c . sum ( ) == 0 : <NEWLINE> <INDENT> b //= 2 <NEWLINE> <DEDENT> elif c . sum ( ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> d = lcm_list ( a ) <NEWLINE> if d > 10 ** 9 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = ( m // d ) - ( m // ( d + d ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def z_algo ( S ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> i , j , n = 1 , 0 , len ( S ) <NEWLINE> Z = np . zeros_like ( S ) <NEWLINE> Z [ 0 ] = n <NEWLINE> while i < n : <NEWLINE> <INDENT> while i + j < n and S [ j ] == S [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> Z [ i ] = j <NEWLINE> d = 1 <NEWLINE> while i + d < n and d + Z [ d ] < j : <NEWLINE> <INDENT> Z [ i + d ] = Z [ d ] <NEWLINE> d += 1 <NEWLINE> <DEDENT> i += d <NEWLINE> j -= d <NEWLINE> <DEDENT> return Z <NEWLINE> <NL> <DEDENT> def solve ( N , A , B ) : <NEWLINE> <INDENT> Diff = np . empty ( 3 * N , dtype = np . int64 ) <NEWLINE> Diff [ 0 ] = B [ 0 ] ^ B [ - 1 ] <NEWLINE> Diff [ 1 : N ] = B [ 1 : ] ^ B [ : - 1 ] <NEWLINE> Diff [ N ] = Diff [ 2 * N ] = A [ 0 ] ^ A [ - 1 ] <NEWLINE> Diff [ N + 1 : 2 * N ] = Diff [ 2 * N + 1 : 3 * N ] = A [ 1 : ] ^ A [ : - 1 ] <NEWLINE> Z = z_algo ( Diff ) [ N : 2 * N ] <NEWLINE> Ans = [ ( 0 , 0 ) ] * 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> z = Z [ i ] <NEWLINE> if z >= N : <NEWLINE> <INDENT> Ans . append ( ( i , B [ 0 ] ^ A [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> return np . array ( Ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> numba_config = [ <NEWLINE> <INDENT> [ z_algo , <STRING> ] , <NEWLINE> [ solve , <STRING> ] , <NEWLINE> <DEDENT> ] <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> B = np . array ( input ( ) . split ( ) , dtype = np . int64 ) <NEWLINE> Ans = solve ( N , A , B ) . tolist ( ) <NEWLINE> print ( <STRING> . join ( map ( lambda x : <STRING> . join ( map ( str , x ) ) , Ans ) ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
s , t = intput ( ) . split ( ) <NEWLINE> print ( t + s ) <NEWLINE>
N , M = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> l = [ ] <NEWLINE> for b in a : <NEWLINE> <INDENT> for c in a : <NEWLINE> <INDENT> l . append ( b + c ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( sorted ( l ) [ len ( l ) - M : ] ) ) <NEWLINE>
A , B = map ( input ( ) . split ( ) ) <NEWLINE> print ( B + A ) <NEWLINE>
s , t = str ( input ( ) ) <NEWLINE> a = t + s <NEWLINE> print ( a ) <NEWLINE>
s , t = input ( ) <NEWLINE> print ( t + s ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> print ( T + S ) <NEWLINE>
S , T = map ( input ( ) split ( ) ) <NEWLINE> print ( T . S ) <NEWLINE>
s , t = map ( input ( ) . split ( ) ) <NEWLINE> print ( s + t ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( b + a ) <NEWLINE>
s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( t + s ) <NEWLINE>
S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( T + S ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( b + a ) <NEWLINE>
a , b = map ( str , input ( ) . split ( ) ) <NEWLINE> print ( b + c ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( b + a ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if k <= a : <NEWLINE> <INDENT> print ( str ( a - k ) + <STRING> + str ( b ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( 0 ) + <STRING> + str ( min ( 0 , b - ( k - a ) ) ) ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( a + b ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( b , a sep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> print ( T + S ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( b + a ) <NEWLINE>
print ( input ( ) . split ( ) [ : : - 1 ] . join ( ) ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> print ( <STRING> . join ( t , s ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> print ( t + s ) <NEWLINE>
S , T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( T + S ) <NEWLINE>
import sys <NEWLINE> A , B , K = map ( int , next ( sys . stdin . buffer ) ) <NEWLINE> x = min ( A , B , K ) <NEWLINE> print ( A - x , B - x ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if a >= k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> elif a < k and k <= a + b <NEWLINE> <INDENT> print ( 0 , a + b - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> if A >= K : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> else : <NEWLINE> print ( 0 , B - ( K - A ) ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( c ) : <NEWLINE> <INDENT> if ( a == 0 ) : <NEWLINE> <INDENT> b -= 1 <NEWLINE> if ( b == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif ( a > 0 ) : <NEWLINE> <INDENT> a -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( str ( a ) , str ( b ) ) <NEWLINE>
A , B , K = map ( int , input ( ) . Split ( ) ) <NEWLINE> <NL> if A - K > 0 : <NEWLINE> <INDENT> print ( A - K , B ) <NEWLINE> <DEDENT> elif B - ( K - A ) > 0 : <NEWLINE> <INDENT> print ( 0 , B - K + A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT>
A , B , K = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if A = > K : <NEWLINE> <INDENT> A -= K <NEWLINE> <DEDENT> elif A < K < A + B : <NEWLINE> <INDENT> B -= K - A <NEWLINE> A = 0 <NEWLINE> <DEDENT> elif A + B <= K : <NEWLINE> <INDENT> A = B = 0 <NEWLINE> <NL> <DEDENT> print ( A , B ) <NEWLINE>
a , b , k = ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <INDENT> if a > k : <NEWLINE> <INDENT> print ( a - k , b ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a + b > k : <NEWLINE> <INDENT> print ( 0 , a + b - k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 , 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> x = int ( input ( ) ) <NEWLINE> <NL> def prime_check ( num , count ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> while num % count == 0 : <NEWLINE> <INDENT> num = num + 1 <NEWLINE> count = 2 <NEWLINE> if num <= count ** 2 : <NEWLINE> print ( num ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if x == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> prime_check ( x , 2 ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> i = int ( n ** 0.5 ) <NEWLINE> <NL> while i >= 2 : <NEWLINE> <INDENT> if X % i == 0 : <NEWLINE> <INDENT> X += 1 <NEWLINE> i = int ( X ** 0.5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( X ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for i in range ( X + 1 , 9999999999999999 ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> for j in range ( 2 , X // 2 + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> flag = - 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> elif flag == 1 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> flag == 0 <NEWLINE> for i in range ( 2 , x // 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> flag == 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x + 1 <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> flg = 0 <NEWLINE> if x == 2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> for i in range ( 2 , int ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> flg += 1 <NEWLINE> <DEDENT> if i == int ( x ** 0.5 ) and flg == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> x += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def prime ( n ) : <NEWLINE> <INDENT> limit = math . floor ( math . sqrt ( n ) ) <NEWLINE> for i in range ( 2 , limit + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return prime ( n + 1 ) <NEWLINE> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <DEDENT> X = int ( input ( ) ) <NEWLINE> <NL> print ( prime ( X ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( 2 , x ) : <NEWLINE> <INDENT> if x % i == 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> x = int ( input ( ) ) <NEWLINE> ans = x <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( 2 , math . sqrt ( x ) + 1 ) : <NEWLINE> <INDENT> if x % i = 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> x += 1 <NEWLINE> <NL> <DEDENT>
X = int ( input ( ) ) <NEWLINE> for i in range ( X , 120000 ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> for j in range ( 2 , math . ceil ( math . sqrt ( i ) ) ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> f += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
pip install sympy <NEWLINE> from sympy import isprime <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> if x % 2 == 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> <NL> while flag == True : <NEWLINE> <INDENT> if isprime ( x ) == True : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def eratosthenes_sieve ( n ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> for p in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ p ] : <NEWLINE> <INDENT> for q in range ( 2 * p , n + 1 , p ) : <NEWLINE> <INDENT> is_prime [ q ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return is_prime <NEWLINE> <NL> <DEDENT> MAX_N = ( 10 ** 6 ) <NEWLINE> Primes = eratosthenes_sieve ( MAX_N ) <NEWLINE> <NL> x = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if Primes [ x ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> def factorization ( n ) : <NEWLINE> <INDENT> arr = [ ] <NEWLINE> tmp = n <NEWLINE> <NL> for i in range ( 2 , int ( n ** 0.5 // 1 ) + 1 ) : <NEWLINE> <INDENT> if tmp % i == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> arr . append ( [ i , cnt ] ) <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> arr . append ( [ tmp , 1 ] ) <NEWLINE> <DEDENT> if arr == [ ] : <NEWLINE> <INDENT> arr . append ( [ n , 1 ] ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> arr = factorization ( a ) <NEWLINE> if ( len ( arr ) == 1 ) & ( arr [ 1 ] == 1 ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> <NL> def is_Prime ( x ) : <NEWLINE> <INDENT> for i in range ( 2 , x + 1 ) : <NEWLINE> <INDENT> if i * i + 1 > x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( X + 1 , 2 X + 1 ) : <NEWLINE> <INDENT> if is_Prime ( i ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> def p ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( x // 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for i in range ( n , 2 * n ) : <NEWLINE> <INDENT> if p ( i ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
X = int ( input ( ) ) <NEWLINE> prime = [ 2 ] <NEWLINE> for i in range ( 3 , 100004 ) : <NEWLINE> <INDENT> for p in prime : <NEWLINE> <INDENT> is_prime = True <NEWLINE> if i % p == 0 : <NEWLINE> <INDENT> is_prime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if is_prime : prime . append ( i ) <NEWLINE> <NL> <DEDENT> print ( min ( [ i for i in prime if i >= X ] ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 2 : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost = 0 <NEWLINE> for i in range ( n , 10 ** 6 ) : <NEWLINE> <INDENT> for j in range ( 2 , int ( math . sqrt ( i ) ) + 1 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> cost += 1 <NEWLINE> <DEDENT> <DEDENT> if cost == 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def eratosthenes ( n ) : <NEWLINE> <INDENT> A = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> P = [ ] <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> prime = min ( A ) <NEWLINE> P . append ( prime ) <NEWLINE> j = 0 <NEWLINE> while j < len ( A ) : <NEWLINE> <INDENT> if A [ j ] % prime == 0 : <NEWLINE> <INDENT> A . pop ( j ) <NEWLINE> continue <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> for a in A : <NEWLINE> <INDENT> P . append ( a ) <NEWLINE> <DEDENT> return P <NEWLINE> <NL> <DEDENT> x = int ( input ( ) ) <NEWLINE> prime_table = eratosthenes ( 100003 ) <NEWLINE> prime_set = set ( prime_table ) <NEWLINE> if x in prime_set : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> idx = bisect_right ( prime_table , x ) <NEWLINE> ans = prime_table [ idx ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> R , S , P = map ( int , input ( ) . split ( ) ) <NEWLINE> T = input ( ) <NEWLINE> score = { <STRING> : P , <STRING> : R , <STRING> : S } <NEWLINE> m = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> command = [ ] <NEWLINE> mm = [ ] <NEWLINE> ans = 0 <NEWLINE> <NL> <NL> <NL> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> if t == <STRING> : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = P <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = R <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = P <NEWLINE> <NL> <DEDENT> if ( i - K >= 0 ) and ( command [ i - K ] == command ) : <NEWLINE> <INDENT> command = <STRING> <NEWLINE> point = 0 <NEWLINE> <NL> <DEDENT> ans += point <NEWLINE> command . append ( command ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> point = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> T = readline ( ) . strip ( ) <NEWLINE> <NL> T = T . translate ( str . maketrans ( <STRING> , <STRING> ) ) <NEWLINE> T = list ( map ( int , T ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( K ) : <NEWLINE> <INDENT> vec = T [ i : : K ] <NEWLINE> M = len ( vec ) <NEWLINE> <NL> dp = [ [ 0 ] * 3 for _ in range ( M + 1 ) ] <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> for k in range ( 3 ) : <NEWLINE> <INDENT> dp [ j + 1 ] [ k ] = max ( dp [ j ] [ ( k + 1 ) % 3 ] , dp [ j ] [ ( k + 2 ) % 3 ] ) <NEWLINE> if ( k + 1 ) % 3 == vec [ j ] : <NEWLINE> <INDENT> dp [ j + 1 ] [ k ] += point [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += max ( dp [ M ] ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> returnimport sys <NEWLINE> <NL> <DEDENT> read = sys . stdin . read <NEWLINE> readline = sys . stdin . readline <NEWLINE> readlines = sys . stdin . readlines <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> INF = 1 << 60 <NEWLINE> MOD = 1000000007 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N , K = map ( int , readline ( ) . split ( ) ) <NEWLINE> point = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> T = readline ( ) . strip ( ) <NEWLINE> <NL> T = list ( map ( int , T . translate ( str . maketrans ( <STRING> , <STRING> ) ) ) ) <NEWLINE> <NL> hand = [ 0 ] * N <NEWLINE> ans = 0 <NEWLINE> for i , h in enumerate ( T ) : <NEWLINE> <INDENT> win = ( h - 1 ) % 3 <NEWLINE> if i >= K and win == hand [ i - K ] : <NEWLINE> <INDENT> hand [ i ] = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hand [ i ] = win <NEWLINE> ans += point [ win ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s , p , r = map ( int , input ( ) . split ( ) ) <NEWLINE> f = { <STRING> : s , <STRING> : p , <STRING> : r } <NEWLINE> t = str ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> a = i + k <NEWLINE> last = t [ i ] <NEWLINE> ans += f [ last ] <NEWLINE> while a < n - k : <NEWLINE> <INDENT> if t [ a - k ] == last : <NEWLINE> <INDENT> if t [ a + k ] == last : <NEWLINE> <INDENT> if last == <STRING> : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if last == <STRING> : <NEWLINE> <INDENT> if t [ a + k ] == <STRING> : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> <DEDENT> elif last == <STRING> : <NEWLINE> <INDENT> if t [ a + k ] == <STRING> : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> N , M = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> A = np . array ( int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> A . sort ( ) <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def shake_cnt ( x ) : <NEWLINE> <COMMENT> <NL> <INDENT> X = np . searchsorted ( A , x - A ) <COMMENT> <NEWLINE> return N * N - X . sum ( ) <COMMENT> <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> left = 0 <COMMENT> <NEWLINE> right = 10 ** 6 <COMMENT> <NEWLINE> while 1 < right - left : <COMMENT> <NEWLINE> <INDENT> x = ( left + right ) // 2 <NEWLINE> if shake_cnt ( x ) >= M : <NEWLINE> <INDENT> left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = x <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> X = np . searchsorted ( A , right - A ) <COMMENT> <NEWLINE> shake = N * N - X . sum ( ) <COMMENT> <NEWLINE> <NL> Acum = np . zeros ( N + 1 , np . int64 ) <COMMENT> <NEWLINE> <COMMENT> <NL> Acum [ 1 : ] = np . cumsum ( A ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> happy = ( Acum [ - 1 ] - Acum [ X ] ) . sum ( ) + ( A * ( N - X ) ) . sum ( ) <NEWLINE> <NL> happy += ( M - shake ) * left <COMMENT> <NEWLINE> <NL> print ( happy ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ a - 1 ] . append ( ( b - 1 , i ) ) <NEWLINE> edges [ b - 1 ] . append ( ( a - 1 , i ) ) <NEWLINE> <DEDENT> l = [ 0 for i in range ( n ) ] <NEWLINE> def dfs ( cur , x ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in edges [ cur ] : <NEWLINE> <INDENT> if i [ 1 ] != x : <NEWLINE> <INDENT> res += dfs ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> l [ x ] = res <NEWLINE> return res <NEWLINE> <DEDENT> dfs ( 0 , - 1 ) <NEWLINE> l2 = [ 1 ] <NEWLINE> i2 = pow ( 2 , mod - 2 , mod ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l2 . append ( l2 [ - 1 ] * i2 % mod ) <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> cnt += ( 1 - l2 [ i ] ) * ( 1 - l2 [ n - i ] ) <NEWLINE> <DEDENT> print ( ( - n * i2 - l2 [ - 1 ] + cnt + 1 ) % mod ) <NEWLINE>
5 2 3 <NEWLINE>
def main2 ( ) : <NEWLINE> <INDENT> N , A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> d = B - A - 1 <NEWLINE> if d % 2 == 0 : <NEWLINE> <INDENT> print ( min ( B - 1 , N - A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( d + 1 ) // 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> ans = ( b - a ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( n - a , b - 1 , ( b - a - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( b - a ) % 2 == 0 : <NEWLINE> <INDENT> ams = ( b - a ) // 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = min ( a - 1 , N - b ) + 1 + ( b - a - 1 ) // 2 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> N , M , V , P = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> A = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <DEDENT> P -= 1 <COMMENT> <NEWLINE> A . sort ( reverse = True ) <COMMENT> <NEWLINE> cumsum = [ 0 ] * N <NEWLINE> cumsum [ 0 ] = A [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> cumsum [ i ] = cumsum [ i - 1 ] + A [ i ] <NEWLINE> <DEDENT> q = P + 1 <NEWLINE> while q < N : <NEWLINE> <INDENT> left = cumsum [ q - 1 ] <NEWLINE> if P > 0 : <NEWLINE> <INDENT> left -= cumsum [ P - 1 ] <NEWLINE> <DEDENT> right = M * ( N - V ) + A [ q ] * ( q - P ) <NEWLINE> if A [ P ] - A [ q ] > M or left > right : <NEWLINE> <INDENT> print ( q ) <NEWLINE> return <NEWLINE> <DEDENT> q += 1 <NEWLINE> <DEDENT> print ( q ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( 6 - A - B ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> x = [ A , B ] <NEWLINE> A = [ 1 , 2 , 3 ] <NEWLINE> for idx in range ( len ( A ) ) : <NEWLINE> <INDENT> if ( A [ idx ] in x ) == False : <NEWLINE> <INDENT> print ( A [ idx ] ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> n = [ 1 , 2 , 3 ] . remove ( a ) . remove ( b ) <NEWLINE> print ( n [ 0 ] ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( 6 - a + b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <INDENT> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if a != i and b != i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( A == 1 and B == 2 ) or ( A == 2 and B == 1 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( A == 2 and B == 3 ) or ( A == 3 and B == 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif ( A == 1 and B == 3 ) or ( A == 3 and B == 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> x = [ 1 , 2 , 3 ] <NEWLINE> x = x . remove ( a ) <NEWLINE> x = x . remove ( b ) <NEWLINE> print ( x [ 0 ] ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> flag1 = True <NEWLINE> flag2 = True <NEWLINE> flag3 = True <NEWLINE> <NL> if a = 1 : <NEWLINE> <INDENT> flag1 = False <NEWLINE> <DEDENT> elif a = 2 : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <DEDENT> elif a = 3 : <NEWLINE> <INDENT> flag3 = False <NEWLINE> <NL> <DEDENT> if b = 1 : <NEWLINE> <INDENT> flag1 = False <NEWLINE> <DEDENT> elif b = 2 : <NEWLINE> <INDENT> flag2 = False <NEWLINE> <DEDENT> elif b = 3 : <NEWLINE> <INDENT> flag3 = False <NEWLINE> <NL> <DEDENT> if flag1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif flag2 : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> <NL> if ( A == 1 and B == 2 ) or ( A == 2 and B == 1 ) : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif ( A == 1 and B == 3 ) or ( A == 3 and B == 1 ) : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif ( A == 2 and B == 3 ) or ( A == 3 ) and B == 2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
X = { 1 , 2 , 3 } <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( list ( X - set ( a ) - set ( b ) ) [ 0 ] ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> for i in raneg ( 3 ) : <NEWLINE> <INDENT> if i + 1 != A & & i + 1 != B : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT>
A = [ int ( input ( ) ) , int ( input ( ) ) ] <NEWLINE> if not 1 in A : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif not 2 in A : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else not 3 in A : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> if a != i and b != i : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> t = set ( [ 1 , 2 , 3 ] ) <NEWLINE> s = set ( [ a , b ] ) <NEWLINE> ans = t - s <NEWLINE> print ( list ( ans [ 0 ] ) ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> moji = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> moji += a [ i ] + b [ i ] <NEWLINE> <NL> <DEDENT> print ( moji ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = map ( input ( ) . split ( ) ) <NEWLINE> result = <STRING> <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> result += s [ i ] <NEWLINE> reuslt += t [ i ] <NEWLINE> <DEDENT> print ( result ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = map ( input ( ) . split ( ) ) <NEWLINE> <NL> res = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> res += S [ i ] <NEWLINE> res += T [ i ] <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> c = input ( ) <NEWLINE> d = <STRING> <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> d = d + b [ i ] + c [ i ] <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = input ( ) . split ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans += a [ i ] + b [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> ans = S [ 0 ] + T [ 0 ] <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ans + s [ i ] + T [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = map ( , input ( ) . split ( ) ) <NEWLINE> M = len ( S ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> ans += S [ i ] + T [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> lists = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lists += S [ i ] <NEWLINE> lists += T [ i ] <NEWLINE> <DEDENT> print ( * lists . split ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer_list = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> answer_list . append ( s [ i ] ) <NEWLINE> answer_list . append ( t [ i ] ) <NEWLINE> <NL> <DEDENT> s = <STRING> . join ( answer_list ) <NEWLINE> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( s [ i ] ) <NEWLINE> a . append ( t [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> U = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> U . append ( S [ i ] ) <NEWLINE> U . append ( T [ i ] ) <NEWLINE> <DEDENT> print ( U ) <NEWLINE>
a , b , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> x = min ( a , k ) <NEWLINE> a -= x <NEWLINE> k -= x <NEWLINE> y = min ( b , k ) <NEWLINE> b -= y <NEWLINE> <NL> print ( str ( a ) , str ( b ) ) <NEWLINE>
N = input ( ) <NEWLINE> S , T = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> A = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A += S [ i ] <NEWLINE> A += T [ i ] <NEWLINE> <NL> <DEDENT> print ( A ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> for ( ele , mele ) in zip ( s , t ) : <NEWLINE> <INDENT> print ( ele + mele , end = <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split <NEWLINE> <NL> l = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l . append ( S [ i ] ) <NEWLINE> l . append ( T [ i ] ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S , T = input ( ) . split ( ) <NEWLINE> ST = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ST . append ( S [ i ] ) <NEWLINE> ST . append ( T [ i ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ST ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = input ( ) . split ( ) <NEWLINE> out = <STRING> <NEWLINE> for i = range ( n ) : <NEWLINE> <INDENT> out += s [ i ] + t [ i ] <NEWLINE> <DEDENT> print ( out ) <NEWLINE>
n = input ( ) <NEWLINE> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> output = <STRING> <NEWLINE> <NL> for s , t in zip ( a , b ) : <NEWLINE> <INDENT> output += a <NEWLINE> output += b <NEWLINE> <DEDENT> print ( output ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s , t = map ( str , input ( ) . split ( ) ) <NEWLINE> a = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a [ i ] + s [ i ] + t [ i ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
from math import gcd <NEWLINE> a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b / gcd ( a , b ) ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> temp = math . gcd ( a , b ) <NEWLINE> ans = a * b // temp <NEWLINE> print ( ans <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b // math . gcd ( a , b ) ) <NEWLINE>
def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> def abc148c_snack ( ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( lcm ( a , b ) ) <NEWLINE> <NL> <DEDENT> abc148c_snack ( ) <NEWLINE>
import math <NEWLINE> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) def lcm ( x , y ) : <NEWLINE> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> print ( lcm ( a , b ) ) <NEWLINE>
def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <DEDENT> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( lcm ( a , b ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while A != B : <NEWLINE> <INDENT> if A > B : <NEWLINE> <INDENT> A , B = B , A <NEWLINE> <DEDENT> A += A <NEWLINE> <NL> <DEDENT> print ( A ) <NEWLINE>
import math <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( A * B / gcd ( A , B ) ) <NEWLINE>
from math import gcd <NEWLINE> def main ( ) : <NEWLINE> <INDENT> a , b = = map ( int , input ( ) . split ( ) ) <NEWLINE> r = ( a * b ) // gcd ( a , b ) <NEWLINE> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> def lcm ( x , y ) : <NEWLINE> <INDENT> return ( x * y ) // math . gcd ( x , y ) <NEWLINE> <NL> <DEDENT> print ( lcm ( a , b ) ) <NEWLINE>
import numpy as np <NEWLINE> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( lcm ( A , B ) ) <NEWLINE>
import math <NEWLINE> <NL> A , B = map ( int , input ( ) ) <NEWLINE> print ( A * B // math . gcd ( A , B ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = 1 <NEWLINE> d = 0 <NEWLINE> if a > b : <NEWLINE> <INDENT> for i in range ( 1 , a ) : <NEWLINE> <INDENT> if a % ( a - i ) == 0 and b % ( b - i ) == 0 : <NEWLINE> <INDENT> a = a / ( a - i ) <NEWLINE> b = b / ( a - i ) <NEWLINE> c = c * ( a - i ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( a * b * c ) ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> for i in range ( 1 , b ) : <NEWLINE> <INDENT> if a % ( b - i ) == 0 and b % ( b - i ) == 0 : <NEWLINE> <INDENT> a = a / ( b - i ) <NEWLINE> b = b / ( a - i ) <NEWLINE> c = c * ( b - i ) <NEWLINE> <DEDENT> <DEDENT> print ( int ( a * b * c ) ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> lcm = 0 <NEWLINE> for i in range ( 1 , B + 1 ) : <NEWLINE> <INDENT> if ( A * i ) % B == 0 : <NEWLINE> <INDENT> lcm = A * i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( lcm ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( 1 in a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> jud = 0 <NEWLINE> f = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( p [ 0 ] != f ) : <NEWLINE> <INDENT> del p [ 0 ] <NEWLINE> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> t = 1 <NEWLINE> for x in a : <NEWLINE> <INDENT> if x == t : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> t -= 1 <NEWLINE> <NL> if t == 0 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( M - t ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 1 <NEWLINE> ans = 0 <NEWLINE> for i in range b : <NEWLINE> <INDENT> if i == c : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> if ans == a : <NEWLINE> <INDENT> ans = - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = input ( ) <NEWLINE> renga = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> ni = 1 <NEWLINE> remains = 0 <NEWLINE> <NL> for r in renga : <NEWLINE> <INDENT> if ni == r : <NEWLINE> <INDENT> ni += 1 <NEWLINE> remains += 1 <NEWLINE> <DEDENT> <DEDENT> if ni == 1 : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( renga - remains ) <NEWLINE> <DEDENT>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( A * B / math . gcd ( A , B ) ) ) <NEWLINE>
class Stack : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . count = 1 <NEWLINE> self . lst = [ ] <NEWLINE> <NL> <DEDENT> def push ( self , element ) : <NEWLINE> <INDENT> if element == count : <NEWLINE> <INDENT> self . lst . append ( element ) <NEWLINE> self . count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def length ( self ) : <NEWLINE> <INDENT> return len ( self . lst ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> stack = Stack ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> stack . push ( i ) <NEWLINE> <NL> <DEDENT> b = stack . length ( ) <NEWLINE> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n - b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> M = 10 <NEWLINE> ans = 0 <NEWLINE> <NL> if N % 2 == 0 <NEWLINE> <INDENT> while N > M : <NEWLINE> <INDENT> ans += N // M <NEWLINE> M *= 5 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n % 2 == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> l = 10 <NEWLINE> while n >= l : <NEWLINE> <INDENT> ans += floor ( n / ( l ) ) <NEWLINE> l *= 5 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b + c = > 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = [ map ( int , input ( ) . split ( ) ) ] <NEWLINE> print ( <STRING> if sum ( a ) >= 22 else <STRING> ) <NEWLINE>
print ( <STRING> if sum ( list ( map , input ( ) . split ( ) ) ) >= 22 else <STRING> ) <NEWLINE>
a , b , c = map ( int , input ( ) , split ( ) ) <NEWLINE> if a + b + c >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> a = sum ( A ) <NEWLINE> if a >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a + b + c >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> if ( a + b + c ) >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( <STRING> if sun ( map ( int , input ( ) . split ( ) ) ) <= 21 else <STRING> ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> X = [ ] <NEWLINE> Y = [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> box_x = [ ] <NEWLINE> box_y = [ ] <NEWLINE> for _ in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> box_x . append ( x ) <NEWLINE> box_y . append ( y ) <NEWLINE> <DEDENT> X . append ( box_x ) <NEWLINE> Y . append ( box_y ) <NEWLINE> <NL> <DEDENT> person = [ 2 ] * N <NEWLINE> <NL> maxim = 0 <NEWLINE> for i in range ( 1 << N ) : <NEWLINE> <INDENT> c_person = person . copy ( ) <NEWLINE> honest = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> mask = 1 << j <NEWLINE> if mask & i != 0 : <NEWLINE> <INDENT> c_person [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_person [ j ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for k , l in enumerate ( c_person ) : <NEWLINE> <COMMENT> <NL> <INDENT> if l == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> for m , n in zip ( X [ k ] , Y [ k ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if c_person [ m - 1 ] != n : <NEWLINE> <INDENT> honest = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> honest = sum ( c_person ) <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> maxim = max ( maxim , honest ) <NEWLINE> <NL> <DEDENT> print ( maxim ) <NEWLINE>
A1 , A2 , A3 = input ( ) . split ( ) <NEWLINE> <NL> T = A1 + A2 + A3 <NEWLINE> <NL> if T > 21 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) split ( ) ) <NEWLINE> sum = a + b + c <NEWLINE> <NL> if sum >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) ) <NEWLINE> if a + b + c >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B , C = int ( input ( ) ) <NEWLINE> if A + B + C <= 21 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = list ( map ( int , input ( ) split ( ) ) ) <NEWLINE> B = 0 <NEWLINE> B = A [ 0 ] + A [ 1 ] + A [ 2 ] <NEWLINE> if B >= 22 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if sum ( map ( int , input ( ) . split ( ) ) > 21 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A = input ( ) ; print ( sum ( i != j for i , j in zip ( A , A [ : : - 1 ] ) // 2 ) <NEWLINE>
s = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) // 2 + 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ len ( s ) - 1 - i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> s_r = s [ : : - 1 ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != s_r [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
S = input ( ) <NEWLINE> hug = 0 <NEWLINE> if len ( S ) % 2 == 0 : <NEWLINE> <INDENT> for i in range ( len ( S / 2 ) ) : <NEWLINE> <INDENT> if not S [ i ] == S [ - i - 1 ] : <NEWLINE> <INDENT> hug += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( int ( ( len ( S ) + 1 ) / 2 ) ) : <NEWLINE> <INDENT> if not S [ i ] == S [ - i - 1 ] : <NEWLINE> <INDENT> hug += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( hug ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) // 2 <NEWLINE> p = n <NEWLINE> j = - 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if n [ i ] == n [ j ] : <NEWLINE> <INDENT> p -= 1 <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( S // 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ len ( S ) - 1 - i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
A = input ( ) <NEWLINE> c = 0 <NEWLINE> B = A [ : : - 1 ] <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] != B [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for s1 , s2 in zip ( s , s [ : : - 1 ] ) : <NEWLINE> <INDENT> if s1 != s2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt // 2 ) <NEWLINE>
s = input ( ) <NEWLINE> t = s <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> ans += 1 - s [ i ] == t [ i ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] != s [ : : - 1 ] [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> ptint ( t // 2 ) <NEWLINE>
s = input ( ) ; n = len ( s ) - 1 ; print ( sum ( s [ i ] != s [ n - i ] for i in range ( n + 1 ) ) // 2 ) s = input ( ) ; n = len ( s ) - 1 ; print ( sum ( s [ i ] != s [ n - i ] for i in range ( n + 1 ) ) // 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] != a [ len ( a ) - i ] : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> print ( int ( b / 2 ) ) <NEWLINE>
s = input ( ) <NEWLINE> s1 = s [ : s // 2 ] <NEWLINE> s2 = s [ - 1 * ( s // 2 ) : ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( s // 2 ) : <NEWLINE> <INDENT> if s1 [ i ] != s2 [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> xy = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> A . append ( a ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> xy . append ( [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> print ( xy ) <NEWLINE> <NL> honest = 0 <NEWLINE> <NL> for i in range ( 1 , 2 ** N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i >> j ) & 1 == 1 : <NEWLINE> <INDENT> for x , y in xy [ j ] : <NEWLINE> <COMMENT> <NL> <INDENT> if ( i >> x ) & 1 != y : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> honest = max ( honest , bin ( i ) [ 2 : ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( honest ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = [ 0 ] * n <NEWLINE> param_list = [ 0 ] * 2 ** n <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> l = [ False ] * n <NEWLINE> for id_r , row in enumerate ( ls ) : <NEWLINE> <INDENT> if i & ( 2 ** id_r ) > 0 : <NEWLINE> <INDENT> l [ id_r ] = True <NEWLINE> <DEDENT> <DEDENT> param_list [ i ] = l <NEWLINE> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> for k in range ( A ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> b = ( 1 == b ) <NEWLINE> new_param = [ ] <NEWLINE> for d in a_list : <NEWLINE> <INDENT> if d [ i ] : <NEWLINE> <INDENT> if d [ a - 1 ] == b : <NEWLINE> <INDENT> new_param . append ( d ) <NEWLINE> pass <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> new_param . append ( d ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> param_list = new_param <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for d in param_list : <NEWLINE> <INDENT> ans = max ( ans , d . count ( True ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tst = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> st [ i ] . append ( [ x , y ] ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> honest = [ 0 ] * n <NEWLINE> check = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( bit >> i ) & 1 : <NEWLINE> <INDENT> honest [ - 1 - i ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if not honest [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for l in tst [ i ] : <NEWLINE> <INDENT> if l [ 1 ] != honest [ l [ 0 ] - 1 ] : <NEWLINE> <INDENT> check = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> ans = max ( ans , sum ( honest ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ListN = [ ] * <NEWLINE> List = [ ] <NEWLINE> keepOrder <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> ListN . append ( k ) <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> List . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> for bits in range ( 2 ** N ) : <NEWLINE> <INDENT> keepOrder = list ( bin ( bits ) ) <NEWLINE> flag = True <NEWLINE> print ( bits , keepOrder ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( ( bits >> j ) & 1 ) : <NEWLINE> <INDENT> for k in range ( ListN [ j ] ) : <NEWLINE> <INDENT> if keepOrder [ List [ k ] [ 0 ] - 1 ] != List [ k ] [ 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if keepOrder [ List [ k ] [ 0 ] - 1 ] == List [ k ] [ 1 ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> res = max ( res , keepOrder . count ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> XY = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> xy = [ ] <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> xy . append ( [ x , y ] ) <NEWLINE> <DEDENT> XY . append ( xy ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for k in range ( 2 ** n ) : <NEWLINE> <INDENT> s = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> case = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( k >> j ) & 1 : <NEWLINE> <INDENT> s [ n - 1 - j ] = 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> if s [ k ] == 1 : <NEWLINE> <INDENT> for l in range ( len ( XY [ l ] ) ) : <NEWLINE> <INDENT> if s [ XY [ k ] [ l ] [ 0 ] - 1 ] != XY [ k ] [ l ] [ 1 ] : <NEWLINE> <INDENT> case = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if case == 0 : <NEWLINE> <INDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> testimony = [ [ - 1 ] * N for i in range ( N ) ] <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A = int ( input ( ) ) <NEWLINE> for j in range ( A ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> testimony [ i ] [ x - 1 ] = y <NEWLINE> <DEDENT> <DEDENT> fro i in range ( 2 ** N ) : <NEWLINE> <INDENT> honest = [ 0 ] * N <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> honest [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> flag = True <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if honest [ j ] == 1 : <NEWLINE> <INDENT> for k in range ( N ) : <NEWLINE> <INDENT> if testimony [ j ] [ k ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if testimony [ j ] [ k ] != honest [ k ] : <NEWLINE> <INDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> count = max ( count , hones . count ( 1 ) ) <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 2000 ) <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> syogen = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> N_a = int ( input ( ) ) <NEWLINE> syogen_a = [ ] <NEWLINE> for _ in range ( N_a ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> syogen_a . append ( [ int ( x ) - 1 , int ( y ) ] ) <NEWLINE> <DEDENT> syogen . append ( syogen_a ) <NEWLINE> <NL> <NL> <DEDENT> def syojiki ( i ) : <NEWLINE> <INDENT> for x , y in syogen [ i ] : <NEWLINE> <INDENT> if y == 1 : <NEWLINE> <INDENT> syojiki_list . append ( x ) <NEWLINE> if len ( syojiki_list ) >= N : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> syojiki ( x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def check_syojiki ( syojikitati ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for s in range ( N ) : <NEWLINE> <INDENT> if not ( s in syojikitati ) : <NEWLINE> <INDENT> d [ s ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for s in syojikitati : <NEWLINE> <INDENT> d [ s ] = 1 <NEWLINE> for x , y in syogen [ s ] : <NEWLINE> <INDENT> if d [ x ] != y : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] = y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> max_syojiki = 0 <NEWLINE> <NL> for i in range ( 2 ** N ) : <NEWLINE> <INDENT> d = { } <NEWLINE> syojiki_list = [ ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 : <NEWLINE> <INDENT> syojiki_list . append ( j ) <NEWLINE> syojiki ( j ) <NEWLINE> <DEDENT> <DEDENT> syojiki_list = list ( set ( syojiki_list ) ) <NEWLINE> if check_syojiki ( syojiki_list ) : <NEWLINE> <INDENT> max_syojiki = max ( max_syojiki , len ( syojiki_list ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_syojiki ) <NEWLINE>
from itertools import product <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> xy = [ [ ] for i in range ( N ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j i range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> xy [ i ] . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for bit in product ( [ 0 , 1 ] , repeat = N ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> for i , j in enumerate ( bit ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> for x , y in xy [ i ] : <NEWLINE> <INDENT> if bit [ x - 1 ] != y : <NEWLINE> <INDENT> f = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> ans = max ( ans , sum ( bit ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> XY = [ [ [ ] ] for n in range ( N ) ] <NEWLINE> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> XY [ n ] = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( a ) ] <NEWLINE> <NL> <DEDENT> maxH = 0 <NEWLINE> for mask_i in range ( 1 << N ) : <NEWLINE> <NL> <INDENT> H = [ 0 ] * ( N + 1 ) <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> if mask_i >> n & 1 : <NEWLINE> <INDENT> H [ n + 1 ] = 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for n in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> ok = True <NEWLINE> if H [ n ] == 1 : <NEWLINE> <INDENT> for x , y in XY [ n ] : <NEWLINE> <INDENT> if H [ x ] != y : <NEWLINE> <INDENT> ok = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> maxH = max ( maxH , sum ( H ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxH ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> g = [ [ - 1 ] * 15 for _ in range ( 15 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> g [ i ] [ x - 1 ] = y <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( 1 << n ) : <NEWLINE> <INDENT> honest = [ 0 ] * n <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( i >> j ) & 1 == 1 : <NEWLINE> <INDENT> honest [ j ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ok = True <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if honest [ j ] : <COMMENT> <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if g [ j ] [ k ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if g [ i ] [ j ] != honest [ k ] : <NEWLINE> <INDENT> ok = False <NEWLINE> <DEDENT> <DEDENT> if ok : <NEWLINE> <INDENT> ans = max ( ans , honest . count ( 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> XY = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> XY [ i ] . append ( [ x - 1 , y ] ) <NEWLINE> <DEDENT> <DEDENT> honest = 0 <NEWLINE> for bit in range ( 1 << n ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if bit & ( 1 << i ) : <NEWLINE> <INDENT> for a , b in XY [ i ] : <NEWLINE> <INDENT> if bit & ( 1 << a ) != b : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> honest = max ( honest , bin ( i ) [ 2 : ] . count ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> from io import StringIO <NEWLINE> import unittest <NEWLINE> import copy <NEWLINE> <NL> <NL> class TestClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def assertIO ( self , input , output ) : <NEWLINE> <INDENT> stdout , stdin = sys . stdout , sys . stdin <NEWLINE> sys . stdout , sys . stdin = StringIO ( ) , StringIO ( input ) <NEWLINE> resolve ( ) <NEWLINE> sys . stdout . seek ( 0 ) <NEWLINE> out = sys . stdout . read ( ) [ : - 1 ] <NEWLINE> sys . stdout , sys . stdin = stdout , stdin <NEWLINE> self . assertEqual ( out , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_1 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <DEDENT> def test_入力例_2 ( self ) : <NEWLINE> <INDENT> input = <STRING> <NEWLINE> output = <STRING> <NEWLINE> self . assertIO ( input , output ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> R , C = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( R ) ] <NEWLINE> A_rev = [ [ 1 - v for v in a ] for a in A ] <NEWLINE> <NL> ans = 0 <NEWLINE> for bit in range ( 1 << R ) : <NEWLINE> <INDENT> num = 0 <NEWLINE> T = copy . deepcopy ( A ) <NEWLINE> for i , t in enumerate ( T ) : <NEWLINE> <INDENT> if 1 << i & bit : <NEWLINE> <INDENT> T [ i ] = A_rev [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> T = list ( zip ( * T ) ) <NEWLINE> for t in T : <NEWLINE> <INDENT> num += max ( t . count ( 0 ) , t . count ( 1 ) ) <NEWLINE> <DEDENT> ans = max ( ans , num ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10e9 + 7 <NEWLINE> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> x = 1 << i <NEWLINE> n = len ( [ 1 for j in a if j & X ] ) <NEWLINE> ans += x * n * ( N - n ) % mod <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> A = np . array ( A , dtype = np . int64 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 60 ) : <NEWLINE> <INDENT> mask = 1 << i <NEWLINE> cnt = np . count_nonzero ( A & mask ) <NEWLINE> x = cnt * ( N - cnt ) <NEWLINE> x *= mask % mod <NEWLINE> ans += x <NEWLINE> ans %= mod <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
md1 = map ( int , input ( ) . split ( ) ) <NEWLINE> md2 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( 1 if md1 [ 0 ] != md2 [ 0 ] else 0 ) <NEWLINE>
MD = [ map ( int , input ( ) . split ( ) ) for _ in range ( N ) ] <NEWLINE> M , D = [ list ( i ) for i in zip ( * MD ) ] <NEWLINE> <NL> if D [ 1 ] == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( [ 0 , 1 ] [ a == b + 1 ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = <STRING> <NEWLINE> <NL> for X in range ( N - 1 ) : <NEWLINE> <INDENT> if int ( X * 1.08 ) = N : <NEWLINE> <INDENT> ans = X <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if math . floor ( float ( i ) * 1.08 ) == N : <NEWLINE> <INDENT> ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = rond ( n / 1.08 ) <NEWLINE> if int ( m * 1.08 ) == n : <NEWLINE> <INDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( ( m - 1 ) * 1.08 ) == n : <NEWLINE> <INDENT> print ( m - 1 ) <NEWLINE> <DEDENT> elif int ( ( m + 1 ) * 1.08 ) == n : <NEWLINE> <INDENT> print ( m + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> import numpy as np <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> def S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def SL ( ) : return map ( str , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def IL ( ) : return map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> f = math . ceil ( m / 1.08 ) <NEWLINE> if math . floor ( f * 1.08 ) == n : <NEWLINE> <INDENT> print ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> solve ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> num = round ( n / 1.08 ) <NEWLINE> check = round ( num * 1.08 ) <NEWLINE> if check == n <NEWLINE> <INDENT> print ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = math . ceil ( N / 1.08 ) <NEWLINE> if S * 1.08 != N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = float ( input ( ) ) <NEWLINE> a = math . ceil ( N / ( 1.08 ) ) <NEWLINE> for i in range ( a , N ) : <NEWLINE> <INDENT> if math . floor ( i * 1.08 ) == N : <NEWLINE> <INDENT> print ( a ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> flag = False <NEWLINE> for i in range ( 100 * n , 100 * ( n + 1 ) ) : <NEWLINE> <INDENT> if i % 108 == 0 : <NEWLINE> <INDENT> x == int ( i // 108 ) <NEWLINE> print ( x ) <NEWLINE> flag == True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = N / 1.08 <NEWLINE> s = math . ceil ( s ) <NEWLINE> t = s * 1.08 <NEWLINE> t = math . floor ( t ) <NEWLINE> if N == t : <NEWLINE> <INDENT> input ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = n / 1.08 <NEWLINE> nn = x * 1.08 <NEWLINE> if n <= nn < n + 1 : <NEWLINE> <INDENT> if x * 10 % 10 >= 5 : <NEWLINE> print ( int ( x ) + 1 ) <NEWLINE> else : <NEWLINE> <INDENT> print ( int ( x ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def main2 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = int ( math . ceil ( n / 1.08 ) ) <NEWLINE> <NL> if int ( x * 1.08 ) == n : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main2 ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> ans = : ( <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if int ( ( i * 1.08 ) // 1 ) == n : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = N / 1.08 <NEWLINE> B = ( N + 1 ) / 1.08 <NEWLINE> <NL> if math . ceil ( A ) < math . ceil ( B ) : <NEWLINE> <INDENT> print ( ceil ( A ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> kosuu , amari = x // 100 , x % 100 <NEWLINE> ans = 0 <NEWLINE> <NL> for i in kosuu : <NEWLINE> <INDENT> amari -= 5 <NEWLINE> if amari <= 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> dp = [ 0 ] * ( x + 1 ) <NEWLINE> dp [ 100 ] = 1 <NEWLINE> dp [ 101 ] = 1 <NEWLINE> dp [ 102 ] = 1 <NEWLINE> dp [ 103 ] = 1 <NEWLINE> dp [ 104 ] = 1 <NEWLINE> dp [ 105 ] = 1 <NEWLINE> <NL> for i in range ( 100 , x + 1 ) : <NEWLINE> <INDENT> for j in range ( 100 , 106 ) : <NEWLINE> <INDENT> dp [ i + j ] = max ( dp [ i ] , dp [ i + j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dp [ x ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> for i1 in range ( 1000000 ) : <NEWLINE> <INDENT> for i2 in range ( 1000000 ) : <NEWLINE> <INDENT> for i3 in range ( 1000000 ) : <NEWLINE> <INDENT> for i4 in range ( 1000000 ) : <NEWLINE> <INDENT> for i5 in range ( 1000000 ) : <NEWLINE> <INDENT> for i6 in range ( 1000000 ) : <NEWLINE> <INDENT> if 100 * i1 + 101 * i2 + 102 * i3 + 103 * i4 + 104 * i5 + 105 * i6 == X : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
dp = [ Yes ] <COMMENT> <NEWLINE> for i in range ( 99 ) : <NEWLINE> <INDENT> dp . append ( No ) <NEWLINE> <DEDENT> for i in range ( 100 , x + 1 ) : <NEWLINE> <INDENT> if ( i < 106 ) : <NEWLINE> <INDENT> dp . append ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( ( dp [ i - 100 ] == Yes ) or ( dp [ i - 101 ] == Yes ) or ( dp [ i - 102 ] == Yes ) or ( dp [ i - 103 ] == Yes ) or ( dp [ i - 104 ] == Yes ) or ( dp [ i - 105 ] == Yes ) ) : <NEWLINE> <INDENT> dp [ i ] . append ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] . append ( No ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ x ] ) <NEWLINE>
X = int ( input ( ) ) <NEWLINE> number = X // 100 <NEWLINE> teen = X % 100 <NEWLINE> <NL> elif teen <= 5 * number : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
import re <NEWLINE> import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> import functools <NEWLINE> def v ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> cnt = 1 <NEWLINE> ans = 0 <NEWLINE> inf = float ( <STRING> ) <NEWLINE> al = <STRING> <NEWLINE> AL = al . upper ( ) <NEWLINE> <NL> n = k ( ) <NEWLINE> s = v ( ) <NEWLINE> <NL> s1 , s2 , s3 = set ( ) , set ( ) , set ( ) <NEWLINE> for x in S : <NEWLINE> <INDENT> for z in s2 : <NEWLINE> <INDENT> s3 . add ( z + x ) <NEWLINE> <DEDENT> for y in s1 : <NEWLINE> <INDENT> s2 . add ( y + x ) <NEWLINE> <DEDENT> s1 . add ( x ) <NEWLINE> <DEDENT> print ( len ( s3 ) ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> str_i = str ( i ) <NEWLINE> i_index == S . find ( str_i ) <NEWLINE> if i_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> str_j = str ( j ) <NEWLINE> j_index = S . find ( str_j , i_index + 1 ) <NEWLINE> if j_index == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> str_k = str ( k ) <NEWLINE> k_index = S . find ( str_k , j_index + 1 ) <NEWLINE> if k_index != - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> l = [ 0 ] * n <NEWLINE> l [ 0 ] = 3 <NEWLINE> ans = 1 <NEWLINE> for ai in a : <NEWLINE> <INDENT> ans *= l [ ai ] <NEWLINE> ans %= mod <NEWLINE> l [ ai ] -= 1 <NEWLINE> l [ ai + 1 ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> input = sys . stdin . readline <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> candidates = [ 0 ] * n <NEWLINE> candidates [ 0 ] = 3 <NEWLINE> ans = 1 <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans *= candidates [ a ] <NEWLINE> ans %= mod <NEWLINE> candidates [ a ] -= 1 <NEWLINE> candidates [ a + 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 1000000007 <NEWLINE> ans = 1 <NEWLINE> cnt = [ 3 for i == 0 else 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for a in A : <NEWLINE> <INDENT> ans = ans * cnt [ a ] % mod <NEWLINE> if ans == 0 : break <NEWLINE> cnt [ a ] -= 1 <NEWLINE> cnt [ a + 1 ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> if A [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <DEDENT> L = [ 1 , 0 , 0 ] <NEWLINE> ans = 3 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> a = A [ i ] <NEWLINE> count = 0 <NEWLINE> add = True <NEWLINE> for j , l in enumerate ( L ) : <NEWLINE> <INDENT> if a == l : <NEWLINE> <INDENT> count += 1 <NEWLINE> if add : <NEWLINE> <INDENT> L [ j ] += 1 <NEWLINE> add = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans *= count <NEWLINE> ans %= mod <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <COMMENT> <NL>
n , * a = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> cnt = [ 3 ] + [ 0 ] * ( n - 2 ) <NEWLINE> ans = 1 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> for i in a : <NEWLINE> <INDENT> ans = ans * cnt [ i ] % mod <NEWLINE> cnt [ i ] -= 1 <NEWLINE> cnt [ i + 1 ] += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
n = str ( input ( ) ) <NEWLINE> dic = { SUN : 7 , <NEWLINE> <INDENT> MON : 6 , <NEWLINE> TUE : 5 , <NEWLINE> WED : 4 , <NEWLINE> THU : 3 , <NEWLINE> FRI : 2 , <NEWLINE> SAT : 1 } <NEWLINE> <DEDENT> print ( dic ( n ) ) <NEWLINE>
import sys <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> N = int ( readline ( ) ) <NEWLINE> A = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , readline ( ) . split ( ) ) ) <NEWLINE> N , W = map ( int , readline ( ) . split ( ) ) <NEWLINE> SS = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> S = readline ( ) . decode ( ) . rstrip ( ) <NEWLINE> for i in range ( 7 ) : <NEWLINE> <INDENT> if S == SS [ i ] : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
I = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 7 ) : <NEWLINE> <INDENT> if I [ i ] == input ( ) : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> <DEDENT> <DEDENT>
D = input ( ) <NEWLINE> W = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( 7 - l . index ( D ) ) <NEWLINE>
if S == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if S == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT>
if input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 6 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif input ( ) == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
A = input ( ) <NEWLINE> <NL> S = [ SUN , MON , TUE , WED , THU , FRI , SAT ] <NEWLINE> <NL> for i in range ( 7 ) : <NEWLINE> <INDENT> if A == S [ i ] : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
SUN = 7 <NEWLINE> MON = 1 <NEWLINE> TUE = 2 <NEWLINE> WED = 3 <NEWLINE> THU = 4 <NEWLINE> FRI = 5 <NEWLINE> SAT = 6 <NEWLINE> <NL> A = input ( ) <NEWLINE> <NL> <NL> print ( 7 - A ) <NEWLINE>
<COMMENT> <NL> weekday = input ( ) <NEWLINE> <COMMENT> <NL> if weekday == <STRING> : <NEWLINE> <INDENT> print ( 7 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 6 ) S <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 5 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif weekday == <STRING> : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> res = 0 <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> res = 7 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 6 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 5 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 4 <NEWLINE> <DEDENT> leif s == <STRING> : <NEWLINE> <INDENT> res = 3 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 2 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> res = 1 <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> answer = <STRING> <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
S = input ( ) <NEWLINE> print ( 7 if S == <STRING> 6 if S == <STRING> 5 if S == <STRING> 4 if S == <STRING> 3 if S == <STRING> 2 if S == <STRING> 1 if S == <STRING> <NEWLINE>
S = input ( ) <NEWLINE> week = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in week : <NEWLINE> <INDENT> if week [ i ] == S : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> <DEDENT> <DEDENT>
s = input ( ) <NEWLINE> d = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( d . index ( s ) [ : : - 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> days = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> } <NEWLINE> print ( 7 - days . index ( S ) ) <NEWLINE>
s = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( 7 - a . index ( a ) ) <NEWLINE>
S = input ( ) <NEWLINE> DAY = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for num in range ( 7 ) : <NEWLINE> <INDENT> if DAY [ num ] = S : <NEWLINE> <INDENT> print ( 7 - num ) <NEWLINE> <DEDENT> <DEDENT>
youbi = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> y = input ( ) <NEWLINE> <NL> for i in range ( 1 , 7 ) : <NEWLINE> <INDENT> if y = youbi [ i ] : <NEWLINE> <INDENT> print ( 7 - i ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> x = len ( s ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> a = s [ i ] <NEWLINE> b = ord ( a ) <NEWLINE> c = ord ( <STRING> ) <NEWLINE> d = ( b + n - c ) % 26 <NEWLINE> s [ i ] = chr ( c + d ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = chr ( ord ( ( s [ i ] - 65 + n ) % 26 + 65 ) ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> def push ( chara , dig ) : <NEWLINE> <INDENT> if ord ( chara ) + dig > 90 : return chr ( 64 + dig + ord ( chara ) - 90 ) <NEWLINE> else : return chr ( dig + ord ( chara ) ) <NEWLINE> <NL> <DEDENT> string = input ( ) <NEWLINE> <NL> for i in range ( 0 , len ( string ) ) : <NEWLINE> <INDENT> string [ i ] = push ( string [ i ] , n ) <NEWLINE> <NL> <DEDENT> print ( string ) <NEWLINE>
import string <NEWLINE> l = string . ascii_uppercase <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> ans = [ ] <NEWLINE> plusNumber = N % 26 <NEWLINE> for c in S : <NEWLINE> <INDENT> ans . append ( l [ l . index ( c ) + plusNumber ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
A = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> X = input ( ) <NEWLINE> for i in range ( 0 , len ( X ) - 1 ) : <NEWLINE> <INDENT> n = ( A . index ( X [ i ] ) + N ) % 26 <NEWLINE> X [ i ] = A [ n ] <NEWLINE> <DEDENT> print ( X ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( input ( ) ) <NEWLINE> A_change = { } <NEWLINE> B = [ A , B , C , D , E , F , G , H , I , J , K , L , M , N , O , P , Q , R , S , T , U , V , W , X , Y , Z ] <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in B : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> A_change [ i ] = str ( B [ ( B . index ( j ) + n ) % 26 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( list ( A_change . values ( ) ) ) <NEWLINE>
A = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> x = n % 26 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for j in range ( 25 ) : <NEWLINE> <INDENT> if s [ i ] == A [ j ] : <NEWLINE> <INDENT> if j + x <= 25 : <NEWLINE> <INDENT> s [ i ] = A [ j + x ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s [ i ] = A [ j + x - 26 ] <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> e = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> e . append ( b ) <NEWLINE> <NL> <DEDENT> q = deque ( [ 0 ] ) <NEWLINE> <NL> color = [ 0 for _ in range ( n ) ] <NEWLINE> while ( len ( q ) > 0 ) : <NEWLINE> <INDENT> ei = q . popleft ( ) <NEWLINE> c = 1 <NEWLINE> for x in g [ ei ] : <NEWLINE> <INDENT> if c == color [ ei ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> color [ x ] = c <NEWLINE> c += 1 <NEWLINE> q . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( color ) ) <NEWLINE> for i in e : <NEWLINE> <INDENT> print ( color [ i ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> graph = [ ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( [ b , i ] ) <NEWLINE> graph [ b ] . append ( [ a , i ] ) <NEWLINE> <NL> <DEDENT> ans = [ 0 ] * ( n - 1 ) <NEWLINE> <NL> q = deque ( [ [ 1 , 0 , 0 ] ] ) a <NEWLINE> <NL> while q : <NEWLINE> <INDENT> node , pcol , p_node = q . popleft ( ) <NEWLINE> cnt = 1 <NEWLINE> for n_node in graph [ node ] : <NEWLINE> <INDENT> if n_node [ 0 ] == p_node : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cnt == pcol : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> ans [ n_node [ 1 ] ] = cnt <NEWLINE> q . append ( [ n_node [ 0 ] , cnt , node ] ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( ans ) ) <NEWLINE> print ( * ans , sep = <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) ) <NEWLINE> coin = 0 <NEWLINE> if x == 1 and y == 1 : <NEWLINE> <INDENT> coin += 400000 <NEWLINE> <DEDENT> if x == 1 : <NEWLINE> <INDENT> coin += 300000 <NEWLINE> <DEDENT> if y == 1 : <NEWLINE> <INDENT> coin += 300000 <NEWLINE> <DEDENT> if x == 2 : <NEWLINE> <INDENT> coin += 200000 <NEWLINE> <DEDENT> if y == 2 : <NEWLINE> <INDENT> coin += 200000 <NEWLINE> <DEDENT> if x == 3 : <NEWLINE> <INDENT> coin += 100000 <NEWLINE> <DEDENT> if y == 3 : <NEWLINE> <INDENT> coin += 100000 <NEWLINE> <DEDENT> print ( coin ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> import bisect <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> AList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ASum = sum ( a ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c += AList [ i ] <NEWLINE> if c >= ASum / 2 : <NEWLINE> <INDENT> k = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = min ( 2 * c - ASum , ASum - 2 * c + 2 * AList [ k ] ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = float ( <STRING> ) <NEWLINE> sa = [ ] <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> sa . append ( sa [ i ] + ai ) <NEWLINE> <DEDENT> for i in range ( n + 1 ) : <NEWLINE> <INDENT> ans = min ( ans , abs ( sa [ i ] - ( sa [ - 1 ] - sa [ i ] ) ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> val = sum ( A ) // 2 <NEWLINE> tmp = 0 <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> tmp += A [ n ] <NEWLINE> if tmp >= val : <NEWLINE> <INDENT> print ( min ( abs ( sum ( A [ n + 1 : ] - tmp ) , abs ( sum ( A [ n : ] - tmp - A [ n ] ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
h , w , k = list ( map ( int , f . readline ( ) . split ( ) ) ) <NEWLINE> <NL> grid = [ input ( ) for _ in range ( h ) ] <NEWLINE> ans = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for j in range ( h ) : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if grid [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> l = i <NEWLINE> r = i <NEWLINE> u = j <NEWLINE> d = j <NEWLINE> <NL> moving = True <NEWLINE> while moving and l > 0 : <NEWLINE> <INDENT> moving = False <NEWLINE> if ans [ j ] [ l - 1 ] == 0 and grid [ j ] [ l - 1 ] == <STRING> : <NEWLINE> <INDENT> moving = True <NEWLINE> l -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> moving = True <NEWLINE> while moving and r < w - 1 : <NEWLINE> <INDENT> moving = False <NEWLINE> if ans [ j ] [ r + 1 ] == 0 and grid [ j ] [ r + 1 ] == <STRING> : <NEWLINE> <INDENT> moving = True <NEWLINE> r += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> moving = True <NEWLINE> while moving and u > 0 : <NEWLINE> <INDENT> moving = False <NEWLINE> canMove = True <NEWLINE> <NL> for x in range ( l , r + 1 ) : <NEWLINE> <INDENT> if not ( ans [ u - 1 ] [ x ] == 0 and grid [ u - 1 ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> canMove = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if canMove : <NEWLINE> <INDENT> moving = True <NEWLINE> u -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> moving = True <NEWLINE> while moving and d < h - 1 : <NEWLINE> <INDENT> moving = False <NEWLINE> canMove = True <NEWLINE> <NL> for x in range ( l , r + 1 ) : <NEWLINE> <INDENT> if not ( ans [ d + 1 ] [ x ] == 0 and grid [ d + 1 ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> canMove = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if canMove : <NEWLINE> <INDENT> moving = True <NEWLINE> d += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for y in range ( u , d + 1 ) : <NEWLINE> <INDENT> for x in range ( l , r + 1 ) : <NEWLINE> <INDENT> ans [ y ] [ x ] = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for row in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , row ) ) ) <NEWLINE> <DEDENT>
h , w , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ list ( input ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> ans = [ ] <NEWLINE> n = 1 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> if <STRING> in s [ i ] : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for s [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for _ in range ( j + 1 - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( str ( n ) ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> if len ( ans ) < w : <NEWLINE> <INDENT> x = ans [ - 1 ] <NEWLINE> for _ in range ( w - len ( ans ) ) : <NEWLINE> <INDENT> ans . append ( x ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> for _ in range ( i + 1 - cnt ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> a , b , c = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> r = int ( input ( ) ) <NEWLINE> <NL> a = ( math . pi * ( r ) ** 2 ) <NEWLINE> ans = a / math . pi <NEWLINE> <NL> <COMMENT> <NL> print ( int ( ans ) ) <NEWLINE>
r = int ( ( input ) ) <NEWLINE> print ( r ** 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( r * r ) <NEWLINE>
r = int ( input ) <NEWLINE> x = r ** 2 <NEWLINE> print ( x ) <NEWLINE>
import sys <NEWLINE> <NL> def cirCle ( r : int ) : <NEWLINE> <INDENT> ans = r ** 2 <NEWLINE> print ( ans ) <NEWLINE> return ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> args = sys . argv <NEWLINE> cirCle ( int ( args [ 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> r = sys . argv [ 1 ] <NEWLINE> print ( int ( r ) ** 2 ) <NEWLINE>
import math <NEWLINE> r = int ( input ( ) ) <NEWLINE> area1 = pi <NEWLINE> arear = pi * pow ( r , 2 ) <NEWLINE> ratio = int ( arear / area1 ) <NEWLINE> print ( ratio ) <NEWLINE>
import sys <NEWLINE> <NL> sys . setrecursionlimit ( 500005 ) <NEWLINE> stdin = sys . stdin <NEWLINE> <NL> ni = lambda : int ( ns ( ) ) <NEWLINE> na = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> ns = lambda : stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> r = list ( input ( ) ) <NEWLINE> print ( r * r ) <NEWLINE>
r = int ( input ) <NEWLINE> print ( r ** 2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( r ** 2 ) <NEWLINE>
r = int ( input ( ) ) <NEWLINE> print ( powr , 2 ) <NEWLINE>
hamkei = input ( ) <NEWLINE> print ( int ( hankei ) ** 2 ) <NEWLINE>
print ( int ( input ( ) ** 2 ) <NEWLINE>
print ( r ** 2 ) <NEWLINE>
r = input ( ) <NEWLINE> print ( r * r ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a * a ) <NEWLINE>
int ( r * r ) <NEWLINE>
r = int ( input ( <STRING> ) ) <NEWLINE> <NL> return r * r <NEWLINE>
num = input ( ) <NEWLINE> <NL> return num * num <NEWLINE>
print ( r * r ) <NEWLINE>
r = input ( ) <NEWLINE> result = int ( r * r ) <NEWLINE> print ( result ) <NEWLINE>
pritn ( int ( input ( ) ) ** 2 ) <NEWLINE>
<NL> output = r ** 2 <NEWLINE> <NL> print ( output ) <NEWLINE>
int ( input ( ) ) <NEWLINE> print ( r * r ) <NEWLINE>
print ( int ( input ( ) ** 2 ) <NEWLINE>
r = input ( ) <NEWLINE> r1 = 1 <NEWLINE> <NL> print ( r ** 2 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a ^ 2 ) <NEWLINE>
import math <NEWLINE> <NL> r = int ( input ( <STRING> ) <NEWLINE> arear = r * r * math . pi <NEWLINE> area1 = 1 * 1 * math . pi <NEWLINE> <NL> nanbai = arear / area1 <NEWLINE> print ( <STRING> , r , nanbai ) <NEWLINE>
print ( r * r ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> if a [ : n / 2 + 1 ] == a [ n / 2 + 1 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if s % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if s [ : n // 2 ] == s [ n // 2 : ] else <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if N % 2 > 0 or S != S [ : int ( N / 2 ) ] + S [ : int ( N / 2 ) ] : <NEWLINE> <INDENT> exit ( <STRING> ) <NEWLINE> <DEDENT> exit ( <STRING> ) <NEWLINE>
lst = input ( ) <NEWLINE> <NL> lst [ 0 ] = int ( lst [ 0 ] ) <NEWLINE> n = lst [ 0 ] <NEWLINE> s = lst [ 1 ] <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> t = <STRING> <NEWLINE> <NL> for i in range ( 0 , n // 2 ) : <NEWLINE> <INDENT> t += s [ i ] <NEWLINE> <NL> <DEDENT> if t + t == s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( ( n // 2 ) + 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + ( n // 2 ) ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c * 2 == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> T = S [ 0 : N / 2 ] <NEWLINE> if T + T == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if s [ 0 : s / 2 ] == s [ s / 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = str ( input ( ) ) <NEWLINE> <NL> if ( N % 2 == 0 ) : <NEWLINE> <INDENT> if ( A [ : N / 2 ] == A [ N / 2 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> s1 = <STRING> <NEWLINE> s2 = <STRING> <NEWLINE> for i in range ( 0 , n / 2 ) : <NEWLINE> <INDENT> s1 += s [ i ] <NEWLINE> s2 += s [ n / 2 + i ] <NEWLINE> <DEDENT> if ( s1 == s2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = str ( input ( ) ) <NEWLINE> if len ( n ) % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = n [ 0 : len ( n ) / 2 ] <NEWLINE> b = n [ len ( n ) / 2 : len ( n ) ] <NEWLINE> if a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
c = input ( ) <NEWLINE> a = input ( ) <NEWLINE> b = 0 <NEWLINE> if c % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( c / 2 ) : <NEWLINE> <INDENT> if a [ i ] != a [ i + int ( c / 2 ) ] : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> c = n / 2 <NEWLINE> stt = s [ : c ] <NEWLINE> end = s [ c : ] <NEWLINE> <NL> if ( n % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if ( stt == end ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = input ( ) <NEWLINE> c = s [ : a // 2 ] <NEWLINE> d = s [ a // 2 : a ] <NEWLINE> print ( <STRING> if c == d else <STRING> ) <NEWLINE> <NL>
<INDENT> = int ( input ( ) ) <NEWLINE> <DEDENT> s = str ( input ( ) ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s [ : n // 2 ] == s [ n // 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> if s [ : n // 2 ] = s [ n // 2 : ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <NL> if ( n % 2 == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <NL> <INDENT> if s [ 0 : n // 2 ] == s [ ( n // 2 ) + 1 : n ] : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( N / 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ N / 2 + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 0 and s [ : n // 2 ] == s [ s // 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = str ( input ( ) ) <NEWLINE> <NL> if N % 2 == 0 : <NEWLINE> <INDENT> NN = N / 2 <NEWLINE> for i in range ( 0 , NN ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + NN ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif s [ : n / 2 ] == s [ n / 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if s [ : len ( s ) // 2 - 1 ] == s [ len ( s ) // 2 : ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N , S = [ int ( input ( ) ) for _ in range ( 2 ) ] <NEWLINE> if N % 2 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( S [ : ( N / 2 - 1 ) ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if n % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s1 = s [ : n // 2 ) ] <NEWLINE> s2 = s [ n // 2 : ] <NEWLINE> <NL> if s1 == s2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if N % 2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( N / 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ N / 2 + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( str ( input ( ) ) ) <NEWLINE> <NL> p = [ ] <NEWLINE> for i in range ( N / 2 ) : <NEWLINE> <INDENT> if S [ i ] != S [ N / 2 + i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
def distance ( a , b ) : <NEWLINE> <INDENT> return ( ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> l = [ ] <NEWLINE> for m in list ( itertools . permutations ( a ) ) : <NEWLINE> <INDENT> d = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d += distance ( m [ i ] , m [ i + 1 ] ) <NEWLINE> <DEDENT> l . append ( d ) <NEWLINE> <DEDENT> print ( sum ( l ) / len ( l ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> sum += sqrt ( ( l [ i ] [ 0 ] - l [ j ] [ 0 ] ) * ( l [ i ] [ 0 ] - l [ j ] [ 0 ] ) + ( l [ i ] [ 1 ] - l [ j ] [ 1 ] ) * ( l [ i ] [ 1 ] - l [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum / n ) <NEWLINE>
def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x , y , = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x_tmp , y_tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( x_tmp ) <NEWLINE> y . append ( y_tmp ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> ls = list ( permutations ( list ( range ( N ) ) , N ) ) <NEWLINE> for l in ls : <NEWLINE> <INDENT> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> ans += dist ( x [ l [ i ] ] , y [ l [ i ] ] , x [ l [ i + 1 ] ] , y [ l [ i + 1 ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans / len ( ls ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> cnt += math . sqrt ( ( a [ i ] [ 0 ] - a [ j ] [ 0 ] ) ** 2 + ( a [ i ] [ 1 ] - a [ j ] [ 1 ] ) ** 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt * 2 / n ) <NEWLINE>
import itertools <NEWLINE> import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = math . factorial ( n ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> x , y = [ list ( i ) for i in zip ( * l ) ] <NEWLINE> z = list ( range ( n ) ) <NEWLINE> z = list ( itertools . permutations ( l ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> ans += math . sqrt ( ( x [ z [ i ] [ j ] ] - x [ z [ i ] [ j + 1 ] ] ) ** 2 + ( y [ z [ i ] [ j ] ] - y [ z [ i ] [ j + 1 ] ] ) ** 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans / m ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> import itertools <NEWLINE> <NL> <NL> def get_input ( ) -> tuple : <NEWLINE> <INDENT> <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> x , y = [ ] , [ ] <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> x_n , y_n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( x_n ) <NEWLINE> y . append ( y_n ) <NEWLINE> <NL> <DEDENT> return N , x , y <NEWLINE> <NL> <NL> <DEDENT> def get_distance ( x : list , y : list , i : int , j : int ) -> float : <NEWLINE> <INDENT> <STRING> <NEWLINE> return math . sqrt ( ( x [ i ] - x [ j ] ) ** 2 + ( y [ i ] - y [ j ] ) ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> def get_path_length ( N : int , distance : dict , path : list ) -> float : <NEWLINE> <INDENT> <STRING> <NEWLINE> path_length = 0 <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> path_length += distance [ ( path [ n ] , path [ n + 1 ] ) ] <NEWLINE> <NL> <DEDENT> return path_length <NEWLINE> <NL> <NL> <DEDENT> def main ( N : int , x : list , y : list ) -> None : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> distance = { } <NEWLINE> for i , j in itertools . product ( range ( N ) , repeat = 2 ) : <NEWLINE> <INDENT> distance [ ( i , j ) ] = get_distance ( i , j ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> ans = 0 <NEWLINE> for path in itertools . permutations ( range ( N ) ) : <NEWLINE> <INDENT> ans += get_path_length ( distance , path ) <NEWLINE> <DEDENT> ans /= math . factorial ( N ) <NEWLINE> <NL> <COMMENT> <NL> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> N , x , y = get_input ( ) <NEWLINE> <NL> <COMMENT> <NL> main ( N , x , y ) <NEWLINE> <DEDENT>
import math <NEWLINE> import itertools <NEWLINE> <NL> def l2 ( z1 , z2 ) : <NEWLINE> <INDENT> return math . sqrt ( pow ( z1 [ 0 ] - z2 [ 0 ] , 2 ) + pow ( z1 [ 1 ] - z2 [ 1 ] , 2 ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> dist = 0 <NEWLINE> z_fr = [ ] <NEWLINE> z_to = [ ] <NEWLINE> for seq in itertools . permutations ( l , n ) : <NEWLINE> <INDENT> for z in seq : <NEWLINE> <INDENT> z_fr = z_to <NEWLINE> z_to = z <NEWLINE> if len ( z_fr ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist += l2 ( z_fr , z_to ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import numpy as np <NEWLINE> N = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( <STRING> ) ) ) for i in range ( N ) ] <NEWLINE> <NL> L = 0 <NEWLINE> for i in range ( len ( xy ) - 1 ) : <NEWLINE> <INDENT> a = xy [ i ] [ 0 ] - xy [ i + 1 ] [ 0 ] <NEWLINE> b = xy [ i ] [ 1 ] - xy [ i + 1 ] [ 2 ] <NEWLINE> l = np . sqrt ( a ** 2 + b ** 2 ) <NEWLINE> L += l <NEWLINE> <DEDENT> print ( L ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> ans = [ ] <NEWLINE> import numpy as np <NEWLINE> for zyun in itertools . permutations ( range ( N ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( len ( zyun ) - 1 ) : <NEWLINE> <INDENT> cnt += np . sqrt ( ( A [ zyun [ k + 1 ] ] [ 0 ] - A [ zyun [ k ] ] [ 0 ] ) ** 2 + ( A [ zyun [ k + 1 ] ] [ 1 ] - A [ zyun [ k ] ] [ 1 ] ) ** 2 ) <NEWLINE> <DEDENT> ans . append ( cnt ) <NEWLINE> <DEDENT> print ( sum ( ans ) / len ( ans ) ) <NEWLINE>
<INDENT> import itertools <NEWLINE> import math <NEWLINE> def distance ( i , j ) : <NEWLINE> <INDENT> return math . sqrt ( ( i [ 0 ] - j [ 0 ] ) ** 2 + ( i [ 1 ] - j [ 1 ] ) ** 2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( range ( n ) ) <NEWLINE> X_Y = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> X_Y . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> p_list = list ( itertools . permutations ( l , n ) ) <NEWLINE> total = 0 <NEWLINE> for p in p_list : <NEWLINE> <INDENT> p_t = 0 <NEWLINE> for index in range ( n - 1 ) : <NEWLINE> <INDENT> p_t += distance ( X_Y [ p [ index ] ] , X_Y [ p [ index + 1 ] ] ) <NEWLINE> <DEDENT> total += p_t <NEWLINE> <DEDENT> print ( total / len ( p_list ) ) <NEWLINE> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( j + 1 , n ) : <NEWLINE> <INDENT> sum += ( ( a [ i ] [ 0 ] - a [ j ] [ 0 ] ) ** 2 + ( a [ i ] [ 1 ] - a [ j ] [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> <DEDENT> <DEDENT> print ( 2 * sum / n ) <NEWLINE>
def dist ( x0 , y0 , x1 , y1 ) : <NEWLINE> <INDENT> return math . sqrt ( ( x0 - x1 ) ** 2 + ( y0 - y1 ) ** 2 ) <NEWLINE> <NL> <DEDENT> def resolve ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> x , y = [ ] , [ ] <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> x_tmp , y_tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x . append ( x_tmp ) <NEWLINE> y . append ( y_tmp ) <NEWLINE> <NL> <DEDENT> ls = list ( permutations ( list ( range ( N ) ) , N ) ) <NEWLINE> ans = 0 <NEWLINE> for l in ls : <NEWLINE> <INDENT> idx = 0 <NEWLINE> while idx + 1 < len ( l ) : <NEWLINE> <INDENT> ans += dist ( x [ l [ idx ] ] , y [ l [ idx ] ] , x [ l [ idx + 1 ] ] , y [ l [ idx + 1 ] ] ) <NEWLINE> idx += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans / len ( ls ) ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> resolve ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> xy = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> ans += ( ( xy [ i ] [ 0 ] - xy [ j ] [ 0 ] ) ** 2 + ( xy [ i ] [ 1 ] - xy [ j ] [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans / n ) <NEWLINE>
def nCr ( n , r , mod ) : <NEWLINE> <INDENT> x , y = 1 , 1 <NEWLINE> for r_ in range ( 1 , r + 1 ) : <NEWLINE> <INDENT> x = x * ( n + 1 - r_ ) % mod <NEWLINE> y = y * r_ % mod <NEWLINE> <DEDENT> return x * pow ( y , mod - 2 , mod ) % mod <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 or 2 * x < y or 2 * y < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nCr ( ( x + y ) // 3 , ( 2 * x - y ) // 3 , mod ) ) <NEWLINE> <DEDENT>
X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if ( x + y ) % 3 != 0 or x * 2 < y or y * 2 < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> n = ( 2 * X - Y ) // 3 <NEWLINE> m = ( 2 * Y - X ) // 3 <NEWLINE> <NL> P = 10 ** 9 + 7 <NEWLINE> N = 10 ** 6 <NEWLINE> fact = [ 1 , 1 ] <NEWLINE> factinv = [ 1 , 1 ] <NEWLINE> inv = [ 0 , 1 ] <NEWLINE> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> fact . append ( ( fact [ - 1 ] * i ) % P ) <NEWLINE> inv . append ( ( - inv [ P % i ] * ( P // i ) ) % P ) <NEWLINE> factinv . append ( ( factinv [ - 1 ] * inv [ - 1 ] ) % P ) <NEWLINE> <DEDENT> print ( fact [ n + m ] * factinv [ n ] * factinv [ m ] % P ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 2 * x - y <NEWLINE> t = 2 * y - x <NEWLINE> if s % 3 != 0 or s < 0 or t % 3 != 0 or t < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> import sys <NEWLINE> mod = 1000000007 <NEWLINE> p = 1 <NEWLINE> q = 1 <NEWLINE> for i in range ( s // 3 ) : <NEWLINE> <INDENT> p = ( p * ( n - i ) ) % mod <NEWLINE> q = ( q * ( i + 1 ) ) % mod <NEWLINE> <DEDENT> print ( ( p * pow ( q , - 1 , mod ) ) % mod ) <NEWLINE> <DEDENT>
x , y = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> mmm = 1000000000 + 7 <NEWLINE> sss = x + y <NEWLINE> if sss % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> hoge = sss // 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> p = y - hoge <NEWLINE> q = x - hoge <NEWLINE> <COMMENT> <NL> if p < 0 or q < 0 : <COMMENT> <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> fac = [ ] <NEWLINE> inv = [ ] <NEWLINE> inv_fac = [ ] <NEWLINE> def init ( n ) : <NEWLINE> <INDENT> fac . append ( 1 ) <NEWLINE> fac . append ( 1 ) <NEWLINE> inv . append ( 0 ) <NEWLINE> inv . append ( 1 ) <NEWLINE> inv_fac . append ( 1 ) <NEWLINE> inv_fac . append ( 1 ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> fac . append ( fac [ - 1 ] * i % mmm ) <NEWLINE> inv . append ( mmm - inv [ mmm % i ] * ( mmm // i ) % mmm ) <NEWLINE> inv_fac . append ( inv_fac [ - 1 ] * inv [ - 1 ] % mmm ) <NEWLINE> <NL> <DEDENT> <DEDENT> def choice ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return fac [ a ] * ( inv_fac [ b ] * inv_fac [ a - b ] % mmm ) % mmm <NEWLINE> <NL> <DEDENT> init ( hoge * 2 + 1 ) <NEWLINE> print ( choice ( hoge , p ) % mmm ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if x < y : <NEWLINE> <INDENT> y = x <NEWLINE> x , y = y , x <NEWLINE> <DEDENT> if 2 y < x : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> a = ( 2 y - x ) // 3 <NEWLINE> b = ( 2 x - y ) // 3 <NEWLINE> mx = 10 ** 6 * 2 <NEWLINE> k = [ 1 ] * ( mx + 1 ) <NEWLINE> def inv ( n ) : <NEWLINE> <INDENT> return pow ( n , mod - 2 , mod ) <NEWLINE> <DEDENT> for i in range ( mx ) : <NEWLINE> <INDENT> k [ i + 1 ] = k [ i ] * ( i + 1 ) % mod <NEWLINE> <DEDENT> ans = ( k [ w + h ] * inv ( k [ w ] ) * inv ( k [ h ] ) ) % mod <NEWLINE> print ( ans ) <NEWLINE>
def inv ( a , p ) : <NEWLINE> <INDENT> if a == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif a == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return p - ( inv ( p % a , p ) * ( p // a ) ) % p <NEWLINE> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( x + y ) % 3 != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if y / x > 2 or y / x < 0.5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = ( x + y ) // 3 <NEWLINE> r = ( 2 * x - y ) // 3 <NEWLINE> p = 10 ** 9 + 7 <NEWLINE> def fact ( n , p ) : <NEWLINE> <INDENT> a = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> a [ 0 ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i + 1 ] = ( a [ i ] * ( i + 1 ) ) % p <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> c = f [ - 1 ] <NEWLINE> d = f [ r ] <NEWLINE> e = f [ n - r ] <NEWLINE> dd = inv ( d , p ) <NEWLINE> ee = inv ( e , p ) <NEWLINE> ans = ( c * dd * ee ) % p <NEWLINE> print ( ans ) <NEWLINE>
<COMMENT> <NL> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> import numpy as np <NEWLINE> a = [ [ 1 , 2 ] , [ 2 , 1 ] ] <NEWLINE> <COMMENT> <NL> mod = pow ( 10 , 9 ) + 7 <NEWLINE> <NL> b = np . linalg . inv ( a ) <NEWLINE> <NL> <NL> Z = np . array ( [ [ X ] , [ Y ] ] ) <NEWLINE> <NL> n , m = np . dot ( b , Z ) <NEWLINE> p , q = * n , * m <NEWLINE> <NL> def comb ( n , k , p ) : <NEWLINE> <INDENT> if k == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> A = reduce ( lambda x , y : x * y % p , [ n - k + 1 + i for i in range ( k ) ] ) <NEWLINE> B = reduce ( lambda x , y : x * y % p , [ i + 1 for i in range ( k ) ] ) <NEWLINE> return A * pow ( B , p - 2 , p ) % p <NEWLINE> <NL> <DEDENT> if p < 0 or q < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif not p == int ( p ) or not q == int ( q ) : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif p == 0 and q == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> elif p == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif q == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( p ) <NEWLINE> m = int ( q ) <NEWLINE> ans = comb ( n , m , mod ) <NEWLINE> <NL> print ( ans % mod ) <NEWLINE> <DEDENT>
import math <NEWLINE> import numpy as np <NEWLINE> <NL> def cmb ( n , r , mod ) : <NEWLINE> <INDENT> r = min ( r , n - r ) <NEWLINE> return g1 [ n ] * g2 [ r ] * g2 [ n - r ] % mod <NEWLINE> <NL> <DEDENT> mod = 10 ** 9 + 7 <NEWLINE> N = 10 ** 6 <NEWLINE> g1 = [ 1 , 1 ] <NEWLINE> g2 = [ 1 , 1 ] <NEWLINE> inverse = [ 0 , 1 ] <NEWLINE> <NL> for i in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> g1 . append ( ( g1 [ - 1 ] * i ) % mod ) <NEWLINE> inverse . append ( ( - inverse [ mod % i ] * ( mod // i ) ) % mod ) <NEWLINE> g2 . append ( ( g2 [ - 1 ] * inverse [ - 1 ] ) % mod ) <NEWLINE> <NL> <DEDENT> X , Y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> a = ( - X + 2 * Y ) / 3 <NEWLINE> b = ( 2 * X - Y ) / 3 <NEWLINE> if a . is_integer ( ) == False or b . is_integer ( ) == False or a < 0 or b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cmb ( int ( N [ 0 ] + N [ 1 ] ) , int ( N [ 0 ] ) , mod ) ) <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import sys <NEWLINE> def input ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , t = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = np . zeros ( t , dtype = int ) <NEWLINE> food = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> food . append ( [ a , b ] ) <NEWLINE> <DEDENT> food . sort ( key = lambda x : x [ 0 ] * - 1 ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a , b = food [ j ] [ 0 ] , food [ j ] [ 1 ] <NEWLINE> dptmp = np . zeros ( t , dtype = int ) <NEWLINE> dptmp [ a : ] = np . maximum ( dp [ a : ] , dp [ : - a ] + b ) <NEWLINE> dptmp [ : a ] = np . maximum ( np . full ( a , b , dtype = int ) , dp [ : a ] ) <NEWLINE> dp = dptmp <NEWLINE> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import numba <NEWLINE> from numba import njit , b1 , i4 , i8 , f8 <NEWLINE> <NL> <COMMENT> <NL> def main ( N , T , A ) : <NEWLINE> <INDENT> dp = np . zeros ( T + 1 , np . int64 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for t in range ( T - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> u = min ( T , t + A [ i , 0 ] ) <NEWLINE> dp [ u ] = max ( dp [ u ] , dp [ t ] + A [ i , 1 ] ) <NEWLINE> <DEDENT> <DEDENT> ans = dp [ - 1 ] <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> N , T = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> A = np . array ( sorted ( A ) ) <NEWLINE> print ( main ( N , T , A ) ) <NEWLINE>
N = input ( ) <NEWLINE> print ( ( N - 1 ) // 2 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N / 2 + 1 ) : <NEWLINE> <INDENT> if i != N - i : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
print ( ( int ( input ( ) - 1 ) // 2 ) <NEWLINE>
import sys <NEWLINE> import itertools <NEWLINE> <COMMENT> <NL> import time <NEWLINE> import math <NEWLINE> import heapq <NEWLINE> from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> INF = 10 ** 18 <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readlines <NEWLINE> <NL> <COMMENT> <NL> <NL> def my_pow ( base , n , mod ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> x = base <NEWLINE> y = 1 <NEWLINE> while n > 1 : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> x *= x <NEWLINE> n //= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y *= x <NEWLINE> n -= 1 <NEWLINE> <DEDENT> x %= mod <NEWLINE> y %= mod <NEWLINE> <DEDENT> return x * y % mod <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> MOD = 998244353 <NEWLINE> cnt = [ 0 ] * ( 10 ** 5 + 1 ) <NEWLINE> for d in D : <NEWLINE> <INDENT> cnt [ d ] += 1 <NEWLINE> <NL> <DEDENT> if cnt [ 0 ] != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = cnt [ 0 ] <NEWLINE> for i in range ( 1 , dmax + 1 ) : <NEWLINE> <INDENT> if cnt [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> now = my_pow ( cnt [ i - 1 ] , cnt [ i ] , MOD ) <NEWLINE> ans *= now <NEWLINE> ans %= MOD <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 998244353 <NEWLINE> from collections import Counter <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> cd = Counter ( D ) <NEWLINE> if cd [ 0 ] != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> tmp = sorted ( cd . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> <NL> import math <NEWLINE> for kx in range ( 1 , max ( D ) + 1 ) : <NEWLINE> <INDENT> ans *= math . pow ( cd [ kx - 1 ] , cd [ kx ] , M ) <NEWLINE> ans %= M <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> mod = 998244353 <NEWLINE> max_v = 0 <NEWLINE> lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> if lis [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> for v in list ( map ( int , input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> if v not in d : <NEWLINE> <INDENT> d [ v ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ v ] += 1 <NEWLINE> <DEDENT> max_v = max ( max_v , v ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if 0 not in d or d [ 0 ] > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> <COMMENT> <NL> for i in range ( 1 , max_v + 1 ) : <NEWLINE> <INDENT> if i not in d or i - 1 not in d : <NEWLINE> <INDENT> ans *= 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans *= pow ( d [ i - 1 ] , d [ i ] , mod ) <NEWLINE> ans %= mod <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = 998244353 <NEWLINE> from collections import Counter <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> cd = Counter ( D ) <NEWLINE> if cd [ 0 ] != 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> tmp = sorted ( cd . items ( ) , key = lambda x : x [ 0 ] ) <NEWLINE> <NL> ans = 1 <NEWLINE> <COMMENT> <NL> for kx in range ( 2 , len ( tmp ) + 1 ) : <NEWLINE> <INDENT> __ , p = tmp [ kx - 1 ] <NEWLINE> _ , v = tmp [ kx ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while v > 0 : <NEWLINE> <INDENT> ans *= p <NEWLINE> ans %= M <NEWLINE> v -= 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> a = sorted ( a ) <NEWLINE> d = { } <NEWLINE> for av in a : <NEWLINE> <INDENT> if av not in d : <NEWLINE> <INDENT> d [ av ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ av ] += 1 <NEWLINE> <DEDENT> <DEDENT> if d [ 0 ] != 1 <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> MOD = 998244353 <NEWLINE> <NL> ans = 1 <NEWLINE> for i in range ( 1 , a [ - 1 ] + 1 ) : <NEWLINE> <INDENT> if i not in d : <NEWLINE> <INDENT> ans = 0 <NEWLINE> break <NEWLINE> <DEDENT> ans *= pow ( d [ i - 1 ] , d [ i ] , MOD ) <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
<NL> def resolve ( ) : <NEWLINE> <INDENT> MOD = 998244353 <NEWLINE> N = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if D [ 0 ] != 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> CNT = Counter ( D ) <NEWLINE> if CNT [ 0 ] > 1 : <COMMENT> <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> ans = 1 <NEWLINE> for i in range ( 1 , max ( D ) + 1 ) : <NEWLINE> <INDENT> ans *= pow ( CNT [ i - 1 ] , CNT [ i ] , MOD ) <NEWLINE> ans %= MOD <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> resolve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import Counter <NEWLINE> <NL> def II ( ) : return int ( input ( ) ) <NEWLINE> def MII ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def LII ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = II ( ) <NEWLINE> D = LII ( ) <NEWLINE> <NL> if D [ 0 ] != 0 or D . count ( 0 ) > 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> mx = max ( D ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , mx + 1 ) : <NEWLINE> <INDENT> pre = D . count ( i ) <NEWLINE> post = D . count ( i + 1 ) <NEWLINE> cnt *= pre ** post <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> l , count = [ ] , 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : count += 1 <NEWLINE> else : <NEWLINE> <INDENT> if count : l . append ( count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> if count : l . append ( count ) ; count = 0 <NEWLINE> j = 0 <NEWLINE> ans = [ ] <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> if s [ i ] == <STRING> : ans . append ( ans [ - 1 ] + 1 ) <NEWLINE> else : <NEWLINE> <INDENT> if l [ j ] == 0 : j += 1 <NEWLINE> if ans [ - 1 ] >= l [ j ] : <NEWLINE> <INDENT> l [ j ] -= 1 <NEWLINE> ans . append ( l [ j ] ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ - 1 ] = l [ j ] <NEWLINE> l [ j ] -= 1 <NEWLINE> ans . append ( l [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( l [ j ] ) <NEWLINE> l [ j ] -= 1 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> if s [ i ] == <STRING> : ans . append ( ans [ - 1 ] + 1 ) <NEWLINE> else : <NEWLINE> <INDENT> if l [ j ] == 0 : j += 1 <NEWLINE> if j < len ( l ) : <NEWLINE> <NL> <INDENT> if ans [ - 1 ] >= l [ j ] : <NEWLINE> <INDENT> ans . append ( l [ j ] ) <NEWLINE> l [ j ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ - 1 ] = l [ j ] <NEWLINE> ans . append ( l [ j ] ) <NEWLINE> l [ j ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> else : ans . append ( 0 ) <NEWLINE> <DEDENT> print ( sum ( ans ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = [ 0 ] * len ( s ) <NEWLINE> for i in range ( len ( s ) + 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( s ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> a [ i ] = max ( a [ i ] , a [ i + 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE>
s = input ( ) <NEWLINE> n = len ( s ) <COMMENT> <NEWLINE> aa = [ <STRING> ] * ( n + 1 ) <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> aa [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> aa [ i + 1 ] = 0 <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and s [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> aa [ i + 1 ] = n <NEWLINE> <NL> <DEDENT> <DEDENT> id0 = [ i for i , x in enumerate ( aa ) if x == 0 ] <NEWLINE> idm = [ i for i , x in enumerate ( aa ) if x == n ] <NEWLINE> <NL> <NL> for i in range ( len ( id0 ) - 1 ) : <NEWLINE> <INDENT> aa [ idm [ i ] ] = max ( idm [ i ] - id0 [ i ] , id0 [ i + 1 ] - idm [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> and aa [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> aa [ i + 1 ] = aa [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if aa [ i ] == <STRING> and s [ i ] == <STRING> : <NEWLINE> <INDENT> aa [ i ] = aa [ i + 1 ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( aa ) ) <NEWLINE>
i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> while s [ i ] == <STRING> if i < len ( s ) else False : <NEWLINE> <INDENT> k += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if k > 0 : <NEWLINE> <INDENT> l . append ( k ) <NEWLINE> <DEDENT> k = 0 <NEWLINE> while s [ i ] == <STRING> if i < len ( s ) else False : <NEWLINE> <INDENT> k += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> sm = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> sm += ( i * ( i + 1 ) ) // 2 <NEWLINE> <NL> <DEDENT> print ( sm ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> sl = len ( s ) + 1 <NEWLINE> l = [ 0 ] * sl <NEWLINE> <NL> for i in range ( sl - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i + 1 ] = l [ i ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( sl - 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = max ( l [ i + 1 ] , l [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( l ) ) <NEWLINE> <NL>
S = input ( ) <NEWLINE> ans = 0 <NEWLINE> S = S . repace ( <STRING> / , <STRING> ) . split ( <STRING> ) <NEWLINE> for s in S : <NEWLINE> <INDENT> a = s . count ( <STRING> ) <NEWLINE> b = s . count ( <STRING> ) <NEWLINE> ans += a * ( a - 1 ) // 2 + b * ( b - 1 ) // 2 + max ( a , b ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
INF = 10 ** 10 <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> L = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> L . sort ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) <NEWLINE> <NL> MAX_L = 0 <NEWLINE> MIN_R = INF <NEWLINE> MAX = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if MAX_L < L [ i ] [ 0 ] : <NEWLINE> <INDENT> MAX_L = L [ i ] [ 0 ] <NEWLINE> a = i <NEWLINE> <DEDENT> if MIN_R > L [ i ] [ 1 ] : <NEWLINE> <INDENT> MIN_R = L [ i ] [ 1 ] <NEWLINE> b = i <NEWLINE> <DEDENT> MAX = max ( MAX , L [ i ] [ 1 ] - L [ i ] [ 0 ] + 1 ) <NEWLINE> <NL> <DEDENT> ans = MAX + max ( 0 , MIN_R - MAX_L + 1 ) <NEWLINE> <NL> p = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p = max ( p , L [ i + 1 ] [ 0 ] ) <NEWLINE> ans = max ( ans , max ( 0 , L [ i ] [ 1 ] - L [ 0 ] [ 0 ] + 1 ) + max ( 0 , L [ - 1 ] [ 1 ] - L [ i + 1 ] [ 0 ] + 1 ) ) <NEWLINE> <NL> <NL> print ( ans ) INF = 10 ** 10 <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> <NL> L = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( N ) ] <NEWLINE> <NL> L . sort ( key = lambda x : ( - x [ 0 ] , x [ 1 ] ) ) <NEWLINE> <NL> MAX_L = 0 <NEWLINE> MIN_R = INF <NEWLINE> MAX = 0 <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if MAX_L < L [ i ] [ 0 ] : <NEWLINE> <INDENT> MAX_L = L [ i ] [ 0 ] <NEWLINE> a = i <NEWLINE> <DEDENT> if MIN_R > L [ i ] [ 1 ] : <NEWLINE> <INDENT> MIN_R = L [ i ] [ 1 ] <NEWLINE> b = i <NEWLINE> <DEDENT> MAX = max ( MAX , L [ i ] [ 1 ] - L [ i ] [ 0 ] + 1 ) <NEWLINE> <NL> <DEDENT> ans = MAX + max ( 0 , MIN_R - MAX_L + 1 ) <NEWLINE> <NL> p = 0 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> p = max ( p , L [ i + 1 ] [ 0 ] ) <NEWLINE> ans = max ( ans , max ( 0 , L [ i ] [ 1 ] - L [ 0 ] [ 0 ] + 1 ) + max ( 0 , L [ - 1 ] [ 1 ] - L [ i + 1 ] [ 0 ] + 1 ) ) <NEWLINE> <NL> <NL> print ( ans ) <NEWLINE> <DEDENT>
a1 = input ( ) <NEWLINE> a2 = [ i for i in a1 . split ( ) ] <NEWLINE> x , y = float ( a2 [ 0 ] ) , float ( a2 [ 1 ] ) <NEWLINE> v , v1 = x . is_integer ( ) , y . is_integer ( ) <NEWLINE> if 1 <= ( x and y ) <= 20 and v1 == v2 == True : <NEWLINE> <INDENT> if 1 <= ( x and y ) <= 9 : <NEWLINE> <INDENT> print ( int ( x * y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
A , B = int ( input ( ) ) <NEWLINE> if A * B <= 81 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A <= 9 & & B <= 9 : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if 1 <= A , B <= 9 : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b if 1 <= a <= 9 ans 1 <= b <= 9 else - 1 ) <NEWLINE>
A , B = int ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( A * B ) <NEWLINE>
a , b = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> <NL> if a < 10 and b < 10 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a . b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if 1 <= a <= 9 and 1 <= b <= 9 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if 1 <= a <= 9 and 1 <= b <= 9 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if 1 <= a and a <= 9 and 1 <= b nd b <= 9 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
A , B = map ( int . input ( ) . split ( ) ) <NEWLINE> if ( 0 <= A <= 9 ) and ( 0 <= B <= 9 ) : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if n % i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n / i <= 9 : <NEWLINE> <INDENT> a += 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if a == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) , split ( ) ) <NEWLINE> if A <= 9 and B <= 9 : <NEWLINE> <INDENT> print ( A * B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b if a <= 9 and b <= 9 else - 1 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 1 == 0 or a % 2 == 0 or a % 3 == 0 or a % 4 == 0 or a % 5 == 0 or a % 6 == 0 or a % 7 == 0 or a % 8 == 0 or a % 9 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a < 10 and b < 10 : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> array = [ I for I in range ( 1 , 10 ) ] <NEWLINE> <NL> if not ( 1 <= N <= 100 ) : sys . exit ( ) <NEWLINE> <NL> for J in range ( 1 , 10 ) : <NEWLINE> <INDENT> for K in range ( 1 , 10 ) : <NEWLINE> <INDENT> if n == J * K : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> if i * j = n : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = set ( ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> a . append ( i * j ) <NEWLINE> <DEDENT> <DEDENT> if n in a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> result = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i * j == N : <NEWLINE> <INDENT> result = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if result = 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> import sys <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if ( N == i * j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
Suji = [ ] <NEWLINE> for i in range ( 1 , 9 ) : <NEWLINE> <INDENT> Suji . append ( i ) <NEWLINE> <DEDENT> N = int ( input ( ) ) <NEWLINE> Suji_check = False <NEWLINE> for s in Suji : <NEWLINE> <INDENT> A = N % s <NEWLINE> try A != 0 : <NEWLINE> <INDENT> for t in Suji : <NEWLINE> if A == t : <NEWLINE> <INDENT> Suji_check = True <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> if Suji_check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> kuku = [ ] <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> kuku += [ i * e for i in range ( 1 , 10 ) ] <NEWLINE> <DEDENT> if N in kuku : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for i range ( 1 , 10 ) : <NEWLINE> <INDENT> if N % i == 0 and N // i <= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : print ( <STRING> ) <NEWLINE>
product = [ ] <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> product . append ( i * j ) <NEWLINE> <NL> <DEDENT> <DEDENT> if N in product : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
n = int ( input ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( i , 10 ) : <NEWLINE> <INDENT> if n == i * j : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> bol = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 : 10 ) : <NEWLINE> <INDENT> if i * j == n : <NEWLINE> <INDENT> bol = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if bol == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> k = i * j <NEWLINE> if n % k == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = set ( filter ( lambda x : n % x == 0 and n / x < 10 , [ x for x in range ( 1 , 10 ) ] ) <NEWLINE> <NL> print ( <STRING> if len ( s ) == 0 in s else <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> judge = <STRING> <NEWLINE> for i in range ( 1 : 10 ) : <NEWLINE> <INDENT> for j in range ( 1 : 10 ) : <NEWLINE> <INDENT> if i * j == N : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> print ( judge ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> list = [ ] <NEWLINE> <NL> for i in range ( 1 , 10 ) <NEWLINE> <INDENT> for j in range ( 1 , 10 ) <NEWLINE> <INDENT> list . append ( i * j ) <NEWLINE> <NL> <DEDENT> <DEDENT> if n in list : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> for k in range ( 9 ) : <NEWLINE> <INDENT> if ( i + 1 ) * ( k + 1 ) == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b = 81 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> f = False <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if a % i == 0 and a / i < 10 : <NEWLINE> <INDENT> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a , b = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> b = i <NEWLINE> a = n // i <NEWLINE> if n % i != 0 : continue <NEWLINE> elif a <= 9 and b <= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i * j == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i * j == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for x in range ( 1 , 10 ) <NEWLINE> <INDENT> for y in range ( 1 , 10 ) <NEWLINE> <INDENT> if x * y == n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> while cnt <= 9 : <NEWLINE> <INDENT> s = N / cnt <NEWLINE> if 1 <= s <= 9 and s == type ( int ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c , x = [ int ( input ( ) ) for _ in range ( 4 ) ] <NEWLINE> print ( sum ( 500 * i + 100 * j + 50 * k == x for i in range ( a + 1 ) for j in range ( b + 1 ) for k in range ( c + 1 ) ) ) <NEWLINE>
ans = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> if int ( input ( ) ) == i * j : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if ans else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( n // 2 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + n // 2 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if cnt == n // 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a >= 10 or b >= 10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if N % i == 0 and N / i <= 9 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> s = 0 <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> s = 2 + N // 2 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( math . sqrt ( N ) , 2 ) : <NEWLINE> <INDENT> if N % i == 0 and s > i + N // i : <NEWLINE> <INDENT> s = i + N // i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( s - 2 ) <NEWLINE>
from math import sqrt <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> search_max = int ( sqrt ( N ) ) <NEWLINE> <NL> min_number = 10 ** 12 <NEWLINE> for x in range ( 1 , search_max + 1 ) : <NEWLINE> <INDENT> if N % x == 0 : <NEWLINE> <INDENT> y = N // x <NEWLINE> if x + y < min_number : <NEWLINE> <INDENT> min_number = x + y <NEWLINE> print ( min_number - 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> m = 10 ** 12 <NEWLINE> a = int ( ( n ** 0.5 ) // 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> m = min ( m , i + ( n / i ) - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
import math <NEWLINE> <NL> ans = 1000000000000000000 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( math . sqrt ( N + 1000 ) ) : <NEWLINE> <INDENT> if i > 0 and N % i == 0 : <NEWLINE> <INDENT> ans = min ( i + N / i - 2 , ans ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
zimport numpy <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> <NL> def is_prime ( q ) : <NEWLINE> <INDENT> q = abs ( q ) <NEWLINE> if q == 2 : return True <NEWLINE> if q < 2 or q & 1 == 0 : return False <NEWLINE> return pow ( 2 , q - 1 , q ) == 1 <NEWLINE> <NL> <DEDENT> if is_prime ( n ) : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> if is_prime ( n ) == False : <NEWLINE> <INDENT> for i in range ( 2 , int ( numpy . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> a = i <NEWLINE> b = n // i <NEWLINE> l . append ( a + b - 2 ) <NEWLINE> <DEDENT> <DEDENT> print ( min ( l ) ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> N = int ( input ( ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> a = N - 1 <NEWLINE> for x in range ( 2 , int ( sqrt ( N ) ) + 1 ) : <NEWLINE> <INDENT> q , r = divmod ( N , x ) : <NEWLINE> if r == 0 : <NEWLINE> <INDENT> a = min ( x - 1 + q - 1 , a ) <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> ans = n <NEWLINE> <NL> i = 1 <NEWLINE> <NL> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> d = n / i <NEWLINE> if ans > i * d - 2 : ans = i * d - 2 <NEWLINE> <DEDENT> i + + <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> import bisect <NEWLINE> from copy import copy <NEWLINE> from collections import deque , Counter <NEWLINE> from decimal import Decimal <NEWLINE> def s ( ) : return input ( ) <NEWLINE> def k ( ) : return int ( input ( ) ) <NEWLINE> def S ( ) : return input ( ) . split ( ) <NEWLINE> def I ( ) : return map ( int , input ( ) . split ( ) ) <NEWLINE> def X ( ) : return list ( input ( ) ) <NEWLINE> def L ( ) : return list ( input ( ) . split ( ) ) <NEWLINE> def l ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def lcm ( a , b ) : return a * b // math . gcd ( a , b ) <NEWLINE> def gcd ( * numbers ) : reduce ( math . gcd , numbers ) <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> <NL> N = k ( ) <NEWLINE> ans = 1000000 <NEWLINE> <NL> for i in range ( 1 , N ** 0.5 + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> b = N // i <NEWLINE> ans = min ( ans , b + i - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> import math <NEWLINE> minn = 100000000000000000000 <NEWLINE> i = 1 <NEWLINE> while i ** 2 < n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> j = n / i <NEWLINE> minn = min ( int ( i + j - 2 ) , minn ) <NEWLINE> <DEDENT> <DEDENT> print ( minn ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> a = 1 <NEWLINE> b = N // a <NEWLINE> dis = abs ( a - b ) <NEWLINE> <NL> for i in range ( int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if N % i == 0 : <NEWLINE> <INDENT> _a = i <NEWLINE> _b = N / i <NEWLINE> _dis = abs ( _a - _b ) <NEWLINE> if _dis < dis : <NEWLINE> <INDENT> a = _a <NEWLINE> b = _b <NEWLINE> dis = _dis <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( a - 1 + b - 1 ) <NEWLINE>
<INDENT> import numpy as np <NEWLINE> <INDENT> a , b , x = map ( int , input ( ) . split ( ) ) <NEWLINE> if x >= a ** 2 * b / 2 : <NEWLINE> <INDENT> ans = np . arctan ( 2 * ( b - x / a ** 2 ) / a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = np . arctan ( a * b / 2 / x * b ) <NEWLINE> <DEDENT> print ( ans * 180 / np . pi ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> @ cc . export ( <STRING> , <STRING> ) <NEWLINE> def is_ok ( A , F , x , k ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , f in zip ( A , F ) : <NEWLINE> <INDENT> while a * f > x : <NEWLINE> <INDENT> a -= 1 <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> return tmp <= k <NEWLINE> <NL> <DEDENT> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> from my_module import is_ok <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> F = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> ok = 10 ** 16 <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( A , F , mid , k ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> @ cc . export ( <STRING> , <STRING> ) <NEWLINE> def is_ok ( A , F , x , k ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for a , f in zip ( A , F ) : <NEWLINE> <INDENT> y = a * f <NEWLINE> if y > x : <NEWLINE> <INDENT> tmp += a - x // f <NEWLINE> <DEDENT> <DEDENT> return tmp <= k <NEWLINE> <NL> <DEDENT> cc . compile ( ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <DEDENT> from my_module import is_ok <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> A = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> F = np . array ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> A = np . sort ( A ) <NEWLINE> F = np . sort ( F ) [ : : - 1 ] <NEWLINE> <NL> ok = 10 ** 12 <NEWLINE> ng = - 1 <NEWLINE> while ok - ng > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( A , F , mid , k ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ok ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , A - B * 2 ) <NEWLINE>
A . B = map ( int , input ( ) . split ( ) ) <NEWLINE> if A <= B * 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A - 2 * B ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( a - 2 b , 0 ) ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( max ( 0 , a - 2 * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if A - B * 2 > 0 : <NEWLINE> <INDENT> print ( A - B * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> c = b + b <NEWLINE> if ( a - b != 0 ) : <NEWLINE> <INDENT> print ( int ( a - b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> <NL> print ( max ( [ 0 , A - 2 * B ] ) ) <NEWLINE>
tmp = input ( ) . split ( <STRING> ) <NEWLINE> A = int ( tmp [ 0 ] ) <NEWLINE> B = int ( tmp [ 1 ] ) <NEWLINE> <NL> import math <NEWLINE> print ( math . max ( A - 2 * B , 0 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a - ( 2 * b ) if a > 2 b else 0 ) <NEWLINE>
a . b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a > b * 2 ) : <NEWLINE> <INDENT> print ( a - b * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( 0 , a - 2 b ) ) <NEWLINE>
a1 = input ( ) <NEWLINE> a2 = [ i for i in a1 . split ( ) ] <NEWLINE> a3 , a4 = [ res [ i ] for i in ( 0 , 1 ) ] <NEWLINE> A , B = int ( a3 ) , int ( a4 ) <NEWLINE> if A > 2 * B : <NEWLINE> <INDENT> print ( A - ( 2 * B ) ) <NEWLINE> <DEDENT> elif A < 2 * B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> len_ = A - * B <NEWLINE> <NL> if len_ <= 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( len_ ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( Max ( a - 2 * b , 0 ) ) <NEWLINE>
print ( max ( int ( input ( ) ) - int ( input ( ) ) * 2 , 0 ) ) <NEWLINE>
a , b = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a - 2 b < 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a - 2 b ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans <NEWLINE>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> def inpl ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> st = time . perf_counter ( ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> d = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <COMMENT> <NL> ed = time . perf_counter ( ) <NEWLINE> print ( <STRING> , ed - st , file = sys . stderr ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> ans += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range [ i + 1 : ] : <NEWLINE> <INDENT> s += d [ i ] * d [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = itertools . combinations ( l , 2 ) <NEWLINE> ans = sum ( x * y for x , y in c ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sam = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - i ) : <NEWLINE> <INDENT> sam = sam + ( d [ i ] * d [ j + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sam ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> print ( sum ( d [ a ] * d [ b ] for a , b in combinations ( range ( n ) , 2 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> a += li [ i ] * li [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> D = map ( int , input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in D [ i + 1 : ] : <NEWLINE> <INDENT> A = D [ i ] * j <NEWLINE> count += A <NEWLINE> <DEDENT> <DEDENT> print ( A ) <NEWLINE>
from itertools import combinations <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> c = combinations ( d , 2 ) <NEWLINE> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> kaihuku = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> kaihuku += d ( i ) * d ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( kaihuku ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> wa = 0 <NEWLINE> k = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if i + 1 == N : <NEWLINE> <INDENT> wa += List [ 0 ] * List [ N - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> wa += List [ i ] * List [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> su = s <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> su . pop ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( len ( su ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = str ( input ( ) ) <NEWLINE> s += <STRING> <NEWLINE> q = s [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if ( q == s [ i ] ) : <NEWLINE> <INDENT> None : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> q = s [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if s [ i ] != s [ i + 1 ] ; <NEWLINE> <INDENT> count = count + 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = list ( input ( ) ) <NEWLINE> for i in range ( n , 1 , - 1 ) : <NEWLINE> <INDENT> if x [ i ] == x [ i - 1 ] : <NEWLINE> <INDENT> x . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( len ( x ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> last = s [ 0 ] <NEWLINE> cnt = 0 <NEWLINE> for s in S [ 1 : ] : <NEWLINE> <INDENT> if last != s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> last = s <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if S [ i ] != S [ i - 1 ] <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE>
a = int ( input ( ) ) a b = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in range ( a - 1 ) : <NEWLINE> <INDENT> if b [ i ] == b [ i + 1 ] : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> print ( a - c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> from numba import njit , jit <NEWLINE> from itertools import combinations <NEWLINE> <NL> <NL> @ jit <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for a , b , c in combinations ( L , r = 3 ) : <NEWLINE> <INDENT> ans += a + b > c <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ans += bisect_left ( l . , l [ i ] + l [ j ] ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a . sort ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = i - 1 <NEWLINE> while ( l < r ) : <NEWLINE> <INDENT> if a [ l ] + a [ r ] > a [ i ] : <NEWLINE> <INDENT> count += r - l <NEWLINE> r -= 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> l += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> def findnumberofTriangles ( arr ) : <NEWLINE> <INDENT> n = len ( arr ) <NEWLINE> arr . sort ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , n - 2 ) : <NEWLINE> <INDENT> k = i + 2 <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> if ( k > j ) : <NEWLINE> <INDENT> count += k - j - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( findnumberoftriangles ( arr ) ) <NEWLINE> <NL>
from numba import njit <NEWLINE> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L . sort ( ) <NEWLINE> <NL> @ njit <NEWLINE> def solve ( N , L ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> b = L [ j ] <NEWLINE> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> cnt += a + b > L [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <DEDENT> print ( solve ( N , L ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> L = sorted ( L ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N - 2 ) : <NEWLINE> <INDENT> a = L [ i ] <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ans += bisect_left ( L , a + b ) - ( j + 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> import numba as nb <NEWLINE> <NL> input = sys . stdin . readline <NEWLINE> <NL> <NL> @ nb . njit ( <STRING> , cache = True ) <NEWLINE> def binary_search ( a , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ok = - 1 <NEWLINE> ng = len ( a ) <NEWLINE> <NL> def is_ok ( a , key , idx ) : <NEWLINE> <INDENT> if a [ idx ] < key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> while ( abs ( ok - ng ) > 1 ) : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> if is_ok ( a , key , mid ) : <NEWLINE> <INDENT> ok = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> L . sort ( ) <NEWLINE> ans = 0 <NEWLINE> for a in range ( N - 2 ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N - 1 ) : <NEWLINE> <INDENT> x = binary_search ( L , L [ a ] + L [ b ] ) <NEWLINE> ans += ( x - b ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> l = sorted ( map ( int , open ( 0 ) . read ( ) . split ( ) [ 1 : ] ) ) <NEWLINE> print ( sum ( max ( 0 , bisect_left ( l , l [ i ] + l [ j ] ) - j - 1 ) for i in range ( n ) for j in range ( i + 1 , n ) ) ) <NEWLINE>
import bisect <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> l = list ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> l = sorted ( l , reverse = True ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( n - 2 ) : <NEWLINE> <INDENT> a = l [ i ] <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> b = l [ j ] <NEWLINE> cnt += bisect . bisectright ( l , a - b ) - ( j + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import numpy as np <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> L = LI ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from numba import njit <NEWLINE> <NL> <COMMENT> <NL> def f ( A ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for k in range ( j + 1 , N ) : <NEWLINE> <INDENT> count += ( A [ k ] < A [ i ] + A [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> A = np . array ( L ) <NEWLINE> A . sort ( ) <NEWLINE> print ( f ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> k = bisect_left ( l , l [ i ] + l [ j ] ) <NEWLINE> ans += k - j - 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import bisect <NEWLINE> N = int ( input ( ) ) <NEWLINE> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list = sorted ( list ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> x = list [ i ] + list [ j ] <NEWLINE> ind = bisect . bisect_left ( list , x ) <NEWLINE> ans += ( ind - j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
from collections import defaultdict <NEWLINE> from scipy . sparse . csgraph import floyd_warshall <NEWLINE> <NL> n , m , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , c ) ) <NEWLINE> graph [ b ] . append ( ( a , c ) ) <NEWLINE> <NL> <NL> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> dist = [ - 1 ] * ( n + 1 ) <NEWLINE> stack = [ u ] <NEWLINE> dist [ u ] = 0 <NEWLINE> while stack : <NEWLINE> <INDENT> u = stack . pop ( ) <NEWLINE> for v , d in graph [ u ] : <NEWLINE> <INDENT> nxt = dist [ u ] + d <NEWLINE> if dist [ v ] == - 1 or dist [ v ] > nxt : <NEWLINE> <INDENT> dist [ v ] = nxt <NEWLINE> stack . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <NL> <DEDENT> dist = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dist [ i - 1 ] = dfs ( i ) [ 1 : ] <NEWLINE> <NL> <DEDENT> dist = np . array ( dist ) <NEWLINE> <NL> graph2 = np . full ( ( n , n ) , np . inf ) <NEWLINE> graph2 [ dist <= l ] = 1 <NEWLINE> dist = floyd_warshall ( graph2 , directed = False ) <NEWLINE> dist = dist . astype ( int ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( dist [ s - 1 , t - 1 ] - 1 ) <NEWLINE> <NL> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> S = S + <STRING> <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> cnt = [ ] <NEWLINE> conti = 1 <NEWLINE> for i in range ( 1 , len ( S ) ) : <NEWLINE> <INDENT> if S [ i - 1 ] == S [ i ] : <NEWLINE> <INDENT> conti += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt . append ( conti ) <NEWLINE> conti = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if S [ 0 ] == S [ - 2 ] : <NEWLINE> <COMMENT> <NL> <INDENT> if cnt [ 0 ] % 2 == 1 and cnt [ - 1 ] % 2 == 1 : <NEWLINE> <INDENT> comp = K - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = [ a // 2 for a in cnt if a >= 2 ] <NEWLINE> ans = sum ( ans ) * K + comp <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> import string <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> T = S + S [ 0 ] <NEWLINE> <NL> lower = string . ascii_lowercase <NEWLINE> ans = 0 <NEWLINE> is_specila_case = False <NEWLINE> <NL> for c in lower : <NEWLINE> <INDENT> key = c * 2 <NEWLINE> ans += T . count ( key ) <NEWLINE> <NL> if T . endswith ( key ) : <NEWLINE> <INDENT> is_specila_case = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans *= K <NEWLINE> <NL> if is_specila_case : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) import sys <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> import string <NEWLINE> <NL> S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> T = S + S [ 0 ] <NEWLINE> <NL> lower = string . ascii_lowercase <NEWLINE> ans = 0 <NEWLINE> is_specila_case = False <NEWLINE> <NL> for c in lower : <NEWLINE> <INDENT> key = c * 2 <NEWLINE> ans += T . count ( key ) <NEWLINE> <NL> if T . endswith ( key ) : <NEWLINE> <INDENT> is_specila_case = True <NEWLINE> <NL> <DEDENT> <DEDENT> ans *= K <NEWLINE> <NL> if is_specila_case : <NEWLINE> <INDENT> print ( ans - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> lint INF = 2e18 ; <NEWLINE> lint MOD = 1e9 + 7 ; <NEWLINE> <NL> lint i , j , k , t ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> string S ; <NEWLINE> lint K ; <NEWLINE> <NL> cin >> S >> K ; <NEWLINE> <NL> S += S [ 0 ] ; <NEWLINE> <NL> lint cnt = 0 ; <NEWLINE> regex re ( <STRING> ) ; <NEWLINE> <NL> for ( sregex_iterator it ( all ( S ) , re ) , end ; it != end ; + + it ) { <NEWLINE> <INDENT> auto & & m = * it ; <NEWLINE> cnt += m . length ( ) / 2 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> cout << cnt * K << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque , defaultdict <NEWLINE> from math import sqrt , factorial , gcd , ceil <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import string <NEWLINE> <COMMENT> <NL> from bisect import bisect_left <NEWLINE> <NL> def solve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> s = [ x for x in input ( ) ] <NEWLINE> a = s [ : ] <NEWLINE> k = int ( input ( ) ) <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( k // 2 ) <NEWLINE> return <NEWLINE> <DEDENT> if len ( set ( s ) ) == 1 : <NEWLINE> <INDENT> print ( ( len ( s ) * k ) // 2 ) <NEWLINE> return <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == s [ i - 1 ] : <NEWLINE> <INDENT> s [ i ] = <STRING> <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> cnt *= k <NEWLINE> <NL> if s [ 0 ] == s [ - 1 ] and s [ 0 ] != <STRING> : <NEWLINE> <INDENT> cnt += ( k - 1 ) <NEWLINE> <NL> <DEDENT> print ( min ( cnt , ans ) ) <NEWLINE> <NL> <NL> <DEDENT> t = 1 <NEWLINE> <COMMENT> <NL> for case in range ( 1 , t + 1 ) : <NEWLINE> <INDENT> ans = solve ( ) <NEWLINE> <NL> <NL> <DEDENT> <STRING> <NEWLINE>
s = input ( ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> cnt = 1 <NEWLINE> temp = [ ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == s [ i + 1 ] : cnt += 1 <NEWLINE> else : <NEWLINE> <INDENT> temp . append ( [ s [ i ] , cnt ] ) <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= 1 : temp . append ( [ s [ - 1 ] , cnt ] ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> print ( k * len ( s ) // 2 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> if temp [ 0 ] [ 0 ] != temp [ - 1 ] [ 0 ] : <NEWLINE> <INDENT> for pair in temp : <NEWLINE> <INDENT> if pair [ 1 ] != 1 : ans += pair [ 1 ] // 2 <NEWLINE> <DEDENT> print ( ans * k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for pair in temp [ 1 : - 1 ] : <NEWLINE> <INDENT> if pair [ 1 ] != 1 : ans += pair [ 1 ] // 2 <NEWLINE> <DEDENT> ans *= k <NEWLINE> ans += ( k - 1 ) * ( ( temp [ 0 ] [ 0 ] + temp [ - 1 ] [ 0 ] ) // 2 ) <NEWLINE> ans += temp [ 0 ] [ 0 ] // 2 + temp [ - 1 ] [ 0 ] // 2 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if len ( set ( s ) ) == 1 : <NEWLINE> <INDENT> print ( len ( S ) * K // 2 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> b = [ 1 ] <NEWLINE> for i in S [ : - 1 ] : <NEWLINE> <INDENT> if S [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> b [ - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in b : <NEWLINE> <INDENT> ans += i // 2 <NEWLINE> <DEDENT> ans *= K <NEWLINE> <NL> if S [ 0 ] == S [ - 1 ] and b [ 0 ] % 2 == b [ - 1 ] % 2 == 1 : <NEWLINE> <INDENT> ans += K - 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> K = int ( input ( ) ) <NEWLINE> <NL> if ( S . count ( S [ 0 ] ) == len ( S ) ) : <NEWLINE> <INDENT> print ( len ( S ) * K // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> lst = [ ] <NEWLINE> tmp = S [ 0 ] <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( tmp == S [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = S [ i ] <NEWLINE> if ( cnt > 1 ) : <NEWLINE> <INDENT> lst . append ( cnt ) <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if ( cnt > 1 ) : <NEWLINE> <INDENT> lst . append ( cnt ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in lst : <NEWLINE> <INDENT> ans += K * ( i // 2 ) <NEWLINE> <DEDENT> if ( S [ 0 ] != S [ - 1 ] ) : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if ( tmp != S [ i ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a += 1 <NEWLINE> <DEDENT> for i in S [ : : - 1 ] : <NEWLINE> <INDENT> if ( tmp != i ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b += 1 <NEWLINE> <DEDENT> print ( ans + ( ( a + b ) // 2 - ( a // 2 + b // 2 ) ) * ( K - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <COMMENT> <NL> sysread = sys . stdin . buffer . readline <NEWLINE> read = sys . stdin . buffer . read <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> import numpy as np <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> from numba import jit <NEWLINE> <NL> INF = 1 << 50 <NEWLINE> EPS = 1e-8 <NEWLINE> <NL> @ jit <NEWLINE> def solve ( S ) : <NEWLINE> <INDENT> N = S . shape [ 0 ] <NEWLINE> ans = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> seen = set ( ) <NEWLINE> seen . add ( k ) <NEWLINE> merged = np . ones ( N , dtype = np . int32 ) * ( - 1 ) <NEWLINE> merged [ 0 ] = k <NEWLINE> count = 0 <NEWLINE> while merged [ 0 ] > - 1 : <NEWLINE> <COMMENT> <NL> <INDENT> count += 1 <NEWLINE> nexts = np . ones ( N , dtype = np . int32 ) * ( - 1 ) <NEWLINE> p = 0 <NEWLINE> for i in merged : <NEWLINE> <INDENT> if i == - 1 : break <NEWLINE> for j , e in enumerate ( S [ i ] ) : <NEWLINE> <INDENT> if e and not j in seen : <NEWLINE> <COMMENT> <NL> <INDENT> nexts [ p ] = j <NEWLINE> p += 1 <NEWLINE> seen . add ( j ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if nexts [ i ] == - 1 : break <NEWLINE> <DEDENT> checks = S [ nexts [ : i ] , : ] [ : , nexts [ : i ] ] <NEWLINE> <COMMENT> <NL> if checks . sum ( ) != 0 : <NEWLINE> <INDENT> seen = set ( ) <NEWLINE> break <NEWLINE> <DEDENT> merged = nexts <NEWLINE> <DEDENT> if len ( seen ) == N : <NEWLINE> <INDENT> ans = max ( ans , count ) <NEWLINE> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> N = int ( sysread ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( list ( map ( int , list ( input ( ) ) ) ) ) <NEWLINE> <DEDENT> S = np . array ( S , dtype = np . int8 ) <NEWLINE> <NL> solve ( S ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( N / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( N / 2 ) ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> if N % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( N // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( N // 2 + 1 ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> <NL> if a % 2 == 1 : print ( ( ( a - 1 ) / 2 + 1 ) / a ) <NEWLINE> else : print 0.5 <NEWLINE>
N = int ( input ( ) ) <NEWLINE> if N % 2 = 1 : <NEWLINE> <INDENT> n = int ( ( N + 1 ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( N / 2 ) <NEWLINE> <DEDENT> res = n / N <NEWLINE> print ( res ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> print ( a / 2 / a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( a // 2 + 1 ) a ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> elif N % 2 == 0 : <NEWLINE> <INDENT> print ( 0.5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( N - ( N // 2 ) / N ) <NEWLINE> <DEDENT>
N , K = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> h = list ( map ( lambda x : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> print ( len ( list ( filter ( lambda height : height >= K , h ) ) ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> xlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if x [ i ] >= k : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
result = 0 <NEWLINE> <NL> for h in heights : <NEWLINE> <INDENT> if h >= K : <NEWLINE> <INDENT> result += 1 <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N + 1 ) : <NEWLINE> <INDENT> if d [ i ] >= K : <NEWLINE> <INDENT> ans = ans + 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def atc_142b ( NK_input : str , hi_input : str ) -> int : <NEWLINE> <INDENT> N , K = map ( int , NK_input . split ( <STRING> ) ) <NEWLINE> hi = [ int ( i ) for i in hi_input . split ( <STRING> ) ] <NEWLINE> hi = sorted ( hi ) <NEWLINE> for i in range ( 0 , len ( hi ) ) : <NEWLINE> <INDENT> if hi [ i ] >= K : <NEWLINE> <INDENT> return len ( hi ) - i <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> NK_input_value = input ( ) <NEWLINE> hi_input_value = input ( ) <NEWLINE> pritn ( atc_142b ( NK_input_value , hi_input_value ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> if h >= K : <NEWLINE> count = count + 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if h >= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in h : <NEWLINE> <INDENT> if i > K : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> print ( total ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] >= K : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N , K = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> counter = 0 <NEWLINE> for h in H : <NEWLINE> <INDENT> if h >= K : <NEWLINE> <INDENT> couter += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( counter ) <NEWLINE>
n , k = map ( int , input ( ) . spilit ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in h : <NEWLINE> <INDENT> if a >= k : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for high in h : <NEWLINE> <INDENT> if h >= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n , k = map ( int , input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( a [ i ] >= k ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
A = B = int ( input ( ) ) <NEWLINE> N = list ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( A ) : <NEWLINE> <INDENT> if N [ i ] >= B : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
<NL> n , k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> if h [ i ] >= k : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in h : <NEWLINE> <INDENT> if h >= K : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * N <NEWLINE> for i , val in enumerate ( A ) : <NEWLINE> <INDENT> ans [ val - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Alist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> Alist = [ [ idx + 1 , a ] for ( idx , a ) in enumerate ( Alist ) ] <NEWLINE> <NL> Alist . sort ( key = lambda x : x [ 1 ] ) <NEWLINE> <NL> ans = [ a for a , _ in Alist ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> Ai = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> ans = [ ] * N <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans [ Ai [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
import bisect , collections , copy , heapq , itertools , math , string <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> def _S ( ) : return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> def LI ( ) : return list ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) ) <NEWLINE> def LS ( ) : return list ( sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> <NL> N = I ( ) <NEWLINE> A = LI ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> ans = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans . append ( A . index ( i + 1 ) + 1 ) <NEWLINE> <DEDENT> print ( * ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a [ i ] <NEWLINE> b [ x - 1 ] = i + 1 <NEWLINE> <DEDENT> c = <STRING> . join ( b ) <NEWLINE> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> B = [ 0 ] * N <NEWLINE> C = <STRING> <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> C += str ( B [ i ] ) + <STRING> <NEWLINE> <NL> <DEDENT> print ( C [ 0 : - 1 ] ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 1 <NEWLINE> X = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if A [ i ] == ans : <NEWLINE> <INDENT> ans += 1 <NEWLINE> X . append ( i + 1 ) <NEWLINE> <DEDENT> <DEDENT> L = <STRING> . join ( X ) <NEWLINE> print ( X ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ a . pop ( i ) - 1 ] = i + 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( ans , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> al = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> lst = [ ] * n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> lst [ al [ i - 1 ] - 1 ] = i <NEWLINE> <DEDENT> print ( * lst ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ 0 ] * N <NEWLINE> for i in range ( Nh ) : <NEWLINE> <INDENT> ans [ S [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , ans ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> line = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ line [ i - 1 ] ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans [ A [ i ] - 1 ] = i + 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = [ 0 ] * ( N ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> B [ A [ i ] ] = A [ i ] <NEWLINE> <DEDENT> print ( B ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> copy = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> copy [ ls [ i ] - 1 = i + 1 <NEWLINE> <DEDENT> for i in copy : <NEWLINE> <INDENT> print ( i , end = <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> alist = [ 0 ] * n <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> alist [ a [ i ] - 1 ] = str ( i + 1 ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( alist ) ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> an = list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> ans = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans [ an [ i ] - 1 ] = i + 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> a , b = map ( lambda x : set ( prime_factorize ( int ( x ) ) ) , input ( ) . split ( ) ) <NEWLINE> print ( len ( a & b ) + 1 ) <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def primes ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return [ i for i in range ( n + 1 ) if is_prime [ i ] ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def is_prime ( n : int ) -> bool : <NEWLINE> <INDENT> <STRING> <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def prime_factorize ( n : int ) -> list : <NEWLINE> <INDENT> <STRING> <NEWLINE> arr = [ ] <NEWLINE> <COMMENT> <NL> while n % 2 == 0 : <NEWLINE> <INDENT> arr . append ( 2 ) <NEWLINE> n //= 2 <NEWLINE> <COMMENT> <NL> <DEDENT> for f in primes ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> while n % f == 0 : <NEWLINE> <INDENT> arr . append ( f ) <NEWLINE> n //= f <NEWLINE> <DEDENT> <DEDENT> if n != 1 : <NEWLINE> <INDENT> arr . append ( n ) <NEWLINE> <DEDENT> return arr <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def make_divisors ( n : int ) -> list : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> table = sorted ( table ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> A_list = set ( divisor ( A ) ) <NEWLINE> B_list = set ( divisor ( B ) ) <NEWLINE> <NL> list = A_list & B_list <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> if is_prime ( i ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import numpy as np <NEWLINE> <NL> def divisor ( n ) : <NEWLINE> <INDENT> i = 1 <NEWLINE> table = [ ] <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> table . append ( i ) <NEWLINE> table . append ( n // i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> table = list ( set ( table ) ) <NEWLINE> table = sorted ( table ) <NEWLINE> return table <NEWLINE> <NL> <DEDENT> def make_prime ( U ) : <NEWLINE> <INDENT> is_prime = np . zeros ( U , np . bool ) <NEWLINE> is_prime [ 2 ] = 1 <NEWLINE> is_prime [ 3 : : 2 ] = 1 <NEWLINE> M = int ( U ** .5 ) + 1 <NEWLINE> for p in range ( 3 , M , 2 ) : <NEWLINE> <INDENT> if is_prime [ p ] : <NEWLINE> <INDENT> is_prime [ p * p : : p + p ] = 0 <NEWLINE> <DEDENT> <DEDENT> return is_prime , is_prime . nonzero ( ) [ 0 ] <NEWLINE> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> A_list = set ( divisor ( A ) ) <NEWLINE> B_list = set ( divisor ( B ) ) <NEWLINE> <NL> list = A_list & B_list <NEWLINE> <NL> _ , primes = make_prime ( 10 ** 9 ) <NEWLINE> <NL> cnt = 1 <NEWLINE> <NL> for i in list : <NEWLINE> <INDENT> if i in primes : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def gcd ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if a % b == 0 : return b <NEWLINE> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> def ela ( g ) : <NEWLINE> <INDENT> s = { } <NEWLINE> i = 2 <NEWLINE> while i * i <= g : <NEWLINE> <INDENT> while g % i == 0 : <NEWLINE> <INDENT> g //= i <NEWLINE> s . add ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G = gcd ( max ( a , b ) , min ( a , b ) ) <NEWLINE> print ( len ( ela ( G ) ) + 1 ) <NEWLINE>
from math import * <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> divisors = set ( ) <NEWLINE> for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> divisors . add ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> divisors . add ( n // i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return divisors <NEWLINE> <NL> <DEDENT> def eratosthenes ( n ) : <NEWLINE> <INDENT> table = [ 0 ] * ( n + 1 ) <NEWLINE> prime_list = [ ] <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if table [ i ] == 0 : <NEWLINE> <INDENT> prime_list . append ( i ) <NEWLINE> for j in range ( i + i , n + 1 , i ) : <NEWLINE> <INDENT> table [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return prime_list <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> upper = 10 ** 8 <NEWLINE> ans = set ( eratosthenes ( upper ) ) & make_divisors ( a ) & make_divisors ( b ) <NEWLINE> print ( len ( ans ) + 1 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> import os <NEWLINE> import itertools <NEWLINE> import string <NEWLINE> import heapq <NEWLINE> import _collections <NEWLINE> from collections import Counter <NEWLINE> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> from functools import lru_cache <NEWLINE> import bisect <NEWLINE> import re <NEWLINE> import queue <NEWLINE> import decimal <NEWLINE> <NL> <NL> class Scanner ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def int ( ) : <NEWLINE> <INDENT> return int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def map_int ( ) : <NEWLINE> <INDENT> return [ int ( x ) for x in Scanner . string ( ) . split ( ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def string_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . string ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_list_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . map_int ( ) for i in range ( n ) ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def int_cols_list ( n ) : <NEWLINE> <INDENT> return [ Scanner . int ( ) for i in range ( n ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Math ( ) : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return Math . gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def lcm ( a , b ) : <NEWLINE> <INDENT> return ( a * b ) // Math . gcd ( a , b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def divisor ( n ) : <NEWLINE> <INDENT> lower , upper = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower + upper [ : : - 1 ] <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def round_up ( a , b ) : <NEWLINE> <INDENT> return - ( - a // b ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def is_prime ( n ) : <NEWLINE> <INDENT> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> d = int ( n ** 0.5 ) + 1 <NEWLINE> for i in range ( 3 , d + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def fact ( N ) : <NEWLINE> <INDENT> res = { } <NEWLINE> tmp = N <NEWLINE> for i in range ( 2 , int ( N ** 0.5 + 1 ) + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while tmp % i == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp //= i <NEWLINE> <DEDENT> if cnt > 0 : <NEWLINE> <INDENT> res [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> if tmp != 1 : <NEWLINE> <INDENT> res [ tmp ] = 1 <NEWLINE> <DEDENT> if res == { } : <NEWLINE> <INDENT> res [ N ] = 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def pop_count ( x ) : <NEWLINE> <INDENT> x = x - ( ( x >> 1 ) & 0x5555555555555555 ) <NEWLINE> x = ( x & 0x3333333333333333 ) + ( ( x >> 2 ) & 0x3333333333333333 ) <NEWLINE> x = ( x + ( x >> 4 ) ) & 0x0f0f0f0f0f0f0f0f <NEWLINE> x = x + ( x >> 8 ) <NEWLINE> x = x + ( x >> 16 ) <NEWLINE> x = x + ( x >> 32 ) <NEWLINE> return x & 0x0000007f <NEWLINE> <NL> <NL> <DEDENT> MOD = int ( 1e09 ) + 7 <NEWLINE> INF = int ( 1e15 ) <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> A , B = Scanner . map_int ( ) <NEWLINE> div_A = Math . divisor ( A ) <NEWLINE> div_B = Math . divisor ( B ) <NEWLINE> X = set ( div_A ) & set ( div_B ) <NEWLINE> ans = 0 <NEWLINE> for x in X : <NEWLINE> <INDENT> if Math . is_prime ( x ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans + 1 ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> sys . stdin = open ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> solve ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> d = math . gcd ( a , b ) <NEWLINE> <NL> def make_divisors ( n ) : <NEWLINE> <INDENT> lower_divisors , upper_divisors = [ ] , [ ] <NEWLINE> i = 1 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> lower_divisors . append ( i ) <NEWLINE> if i != n // i : <NEWLINE> <INDENT> upper_divisors . append ( n // i ) <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return lower_divisors + upper_divisors [ : : - 1 ] <NEWLINE> <NL> <DEDENT> r = make_divisors ( d ) <NEWLINE> l = len ( r ) <NEWLINE> ans = 1 <NEWLINE> w = [ True ] * l <NEWLINE> if l >= 2 : <NEWLINE> <INDENT> for x in range ( 1 , l ) : <NEWLINE> <INDENT> if w [ x ] == True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> for y in range ( x , l ) : <NEWLINE> <INDENT> if r [ y ] % r [ x ] == 0 : <NEWLINE> <INDENT> w [ y ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> <NL> class Graph ( ) : <COMMENT> <NEWLINE> <INDENT> def __init__ ( self , n , edge , indexed = 1 ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . graph = [ [ ] for _ in range ( n ) ] <NEWLINE> for e in edge : <NEWLINE> <INDENT> self . graph [ e [ 0 ] - indexed ] . append ( e [ 1 ] - indexed ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> INF = 10 ** 18 <NEWLINE> <NL> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( M ) ] <NEWLINE> <NL> g = Graph ( N , edge ) <NEWLINE> <NL> loopsize = INF <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> root = i <NEWLINE> queue = deque ( [ root ] ) <NEWLINE> dist = [ INF for _ in range ( N ) ] <NEWLINE> dist [ root ] = 0 <NEWLINE> prev = [ None for _ in range ( N ) ] <NEWLINE> while queue : <NEWLINE> <INDENT> node = queue . popleft ( ) <NEWLINE> for adj in g . graph [ node ] : <NEWLINE> <INDENT> if adj == root : <COMMENT> <NEWLINE> <INDENT> dist [ root ] = dist [ node ] + 1 <NEWLINE> prev [ root ] = node <NEWLINE> break <NEWLINE> <DEDENT> if dist [ adj ] != INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ adj ] = dist [ node ] + 1 <NEWLINE> prev [ adj ] = node <NEWLINE> queue . append ( adj ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> if loopsize > dist [ root ] : <NEWLINE> <INDENT> loopsize = dist [ root ] <NEWLINE> path = [ root ] <NEWLINE> node = root <NEWLINE> while prev [ node ] != root : <NEWLINE> <INDENT> node = prev [ node ] <NEWLINE> path . append ( node ) <NEWLINE> <DEDENT> res = path <NEWLINE> <NL> <DEDENT> <DEDENT> if loopsize != INF : <NEWLINE> <INDENT> print ( loopsize ) <NEWLINE> for node in res : <NEWLINE> <INDENT> print ( node + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT>
H , W , A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> M = [ [ 0 ] * W for _ in range ( H ) ] <NEWLINE> <NL> <NL> <NL> for ih in range ( H ) : <NEWLINE> <INDENT> for iw in range ( W ) : <NEWLINE> <INDENT> if ( ih < B and iw < S ) or ( ih >= B and iw >= A ) : <NEWLINE> <INDENT> M [ ih ] [ iw ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , M [ i ] ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
s = list ( input ( ) ) <NEWLINE> k = int ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif s [ i ] == s [ i + 1 ] : <NEWLINE> <INDENT> s [ i + 1 ] = 0 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> ans2 = 0 <NEWLINE> if s [ 0 ] == s [ - 1 ] : <NEWLINE> <INDENT> ans2 = 1 <NEWLINE> s [ - 1 ] = 0 <NEWLINE> <DEDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> print ( k // 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans * k + ans2 * ( k - 1 ) ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> result = <STRING> : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> <NL> <DEDENT> print ( result ) <NEWLINE>
S = input ( ) <NEWLINE> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if S = <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( Cloudy ) <NEWLINE> <NL> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( Rainy ) <NEWLINE> <NL> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> print ( Sunny ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> l = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( l [ l . index ( s ) + 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> if S == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif S == <STRING> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( a [ a . index ( s ) + 1 ] <NEWLINE>
w = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( w [ ( w . index ( input ) + 1 ) % 3 ] ) <NEWLINE>
s = input ( ) <NEWLINE> w = ( Sunny , Cloudy , Rainy , Sunny ) <NEWLINE> n = w . index ( s ) <NEWLINE> print ( w [ n + 1 ] ) <NEWLINE>
S = input ( ) <NEWLINE> weather = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> print ( weather [ weather . index ( S ) + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = input ( ) <NEWLINE> <NL> if N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) : <NEWLINE> <DEDENT> elif N == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> if S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif S == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
weather = input ( ) <NEWLINE> <NL> if weather == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> if weather == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> if weather == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if ans != 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
str = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in len ( str ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 0 and str [ i ] not in ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <DEDENT> if ( i + 1 ) % 2 == 1 and str [ i ] not in ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = input ( ) <NEWLINE> for i in range ( len ( S ) + 1 ) : <NEWLINE> <INDENT> if i == len ( S ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] % 2 == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> S = list ( input ( ) ) <NEWLINE> S_odd = S [ : : 2 ] <NEWLINE> S_even = S [ 1 : : 2 ] <NEWLINE> easy_odd = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> easy_even = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> print ( <STRING> ) if set ( S_odd ) . issubset ( easy_odd ) and set ( S_even ) . issubset ( easy_even ) else <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> s = input ( ) <NEWLINE> for i in len ( s ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> O = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> E = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> ng = False <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if S [ i ] not in O : <NEWLINE> <INDENT> ng = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if S [ i ] not in E : <NEWLINE> <INDENT> ng = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) if ng print ( <STRING> ) <NEWLINE>
a = input ( ) <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> for i in range ( int ( len ( a ) / 2 ) ) : <NEWLINE> <INDENT> if a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> if a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if b = len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if a % 2 == 1 : <NEWLINE> <INDENT> for i in range ( int ( len ( a ) / 2 ) + 1 ) : <NEWLINE> <INDENT> if a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> or a [ 2 * i ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( int ( len ( a ) / 2 ) ) : <NEWLINE> <INDENT> if a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> or a [ 2 * i + 1 ] == <STRING> : <NEWLINE> <INDENT> b = b + 1 <NEWLINE> <DEDENT> <DEDENT> if b = len ( a ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
S = input ( ) <NEWLINE> <NL> check = True <NEWLINE> for i , s in enumerate ( S ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 0 : <NEWLINE> <INDENT> if not ( s == <STRING> or s == <STRING> or s == <STRING> ) : <NEWLINE> <INDENT> check = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not ( s == <STRING> or s == <STRING> or s = <STRING> ) : <NEWLINE> <INDENT> check = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if check : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> print ( <STRING> [ len ( re . sub ( <STRING> , <STRING> , S [ 0 : : 2 ] ) ) == 0 == len ( re . sub ( <STRING> , <STRING> , S [ 1 : : 2 ] ) ) : : 2 ] ) <NEWLINE>
odd = <STRING> <NEWLINE> even = <STRING> <NEWLINE> s = int ( input ( ) ) <NEWLINE> flag = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> a = i + 1 <NEWLINE> if a % 2 == 0 : <NEWLINE> <INDENT> if s [ i ] not in even : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if s [ i ] not in odd : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> <NL> N = len ( S ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if ( i % 2 == 0 and S [ i ] == <STRING> ) or ( i % 2 == 1 and S [ i ] == <STRING> ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> <NL> Ans = True <NEWLINE> for i in range ( 0 , len ( S ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> else : <NEWLINE> <INDENT> Ans = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i % 2 != 0 : <NEWLINE> <INDENT> if S [ i ] == <STRING> or S [ i ] == <STRING> or S [ i ] == <STRING> : <NEWLINE> else : <NEWLINE> <INDENT> Ans = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if Ans == False : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
s = list ( input ( ) ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if i % 2 == 0 and s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> if i % 2 == 1 and s [ i ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> sys . exit ( ) <NEWLINE> <DEDENT> <DEDENT> print ( Yes ) <NEWLINE>
N , K , Q = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> point = [ K - Q ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> c = int ( input ( ) ) <NEWLINE> point [ c - 1 ] += 1 <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( [ <STRING> if p > 0 else <STRING> for p in point ] ) ) <NEWLINE>
inp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = inp [ 0 ] <NEWLINE> k = inp [ 1 ] <NEWLINE> q = inp [ 2 ] <NEWLINE> if q < k : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> arr = [ k - q ] * ( n ) <NEWLINE> z = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> arr [ x - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if arr [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def i ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def i2 ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> return str ( input ( ) ) <NEWLINE> <DEDENT> def l ( ) : <NEWLINE> <INDENT> return list ( input ( ) ) <NEWLINE> <DEDENT> def intl ( ) : <NEWLINE> <INDENT> return list ( int ( k ) for k in input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> n , k , q = i2 ( ) <NEWLINE> ls = [ k - q ] * n <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a = i ( ) <NEWLINE> ls [ a - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> if ls [ j ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> start = [ k - q ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> start [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if start [ i ] > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> point = [ 0 ] * ( n + 1 ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> point [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if k + point [ i ] > q : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<STRING> <NEWLINE> <NL> N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = ( int ( x ) for x in open ( 0 ) . input ( ) . split ( ) ) <NEWLINE> <NL> score = [ K - Q ] * ( N + 1 ) <NEWLINE> for x in A : <NEWLINE> <INDENT> score [ x ] += 1 <NEWLINE> <NL> <DEDENT> ans = <STRING> . join ( <STRING> if x <= 0 else <STRING> for x in score [ 1 : ] ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> <NL> def main ( stdin ) : <NEWLINE> <INDENT> N , K , Q = stdin [ : 3 ] <NEWLINE> ans = np . full ( N + 1 , K - Q , dtype = np . int64 ) <NEWLINE> for i in stdin [ 3 : ] : <NEWLINE> <INDENT> ans [ i ] += 1 <NEWLINE> <DEDENT> ans = np . where ( ans > 0 , <STRING> , <STRING> ) <NEWLINE> return ans [ 1 : ] <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> from my_module import main <NEWLINE> stdin = np . array ( [ int ( _ ) for _ in open ( 0 ) . read ( ) . split ( ) ] ) <NEWLINE> print ( * main ( stdin ) , sep = <STRING> ) <NEWLINE> <DEDENT>
N , K , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if K > Q : <NEWLINE> <INDENT> ans = [ <STRING> for i in range ( N ) ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> exit ( ) <NEWLINE> <NL> T = [ 0 for i in range ( N ) ] <NEWLINE> t = Q - K <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> T [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if T [ i ] > t : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
eople , point , quiz = map ( int , input ( ) . split ( ) ) <NEWLINE> an = [ int ( input ( ) ) for _ in range ( quiz ) ] <NEWLINE> each_p = [ point - quiz ] * people <NEWLINE> <NL> for x in an : <NEWLINE> <INDENT> each_p [ x - 1 ] += 1 <NEWLINE> <NL> <DEDENT> for y in each_p : <NEWLINE> <INDENT> if y <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n , k , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> ans = k <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> que = int ( input ( ) ) <NEWLINE> if que != i : <NEWLINE> <INDENT> ans -= 1 <NEWLINE> <DEDENT> if ans <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ans <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
from heapq import heapify , heappush , heappop <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) split ( ) ) <NEWLINE> A = [ - x for x in map ( int , input ( ) . split ( ) ) ] <NEWLINE> heapify ( A ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> tmp = heappop ( A ) <NEWLINE> tmp2 = tmp // 2 <NEWLINE> heappush ( A , tmp2 ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += A [ i ] <NEWLINE> <NL> <DEDENT> ans = abs ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 0 , M ) : <NEWLINE> <INDENT> A [ A . index ( max ) ] = int ( A [ A . index ( max ) ] ) <NEWLINE> <NL> <DEDENT> print ( sum ( A ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = [ int ( x ) * - 1 for x in input ( ) . split ( ) ] <NEWLINE> ans = sum ( a ) * - 1 <NEWLINE> diff = 0 <NEWLINE> <NL> heapify ( a ) <NEWLINE> for _ in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> _h_a = heappop ( a ) * - 1 <NEWLINE> diff += _h_a - _h_a // 2 <NEWLINE> heappush ( a , ( _h_a // 2 ) * - 1 ) <NEWLINE> <DEDENT> ans -= diff <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def getN ( ) : <NEWLINE> <INDENT> return int ( input ( ) ) <NEWLINE> <DEDENT> def getNM ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> def getList ( ) : <NEWLINE> <INDENT> return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def getArray ( intn ) : <NEWLINE> <INDENT> return [ int ( input ( ) ) for i in range ( intn ) ] <NEWLINE> <DEDENT> def input ( ) : <NEWLINE> <INDENT> return sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> <DEDENT> def rand_N ( ran1 , ran2 ) : <NEWLINE> <INDENT> return random . randint ( ran1 , ran2 ) <NEWLINE> <DEDENT> def rand_List ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> return [ random . randint ( ran1 , ran2 ) for i in range ( rantime ) ] <NEWLINE> <DEDENT> def rand_ints_nodup ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> ns = [ ] <NEWLINE> while len ( ns ) < rantime : <NEWLINE> <INDENT> n = random . randint ( ran1 , ran2 ) <NEWLINE> if not n in ns : <NEWLINE> <INDENT> ns . append ( n ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( ns ) <NEWLINE> <NL> <DEDENT> def rand_query ( ran1 , ran2 , rantime ) : <NEWLINE> <INDENT> r_query = [ ] <NEWLINE> while len ( r_query ) < rantime : <NEWLINE> <INDENT> n_q = rand_ints_nodup ( ran1 , ran2 , 2 ) <NEWLINE> if not n_q in r_query : <NEWLINE> <INDENT> r_query . append ( n_q ) <NEWLINE> <DEDENT> <DEDENT> return sorted ( r_query ) <NEWLINE> <NL> <DEDENT> from collections import defaultdict , deque , Counter <NEWLINE> from sys import exit <NEWLINE> from decimal import * <NEWLINE> import heapq <NEWLINE> import math <NEWLINE> from fractions import gcd <NEWLINE> import random <NEWLINE> import string <NEWLINE> import copy <NEWLINE> from itertools import combinations , permutations , product <NEWLINE> from operator import mul <NEWLINE> from functools import reduce <NEWLINE> from bisect import bisect_left , bisect_right <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 1000000000 ) <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = getN ( ) <NEWLINE> S = <STRING> + input ( ) <NEWLINE> <NL> lista = defaultdict ( int ) <NEWLINE> <NL> for i in range ( N // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , N - i + 1 ) : <NEWLINE> <INDENT> opt = S [ j : i + j + 1 ] <NEWLINE> if lista [ opt ] == 0 : <NEWLINE> <INDENT> lista [ opt ] = i + j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if lista [ opt ] < j : <NEWLINE> <INDENT> print ( len ( opt ) ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( 0 ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> from numba import njit <NEWLINE> <NL> def main ( N , S , dp ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> dp [ i , j ] = min ( j - i , dp [ i - 1 , j - 1 ] + 1 ) if S [ i ] == S [ j ] else 0 <NEWLINE> <DEDENT> ans = max ( ans , np . max ( dp [ i ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> i8 = numba . int64 <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> <NL> def cc_export ( f , signature ) : <NEWLINE> <INDENT> cc . export ( f . __name__ , signature ) ( f ) <NEWLINE> return numba . njit ( f ) <NEWLINE> <NL> <DEDENT> main = cc . export ( main , ( i8 , i8 [ : ] , i8 [ : , : ] , ) ) <NEWLINE> cc . compile ( ) <NEWLINE> <NL> <DEDENT> from my_module import main <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> S = np . array ( [ ord ( _ ) for _ in input ( ) ] ) <NEWLINE> dp = np . zeros ( ( N + 1 , N + 1 ) , dtype = int ) <NEWLINE> print ( main ( N , S , dp ) ) <NEWLINE>
import numpy as np <NEWLINE> import numba <NEWLINE> @ numba . jit <NEWLINE> def solve ( n , s ) : <NEWLINE> <INDENT> dp = np . zeros ( ( n + 1 , n + 1 ) , dtype = np . int16 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> if dp [ i ] [ j ] < j - i : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + 1 ] = dp [ i ] [ j ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( np . amax ( dp ) ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> solve ( n , s ) <NEWLINE>
import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( N , S , dp ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> dp [ i , j ] = min ( j - i , dp [ i - 1 , j - 1 ] + 1 ) if S [ i ] == S [ j ] else 0 <NEWLINE> <DEDENT> ans = max ( ans , np . max ( dp [ i ] ) ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> import numba <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> cc . export ( <STRING> , <STRING> ) ( main ) <NEWLINE> <COMMENT> <NL> cc . compile ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> from my_module import main <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> 1 <NEWLINE> <DEDENT> dp = np . zeros ( ( N + 1 , N + 1 ) , dtype = int ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> S = np . array ( [ ord ( _ ) for _ in input ( ) ] ) <NEWLINE> print ( main ( N , S , dp ) ) <NEWLINE> <DEDENT>
def numba_compile ( numba_config ) : <NEWLINE> <INDENT> import os , sys <NEWLINE> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> from numba import njit <NEWLINE> from numba . pycc import CC <NEWLINE> cc = CC ( <STRING> ) <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> vars ( ) [ func . __name__ ] = njit ( signature ) ( func ) <NEWLINE> cc . export ( func . __name__ , signature ) ( func ) <NEWLINE> <DEDENT> cc . compile ( ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> elif os . name == <STRING> : <NEWLINE> <INDENT> exec ( <STRING> ) <NEWLINE> for func , _ in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = vars ( ) [ func . __name__ ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> from numba import njit <NEWLINE> for func , signature in numba_config : <NEWLINE> <INDENT> globals ( ) [ func . __name__ ] = njit ( signature , cache = True ) ( func ) <NEWLINE> <DEDENT> print ( <STRING> , file = sys . stderr ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> import numpy as np <NEWLINE> <NL> def z_algo ( S ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> i , j , n = 1 , 0 , len ( S ) <NEWLINE> Z = np . zeros ( S . shape , dtype = np . int64 ) <NEWLINE> Z [ 0 ] = n <NEWLINE> while i < n : <NEWLINE> <INDENT> while i + j < n and S [ j ] == S [ i + j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> if j == 0 : <NEWLINE> <INDENT> i += 1 <NEWLINE> continue <NEWLINE> <DEDENT> Z [ i ] = j <NEWLINE> d = 1 <NEWLINE> while i + d < n and d + Z [ d ] < j : <NEWLINE> <INDENT> Z [ i + d ] = Z [ d ] <NEWLINE> d += 1 <NEWLINE> <DEDENT> i += d <NEWLINE> j -= d <NEWLINE> <DEDENT> return Z <NEWLINE> <NL> <DEDENT> def solve ( N , S ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Z = z_algo ( S [ i : ] ) <NEWLINE> for idx_Z , z in enumerate ( Z ) : <NEWLINE> <INDENT> an = min ( z , idx_Z ) <NEWLINE> ans = max ( ans , an ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> numba_compile ( [ <NEWLINE> <INDENT> [ z_algo , <STRING> ] , <NEWLINE> [ solve , <STRING> ] <NEWLINE> <DEDENT> ] ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( sys . stdin . buffer . readline ( ) ) <NEWLINE> S = np . frombuffer ( sys . stdin . buffer . readline ( ) , dtype = np . uint8 ) . copy ( ) <NEWLINE> ans = solve ( N , S ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
from typing import List <NEWLINE> <NL> <NL> class RollingHash : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> def __init__ ( self , source : str , base : int = 1007 , mod : int = 10 ** 9 + 7 ) : <NEWLINE> <INDENT> self . source = source <NEWLINE> self . length = len ( source ) <NEWLINE> self . base = base <NEWLINE> self . mod = mod <NEWLINE> self . hash = self . _get_hash_from_zero ( ) <NEWLINE> self . power = self . _get_base_pow ( ) <NEWLINE> <NL> <DEDENT> def _get_hash_from_zero ( self ) -> List [ int ] : <NEWLINE> <INDENT> <STRING> <NEWLINE> hash_from_zero = [ 0 ] * self . length <NEWLINE> cur = 0 <NEWLINE> for i , c in enumerate ( self . source ) : <NEWLINE> <INDENT> cur = ( cur * self . base + ord ( c ) ) % self . mod <NEWLINE> hash_from_zero [ i ] = cur <NEWLINE> <DEDENT> return hash_from_zero <NEWLINE> <NL> <DEDENT> def _get_base_pow ( self ) -> List [ int ] : <NEWLINE> <INDENT> <STRING> <NEWLINE> power = [ 1 ] * self . length <NEWLINE> cur = 1 <NEWLINE> for i in range ( self . length ) : <NEWLINE> <INDENT> cur *= self . base % self . mod <NEWLINE> power [ i ] = cur <NEWLINE> <DEDENT> return power <NEWLINE> <NL> <DEDENT> def get_hash ( self , left : int , right : int ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return ( <NEWLINE> <INDENT> self . hash [ right ] - self . hash [ left ] * self . power [ right - left ] <NEWLINE> <DEDENT> ) % self . mod <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def abc141_e ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( input ( ) ) <NEWLINE> S = input ( ) . rstrip ( ) <NEWLINE> rh = RollingHash ( S ) <NEWLINE> ok , ng = 0 , N // 2 + 1 <NEWLINE> while ng - ok > 1 : <NEWLINE> <INDENT> mid = ( ok + ng ) // 2 <NEWLINE> flg = False <NEWLINE> memo = set ( ) <NEWLINE> for i in range ( N - 2 * mid + 1 ) : <NEWLINE> <INDENT> memo . add ( rh . get_hash ( i , i + mid ) ) <NEWLINE> if rh . get_hash ( i + mid , i + 2 * mid ) in memo : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> ok = mid <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ng = mid <COMMENT> <NEWLINE> <DEDENT> <DEDENT> print ( ok ) <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc141_e ( ) <NEWLINE> <DEDENT>
print ( int ( input ( ) ** 3 ) ) <NEWLINE>
N = import ( ) <NEWLINE> output = N * N * N <NEWLINE> print ( output ) <NEWLINE>
print ( ( input ( ) ) ^ 3 ) <NEWLINE>
import itertools <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> print ( sum ( [ 1 for i , j , k in itertools . product ( range ( 1 , N + 1 ) , range ( 1 , N + 1 ) , range ( 1 , N + 1 ) ) ] ) ) <NEWLINE> <DEDENT>
print = ( input ( ) ** 3 ) <NEWLINE>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = [ B [ 0 ] ] <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if B [ i ] > B [ i - 1 ] : <NEWLINE> <INDENT> A . append ( B [ i - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( B [ i ] ) <NEWLINE> <DEDENT> <DEDENT> A . append ( B [ - 1 ] ) <NEWLINE> print ( sum ( A ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> print ( n ** 3 ) <NEWLINE>
print ( int ( input ( ) ** 3 ) ) <NEWLINE>
n = int ( input ) <NEWLINE> print ( n * n * n ) <NEWLINE>
<COMMENT> <NL> from itertools import combination_with_replacement <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> print ( len ( list ( combination_with_replacement ( n , 3 ) ) ) ) <NEWLINE>
N = input ( ) <NEWLINE> print ( N ** 3 ) <NEWLINE>
prnt ( int ( input ( ) ) ** 3 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = sum ( B ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i + 1 ] - A [ i ] == 1 : <NEWLINE> <INDENT> d += B [ A [ i - 1 ] ] <NEWLINE> <DEDENT> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> addans = 0 <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if a [ i - 1 ] + 1 == a [ i ] : <NEWLINE> <INDENT> addans += c [ a [ i - 2 ] ] <NEWLINE> print ( addans ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( b ) + addans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( lambda a : int ( a ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> B = list ( map ( lambda b : int ( b ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> C = list ( map ( lambda c : int ( c ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> satis = 0 <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> satis += B [ A [ i ] ] <NEWLINE> if i >= 1 and A [ i ] - A [ i - 1 ] == 1 : <NEWLINE> <INDENT> satis += C [ i - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( satis ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s += B [ A [ i ] - 1 ] <NEWLINE> if i != 0 and A [ i - 1 ] + 1 == A [ i ] : <NEWLINE> <INDENT> s += C [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p = O <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p += b [ a [ i ] - 1 ] <NEWLINE> if i >= 1 and a [ i ] - a [ i - 1 ] == 1 : <NEWLINE> <INDENT> p += c [ a [ i - 1 ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += B [ A [ i ] - 1 ] <NEWLINE> if ( i >= 1 ) : <NEWLINE> <INDENT> if ( A [ i ] == A [ i - 1 ] + 1 ) : <NEWLINE> <INDENT> ans += C [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> B = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> C = [ int ( input ( ) ) for i in range ( N - 1 ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += B [ A [ i ] - 1 ] <NEWLINE> if i > 0 and A [ i ] - A [ i - 1 ] == 1 : <NEWLINE> <INDENT> ans += C [ A [ i ] - 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> C = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> res += B [ i ] <NEWLINE> if A [ i ] + 1 == A [ i + 1 ] : <NEWLINE> res += C [ A [ i ] - 1 ] <NEWLINE> <DEDENT> print ( res ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> bef = a [ 0 ] - 1 <NEWLINE> man = b [ 0 ] <NEWLINE> <NL> for i in a [ 1 : ] : <NEWLINE> <INDENT> if i - 1 = bef + 1 : <NEWLINE> <INDENT> man += c [ bef ] <NEWLINE> <DEDENT> man += b [ i - 1 ] <NEWLINE> bef = i - 1 <NEWLINE> <DEDENT> print ( man ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = sum ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i + 1 ] - a [ i ] == 1 : <NEWLINE> <INDENT> s += c [ a [ i ] - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( b + s ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> b = Input ( ) <NEWLINE> data = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> data += b [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> data += min ( b [ i ] , b [ i - 1 ] ) <NEWLINE> <DEDENT> data += b [ - 1 ] <NEWLINE> print ( data ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ b [ 0 ] , b [ n - 2 ] ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a . append ( min ( a [ i + 1 ] , a [ i + 2 ] ) ) <NEWLINE> <DEDENT> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ b [ 0 ] ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a . append ( min ( b [ i ] , b [ i + 1 ] ) ) <NEWLINE> <NL> <DEDENT> a . append ( b [ - 1 ] ) <NEWLINE> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> a = [ b [ 0 ] ] <NEWLINE> <NL> for x in range ( n - 1 ) : <NEWLINE> <INDENT> s = min ( b [ x ] , b [ x + 1 ] ) <NEWLINE> a . append ( s ) <NEWLINE> <NL> <DEDENT> a . append ( b [ - 1 ] ) <NEWLINE> <NL> print ( sum ( a ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> bb = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> aa = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> aa [ i ] = max ( a [ i ] , bb [ i ] ) <NEWLINE> aa [ i + 1 ] = max ( a [ i + 1 ] , bb [ i ] ) <NEWLINE> <DEDENT> print ( sum ( aa ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> a [ 0 ] = b [ 0 ] <NEWLINE> a [ n - 1 ] = b [ n - 2 ] <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if b [ i ] >= b [ i - 1 ] : <NEWLINE> <INDENT> a [ i ] = b [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> c += a [ i ] <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <NL> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ 10 ** 8 ] * <COMMENT> <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if dp [ i ] > b [ i ] : <NEWLINE> <INDENT> dp [ i ] = b [ i ] <NEWLINE> <DEDENT> if dp [ i + 1 ] > b [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] = b [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ( dp ) ) <NEWLINE>
input_data = input ( ) . split ( <STRING> ) <NEWLINE> N = int ( input_data [ 0 ] ) <NEWLINE> ls = [ int ( b ) for b in input_data [ 1 ] . split ( ) ] <NEWLINE> if len ( ls ) == 1 : <NEWLINE> <INDENT> print ( ls [ 0 ] * 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first = ls [ 0 ] <NEWLINE> als = [ ls [ 0 ] ] <NEWLINE> <NL> for n in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> als . append ( min ( ls [ n - 1 ] , ls [ n ] ) ) <NEWLINE> <DEDENT> als . append ( ls [ - 1 ] ) <NEWLINE> print ( sum ( als ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> b = list ( map ( in , input ( ) . split ( ) ) ) <NEWLINE> ans = b [ 0 ] + b [ - 1 ] <NEWLINE> for i in range ( n - 2 ) : <NEWLINE> <INDENT> ans += min ( b [ i ] , b [ i - 1 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> <COMMENT> <NL> cnt = 1 <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if S [ i ] != S [ i + 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( N - max ( 1 , cnt - 2 * k ) ) <NEWLINE>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> h = 0 <NEWLINE> for i in range ( len ( S ) - 1 ) : <NEWLINE> <INDENT> if s [ i ] == S [ i + 1 ] : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> <DEDENT> h += 2 * K <NEWLINE> print ( min ( N - 1 , h ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = list ( input ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> tran = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> chk = s [ i ] + s [ i + 1 ] <NEWLINE> <NL> if chk == <STRING> or chk == <STRING> : <NEWLINE> <INDENT> tran += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if k * 2 >= tran : <NEWLINE> <INDENT> print ( n - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( tran + ( k * 2 ) ) <NEWLINE> <DEDENT>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> pre = s [ 0 ] <NEWLINE> rsans = s [ 0 ] <NEWLINE> first = s [ 0 ] <NEWLINE> <NL> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> second = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> second = <STRING> <NEWLINE> <NL> <DEDENT> for i in s [ 1 : ] : <NEWLINE> <INDENT> if i == second and k > 0 : <NEWLINE> <INDENT> ans = ans + first <NEWLINE> pre = i <NEWLINE> <DEDENT> elif i == first and pre == second : <NEWLINE> <INDENT> k -= 1 <NEWLINE> ans = ans + i <NEWLINE> pre = i <NEWLINE> <DEDENT> elif k == 0 : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <DEDENT> elif i == first and pre == first : <NEWLINE> <INDENT> ans = ans + i <NEWLINE> <NL> <DEDENT> <DEDENT> pre = <STRING> <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in ans : <NEWLINE> <INDENT> if i == pre : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> pre = i <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
q_input = input ( ) <NEWLINE> <NL> a , b = map ( int , q_input . split ( <STRING> ) ) <NEWLINE> <NL> ans = int ( ( 10 - 1 + a - 2 ) / ( a - 1 ) ) <NEWLINE> <NL> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> avail = 1 <NEWLINE> <NL> while avail < B : <NEWLINE> <INDENT> avail -= 1 <NEWLINE> count += 1 <NEWLINE> avail = + A <NEWLINE> <NL> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> for i in range ( 3 ) <NEWLINE> ans = 0 <NEWLINE> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
f = inout ( ) <NEWLINE> r = input ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if f [ i ] == r [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> t = input ( ) . split ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> c = 0 <NEWLINE> for i in ( 2 ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
perint ( <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> if s [ 0 ] = t [ 0 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if s [ 1 ] = t [ 1 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if s [ 2 ] = t [ 2 ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = input ( ) . split ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s , t = input ( ) . split ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> A , B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> total_plug = 1 <NEWLINE> for i in range ( 1 , 100 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> total_plug += ( A - 1 ) <NEWLINE> if B <= total_plug : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for in in range ( 3 ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> <NL> ans = 0 <NEWLINE> i = 0 <NEWLINE> while i < len ( s ) : <NEWLINE> <NL> <INDENT> if s [ i ] == t [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
days = list ( str ( input ( ) ) ) <NEWLINE> days_real = list ( str ( input ( ) ) ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if days [ i ] == days_real [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( s ) : <NEWLINE> <INDENT> ans += s [ i ] == t [ i ] <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
S = str ( input ( ) ) <NEWLINE> T = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 3 ) <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> ans = ans + a <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> if a [ i ] = b [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> N = int ( input ( ) ) <NEWLINE> print ( N * ( N - 1 ) / 2 ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
S = input ( ) <NEWLINE> T = input ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == T [ i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> taps = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if taps >= B : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> taps += ( A - 1 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> taps = 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if taps >= B : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> taps += ( A - 1 ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( math . ceil ( ( B - 1 ) / ( A - 1 ) ) ) <NEWLINE>
A , B = map ( int , split ( ) ) <NEWLINE> num = B / A <NEWLINE> <NL> if B == 0 or B == 1 : <NEWLINE> <INDENT> print ( int ( 0 ) ) <NEWLINE> <DEDENT> elif B % A == 0 : <NEWLINE> <INDENT> print ( int ( num ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( int ( num + 1 ) ) <NEWLINE> <DEDENT>
<INDENT> = input ( ) . split ( ) <NEWLINE> <DEDENT> syou = x [ 0 ] / x [ 1 ] <NEWLINE> amari = x [ 0 ] % x [ 1 ] <NEWLINE> <NL> if ( amari > 0 ) : <NEWLINE> <INDENT> print ( syou + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( syou ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b > a : if b % a > 0 : print ( b // a + 1 ) <NEWLINE> elif b <= a : print ( 1 ) <NEWLINE> else : print ( b // a ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans , num = 0 , 1 : <NEWLINE> while num < b : <NEWLINE> <INDENT> num -= 1 <NEWLINE> num += a <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = input2 ( ) <NEWLINE> count = 1 <NEWLINE> <NL> for i in range ( 1 , 21 ) : <NEWLINE> <INDENT> count = count - 1 + a <NEWLINE> if count >= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> int main ( void ) { <NEWLINE> <INDENT> int a , b ; <NEWLINE> cin >> a >> b ; <NEWLINE> int x = 0 ; <NEWLINE> while ( x * ( a - 1 ) + 1 < b ) { <NEWLINE> <INDENT> x + + ; <NEWLINE> <DEDENT> } <NEWLINE> cout << x << endl ; <NEWLINE> <DEDENT> } <NEWLINE>
import math <NEWLINE> a , b = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( math . ceil ( b / a ) ) <NEWLINE> <DEDENT>
g = a - 1 <NEWLINE> d , r = divmod ( b - 1 , g ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d + 1 ) <NEWLINE> <DEDENT>
a , b = map ( input ( ) . split ( <STRING> ) ) <NEWLINE> i = 1 <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> d = ( a - 1 ) * i + 1 <NEWLINE> if d >= b : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
A , B = int ( input ( ) ) <NEWLINE> if ( A % B == 0 ) : <NEWLINE> <INDENT> print ( B / A ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B // A + 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while n * ( a - 1 ) + 1 < b : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> result = 0 <NEWLINE> while result * ( a - 1 ) + 1 > b : <NEWLINE> <INDENT> result + + <NEWLINE> <DEDENT> print ( str ( result ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> now_sum = A <NEWLINE> ans = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if now_sum >= B : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> now_sum += A - 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> answer = 1 <NEWLINE> num = 0 <NEWLINE> while ( answer < b ) : <NEWLINE> <INDENT> anwer += a - 1 <NEWLINE> num += 1 <NEWLINE> <NL> <DEDENT> print ( num ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in rnage ( 0 , b , a - 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> print ( ans + 1 ) <NEWLINE>
import math <NEWLINE> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( mach . ceil ( ( B - 1 ) / ( A - 1 ) ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> a = 0 <NEWLINE> num = 1 <NEWLINE> while num < B : <NEWLINE> <INDENT> num -= 1 <NEWLINE> num += a <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE>
A , B = input ( ) . split ( ) <NEWLINE> import math <NEWLINE> print ( math . ceil ( ( B - 1 ) / A ) ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> return <NEWLINE> <DEDENT> n = ( b - 2 ) / ( a - 1 ) <NEWLINE> print ( n + 1 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = ( ( 1 - b ) // ( a - 1 ) ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( - x ) <NEWLINE>
inputs = input ( ) <NEWLINE> a , b = int ( inputs . split ( <STRING> ) ) <NEWLINE> a * n - ( n - 1 ) >= b <NEWLINE> print ( int ( ( b + 1 ) / ( a - 1 ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> b - 1 = x * ( a - 1 ) <NEWLINE> <NL> if ( b - 1 ) % ( a - 1 ) == 0 : <NEWLINE> <INDENT> print ( ( b - 1 ) // ( a - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ( b - 1 ) // ( a - 1 ) + 1 ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> n = 1 <NEWLINE> while ( a - 1 ) n + 1 <= b : <NEWLINE> <INDENT> n += 1 <NEWLINE> <NL> <DEDENT> print ( n ) <NEWLINE>
def solve ( a , b ) : <NEWLINE> <INDENT> def needTaps ( a , b , holes = 1 , res = 0 ) : <NEWLINE> <INDENT> if holes >= b : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> return needTaps ( a , b , holes + a - 1 , res + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return needTaps ( a , b ) <NEWLINE> <NL> <DEDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( solve ( a , b ) ) <NEWLINE>
<COMMENT> <NL> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> B = B - A <NEWLINE> for i in range ( 20 ) : <NEWLINE> <INDENT> if B <= 0 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break ( ) <NEWLINE> B = B - A + 1 <NEWLINE> <DEDENT> <DEDENT>
n = list ( map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( - ( - n [ 1 ] + 1 ) // ( n [ 0 ] - 1 ) ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> if B == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else if B < A : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( B // ( A - 1 ) ) <NEWLINE> <DEDENT>
m , n = input ( ) . split ( ) <NEWLINE> m , n = int ( m ) , int ( n ) <NEWLINE> <NL> tot = 0 <NEWLINE> a = 1 <NEWLINE> while a < n : <NEWLINE> <INDENT> a -= 1 <NEWLINE> a += m <NEWLINE> tot += 1 <NEWLINE> <NL> <DEDENT> print ( c ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if b == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> b -= a <NEWLINE> elif b % a == 0 : <NEWLINE> <INDENT> print ( b // a + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( b // a + 2 ) <NEWLINE> <DEDENT>
min_tap = 0 <NEWLINE> if B <= A : <NEWLINE> <INDENT> min_tap = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_tap = math . ceil ( ( B - A ) / ( A - 1 ) ) + 1 <NEWLINE> <DEDENT> print ( int ( min_tap ) ) <NEWLINE>
a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> print ( ( b - 0.1 ) // a + 1 ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = [ ] <NEWLINE> for i in range ( len ( H ) - 1 ) : <NEWLINE> <INDENT> count . append ( 0 ) <NEWLINE> if H [ i ] > H [ i + 1 ] : <NEWLINE> <INDENT> count [ i ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> S = str ( count ) . split ( <STRING> ) <NEWLINE> L = map ( len , S ) <NEWLINE> print ( max ( L ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> heights = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt_list = [ ] <NEWLINE> for i in range ( len ( heights ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> if heights [ j ] <= heights [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> cnt_list . append ( cnt ) <NEWLINE> <NL> <DEDENT> cnt_list . sort ( reverse = True ) <NEWLINE> ans = cnt_list [ 0 ] <NEWLINE> <NL> print ( ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , inpu ( ) . split ( ) ) ) <NEWLINE> bef = 99999999999999 <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = A . pop ( ) <NEWLINE> if l > bef : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> if max <= count : <NEWLINE> <INDENT> max = count <NEWLINE> <DEDENT> bef = l <NEWLINE> <DEDENT> print ( max ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> N_List = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxct = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if N_List [ i ] >= N_List [ i + 1 ] : <NEWLINE> <INDENT> ct += 1 <NEWLINE> if ( i == N - 2 ) & ( ct > maxct ) : <NEWLINE> <INDENT> maxct = ct <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if maxct < ct : <NEWLINE> <INDENT> maxct = ct <NEWLINE> ct = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( maxct ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input . split ( <STRING> ) ) ) <NEWLINE> count = 0 <NEWLINE> count2 = count <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if nums [ i ] >= nums [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count2 = max ( [ count , count2 ] ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( max ( [ count , count2 ] ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> H = map ( int , input ( ) . split ( ) ) <NEWLINE> m = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if H [ i ] >= H [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = max ( m , c ) <NEWLINE> c = 0 <NEWLINE> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( reversed ( Input ( ) ) ) <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if h [ i ] <= h [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , count ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> main ( ) <NEWLINE>
input ( ) <NEWLINE> towers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> count = 0 <NEWLINE> for x in range ( len ( towers ) - 1 ) : <NEWLINE> <INDENT> if towers [ x ] >= towers [ x + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( count ) <NEWLINE> count = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans . max ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = map ( int , input ( ) . split ( ) ) <NEWLINE> cur = [ 0 ] * n <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if h [ i ] <= h [ i - 1 ] : <NEWLINE> <INDENT> cur [ i ] = cur [ i - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( cur ) ) <NEWLINE>
xN = int ( input ( ) ) <NEWLINE> H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> cur = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if H [ i ] <= H [ i - 1 ] : <NEWLINE> <INDENT> cur [ i ] = cur [ i - 1 ] + 1 <NEWLINE> <DEDENT> <DEDENT> print ( max ( cur ) ) <NEWLINE>
print ( ( 1 + N ) * ( N / 2 ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> print ( int ( N * ( N - 1 ) // 2 ) <NEWLINE>
from numba import njit <NEWLINE> <NL> @ njit ( cache = True ) <NEWLINE> def f ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = 0 <NEWLINE> for i , j in zip ( range ( 1 , n ) , range ( 2 , n + 1 ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans += i % j <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> r = f ( n ) <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
package main <NEWLINE> <NL> import <STRING> <NEWLINE> <NL> func main ( ) { <NEWLINE> <INDENT> var n int <NEWLINE> fmt . Scan ( & n ) <NEWLINE> <NL> ans : = 0 <NEWLINE> for i : = 1 ; i < n ; i + + { <NEWLINE> <INDENT> ans += i <NEWLINE> <DEDENT> } <NEWLINE> <NL> fmt . Println ( ans ) <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> from typing import Deque , List <NEWLINE> <NL> readline = sys . stdin . buffer . readline <NEWLINE> readlines = sys . stdin . buffer . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( readline ( ) ) <NEWLINE> A : List [ Deque [ int ] ] = [ deque ( ) ] + list ( <NEWLINE> <INDENT> deque ( map ( int , line . split ( ) ) ) for line in readlines ( ) <NEWLINE> <DEDENT> ) <NEWLINE> matched_games_cnt = 0 <NEWLINE> next_games_opponent , last_games_day = [ 0 ] * ( N + 1 ) , [ 0 ] * ( N + 1 ) <NEWLINE> queue = deque ( list ( range ( 1 , N + 1 ) ) ) <NEWLINE> while queue : <NEWLINE> <INDENT> player = queue . popleft ( ) <NEWLINE> if not A [ player ] : <COMMENT> <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> opponent = A [ player ] . popleft ( ) <NEWLINE> <NL> <COMMENT> <NL> if next_games_opponent [ opponent ] != player : <NEWLINE> <INDENT> next_games_opponent [ player ] = opponent <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> matched_games_cnt += 1 <NEWLINE> last_games_day [ player ] = last_games_day [ opponent ] = ( <NEWLINE> <INDENT> max ( last_games_day [ player ] , last_games_day [ opponent ] ) + 1 <NEWLINE> <DEDENT> ) <NEWLINE> <COMMENT> <NL> next_games_opponent [ player ] = next_games_opponent [ opponent ] = 0 <NEWLINE> queue . append ( player ) , queue . append ( opponent ) <NEWLINE> <NL> <DEDENT> print ( max ( last_games_day ) if matched_games_cnt == N * ( N - 1 ) // 2 else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> from typing import List , Optional , Tuple <NEWLINE> <NL> <NL> def cycle_detectable_topological_sort ( <NEWLINE> <INDENT> graph : List [ List [ int ] ] , in_degrees : List [ int ] , first_index : int = 0 <NEWLINE> <DEDENT> ) -> Tuple [ Optional [ List [ int ] ] , Optional [ List [ int ] ] ] : <NEWLINE> <INDENT> <STRING> <NEWLINE> V = len ( graph ) + first_index <NEWLINE> order = [ ] <NEWLINE> depths = [ - 1 ] * V <COMMENT> <NEWLINE> for i in range ( first_index , V ) : <NEWLINE> <INDENT> if not in_degrees [ i ] : <NEWLINE> <INDENT> order . append ( i ) <NEWLINE> depths [ i ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> queue = deque ( order ) <NEWLINE> while queue : <NEWLINE> <INDENT> u = queue . popleft ( ) <NEWLINE> cur_depth = depths [ u ] <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> in_degrees [ v ] -= 1 <NEWLINE> if not in_degrees [ v ] : <NEWLINE> <INDENT> depths [ v ] = max ( depths [ v ] , cur_depth + 1 ) <NEWLINE> queue . append ( v ) , order . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( order , depths ) if len ( order ) + first_index == V else ( None , None ) <NEWLINE> <NL> <NL> <DEDENT> def abc139_e ( ) : <NEWLINE> <INDENT> N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> ids = [ [ - 1 ] * ( N + 1 ) for _ in range ( N + 1 ) ] <NEWLINE> cur_id = 0 <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> ids [ i ] [ j ] = ids [ j ] [ i ] = cur_id <NEWLINE> cur_id += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> graph = [ [ ] for _ in range ( N * ( N - 1 ) // 2 ) ] <NEWLINE> in_degrees = [ 0 ] * ( N * ( N - 1 ) // 2 ) <NEWLINE> for i , a in enumerate ( zip ( * [ iter ( A ) ] * ( N - 1 ) ) , 1 ) : <NEWLINE> <INDENT> prev_id = - 1 <NEWLINE> for j in a : <NEWLINE> <INDENT> cur_id = ids [ i ] [ j ] <NEWLINE> if prev_id != - 1 : <NEWLINE> <INDENT> graph [ prev_id ] . append ( cur_id ) <NEWLINE> in_degrees [ cur_id ] += 1 <NEWLINE> <DEDENT> prev_id = cur_id <NEWLINE> <NL> <DEDENT> <DEDENT> _ , depths = cycle_detectable_topological_sort ( graph , in_degrees , 1 ) <NEWLINE> print ( max ( depths ) + 1 if depths is not None else - 1 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> abc139_e ( ) <NEWLINE> <DEDENT>
m , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> temp = str ( i ) <NEWLINE> if int ( temp [ 0 ] ) >= 2 and int ( temp [ 1 ] ) >= 2 and int ( temp [ 1 ] ) * int ( temp [ 1 ] ) = < m : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> from functools import lru_cache <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> MOD = 10 ** 9 + 7 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> a = set ( [ int ( input ( ) ) for _ in range ( m ) ] ) <NEWLINE> if 1 in a : <NEWLINE> <INDENT> ans = [ 1 , 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = [ 1 , 1 ] <NEWLINE> <NL> <DEDENT> @ lru_cache ( maxsize = None ) <NEWLINE> def cnt ( x ) : <NEWLINE> <INDENT> if x < 2 : <NEWLINE> <INDENT> return ans [ x ] <NEWLINE> <DEDENT> if x in a : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( cnt ( x - 1 ) + cnt ( x - 2 ) ) % MOD <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ( n ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total_1 = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ i ] > a [ j ] : <NEWLINE> <INDENT> total_1 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> total_2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if a [ i ] > a [ j ] : <NEWLINE> <INDENT> total_2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ( total_1 * k + ( total_2 * k * ( k - 1 ) ) // 2 ) % ( 10 ** 9 + 7 ) <NEWLINE>
from collections import Counter <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = Counter ( A ) . most_common ( ) <NEWLINE> <NL> if c [ 0 ] [ 0 ] == <STRING> and c [ 0 ] [ 1 ] == N : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( c ) == 2 and c [ 0 ] [ 1 ] == 2 * N // 3 and c [ 1 ] [ 0 ] == <STRING> and c [ 1 ] [ 1 ] == N // 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( c ) == 3 and int ( c [ 0 ] [ 0 ] ) ^ int ( c [ 1 ] [ 0 ] ) == int ( c [ 2 ] [ 0 ] ) and c [ 0 ] [ 1 ] == c [ 1 ] [ 1 ] and c [ 1 ] [ 1 ] == c [ 2 ] [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = [ 0 ] * N <NEWLINE> ex = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N ) : <NEWLINE> <INDENT> if A [ i ] > A [ j ] : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> if A [ i ] > A [ j ] : <NEWLINE> <INDENT> ex [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ans += cnt [ i ] * ( ( K + 1 ) * K // 2 ) % MOD <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans -= ex [ i ] * K <NEWLINE> <DEDENT> print ( ans % MOD ) <NEWLINE>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> answer = ( s ) <NEWLINE> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> answer = ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( answer ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> S = input ( ) <NEWLINE> <NL> if a = > 3200 : <NEWLINE> <INDENT> print ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , s = input ( ) . split ( ) <NEWLINE> print ( s if int ( a ) < 3200 else <STRING> ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if a >= 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> pint ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ] <NEWLINE> <NL> for x in a : <NEWLINE> <INDENT> b . append ( 1 / x ) <NEWLINE> <NL> <DEDENT> c = sum ( b ) <NEWLINE> ans = 1 / c <NEWLINE> print ( ans ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> <NL> S = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <NL> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> <COMMENT> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
if 3200 <= a : <NEWLINE> <INDENT> print ( input ( s ) ) <NEWLINE> <DEDENT> if a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a < 3200 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , s = map ( int , input ( ) . split ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> s = input ( ) <NEWLINE> <NL> if a >= 3200 : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
X = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> if x >= 3200 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
_ = input ( ) <NEWLINE> print ( 1 / sum [ 1 / r for r in list ( map ( int , input ( ) . split ( ) ) ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum = sum + 1 / a [ i ] <NEWLINE> <DEDENT> print ( 1 / ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> total = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> total += 1 / a <NEWLINE> <DEDENT> print ( 1 / total ) <NEWLINE>
input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> s += 1 / i for i in l <NEWLINE> print ( round ( 1 / s , 3 ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans = ans + 1 / a [ i ] <NEWLINE> <DEDENT> ans = 1 / ans <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A_lis = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in A_lis : <NEWLINE> <INDENT> x += 1 / i <NEWLINE> <DEDENT> ans = 1 / x <NEWLINE> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> res = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for x in res : <NEWLINE> <INDENT> ans += 1 / res <NEWLINE> <DEDENT> print ( 1 / ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> ans += 1 / A [ i ] <NEWLINE> <NL> <DEDENT> print ( 1 / ans ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> for a in A : <NEWLINE> <INDENT> ans += 1 / a <NEWLINE> <DEDENT> print ( 1 / ans <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s += 1 / a <NEWLINE> <DEDENT> print ( 1 / s ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = 0 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S += 1 / i <NEWLINE> <DEDENT> print ( 1 / S ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , a - 1 ) : <NEWLINE> <INDENT> c == c + 1 / b [ i ] <NEWLINE> <DEDENT> print ( 1 / c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> v . sort ( reverse = True ) <NEWLINE> <NL> while len ( v ) > 1 : <NEWLINE> <INDENT> v . append ( ( v . pop ( - 1 ) + v . pop ( - 2 ) ) / 2 ) <NEWLINE> v . sort ( reverse = True ) <NEWLINE> <NL> <DEDENT> print ( v ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> v = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> value = v [ 0 ] <NEWLINE> for in range ( 1 , N ) : <NEWLINE> <INDENT> value = ( value + v [ i ] ) / 2 <NEWLINE> <DEDENT> print ( value ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A = sorted ( A ) <NEWLINE> if N == 2 : <NEWLINE> <INDENT> print ( sum ( A ) / 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = ( A [ 0 ] + A [ 1 ] ) / 2 <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> temp = 1 / 2 * ( A [ i ] + temp ) <NEWLINE> <DEDENT> <DEDENT> print ( temp ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( Input ( ) ) <NEWLINE> while len ( a ) > 1 : <NEWLINE> <INDENT> x , y = a [ 0 ] , a [ 1 ] <NEWLINE> a [ 0 : 2 ] = [ ( x + y ) / 2 ] <NEWLINE> <NL> <DEDENT> return a [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> b = sorted ( a ) <NEWLINE> y = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> y += b [ i - 0 ] * ( 2 ** i ) <NEWLINE> <DEDENT> print ( y // ( 2 ** ( x + 1 ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v . sort ( key = int ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> z = ( v [ i ] + v [ i + 1 ] ) / 2 <NEWLINE> v [ i ] = z <NEWLINE> v [ i + 1 ] = z <NEWLINE> <DEDENT> print ( v [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> v = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ans = v [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> ans = ( ans + v [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from sys import stdin <NEWLINE> nii = lambda : map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> lnii = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> v = lnii ( ) <NEWLINE> v . sort ( ) <NEWLINE> <NL> ans = v [ 0 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> ans = ( ans + v [ i ] ) / 2 <NEWLINE> <NL> <DEDENT> print ( ans <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> <COMMENT> <NL> global tree , point <NEWLINE> <NL> <COMMENT> <NL> def dfs ( v , f ) : <NEWLINE> <INDENT> for next_v in tree [ v ] : <NEWLINE> <INDENT> if next_v == f : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> point [ next_v ] += point [ v ] <NEWLINE> dfs ( next_v , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> tree = [ [ ] for _ in range ( n ) ] <NEWLINE> point = [ 0 ] * n <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ b - 1 ] . append ( a - 1 ) <NEWLINE> tree [ a - 1 ] . append ( b - 1 ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> p = x - 1 <NEWLINE> point [ p ] += x <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 ) <NEWLINE> print ( * point ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> road = [ [ ] for _ in range ( n ) ] <NEWLINE> cnt = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ a - 1 ] . append ( b - 1 ) <NEWLINE> road [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> idx , v = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ idx - 1 ] += v <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * n <NEWLINE> que = deque ( ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> que . append ( 0 ) <NEWLINE> <NL> while ( len ( que ) != 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> v = que . pop ( ) <NEWLINE> for r in road [ v ] : <NEWLINE> <INDENT> if dist [ r ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> dist [ r ] = dist [ v ] + 1 <NEWLINE> cnt [ r ] += cnt [ v ] <NEWLINE> que . append ( r ) <NEWLINE> <DEDENT> <DEDENT> print ( * cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 400000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> score = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <COMMENT> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p ] += x <NEWLINE> <NL> <DEDENT> visited = [ 0 ] * ( N + 1 ) <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] += 1 <NEWLINE> global ans <NEWLINE> ans [ v ] += score [ v ] <NEWLINE> for i in range ( len ( g [ v ] ) ) : <NEWLINE> <INDENT> if visited [ g [ v ] [ i ] ] == 0 : <NEWLINE> <INDENT> ans [ g [ v ] [ i ] ] += ans [ v ] <NEWLINE> dfs ( g [ v ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( 1 ) <NEWLINE> print ( <STRING> . join ( str , map ( ans [ 1 : ] ) ) ) <NEWLINE>
from collections import deque <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> G = [ [ ] * N ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ a - 1 ] . append ( b - 1 ) <NEWLINE> G [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> count = [ 0 ] * N <NEWLINE> for j in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> count [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> visited = [ False ] * N <NEWLINE> que = deque ( [ 0 ] ) <NEWLINE> <NL> while que : <NEWLINE> <INDENT> now = que . pop ( ) <NEWLINE> visited [ now ] = True <NEWLINE> for nxt in G [ now ] : <NEWLINE> <INDENT> if visited [ nxt ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count [ nxt ] += count [ now ] <NEWLINE> que . appendleft ( nxt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * count ) <NEWLINE>
import numpy as np <NEWLINE> import sys <NEWLINE> i4 = np . int32 <NEWLINE> <NL> if sys . argv [ - 1 ] == <STRING> : <NEWLINE> <INDENT> adjacency_list = <STRING> <NEWLINE> import os <NEWLINE> os . makedirs ( <STRING> , exist_ok = True ) <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( adjacency_list ) <NEWLINE> <NL> <DEDENT> abc138_d_numba = <STRING> <NEWLINE> with open ( <STRING> , <STRING> ) as f : <NEWLINE> <INDENT> f . write ( abc138_d_numba ) <NEWLINE> <DEDENT> import subprocess <NEWLINE> cmd = <STRING> <NEWLINE> subprocess . run ( cmd . split ( ) ) <NEWLINE> exit ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> from abc138_d_numba import solve <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> f = open ( 0 ) <NEWLINE> N , Q = [ int ( x ) for x in f . readline ( ) . split ( ) ] <NEWLINE> ap = np . fromstring ( f . read ( ) , i4 , sep = <STRING> ) . reshape ( ( - 1 , 2 ) ) <NEWLINE> a = ap [ : N - 1 ] - 1 <NEWLINE> a = np . concatenate ( ( a , a [ : , : : - 1 ] ) ) <NEWLINE> p = ap [ N - 1 : ] <NEWLINE> val = solve ( a , p , N ) <NEWLINE> print ( * val . tolist ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> road = [ [ ] for _ in range ( n ) ] <NEWLINE> cnt = [ 0 for _ in range ( n ) ] <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> road [ a - 1 ] . append ( b - 1 ) <NEWLINE> road [ b - 1 ] . append ( a - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> idx , v = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt [ idx - 1 ] = v <NEWLINE> <NL> <DEDENT> dist = [ - 1 ] * n <NEWLINE> que = deque ( ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> que . append ( 0 ) <NEWLINE> <NL> while ( len ( que ) != 0 ) : <NEWLINE> <COMMENT> <NL> <INDENT> v = que . pop ( ) <NEWLINE> for r in road [ v ] : <NEWLINE> <INDENT> if dist [ r ] != - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dist [ r ] = dist [ v ] + 1 <NEWLINE> cnt [ r ] += cnt [ v ] <NEWLINE> que . append ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * cnt ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ki = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> ki [ a - 1 ] . append ( b - 1 ) <NEWLINE> ki [ b - 1 ] . append ( a - 1 ) <NEWLINE> <DEDENT> score = [ 0 ] * n <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p - 1 ] += x <NEWLINE> <COMMENT> <NL> <DEDENT> ans = [ 0 ] * n <NEWLINE> <NL> def dfs ( v , p , value ) : <COMMENT> <NEWLINE> <INDENT> value += score ( v ) <NEWLINE> <COMMENT> <NL> ans [ v ] = value <NEWLINE> for i in ki [ v ] : <NEWLINE> <INDENT> if i == p : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( i , v , value ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( * ans ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> tree = [ list ( ) for _ in range ( n ) ] <NEWLINE> score = [ 0 ] * n <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> a -= 1 <NEWLINE> b -= 1 <NEWLINE> tree [ a ] . append ( b ) <NEWLINE> <DEDENT> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> for p , x in px : <NEWLINE> <INDENT> p -= 1 <NEWLINE> add ( p , x , tree , score ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <NL> <DEDENT> def add ( p , x , tree , score ) : <NEWLINE> <INDENT> score [ p ] += x <NEWLINE> s = tree [ p ] [ : ] <NEWLINE> while len ( s ) > 0 : <NEWLINE> <INDENT> t = s . pop ( ) <NEWLINE> score [ t ] += x <NEWLINE> for i in tree [ t ] : <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> <NL> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ab = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n - 1 ) ] <NEWLINE> px = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] <NEWLINE> <NL> graph = [ [ ] for _ in range ( n + 3 ) ] <NEWLINE> for a , b in ab : <NEWLINE> <INDENT> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> value = [ 0 ] * ( n + 1 ) <NEWLINE> for p , x in px : <NEWLINE> <INDENT> value [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v , parent , add ) : <NEWLINE> <INDENT> value [ v ] += add <NEWLINE> for x in graph [ v ] : <NEWLINE> <INDENT> if v == parent : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( x , v , value [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 1 , 0 , 0 ) <NEWLINE> print ( * value [ 1 : ] , end = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 400000 ) <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> score = [ 0 ] * ( n + 1 ) <COMMENT> <NEWLINE> g = [ [ ] for _ in range ( n + 1 ) ] <COMMENT> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> g [ a ] . append ( b ) <NEWLINE> g [ b ] . append ( a ) <NEWLINE> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> score [ p ] += x <NEWLINE> <NL> <DEDENT> visited = [ 0 ] * ( n + 1 ) <NEWLINE> def dfs ( v ) : <NEWLINE> <INDENT> visited [ v ] += 1 <NEWLINE> global ans <NEWLINE> ans [ v ] += score [ v ] <NEWLINE> for i in range ( len ( g [ v ] ) ) : <NEWLINE> <INDENT> ans [ g [ v ] [ i ] ] += ans [ v ] <NEWLINE> dfs ( g [ v ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 1 ) <NEWLINE> print ( <STRING> . join ( map ( str , ans [ 1 : ] ) ) ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> G = [ [ ] for _ in range ( N ) ] <NEWLINE> root = set ( ) <NEWLINE> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> if not ( b in root ) : <NEWLINE> <INDENT> G [ a ] . append ( b ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> G [ b ] . append ( a ) <NEWLINE> <DEDENT> root . add ( b ) <NEWLINE> <NL> <DEDENT> lst = [ ] <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> P , X = map ( int , input ( ) . split ( ) ) <NEWLINE> P -= 1 <NEWLINE> lst . append ( ( P , X ) ) <NEWLINE> <NL> <DEDENT> cnt = [ 0 ] * N <NEWLINE> for p , x in lst : <NEWLINE> <INDENT> cnt [ p ] += x <NEWLINE> <NL> <DEDENT> def dfs ( v ) : <NEWLINE> <COMMENT> <NL> <INDENT> for next_v in G [ v ] : <NEWLINE> <COMMENT> <NL> <INDENT> if seen [ next_v ] == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cnt [ next_v ] += cnt [ v ] <NEWLINE> dfs ( next_v ) <NEWLINE> <DEDENT> <DEDENT> dfs ( 0 ) <NEWLINE> print ( * cnt ) <NEWLINE>
from sys import setrecursionlimit <NEWLINE> <NL> setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( N ) ] <NEWLINE> queries = { p : 0 for p in range ( N ) } <NEWLINE> <NL> for _ in range ( N - 1 ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) - 1 , input ( ) . split ( ) ) <NEWLINE> <NL> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> for _ in range ( Q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> queries [ p - 1 ] += x <NEWLINE> <NL> <DEDENT> answer = [ 0 ] * N <NEWLINE> <NL> def dfs ( p , p_before , acc ) : <NEWLINE> <INDENT> acc += queries [ p ] <NEWLINE> <NL> answer [ p ] = acc <NEWLINE> <NL> for child in graph [ p ] : <NEWLINE> <INDENT> if child == p_before : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> dfs ( child , acc ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( 0 , - 1 , 0 ) <NEWLINE> <NL> print ( * answer ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> a -= 1 <NEWLINE> b -= 1 <NEWLINE> graph [ a ] . append ( b ) <NEWLINE> graph [ b ] . append ( a ) <NEWLINE> <NL> <DEDENT> weight = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> p , x = map ( int , input ( ) . split ( ) ) <NEWLINE> weight [ p - 1 ] = x <NEWLINE> <NL> <DEDENT> st = [ 0 ] <NEWLINE> visit = [ false for i in range ( n ) ] <NEWLINE> while not len ( st ) == 0 : <NEWLINE> <INDENT> now = st . pop ( ) <NEWLINE> visit [ now ] = true <NEWLINE> for e in graph [ now ] : <NEWLINE> <INDENT> if visit [ e ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> weight [ e ] += weight [ e ] <NEWLINE> st . push ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , weight ) ) ) <NEWLINE>
N , * A = map ( int , open ( 0 ) . read ( ) . split ( ) ) <NEWLINE> <NL> A = [ 0 ] + A <NEWLINE> B = [ 0 ] * ( N + 1 ) <NEWLINE> sum_B = 0 <NEWLINE> for i in range ( N , 0 , - 1 ) : <NEWLINE> <INDENT> if sum ( B [ j ] for j in range ( i , N + 1 , i ) ) % 2 != A [ i ] : <NEWLINE> <INDENT> B [ i ] = 1 <NEWLINE> sum_B += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum_B ) <NEWLINE> print ( * [ i for i , b in enumerate ( B ) if b ] ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> i = 0 <NEWLINE> lst = [ ] <NEWLINE> for j in range ( 1 , len ( s ) + 1 ) : <NEWLINE> <INDENT> if lst [ - 1 ] != s [ i : j ] : <NEWLINE> <INDENT> lst . append ( s [ i : j ] ) <NEWLINE> i = j <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( lst ) ) <NEWLINE>
s = input ( ) <NEWLINE> t = s [ 0 ] <NEWLINE> p = 1 <NEWLINE> i = 1 <NEWLINE> while i < len ( s ) : <NEWLINE> <INDENT> if s [ i ] == t : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> t = s [ i - 1 ] <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> print ( p ) <NEWLINE>
A , B = maps ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( max ( A + B , A - B ) , A * B ) ) <NEWLINE>
def Input ( ) : <NEWLINE> <INDENT> return mapt ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a , b = Input ( ) <NEWLINE> return max ( a * b , a - b , a + b ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE>
