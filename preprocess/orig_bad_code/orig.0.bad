l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> l . sort ( reverse = True ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print l [ i ] <NEWLINE> <DEDENT>
first = 0 ; <NEWLINE> second = 0 ; <NEWLINE> third = 0 ; <NEWLINE> for var in range ( 0 , 10 ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> if ( N > first ) : <NEWLINE> <INDENT> third = second <NEWLINE> second = first <NEWLINE> first = N <NEWLINE> <DEDENT> elif ( N > second ) : <NEWLINE> <INDENT> third = second <NEWLINE> second = N <NEWLINE> <DEDENT> elif ( N > third ) : <NEWLINE> <INDENT> third = N <NEWLINE> <DEDENT> <DEDENT> print ( first ) <NEWLINE> print ( second ) <NEWLINE> print ( third ) <NEWLINE>
for i in range ( 10 ) : <NEWLINE> <INDENT> s . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def top_k_sort ( data , k = 3 , reverse = True ) : <NEWLINE> <INDENT> data . sort ( reverse = True ) <NEWLINE> return data [ : k ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> data . append ( int ( line ) ) <NEWLINE> <NL> <DEDENT> data = [ int ( v ) for v in argv [ 1 : ] ] <NEWLINE> for h in top_k_sort ( data ) : <NEWLINE> <INDENT> print ( h ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
height = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> h = raw_input ( ) <NEWLINE> if h == <STRING> : break <NEWLINE> h = int ( h ) <NEWLINE> height . append ( h ) <NEWLINE> <DEDENT> height . sort ( reverse = True ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print height [ i ] <NEWLINE> <DEDENT>
cnt = 10 <NEWLINE> top3 = [ 0 , 0 , 0 ] <NEWLINE> <NL> for x in xrange ( cnt ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> if top3 [ 2 ] > n : continue <NEWLINE> top3 [ 2 ] = n <NEWLINE> <NL> if top3 [ 1 ] > top3 [ 2 ] : continue <NEWLINE> top3 [ 1 ] , top3 [ 2 ] = top3 [ 2 ] , top3 [ 1 ] <NEWLINE> <NL> if top3 [ 0 ] > top3 [ 1 ] : continue <NEWLINE> top3 [ 0 ] , top3 [ 1 ] = top3 [ 1 ] , top3 [ 0 ] <NEWLINE> <NL> <DEDENT> print top [ 0 ] , top [ 1 ] , top [ 2 ] <NEWLINE> <NL>
m = [ int ( l ) for l in input ( ) ] <NEWLINE> m . sort ( ) <NEWLINE> print ( sort [ - 1 ] ) <NEWLINE> print ( sort [ - 2 ] ) <NEWLINE> print ( sort [ - 3 ] ) <NEWLINE>
import sys <NEWLINE> e = sys . stdin . readlines ( ) : <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> m = max ( e ) <NEWLINE> e . remove ( m ) <NEWLINE> print ( m ) <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> l . append ( int ( input ) ) <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
heightOfMountains = [ ] <NEWLINE> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> heightOfMountains . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> heightOfMountains . sort ( ) <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> print ( heightOfMountains [ - j ] ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> while True : <NEWLINE> <DEDENT> except EOFError : <NEWLINE>
array = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> line = int ( input ( ) ) <NEWLINE> array += [ line ] <NEWLINE> <NL> <DEDENT> result = array . sort ( ) [ : : - 1 ] <NEWLINE> <NL> print ( result [ 0 ] ) <NEWLINE> print ( result [ 1 ] ) <NEWLINE> print ( result [ 2 ] ) <NEWLINE>
a = [ int ( input ( ) ) i in range ( 10 ) ] <NEWLINE> a . sort ( ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( a [ 0 : 2 ] ) <NEWLINE>
<INDENT> [ print ( e ) for e in sorted ( [ int ( input ( ) ) for _ in range ( 10 ) ] , reverse = True ) [ 0 : 3 ] ] <NEWLINE> <DEDENT>
mountain = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> mountain [ i ] = int ( input ( ) ) <NEWLINE> <DEDENT> mountain . sort ( ) <NEWLINE> mountain . reverse ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( mountain [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> hills_list = [ ] <NEWLINE> while len ( hills_list ) != 10 : <NEWLINE> <INDENT> hills = raw_input ( ) <NEWLINE> if isinstance ( hills , int ) and ( 10000 >= hills ) and ( hills >= 0 ) : <NEWLINE> <INDENT> hills_list . append ( hills ) <NEWLINE> <DEDENT> <DEDENT> hills_list . sort ( ) <NEWLINE> print hills_list [ 0 ] <NEWLINE> print hills_list [ 1 ] <NEWLINE> print hills_list [ 2 ] <NEWLINE>
from sys import stdin <NEWLINE> <NL> x = [ int ( input ( ) ) for i range ( 10 ) ] <NEWLINE> <NL> x . sort ( reverse = True ) <NEWLINE> <NL> for i in x [ : 3 ] : print ( i ) <NEWLINE>
mountain = [ ] <NEWLINE> for s in range ( 0 , 10 ) : <NEWLINE> <INDENT> mountain . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> mountain . sort ( reverse = true ) <NEWLINE> for s in range ( 0 , 3 ) : <NEWLINE> <INDENT> print ( mountain [ s ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> inputs = [ ] <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> inputs . append ( input ( ) ) <NEWLINE> <DEDENT> inputs . sort ( reverse = True ) <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> print x [ i ] <NEWLINE> <DEDENT>
N = 10 <NEWLINE> A = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> sorted ( A ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( a [ - 1 ] ) <NEWLINE> print ( a [ - 2 ] ) <NEWLINE> print ( a [ - 3 ] ) <NEWLINE>
A = sorted ( [ int ( raw_input ( ) ) for _ in xrange ( 10 ) ] ) <NEWLINE> print A [ 9 ] <NEWLINE> print A [ 8 ] <NEWLINE> Print a [ 7 ] <NEWLINE>
l = [ input ( ) ] * 10 <NEWLINE> for i in l . sort ( reverse = True ) [ : 3 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
x = sorted ( map ( int , input ( ) . split ( ) ) , reverse = True ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT>
a = sorted ( map ( int , input ( ) . split ( <STRING> ) ) , reverse = True ) <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> print ( a [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> array = [ ] <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> array . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> array . sort ( ) <NEWLINE> num = len ( array ) <NEWLINE> for i in range ( num - 1 , num - 4 , - 1 ) : <NEWLINE> <INDENT> print ( array [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def LoT ( List ) : <NEWLINE> <INDENT> T1 = T2 = T3 = List [ 0 ] <NEWLINE> B = 0 <NEWLINE> for i in range ( 1 , len ( List ) ) : <NEWLINE> <INDENT> if List [ i ] > T1 : <NEWLINE> <INDENT> T2 = T1 <NEWLINE> T1 = List [ i ] <NEWLINE> <DEDENT> if List [ i ] < T1 and List [ i ] > T2 : <NEWLINE> <INDENT> T3 = T2 <NEWLINE> T2 = List [ i ] <NEWLINE> <DEDENT> if List [ i ] < T2 and List [ i ] > T3 : <NEWLINE> <INDENT> T3 = List [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( str ( T1 ) + <STRING> + str ( T2 ) + <STRING> + str ( T3 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> List = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> List . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> LoT ( List <NEWLINE> <DEDENT>
import sys <NEWLINE> [ print ( d ) for i , d in enumerate ( [ i for i in sys . stdin ] . reverse ( ) ) if i < 3 ] <NEWLINE>
lst = [ ] <NEWLINE> for n in range ( 10 ) : <NEWLINE> <INDENT> lst . append ( int ( input ( ) ) <NEWLINE> <DEDENT> res = sorted ( lst , reverse = True ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( res [ i ] ) <NEWLINE> <DEDENT>
height = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> height . sort ( ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print height [ 9 - i ] <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> file = sys . argv [ 1 ] <NEWLINE> lis = open ( file , <STRING> ) . readlines ( ) <NEWLINE> lis = map ( int , lis ) <NEWLINE> lis . sort ( ) <NEWLINE> lis . reverse ( ) <NEWLINE> <NL> for height in lis [ 0 : 3 ] : <NEWLINE> <INDENT> print height <NEWLINE> <DEDENT>
moutain = [ 0 for i in range ( 10 ) ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> moutain [ i ] = int ( raw_input ( ) ) <NEWLINE> <DEDENT> moutain . sort ( ) . reverse ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> moutain [ i ] <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> l . sort ( ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( l [ - 1 * [ i + 1 ] ] ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a = [ input ( ) for i in range ( N ) ] <NEWLINE> a . sort ( ) <NEWLINE> print a [ 0 ] , a [ 1 ] , a [ 3 ] <NEWLINE>
n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sorted ( n ) , reverse = True ) [ : 3 ] <NEWLINE>
mt = [ ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> mt . append ( int ( input ( ) . strip ( ) ) ) <NEWLINE> <NL> <DEDENT> mt . sort ( ) . reverse ( ) <NEWLINE> <NL> print ( mt [ 0 ] ) <NEWLINE> print ( mt [ 1 ] ) <NEWLINE> print ( mt [ 2 ] ) <NEWLINE>
inp = input ( ) <NEWLINE> a = [ input ( ) for i in range ( int ( inp ) ) ] <NEWLINE> a . sort ( ) <NEWLINE> a . reverse ( ) <NEWLINE> print ( a [ 0 ] ) <NEWLINE> print ( a [ 1 ] ) <NEWLINE> print ( a [ 2 ] ) <NEWLINE>
m_h = [ int ( input ( I ) for i in range ( 10 ) ] <NEWLINE> <NL> m_h . sort ( reverse = True ) <NEWLINE> <NL> print ( m_h [ 0 ] ) <NEWLINE> print ( m_h [ 1 ] ) <NEWLINE> print ( m_h [ 2 ] ) <NEWLINE>
import sys <NEWLINE> heights = sorted ( [ int ( h ) for h in sys . stdin ] , reverce ) <NEWLINE> heights [ 0 ] <NEWLINE> heights [ 1 ] <NEWLINE> heights [ 2 ] <NEWLINE>
import sys <NEWLINE> mountains = [ int ( line . readline ( ) ) for line in sys . stdin ] <NEWLINE> <NL> for height in sorted ( mountains ) [ - 3 : ] [ : : - 1 ] : <NEWLINE> <INDENT> print ( height ) <NEWLINE> <DEDENT>
print <STRING> . join ( sorted ( [ input ( ) for x in xrange ( 10 ) ] ) [ : 3 ] ) <NEWLINE>
import string <NEWLINE> <NL> count = 0 <NEWLINE> try : <NEWLINE> <INDENT> count += 1 <NEWLINE> h [ count ] = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( h ) ) : <NEWLINE> <INDENT> for j in range ( len ( h ) - 1 ) : <NEWLINE> <INDENT> if int ( h [ i ] ) > int ( h [ j ] ) : <NEWLINE> <INDENT> tmp = h [ i ] <NEWLINE> h [ i ] = h [ j ] <NEWLINE> h [ j ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( h [ 0 ] ) <NEWLINE> print ( h [ 1 ] ) <NEWLINE> print ( h [ 2 ] ) <NEWLINE>
a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> inputNum = int ( raw_input ( ) ) <NEWLINE> <NL> if a < inputNum : <NEWLINE> <INDENT> a = inputNum <NEWLINE> continue <NEWLINE> <DEDENT> elif b < inputNum : <NEWLINE> <INDENT> b = inputNum <NEWLINE> continue <NEWLINE> <DEDENT> elif c < inputNum : <NEWLINE> <INDENT> c = inputNum <NEWLINE> <NL> <DEDENT> <DEDENT> print a <NEWLINE> print b <NEWLINE> print c <NEWLINE>
lis = [ ] <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> lis . append ( input ( ) ) <NEWLINE> <DEDENT> for a in sorted ( lis , reversed = True ) [ : 3 ] : <NEWLINE> <INDENT> print a <NEWLINE> <DEDENT>
x = [ ] <NEWLINE> a = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if a != 10 : <NEWLINE> <INDENT> x . append ( int ( raw_input ( ) ) ) <NEWLINE> a += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> x . sort ( ) <NEWLINE> print x [ 9 ] <NEWLINE> print x [ 8 ] <NEWLINE> print x [ 7 ] <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> array = [ ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> array [ i ] = raw_input ( ) <NEWLINE> <NL> <DEDENT> for j in range ( 3 ) : <NEWLINE> <INDENT> print max ( array ) + <STRING> <NEWLINE> array . remove ( max ( array ) ) <NEWLINE> <NL> <DEDENT> sys . exit ( ) <NEWLINE>
mountains_high = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> mountains_high . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> mountains_high_copy = mountains_high . copy ( ) <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> for j in range ( 9 ) : <NEWLINE> <INDENT> if mountains_high_copy [ j ] > mountains_high_copy [ j + 1 ] : <NEWLINE> <INDENT> num = mountains_high_copy [ j ] <NEWLINE> mountains_high_copy [ j ] = mountains_high_copy [ j + 1 ] <NEWLINE> mountains_high_copy [ j + 1 ] = num <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( mountains_high_copy [ 9 - i <NEWLINE> <DEDENT>
list = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> list . append ( input ( ) ) <NEWLINE> <DEDENT> list . sort ( reverse = true ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print list [ i ] <NEWLINE> <DEDENT>
map ( print , [ int ( n ) for n in stdin ] . sort ( reverse = True ) [ 0 : 3 ] ) <NEWLINE>
num = [ int ( input ( ) ) for i in range ( 10 ) ] <NEWLINE> num . sort ( reverse = True ) <NEWLINE> for i in range [ 0 : 3 ] : <NEWLINE> <INDENT> print ( num [ i ] ) <NEWLINE> <DEDENT>
n = 0 <NEWLINE> list = [ ] <NEWLINE> while n < 10 : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> list . append ( x ) <NEWLINE> n += 1 <NEWLINE> <NL> <DEDENT> sort . list ( ) <NEWLINE> print ( list [ 7 ] ) <NEWLINE> print ( list [ 8 ] ) <NEWLINE> print ( list [ 9 ] ) <NEWLINE>
import sys <NEWLINE> <NL> <COMMENT> <NL> <NL> i = 0 <NEWLINE> list = [ ] <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> list . append ( int ( line . strip ( <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> print soted ( list , reverse = True ) [ 0 ] <NEWLINE> print soted ( list , reverse = True ) [ 1 ] <NEWLINE> print soted ( list , reverse = True ) [ 2 ] <NEWLINE>
list [ ] <NEWLINE> for i range ( 0 , 10 ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> list . append ( n ) <NEWLINE> <DEDENT> list . sort ( reverse = True ) <NEWLINE> for i in range ( 0 , 3 ) : <NEWLINE> <INDENT> print list [ i ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> List = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> List . append ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> List . sort ( reverse = True ) <NEWLINE> print ( List [ 0 ] ) <NEWLINE> print ( List [ 1 ] ) <NEWLINE> print ( List [ 2 ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> l . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> l . sort ( ) . reversed ( ) <NEWLINE> print ( l [ 0 ] ) <NEWLINE> print ( l [ 1 ] ) <NEWLINE> print ( l [ 2 ] ) <NEWLINE>
l = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> l . append ( int ( inp . rstrip ( ) ) ) <NEWLINE> <DEDENT> l . sort ( ) . reverse ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( l [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> mt = sys . stdin . strip ( ) . split ( ) <NEWLINE> mt = sorted ( [ int ( i ) for i in mt ] ) <NEWLINE> print <STRING> . join ( mt [ : 3 ] ) <NEWLINE>
heights = list ( ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> heights . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for height in reversed ( sorted ( heights ) ) [ : 3 ] : <NEWLINE> <INDENT> print ( height ) <NEWLINE> <DEDENT>
height = [ ] <NEWLINE> inp = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if inp == <STRING> : break <NEWLINE> else : height . append ( int ( inp ) ) <NEWLINE> <NL> <DEDENT> height . sort ( reverse = True ) <NEWLINE> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> print ( str ( height [ j ] ) ) <NEWLINE> <DEDENT>
l = [ a , b , c , d , e , f , g , h , i , j ] <NEWLINE> a , b , c , d , e , f , g , h , i , j = int ( input ( ) ) <NEWLINE> l . sort ( ) <NEWLINE> print ( l [ - 1 ] ) <NEWLINE> print ( l [ - 2 ] ) <NEWLINE> print ( l [ - 3 ] ) <NEWLINE>
m = [ 1819 , 2003 , 876 , 2840 , 1723 , 1673 , 3776 , 2848 , 1592 , 922 ] <NEWLINE> m . sort ( ) . reverse ( ) <NEWLINE> print m [ 0 | 2 ] <NEWLINE>
import sys <NEWLINE> <NL> in_ = sys . argv [ 1 ] <NEWLINE> with open ( in_ , <STRING> ) as f : <NEWLINE> <INDENT> lis = [ ] <NEWLINE> for line in f : <NEWLINE> <INDENT> line = line . strip ( ) <NEWLINE> lis . append ( line ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in sorted ( lis , reverse = True ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> if i == 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> heights = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> heights . append ( int ( line . rstrip ( <STRING> ) ) ) <NEWLINE> <DEDENT> for height in heights . sort ( ) [ : 3 ] : <NEWLINE> <INDENT> print height <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> x = [ int ( input ( ) ) for i in range ( 10 ) ] <NEWLINE> x . sort ( ) . reverse ( ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
height = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> height . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> most = max ( height ) <NEWLINE> print ( most ) <NEWLINE> height [ index ( most ) ] = 0 <NEWLINE> <DEDENT>
data = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> data = sorted ( data ) <NEWLINE> data . reverse ( ) <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> print data [ i ] <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> b = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> j = 0 <NEWLINE> while j < 3 : <NEWLINE> <INDENT> if i > b [ j ] : <NEWLINE> <INDENT> b . insert ( j , i ) <NEWLINE> break <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in b [ : 3 ] : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
import sys <NEWLINE> mt_heigts = map ( int , sys . stdin . readlines ( ) ) <NEWLINE> mt_heigts . sort ( reverse = True ) <NEWLINE> for height in mt_heights [ : 3 ] : <NEWLINE> <INDENT> print height <NEWLINE> <DEDENT>
a = [ 0 for i in range ( 10 ) ] <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> a [ i ] = int ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> a . sort ( ) . reverse ( ) <NEWLINE> <NL> print a [ 0 ] <NEWLINE> print a [ 1 ] <NEWLINE> print a [ 2 ] <NEWLINE>
import sys <NEWLINE> <NL> heights = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> heights . append ( int ( line . strip ( ) ) <NEWLINE> <NL> <DEDENT> for height in sorted ( heights , reverse = True ) [ : 3 ] : <NEWLINE> <INDENT> print height <NEWLINE> <NL> <DEDENT> sys . exit ( 0 ) <NEWLINE>
import sys <NEWLINE> <NL> input_list = list ( ) <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> input_list . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> for i in sorted ( input_list , reversed = True ) [ : 3 ] : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
result = [ 0 , 0 , 0 ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> inp = int ( raw_input ( ) ) <NEWLINE> if result [ 2 ] >= inp : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif result [ 1 ] <= inp < result [ 2 ] : <NEWLINE> <INDENT> result [ 2 ] = inp <NEWLINE> <DEDENT> elif result [ 0 ] <= inp < result [ 1 ] : <NEWLINE> <INDENT> result [ 2 ] = result [ 1 ] <NEWLINE> result [ 1 ] = inp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ 2 ] = result [ 1 ] <NEWLINE> result [ 1 ] = result [ 0 ] <NEWLINE> result [ 0 ] = inp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in reange ( 3 ) : <NEWLINE> <INDENT> print result [ i ] <NEWLINE> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( a , reverse = True ) <NEWLINE> print ( b [ 0 ] ) <NEWLINE> print ( b [ 1 ] ) <NEWLINE> print ( b [ 2 ] ) <NEWLINE>
<COMMENT> <NL> <NL> import codecs <NEWLINE> import sys <NEWLINE> <NL> sys . stdout = codecs . getwriter ( <STRING> ) ( sys . stdout ) <COMMENT> <NEWLINE> sys . stdin = codecs . getreader ( <STRING> ) ( sys . stdin ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a . append ( n ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> a . sort ( ) <NEWLINE> a . reverse ( ) <NEWLINE> <NL> print a [ 0 ] <NEWLINE> print a [ 1 ] <NEWLINE> print a [ 2 ] <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> number = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> number . append ( num ) <NEWLINE> <NL> <NL> <DEDENT> numbers = number . sorted ( number ) <NEWLINE> print ( numbers [ 9 ] ) <NEWLINE> print ( numbers [ 8 ] ) <NEWLINE> print ( numbers [ 7 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> x = [ int ( input ( ) ) for i range ( 10 ) ] <NEWLINE> <NL> x . sort ( reverse = True ) <NEWLINE> <NL> for i in x [ : 3 ] : print ( i ) <NEWLINE>
nums = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> if not n : break <NEWLINE> nums . append ( int ( n ) ) <NEWLINE> <DEDENT> nums . sort ( reverse = True ) <NEWLINE> for i in range ( 3 ) : print nums [ i ] <NEWLINE>
height_list = [ int ( input ( ) ) for i in range ( 10 ) ] <NEWLINE> for i in range ( 1 , 4 ) : print sorted ( height_list ) [ - i ] <NEWLINE>
a = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> a = a . sort ( reverse = True ) <NEWLINE> for i in a [ 0 : 2 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
map ( lambda x : print x , sorted ( map ( lambda _ : int ( raw_input ( ) ) , range ( 10 ) ) , reverse = True ) [ : 3 ] ) <NEWLINE>
while ( 1 ) : <NEWLINE> <INDENT> n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( len ( n ) == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = n [ 0 ] <NEWLINE> b = n [ 1 ] <NEWLINE> count = 1 <NEWLINE> n = 10 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> if ( ( a + b ) / n > 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> n = n * 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> print <STRING> . join ( [ len ( str ( sum ( [ int ( x ) for x in l . split ( <STRING> ) ] ) ) ) for l in sys . stdin ] ) <NEWLINE>
import sys <NEWLINE> for i in sys . stdin : print len ( list ( str ( sum ( map ( int , raw_input ( ) . split ( ) ) ) ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> list = str ( raw_input ( ) ) . split ( ) <NEWLINE> x = int ( list [ 0 ] ) + int ( list [ 1 ] ) <NEWLINE> print <STRING> % len ( str ( x ) ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> nums = [ ] <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums . append ( [ int ( item ) for item in line . split ( <STRING> ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for n in nums : <NEWLINE> <INDENT> sum = n [ 0 ] + n [ 1 ] <NEWLINE> print ( len ( str ( sum ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> c = a + b <NEWLINE> <NL> if c == 0 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <NL> while c > 0 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> c //= 10 <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
values = [ ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> values . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> if [ ] == values [ i ] and 0 == len ( values [ i ] ) : <NEWLINE> <INDENT> values . pop ( ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> digit = 0 <NEWLINE> for x , y in values : <NEWLINE> <INDENT> sum = x + y <NEWLINE> digit = 0 <NEWLINE> while sum >= 1 : <NEWLINE> <INDENT> sum //= 10 <NEWLINE> digit += 1 <NEWLINE> <DEDENT> print ( digit ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = [ ] <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> a . append ( map ( int , i . split ( ) ) ) <NEWLINE> <DEDENT> for i in a : <NEWLINE> <INDENT> print ( str ( len ( str ( i [ 0 ] + a [ 1 ] ) ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> rig = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> ke = rig [ 0 ] + rig [ 1 ] <NEWLINE> ans = 1 <NEWLINE> count = 10 <NEWLINE> while True : <NEWLINE> <INDENT> if ke < count : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 1 <NEWLINE> count = count * 10 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> while ( True ) : <NEWLINE> <INDENT> date = input ( ) <NEWLINE> date = date . split ( ) <NEWLINE> date = int ( date [ 0 ] ) + int ( date [ 1 ] ) <NEWLINE> digit = int ( math . log10 ( date ) ) <NEWLINE> print ( digit ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> s = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> t = raw_input ( ) <NEWLINE> s . append ( t ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> a = int ( s [ i ] . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( s [ i ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , s . split ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import codecs <NEWLINE> import sys <NEWLINE> <NL> sys . stdout = codecs . getwriter ( <STRING> ) ( sys . stdout ) <COMMENT> <NEWLINE> sys . stdin = codecs . getreader ( <STRING> ) ( sys . stdin ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> DEBUG = 0 <NEWLINE> <NL> if DEBUG == 0 : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for i in range ( 200 ) : <NEWLINE> <INDENT> deglist = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> a . append ( deglist ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = [ [ 5 , 7 ] , [ 1 , 99 ] , [ 1000 , 999 ] ] <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> wa = a [ i ] [ 0 ] + a [ i ] [ 1 ] <NEWLINE> print len ( str ( wa ) ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
for x in range ( 200 ) : <NEWLINE> <INDENT> print ( len ( str ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) ) <NEWLINE> <NL> <DEDENT>
l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> while ( l != [ ] ) : <NEWLINE> <INDENT> length = len ( str ( l [ 0 ] + l [ 1 ] ) ) <NEWLINE> print ( length ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def keta ( x ) : <NEWLINE> <INDENT> return len ( str ( x ) ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> a , b = [ int ( i ) for i in t . split ( <STRING> ) ] <NEWLINE> print ( keta ( a + b ) ) <NEWLINE> <DEDENT>
for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> array = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> array . append ( line ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( array ) : <NEWLINE> <INDENT> num = array [ i ] . sprit ( <STRING> ) <NEWLINE> a = num [ 0 ] <NEWLINE> b = num [ 1 ] <NEWLINE> n = a + b <NEWLINE> print ( int ( math . log10 ( x ) + 1 ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
While True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( len ( str ( sum ( list ( map ( int , input ( ) . split ( ) ) ) ) ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> print len ( N + M ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for e in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> print ( len ( sum ( map ( int , e . split ( ) ) ) ) ) <NEWLINE> <DEDENT>
height = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> height . append ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> height . sort ( reverse = True ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> print height [ i ] <NEWLINE> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> for i in range ( 200 ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if len ( a ) == 0 : break <NEWLINE> absum = a [ 0 ] + a [ 1 ] <NEWLINE> for j in range ( 1 , 8 ) : <NEWLINE> <INDENT> if absum < 10 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif int ( absum / pow ( 10 , j ) ) == 1 : <NEWLINE> <INDENT> print ( j + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
A = [ ] <NEWLINE> B = [ ] <NEWLINE> s = True <NEWLINE> while ( s ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A . append ( a ) <NEWLINE> B . append ( b ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> sum = A [ i ] + B [ i ] <NEWLINE> digits = 1 <NEWLINE> while ( sum // 10 != 0 ) : <NEWLINE> <INDENT> digits += 1 <NEWLINE> sum //= 10 <NEWLINE> <DEDENT> print ( str ( digits ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> inl = i . split ( ) <NEWLINE> a = inl [ 0 ] + inl [ 1 ] <NEWLINE> time = 0 <NEWLINE> for n in a <NEWLINE> <INDENT> time += 1 <NEWLINE> <DEDENT> print tie <NEWLINE> <DEDENT>
str = input ( ) <NEWLINE> l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> l . append ( str ) <NEWLINE> str = input ( ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> numl = l [ i ] . split ( <STRING> ) <NEWLINE> a = int ( numl [ 0 ] ) <NEWLINE> b = int ( numl [ 1 ] ) <NEWLINE> sum = a + b <NEWLINE> digitstr = <STRING> . format ( sum ) <NEWLINE> print ( len ( digitstr ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin <NEWLINE> <INDENT> n = map ( int , line . split ( ) ) <NEWLINE> a = n [ 0 ] + n [ 1 ] <NEWLINE> print len ( str ( a ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> a = int ( n [ 0 ] ) <NEWLINE> b = int ( n [ 1 ] ) <NEWLINE> ans = int ( math . log10 ( a + b ) + 1 ) <NEWLINE> data . append ( ans ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in data : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input . split ( <STRING> ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <NL> <DEDENT> expect : break <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print int ( math . log10 ( a + b ) + 1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = input ( ) . split ( <STRING> ) <NEWLINE> num = int ( s [ 0 ] ) + int ( s [ 1 ] ) <NEWLINE> print ( len ( str ( num ) ) ) <NEWLINE> <DEDENT> escept : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> print len ( str ( a + b ) ) <NEWLINE> <DEDENT> <DEDENT>
for var in range ( 1 , 2001 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a + b <NEWLINE> c = str ( c ) <NEWLINE> print ( len ( c ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> input_lines = sys . stdin . readlines ( ) <NEWLINE> for line in input_lines : <NEWLINE> <INDENT> x = [ int ( i ) for i in line ] <NEWLINE> print ( len ( str ( x [ 0 ] + x [ 1 ] ) ) ) <NEWLINE> <DEDENT>
while a , b = ( int ( x ) for x in input ( ) . split ( ) ) : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> inp = raw_input ( ) <NEWLINE> if inp == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i = map ( int , inp . split ( ) ) <NEWLINE> a = i [ 0 ] <NEWLINE> b = i [ 1 ] <NEWLINE> <NL> s = a + b <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> while s >= 1 : <NEWLINE> <INDENT> s /= 10 <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> numbers = [ ] <NEWLINE> for line in open ( <STRING> ) : <NEWLINE> <INDENT> numbers . append ( line . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( numbers ) ) : <NEWLINE> <INDENT> sum = int ( numbers [ i ] [ 0 ] ) + int ( numbers [ i ] [ 1 ] ) <NEWLINE> print int ( math . log10 ( float ( sum ) ) ) + 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> for e in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> print ( len ( str ( sum ( map ( int , e . split ( ) ) ) ) ) <NEWLINE> <DEDENT>
for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> c = a + b <NEWLINE> c = str ( c ) <NEWLINE> print ( len ( c ) ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> while a != None : <NEWLINE> <INDENT> b = map ( int , a . split ( ) ) <NEWLINE> print ( len ( str ( sum ( b ) ) ) ) <NEWLINE> a = input ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = [ int ( n ) for n in line ] <NEWLINE> ret = a + b <NEWLINE> print len ( str ( ret ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT> except EOFError : break <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> print ( len ( str ( abs ( sum ( map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) ) ) ) ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> while t == 0 : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = int ( math . log10 ( x + y ) + 1 ) <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
import sys , math <NEWLINE> for i in sys . stdin . realines ( ) : <NEWLINE> <INDENT> if not i . strip ( ) : break <NEWLINE> a , b = map ( int , i . split ( ) ) <NEWLINE> print int ( math . log10 ( a + b ) ) + 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> n = a + b <NEWLINE> ans = 1 <NEWLINE> while ( n >= 10 ) : <NEWLINE> <INDENT> n /= 10 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
import sys . stdin . readlines <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
res = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in s . split ( ) ] <NEWLINE> res . append ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for n in res : <NEWLINE> <INDENT> print ( len ( str ( n ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( <STRING> ) ) <NEWLINE> print int ( math . log10 ( a + b ) + 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> while ( True ) : <NEWLINE> <INDENT> b = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> if ( b == [ <STRING> ] ) : break <NEWLINE> <COMMENT> <NL> c = 1 <NEWLINE> d = b [ 0 ] + b [ 1 ] <NEWLINE> while ( d >= 10 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> d = d / 10 <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> for i in range ( 200 ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = a + b <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> input_line = raw_input ( ) <NEWLINE> num1 = int ( input_line . split ( <STRING> ) [ 0 ] ) <NEWLINE> num2 = int ( input_line . split ( <STRING> ) [ 1 ] ) <NEWLINE> <NL> sum = str ( num1 + num2 ) <NEWLINE> <NL> count = 0 <NEWLINE> for num in sum : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> temp = a . split ( ) <NEWLINE> x = int ( temp [ 0 ] ) + int ( temp [ 1 ] ) <NEWLINE> <NL> c = str ( x ) <NEWLINE> print len ( c ) <NEWLINE> <DEDENT>
import math <NEWLINE> print ( int ( math . log10 ( int ( input ( ) ) + 1 ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> sum = str ( a + b ) <NEWLINE> print ( len ( sum ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> lst = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> lst . append ( int ( math . log ( 10 , a + b ) ) + 1 ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> for i in lst : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( line ) <NEWLINE> <NL> <DEDENT> for n in a : <NEWLINE> <INDENT> inl = n . split ( ) <NEWLINE> num = int ( inl [ 0 ] ) + int ( inl [ 1 ] ) <NEWLINE> l = list ( str ( num ) ) <NEWLINE> time = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> time += 1 <NEWLINE> <DEDENT> print time <NEWLINE> <DEDENT>
def counts ( num ) : <NEWLINE> <INDENT> if num : counts ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> if num : countlist . append ( len ( str ( num [ 0 ] + num [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> countlist = [ ] <NEWLINE> counts ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> countlist . reverse ( ) <NEWLINE> for x in countlist : <NEWLINE> <INDENT> print x <NEWLINE> <DEDENT>
from math import log10 as log <NEWLINE> A = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> try : <NEWLINE> <INDENT> A . append ( int ( log ( S [ 0 ] + S [ 1 ] ) + 1 ) ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in A : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def digits ( n ) : <NEWLINE> <INDENT> if n < 10 : return 1 <NEWLINE> c = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> n = n // 10 <NEWLINE> <NL> <DEDENT> return c <NEWLINE> <NL> <DEDENT> inp = input ( ) <NEWLINE> while ( inp != <STRING> ) : <NEWLINE> <INDENT> n , m = inp . split ( <STRING> ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> print ( digits ( n + m ) ) <NEWLINE> inp = input ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for jk in sys . stdin : <NEWLINE> <INDENT> j , k = map ( int , jk . split ( ) ) <NEWLINE> print len ( j + k ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> def Dnum ( ) : <NEWLINE> <NL> <INDENT> str = <STRING> <NEWLINE> while ( str != <STRING> ) : <NEWLINE> <INDENT> str = sys . stdin . readline ( ) <NEWLINE> cnt = 0 <NEWLINE> list = str . split ( <STRING> ) <NEWLINE> num = int ( list [ 0 ] ) + int ( list [ 1 ] ) <NEWLINE> while ( num >= 1 ) : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> num = num / 10 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> Dnum ( ) <NEWLINE>
judge = True <NEWLINE> while judge : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a != None : <NEWLINE> <INDENT> c = a + b <NEWLINE> print ( len ( str ( c ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge = False <NEWLINE> <DEDENT> <DEDENT>
try : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> lines . append ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> for i in range ( len ( lines ) ) : <NEWLINE> <INDENT> sums = lines [ i ] [ 0 ] + lines [ i ] [ 1 ] <NEWLINE> print ( len ( str ( sums ) ) ) <NEWLINE> <DEDENT> <DEDENT>
try : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> k = int ( x ) + int ( y ) <NEWLINE> print ( len ( str ( k ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> for x in sys . stdin . read ( ) . split ( ) : <NEWLINE> <INDENT> print len ( str ( x [ 0 ] + x [ 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = int ( a ) + int ( b ) <NEWLINE> d = 1 <NEWLINE> while ( int ( c / 10 ) != 0 ) : <NEWLINE> <INDENT> d += 1 <NEWLINE> c = int ( c / 10 ) <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> str = input ( ) <NEWLINE> if str == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = 1 <NEWLINE> a , b = str . split ( <STRING> ) <NEWLINE> s = int ( a ) + int ( b ) <NEWLINE> while s > 9 : <NEWLINE> <INDENT> s = s / 10 <NEWLINE> d = d + 1 <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> digit = ( a + b ) <NEWLINE> digit2 = str ( digit ) <NEWLINE> print ( len ( digit2 ) ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( math . log10 ( a + b , 10 ) ) + 1 ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ( a , b ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = a + b <NEWLINE> i = 0 <NEWLINE> while c != 0 : <NEWLINE> <INDENT> c /= 10 <NEWLINE> i += 1 <NEWLINE> <DEDENT> print i <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> pass : <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = str ( int ( a ) + int ( b ) ) <NEWLINE> print ( len ( c ) ) <NEWLINE>
print len ( str ( int ( raw_input ( ) ) + int ( raw_input ( ) ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = list ( str ( m + n ) ) <NEWLINE> print len ( a ) <NEWLINE> except : <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <NL> <DEDENT> expect : break <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> sum = input ( ) <NEWLINE> sum_list = sum . split ( <STRING> ) <NEWLINE> print ( len ( str ( int ( sum_list [ 0 ] ) + int ( sum_list [ 1 ] ) ) ) ) <NEWLINE> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import sys <NEWLINE> import re <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> for line in sys . stdin : <NEWLINE> <INDENT> ab = map ( ( int , re . split ( <STRING> , line ) ) <NEWLINE> answer = reduce ( ( lambda x , y : x + y ) , ab , 0 ) <NEWLINE> digits = len ( str ( answer ) ) <NEWLINE> print digits <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( int ( math . log10 ( x + y ) ) + 1 ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = str ( a + b ) <NEWLINE> print len ( c ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l1 = [ int ( i ) for i in l ] <NEWLINE> sum = ( l1 [ 0 ] + l1 [ 1 ] ) <NEWLINE> print ( int ( math . log10 ( sum ) + 1 ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> while True : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> b = a [ 0 ] + a [ 1 ] <NEWLINE> print int ( math . log10 ( b ) + 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = [ print ( len ( sum ( map ( int , line . split ( ) ) ) ) ) for line in sys . stdin ] <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print int ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> except EOFerror : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> print len ( int ( s . rstrip ( ) . split ( ) [ 0 ] ) + int ( s . rstrip ( ) . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = ( int ( i ) for i in input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> words = line . strip ( ) . split ( <STRING> ) <NEWLINE> a = int ( words [ 0 ] ) <NEWLINE> b = int ( words [ 1 ] ) <NEWLINE> <NL> if a == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = int ( 1.0 + math . log ( a [ 0 ] , 10 ) ) <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = int ( 1.0 + math . log ( b [ 1 ] , 10 ) ) <NEWLINE> <DEDENT> print ( a + b ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def plus_and_check ( lines ) : <NEWLINE> c , d = lines . split ( ) <NEWLINE> number = c + d <NEWLINE> return len ( str ( number ) ) <NEWLINE> <NL> a = [ ] <NEWLINE> answer = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( int ( line ) ) <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> while i < len ( a ) - 1 : <NEWLINE> <INDENT> answer = plus_and_check ( a [ i ] ) <NEWLINE> <NL> <DEDENT> j = 0 <NEWLINE> while j < len ( answer ) - 1 : <NEWLINE> <INDENT> print answer [ i ] <NEWLINE> <DEDENT>
import math <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print int ( math . log10 ( a + b ) + 1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = raw_input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> print len ( str ( int ( a ) + int ( b ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a + b <NEWLINE> ans = 0 <NEWLINE> if c >= 0 and c <= 9 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> if c >= 10 and c <= 99 : <NEWLINE> <INDENT> ans = 2 <NEWLINE> <DEDENT> if c >= 100 and c <= 999 : <NEWLINE> <INDENT> ans = 3 <NEWLINE> <DEDENT> if c >= 1000 and c <= 9999 : <NEWLINE> <INDENT> ans = 4 <NEWLINE> <DEDENT> if c >= 10000 and c <= 99999 : <NEWLINE> <INDENT> ans = 5 <NEWLINE> <DEDENT> if c >= 100000 and c <= 999999 : <NEWLINE> <INDENT> ans = 6 <NEWLINE> <DEDENT> if c >= 1000000 and c <= 9999999 : <NEWLINE> <INDENT> ans = 7 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> x = a + b <NEWLINE> print ( int ( math . log10 ( x ) ) + 1 ) <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> i = input ( ) <NEWLINE> if not i : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( len ( str ( sum ( map ( int , i . split ( ) ) ) ) ) ) <NEWLINE> <DEDENT>
for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT>
for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> print ( int ( math . log ( a + b , 10 ) // 1 + 1 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> dn = lambda a , b : len ( str ( a + b ) ) <NEWLINE> get = lambda : [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> print <STRING> % dn ( * get ( ) ) <NEWLINE> <DEDENT> <DEDENT>
import os <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> s = sum ( [ int ( num ) for num in line . split ( <STRING> ) ] ) <NEWLINE> print ( len ( str ( s ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> nums = raw_input ( ) <NEWLINE> if nums != <STRING> : <NEWLINE> <INDENT> x = map ( int , nums . split ( <STRING> ) ) <NEWLINE> a = int ( math . log10 ( x [ 0 ] + x [ 1 ] ) + 1 ) <NEWLINE> print a <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> : break <NEWLINE> a , b = ( int ( i ) for i in line . split ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> for line in sys . stdin . readLines ( ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> import math <NEWLINE> <NL> lines = [ line for line in stdin ] <NEWLINE> <NL> for line in lines : <NEWLINE> <INDENT> a , b = [ float ( n ) for n in line ] <NEWLINE> print ( math . floor ( math . log10 ( a + b ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , b = map ( int , line . rstrip ( ) . split ( ) ) <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a == 0 and b == 0 ) : break <NEWLINE> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT>
<NL> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> nums = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> ans = nums [ 0 ] + nums [ 1 ] <NEWLINE> <NL> x = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( 10 ** x - 1 ) < ans < 10 ** ( x + 1 ) : <NEWLINE> <INDENT> print x + 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except EOFerror : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> s = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> s . append ( raw_input ( ) ) <NEWLINE> if s [ - 1 ] == <STRING> : <NEWLINE> <INDENT> s . remove ( <STRING> ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> a , b = map ( int , i . split ( <STRING> ) ) <NEWLINE> print len ( str ( a + b ) ) <NEWLINE> <NL> <DEDENT> <STRING> <NEWLINE>
num = int ( input ( ) ) + int ( input ( ) ) <NEWLINE> print ( len ( str ( num ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> try : a , b = map ( int , raw_input ( ) . split ( ) ) ; print len ( a + b ) <NEWLINE> except EOFError : break <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> a , b = input ( ) . strip ( ) . split ( ) <NEWLINE> if a < 0 or b < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> sum = a + b <NEWLINE> sum = str ( sum ) <NEWLINE> print ( len ( sum ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> print ( len ( str ( a + b ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) . split ( <STRING> ) <NEWLINE> if ( len ( line ) != 2 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 1 ] ) <NEWLINE> print ( int ( math . log10 ( a + b ) ) + 1 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> L = x . split ( <STRING> ) <NEWLINE> sum = int ( L [ 0 ] ) + int ( L [ 1 ] ) <NEWLINE> digit = 1 <NEWLINE> while sum >= 10 : <NEWLINE> <INDENT> sum = sum / 10 <NEWLINE> digit = digit + 1 <NEWLINE> <NL> <DEDENT> print digit <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> def inputs ( ) : <NEWLINE> <INDENT> li = [ ] <NEWLINE> string = input ( ) <NEWLINE> count = 0 <NEWLINE> while count < 201 and string != <STRING> : <NEWLINE> <INDENT> li . append ( string ) <NEWLINE> string = input ( ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> return li <NEWLINE> <NL> <DEDENT> li = inputs ( ) <NEWLINE> for x in li : <NEWLINE> <INDENT> a = x . split ( <STRING> ) <NEWLINE> print ( int ( a [ 0 ] ) + int ( a [ 1 ] ) ) <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = sum ( map ( int , line . split ( ) ) ) <NEWLINE> num = 0 <NEWLINE> for c in s : <NEWLINE> <INDENT> if c . isdigit ( ) : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> d = 0 <NEWLINE> s = sum ( [ a , b ] ) <NEWLINE> while ( s ) : <NEWLINE> <INDENT> s //= 10 <NEWLINE> d += 1 <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) . sort ( reverse = True ) <NEWLINE> if a * a == b * b + c * c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> a = int ( line . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( line . split ( <STRING> ) [ 1 ] ) <NEWLINE> c = int ( line . split ( <STRING> ) [ 2 ] ) <NEWLINE> if ( a * a + b * b == c * c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> values = sorted ( map ( lambda x : int ( x ) ^ 2 , raw_input ( ) . split ( ) ) ) <NEWLINE> if values [ 2 ] == values [ 1 ] + values [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a * a + b * b == c * c or a * a + c * c == b * b or b * b + c * c == a * a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> li = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> li = sorted ( li ) <NEWLINE> for x in li : <NEWLINE> <INDENT> tmp = x . split ( <STRING> ) <NEWLINE> for i in range ( len ( tmp ) ) : <NEWLINE> <INDENT> tmp [ i ] = int ( tmp [ i ] ) <NEWLINE> <DEDENT> tmp = sorted ( tmp ) <NEWLINE> a , b , c = tmp [ 0 ] , tmp [ 1 ] , tmp [ 2 ] <NEWLINE> if ( a ** 2 + b ** 2 ) == c ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
number = int ( input ( ) ) <NEWLINE> <NL> for i in range ( number ) : <NEWLINE> <INDENT> tri = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if tri [ 0 ] > tri [ 1 ] : <NEWLINE> <INDENT> buf = tri [ 0 ] <NEWLINE> tri [ 0 ] = tri [ 1 ] <NEWLINE> tri [ 1 ] = buf <NEWLINE> <DEDENT> if tri [ 1 ] > tri [ 2 ] : <NEWLINE> <INDENT> buf = tri [ 1 ] <NEWLINE> tri [ 1 ] = tri [ 2 ] <NEWLINE> tri [ 2 ] = buf <NEWLINE> <DEDENT> if tri [ 0 ] * tri [ 0 ] + tri [ 1 ] * tri [ 1 ] == tri [ 2 ] * tri [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a ** 2 + b ** 2 == c ** 2 else <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = a [ i ] [ 0 ] ** 2 <NEWLINE> b = a [ i ] [ 1 ] ** 2 <NEWLINE> c = a [ i ] [ 2 ] ** 2 <NEWLINE> <NL> if a == b + c or b == a + c or c == a + b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> answer = <STRING> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if answer != <STRING> : <NEWLINE> <INDENT> answer += <STRING> <NEWLINE> <DEDENT> a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> if a [ 0 ] ** 2 + a [ 1 ] ** 2 == a [ 2 ] ** 2 : <NEWLINE> <INDENT> answer += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer += <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> sides = map ( int , input ( ) . split ( ) ) <NEWLINE> longestSide = max ( sides ) <NEWLINE> sides . remove ( longestSide ) <NEWLINE> if ( longestSide ** 2 ) == ( sides [ 0 ] ** 2 + sides [ 1 ] ** 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
inputs = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> max = max ( inputs ) <NEWLINE> <NL> inputs . remove ( max ) <NEWLINE> <NL> if max ** 2 == inputs [ 0 ] ** 2 + inputs [ 1 ] ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b , c = [ int ( x ) for x in line . split ( ) ] <NEWLINE> if ( a ** 2 + b ** 2 ) == c ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> x = raw_input ( ) <NEWLINE> for abc in sys . stdin : <NEWLINE> <INDENT> L = map ( int , abc . split ( <STRING> ) ) . sort ( ) <NEWLINE> if L [ 0 ] ** 2 + L [ 1 ] ** 2 == L [ 2 ] ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = list ( map ( int , input ( ) ) ) . sort ( ) <NEWLINE> if c ** 2 == ( a ** 2 + b ** 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = sorted ( map ( int , input ( ) . split ( ) ) , reversed = True ) <NEWLINE> if a [ 0 ] ** 2 == a [ 1 ] ** 2 + a [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> n . sort ( ) <NEWLINE> if n [ 0 ] ** 2 + n [ 1 ] ** 2 != n [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
num = int ( input ( ) ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( <STRING> ) <NEWLINE> if ( a == b == c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> a , b , c = sorted ( map ( int , raw_inpu ( ) . split ( ) ) ) <NEWLINE> print <STRING> if a * a + b * b == c * c else <STRING> <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> s = input ( ) . split ( <STRING> ) <NEWLINE> s = [ int ( j ) for j in s ] <NEWLINE> s . sort ( ) <NEWLINE> <NL> if ( s [ 0 ] ** 2 + s [ 1 ] ** 2 == s [ 2 ] ** 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( 1 ) <NEWLINE> while True : <NEWLINE> <INDENT> if b < a + 1 : <NEWLINE> <INDENT> x = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> x . sort ( ) <NEWLINE> if x [ 0 ] ** 2 + x [ 1 ] ** 2 == x [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> b += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> li = sorted ( input ( ) . split ( ) ) <NEWLINE> if ( li [ 0 ] ** 2 + li [ 1 ] ** 2 == li [ 3 ] ** 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> data_length = int ( sys . stdin . readline ( ) ) <NEWLINE> lines [ ] <NEWLINE> for x in xrange ( data_length ) : <NEWLINE> <INDENT> input_line = sys . stdin . readline ( ) <NEWLINE> lines = map ( int , input_line . strip ( ) . split ( ) ) <NEWLINE> lines . sort ( reverse = True ) <NEWLINE> if lines [ 0 ] ** 2 == ( lines [ 1 ] ** 2 + lines [ 2 ] ** 2 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
a = [ print ( s ) for s in map ( lambda x : x [ 0 ] + x [ 1 ] == x [ 2 ] and <STRING> or <STRING> , [ sorted ( int ( x ) ** 2 for x in raw_input ( ) . split ( <STRING> ) ) for i in range ( int ( raw_input ( ) ) ) ] ) ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> A = a ** 2 <NEWLINE> B = b ** 2 <NEWLINE> C = c ** 2 <NEWLINE> for i in len ( N ) : <NEWLINE> <INDENT> if A + B == C : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif A + C == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif B + C == A : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def is_triangle ( x , y , z ) : <NEWLINE> <INDENT> x , y , z = sorted ( x , y , z ) <NEWLINE> return x ** 2 + y ** 2 == z ** 2 <NEWLINE> <NL> <DEDENT> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> x , y , z = map ( int , input ( ) . split ( ) ) <NEWLINE> triangle = is_triangle ( x , y , z ) <NEWLINE> if triangle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( int ( raw_input ( ) ) ) : <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE>
deta_set_count = int ( input ( ) ) <NEWLINE> for _ in range ( deta_set_count ) : <NEWLINE> <INDENT> k = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = k . sorted ( ) <NEWLINE> if k [ 0 ] ** 2 + k [ 1 ] ** 2 == k [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
[ print ( [ <STRING> , <STRING> ] [ 0 if d [ 0 ] ** 2 + d [ 1 ] ** 2 == d [ 2 ] ** 2 else 1 ] ) for i , d in enumerate ( [ sorted ( [ int ( x ) ** 2 for x in input ( ) . split ( ) ] ) ] ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> l = [ None ] * 3 <NEWLINE> l [ 0 ] = int ( line . split ( ) [ 0 ] ) <NEWLINE> l [ 1 ] = int ( line . split ( ) [ 1 ] ) <NEWLINE> l [ 2 ] = int ( line . split ( ) [ 2 ] ) <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a = line . split ( ) <NEWLINE> if len ( a ) == 3 : <NEWLINE> <INDENT> if int ( a [ 0 ] ) * int ( a [ 0 ] ) + int ( a [ 1 ] ) * int ( a [ 1 ] ) == int ( a [ 2 ] ) * int ( a [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> } else { <NEWLINE> <INDENT> console . log ( <STRING> ) <NEWLINE> <NL> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> <DEDENT> } ) ; <NEWLINE>
tri_list = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> k = int ( input ( ) ) <NEWLINE> tri_list = list ( k . split ( <STRING> ) ) <NEWLINE> tri_list . sort ( ) <NEWLINE> a = int ( tri_list [ 2 ] ) ** 2 <NEWLINE> b = int ( tri_list [ 0 ] ) ** 2 + int ( tri_list [ 1 ] ) ** 2 <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h = list ( map ( int , input ( ) ) ) <NEWLINE> h . sort ( ) <NEWLINE> if h [ 0 ] ** 2 + + h [ 1 ] ** 2 == h [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input . split ( ) <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ j ] = int ( s [ j ] ) <NEWLINE> <DEDENT> s . sort ( ) <NEWLINE> print ( <STRING> if ( pow ( s [ 0 ] , 2 ) + pow ( s [ 1 ] , 2 ) == pow ( s [ 2 ] , 2 ) ) else <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for a , b , c in map ( lambda x : sorted ( map ( int , x . split ( ) ) ) , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> print ( [ <STRING> , <STRING> ] [ a * a + b * b == c * c ] ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> edges = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if len ( edges ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> edges . sort ( ) <NEWLINE> <NL> if edges [ 0 ] ** 2 + edges [ 1 ] ** 2 == edges [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def Rec ( N , List ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( List [ i ] . split ( <STRING> ) [ 0 ] ) <NEWLINE> b = int ( List [ i ] . split ( <STRING> ) [ 1 ] ) <NEWLINE> c = int ( List [ i ] . split ( <STRING> ) [ 2 ] ) <NEWLINE> if a * a + b * b == c * c or a * a + c * c == b * b or b * b + c * c == a * a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> List = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> List . append ( input ( ) ) <NEWLINE> <DEDENT> Rec ( N , List <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> list = [ int ( item ) for item in raw_input ( ) . split ( ) ] <NEWLINE> list . sort ( ) <NEWLINE> if list [ 0 ] ** 2 + list [ 1 ] ** 2 == list [ 2 ] ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> c = x [ 2 ] <NEWLINE> if a * a + b * b == c * c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def isRTri ( a , b , c ) : <NEWLINE> <INDENT> if a * a + b * b == c * c : return 1 <NEWLINE> else return 0 <NEWLINE> <NL> <DEDENT> a = [ 0 , 0 , 0 ] <NEWLINE> n = input ( ) <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> r = isRTri ( a [ 0 ] , a [ 1 ] , a [ 2 ] ) <NEWLINE> if r : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ary = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = max ( ary ) <NEWLINE> ary . remove ( c ) <NEWLINE> a , b = ary <NEWLINE> <NL> if a ** 2 + b ** 2 == c ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
a = int , raw_input ( ) <NEWLINE> for i in range ( 0 , a ) : <NEWLINE> <INDENT> x , y , z = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( x > y > z or x > z > y and x * x == y * y + z * z ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ( y > x > z or y > z > x and y * y == x * x + z * z ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ( z > x > y or z > y > z and z * z == x * x + y * y ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
N = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> a , b , c = sorted ( int ( w ) for w in line . split ( ) ) <NEWLINE> <NL> if a ** 2 + b ** 2 == c ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
timel = int ( raw_input ( ) ) <NEWLINE> for gomi in xrange ( timel ) : <NEWLINE> <INDENT> a , b , c = map ( lambda x : int ( x ) ** 2 , raw_input ( ) . split ( ) ) <NEWLINE> if a + b == c or b + c == a or c + a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
= int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <NL> <INDENT> tri_list = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <COMMENT> <NL> a = int ( tri_list [ 2 ] ) ** 2 <NEWLINE> b = int ( tri_list [ 0 ] ) ** 2 + int ( tri_list [ 1 ] ) ** 2 <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def check ( List ) : <NEWLINE> <INDENT> List . sort ( ) <NEWLINE> List . revers ( ) <NEWLINE> if List [ 0 ] ^ 2 == List [ 1 ] ^ 2 + List [ 2 ] ^ 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> list = [ ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> list . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> print check ( list ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> input_line = input ( ) <NEWLINE> if input_line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums = list ( map ( int , input_line . split ( ) ) ) <NEWLINE> max_num = max ( nums ) <NEWLINE> nums . remove ( max_num ) <NEWLINE> if max_num ** 2 == nums [ 0 ] ** 2 + nums [ 1 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> a , b , c = sorted ( int ( e . split ( ) ) ) <NEWLINE> if a ** 2 + b ** 2 == c ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for n in range ( input ( ) ) : <NEWLINE> <INDENT> a , b , c = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> print [ <STRING> , <STRING> ] [ c * c - a * a - b * b ] <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> array = [ int ( x ) for x in line . split ( ) ] <NEWLINE> array . sort ( ) <NEWLINE> if array [ 2 ] ** 2 == ( array [ 0 ] ** 2 + array [ 1 ] ** 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except ( ValueError ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> line = raw_input ( ) <NEWLINE> l . append ( int ( line . split ( ) [ 0 ] ) ) <NEWLINE> l . append ( int ( line . split ( ) [ 1 ] ) ) <NEWLINE> l . append ( int ( line . split ( ) [ 2 ] ) ) <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 2 ] ** 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l = list ( map ( int , line . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> if l [ 0 ] ** 2 + l [ 1 ] ** 2 == l [ 3 ] ** 2 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c = input ( ) . split ( ) <NEWLINE> x = int ( a ) <NEWLINE> y = int ( b ) <NEWLINE> z = int ( c ) <NEWLINE> p = [ a , b , c ] <NEWLINE> p . sort ( ) <NEWLINE> if pow ( p [ 0 ] , 2 ) + pow ( p [ 1 ] , 2 ) == pow ( p [ 2 ] , 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for a in range ( x ) : <NEWLINE> <INDENT> y = map ( int , raw_input ( ) , split ( ) ) <NEWLINE> <INDENT> sort ( y [ 3 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if y [ 2 ] ** 2 - y [ 1 ] ** 2 == y [ 0 ] ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
def check_right_triangle ( side1 , side2 , side3 ) : <NEWLINE> <INDENT> if side1 ** 2 == side2 ** 2 + side3 ** 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if side2 ** 2 == side3 ** 2 + side1 ** 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if sides3 ** 3 == side1 ** 2 + side2 ** 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> sides = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if check_right_triangle ( sides [ 0 ] , sides [ 1 ] , sides [ 2 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for lineCount , line in enumerate ( sys . stdin ) : <NEWLINE> <INDENT> if lineCount == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , b , c = sorted ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> if a ** 2 + b ** 2 = c ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> L = map ( float , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if L : <NEWLINE> <INDENT> ( a , b , c , d , e , f ) = L <NEWLINE> x = ( e * c - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( a * f - d * c ) / ( a * e - b * d ) <NEWLINE> <NL> print x , y <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> fp . close ( ) <NEWLINE> <NL> for line in lines : <NEWLINE> <INDENT> data . append ( line . split ( ) ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> N = len ( data ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for k in range ( 6 ) : <NEWLINE> <INDENT> data [ i ] [ k ] = int ( data [ i ] [ k ] ) <NEWLINE> <DEDENT> det = data [ i ] [ 0 ] * data [ i ] [ 4 ] - data [ i ] [ 1 ] * data [ i ] [ 3 ] <NEWLINE> gx = data [ i ] [ 2 ] * data [ i ] [ 4 ] - data [ i ] [ 1 ] * data [ i ] [ 5 ] <NEWLINE> gy = data [ i ] [ 0 ] * data [ i ] [ 5 ] - data [ i ] [ 2 ] * data [ i ] [ 3 ] <NEWLINE> if det < 0 : <NEWLINE> <INDENT> det = - det ; <NEWLINE> if gx != 0 : gx = - gx <NEWLINE> if gy != 0 : gy = - gy <NEWLINE> <DEDENT> print ( <STRING> . format ( gx / det ) + <STRING> + <STRING> . format ( gy / det ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , input ( ) . split ( ) ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( a * f - d * c ) / ( a * e - b * d ) <NEWLINE> print ( <STRING> . format ( x + 0 , y + 0 ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> x = ( e * c - b * f ) / ( e * a - b * d ) <NEWLINE> y = ( c * d - a * f ) / ( b * d - e * a ) <NEWLINE> if x == - 0.0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> if y == - 0.0 <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
x = y = 0.000 <NEWLINE> for i in sys . stdin ( ) : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , i . split ( ) ) <NEWLINE> y = ( ( c * d ) - ( a * f ) ) / ( ( b * d ) - ( a * e ) ) <NEWLINE> x = ( c - ( b * y ) ) / a <NEWLINE> print <STRING> . format ( x , y ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , l . split ( ) ) <NEWLINE> x = ( c * e - f * b ) / ( a * e - d * b ) <NEWLINE> y = ( f - d * x ) / e <NEWLINE> print <STRING> % ( x , y ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> n = [ int ( y ) for y in x . split ( ) ] <NEWLINE> <NL> print <STRING> % ( ( n [ 2 ] * n [ 4 ] - n [ 1 ] * n [ 5 ] ) / ( n [ 0 ] * n [ 3 ] - n [ 1 ] * n [ 3 ] ) , ( n [ 5 ] * n [ 0 ] - n [ 2 ] * n [ 3 ] ) / ( n [ 0 ] * n [ 4 ] - n [ 3 ] * n [ 1 ] ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> tb , tc = d * b , d * c <NEWLINE> te , tf = a * e , a * f <NEWLINE> y = ( tc - tf ) // ( tb - te ) <NEWLINE> x = ( c - ( y * b ) ) // a <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT>
data = [ ] <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> data . append ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> for i in data : <NEWLINE> <INDENT> a , b , c , d , e , f = i . split ( ) <NEWLINE> a , b , c , d , e , f = int ( a ) , int ( b ) , int ( c ) , int ( d ) , int ( e ) , int ( f ) <NEWLINE> if ( abs ( a ) <= 1000 <NEWLINE> <INDENT> and abs ( b ) <= 1000 <NEWLINE> and abs ( c ) <= 1000 <NEWLINE> and abs ( d ) <= 1000 <NEWLINE> and abs ( e ) <= 1000 <NEWLINE> and abs ( f ) <= 1000 ) : <NEWLINE> for j in range ( - 1000 , 1001 ) : <NEWLINE> <INDENT> y1 = ( c - ( a * j ) ) / float ( b ) <NEWLINE> y2 = ( f - ( d * j ) ) / float ( e ) <NEWLINE> if y1 == y2 : <NEWLINE> <INDENT> print <STRING> . format ( j , y1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> data = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = data [ 0 ] <NEWLINE> b = data [ 1 ] <NEWLINE> c = data [ 2 ] <NEWLINE> d = data [ 3 ] <NEWLINE> e = data [ 4 ] <NEWLINE> f = data [ 5 ] <NEWLINE> <NL> x = ( c * e - b * f ) * 1.0 / ( a * e - b * d ) <NEWLINE> if x == - 0.000 : <NEWLINE> <INDENT> x = 0.000 <NEWLINE> <DEDENT> if b != 0 : <NEWLINE> <INDENT> y = ( c - a * x ) / b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = ( f - d * x ) / e <NEWLINE> <DEDENT> if y == - 0.000 : <NEWLINE> <INDENT> y = 0.000 <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for i in stdin . sys : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> x = float ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = float ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> if x == - 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> if y == - 0 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> print ( <STRING> % ( x , y ) ) <NEWLINE> <DEDENT>
mport sys <NEWLINE> <NL> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a , b , c , d , e , f = [ int ( x ) for x in i . split ( ) ] <NEWLINE> y = ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> x = ( c - b * y ) / a <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , line . split ( ) ) <NEWLINE> print <STRING> % ( ( d * c - a * f ) / ( b * d - a * e ) , ( b * f - c * e ) / ( b * d - a * e ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> return gcd ( b , a % b ) if a % b else b <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> data = map ( int , line . split ( ) ) <NEWLINE> a , b , c , d , e , f = data <NEWLINE> ix = lcm ( a , d ) / a <NEWLINE> jx = lcm ( a , d ) / d <NEWLINE> iy = lcm ( b , e ) / b <NEWLINE> jy = lcm ( b , e ) / e <NEWLINE> x = ( c * 1.0 * iy - f * jy ) / ( a * iy - d * jy ) <NEWLINE> y = ( c * 1.0 * ix - f * jx ) / ( b * ix - e * jx ) <NEWLINE> print <STRING> % ( round ( x , 4 ) , round ( y , 4 ) ) <NEWLINE> <DEDENT>
e True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = map ( long , raw_input ( ) . split ( ) ) <NEWLINE> m = a [ 0 ] * a [ 4 ] - a [ 1 ] * a [ 3 ] <NEWLINE> <NL> x = ( a [ 4 ] * a [ 2 ] - a [ 1 ] * a [ 5 ] ) / m <NEWLINE> y = ( a [ 0 ] * a [ 5 ] - a [ 2 ] * a [ 3 ] ) / m <NEWLINE> <NL> if x == - 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> if y == - 0 : <NEWLINE> y = 0 <NEWLINE> <NL> print <STRING> % ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> break <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( c * e - b * f ) / ) a * e - b * d ) , ( a * f - c * d ) / ( a * e - b * d ) ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> data = raw_input ( ) <NEWLINE> <NL> if not data : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a , b , c , d , e , f = map ( int , data . split ( ) ) <NEWLINE> <NL> x = ( e * c - b * f ) / ( b * d - a * c ) <NEWLINE> <NL> y = ( c - a * x ) / b <NEWLINE> <NL> print <STRING> % ( round ( x , 3 ) , round ( y , 3 ) ) <NEWLINE> <DEDENT>
<NL> import numpy as np <NEWLINE> import sys <NEWLINE> <NL> printf = sys . stdout . write <NEWLINE> <NL> for i in sys . stdin : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , i . split ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> printf ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> A = np . array ( [ [ a , b ] , <NEWLINE> <INDENT> [ d , e ] ] ) <NEWLINE> <DEDENT> B = np . array ( [ c , f ] ) <NEWLINE> X = np . linalg . solve ( A , B ) <NEWLINE> print <STRING> . format ( X [ 0 ] ) , <STRING> . format ( X [ 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> num = map ( float , line . strip ( ) . split ( ) ) <NEWLINE> x = ( num [ 2 ] * num [ 4 ] - num [ 1 ] * num [ 5 ] ) / ( num [ 0 ] * num [ 4 ] - num [ 1 ] * num [ 3 ] ) <NEWLINE> y = ( num [ 5 ] * num [ 0 ] - num [ 2 ] * num [ 3 ] ) / ( num [ 0 ] * num [ 4 ] - num [ 3 ] * num [ 1 ] ) <NEWLINE> out . append ( <STRING> % ( x , y ) ) <NEWLINE> <DEDENT> for i in xrange ( len ( out ) ) : <NEWLINE> <INDENT> print out [ i ] <NEWLINE> <DEDENT>
hile True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a , b , c , d , e , f = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> <NL> <NL> y = ( c * d - f * a ) / ( b * d - a * e ) <NEWLINE> x = ( c * e - f * b ) / ( a * e - b * d ) <NEWLINE> <NL> if x <= 0 and x >= - 0.0005 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <NL> <DEDENT> if y <= 0 and y >= - 0.0005 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( x , y ) ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> from decimal import Decimal <NEWLINE> from fractions import Fraction <NEWLINE> <NL> def main ( ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> for matrix_string in input_strings : <NEWLINE> <INDENT> matrix = list ( map ( Fraction , list ( matrix_string . split ( ) ) ) ) <NEWLINE> if matrix [ 0 ] == 0 : <NEWLINE> <INDENT> matrix = matrix [ 3 : ] + matrix [ : 3 ] <NEWLINE> <DEDENT> matrix = list ( map ( lambda x : x / matrix [ 0 ] , matrix [ : 3 ] ) ) + matrix [ 3 : ] <NEWLINE> matrix = matrix [ : 3 ] + list ( map ( lambda x : x [ 1 ] - matrix [ 3 ] * x [ 0 ] , zip ( matrix [ : 3 ] , matrix [ 3 : ] ) ) ) <NEWLINE> matrix = matrix [ : 3 ] + list ( map ( lambda x : x / matrix [ 4 ] , matrix [ 3 : ] ) ) <NEWLINE> matrix = list ( map ( lambda x : x [ 0 ] - matrix [ 1 ] * x [ 1 ] , zip ( matrix [ : 3 ] , matrix [ 3 : ] ) ) ) + matrix [ 3 : ] <NEWLINE> matrix = list ( map ( float , matrix ) ) <NEWLINE> matrix = list ( map ( Decimal , matrix ) ) <NEWLINE> matrix = list ( map ( lambda x : x . quantize ( Decimal ( <STRING> ) , rounding = <STRING> ) , matrix ) ) <NEWLINE> matrix = list ( map ( lambda x : x + 0 , matrix ) ) <NEWLINE> <NL> print ( <STRING> % ( matrix [ 2 ] , matrix [ 5 ] ) ) <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( f * a - c * d ) / ( a * e - d * b ) <NEWLINE> if x == - 0.000 : <NEWLINE> <INDENT> x = 0.000 <NEWLINE> <DEDENT> if y == - 0.000 : <NEWLINE> <INDENT> y = 0.000 <NEWLINE> <DEDENT> print str ( <STRING> % x ) + <STRING> + str ( <STRING> % y ) + <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def solver ( a , b , c , d , e , f ) : <NEWLINE> <INDENT> answer = [ ] <NEWLINE> <NL> m = a / d <NEWLINE> <NL> d = d * m <NEWLINE> e = e * m <NEWLINE> f = f * m <NEWLINE> <NL> y = ( c - f ) / ( b - e ) <NEWLINE> <NL> x = ( c - b * y ) / a <NEWLINE> answer . append ( x ) <NEWLINE> answer . append ( y ) <NEWLINE> <NL> return answer <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p_1 , p_2 , p_3 , p_4 , p_5 , p_6 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <NL> ans = [ ] <NEWLINE> ans = solver ( p_1 , p_2 , p_3 , p_4 , p_5 , p_6 ) <NEWLINE> <NL> print <STRING> % ( ans [ 0 ] , ans [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> except : <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , input ( ) . split ( ) ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( a * f - c * d ) / ( a * e - b * d ) <NEWLINE> print ( <STRING> . format ( x , y ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import numpy <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> d = map ( int , s . split ( ) ) <NEWLINE> a = numpy . matrix ( [ [ d [ 0 ] , d [ 1 ] ] , [ d [ 3 ] , d [ 4 ] ] ] ) <NEWLINE> b = numpy . matrix ( [ d [ 2 ] , d [ 5 ] ] ) . T <NEWLINE> c = numpy . dot ( a . I , b ) <NEWLINE> print <STRING> % ( float ( c [ 0 ] [ 0 ] ) , float ( c [ 1 ] [ 0 ] ) ) <NEWLINE> <DEDENT>
for line in sys . stdin : <NEWLINE> <INDENT> array = [ float ( x ) for x in line . split ( ) ] <NEWLINE> ar1 = array [ 0 : 3 ] <NEWLINE> ar2 = array [ 3 : ] <NEWLINE> i = ar1 [ 0 ] <NEWLINE> ar1 = [ x * ar2 [ 0 ] for x in ar1 ] <NEWLINE> ar2 = [ x * i for x in ar2 ] <NEWLINE> y = ( ar1 [ 2 ] - ar2 [ 2 ] ) / ( ar1 [ 1 ] - ar2 [ 1 ] ) <NEWLINE> ar1 = array [ 0 : 3 ] <NEWLINE> x = ( ar1 [ 2 ] - ar1 [ 1 ] * y ) / ar1 [ 0 ] <NEWLINE> print ( <STRING> % ( round ( x , 3 ) , round ( y , 3 ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a * d - b * c == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( a * f - c * d ) / ( a * e - b * d ) <NEWLINE> print ( <STRING> % round ( x , 3 ) , ( <STRING> % round ( y , 3 ) ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin ( ) : <NEWLINE> <INDENT> [ a , b , e , c , d , f ] = [ int ( x ) for x in line . split ( ) ] <NEWLINE> delta = a * d - b * c <NEWLINE> x = ( d * e - b * f ) / delta <NEWLINE> y = ( - e * c + a * f ) / delta <NEWLINE> print x , y <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> inputNum = open ( <STRING> , <STRING> ) <NEWLINE> <NL> for i in inputNum : <NEWLINE> <INDENT> new = [ ] <NEWLINE> n = i [ : - 1 ] . split ( <STRING> , 6 ) <NEWLINE> for s in n : <NEWLINE> <INDENT> new . append ( float ( s ) ) <NEWLINE> <DEDENT> k = new [ 0 ] <NEWLINE> q = 0 <NEWLINE> for a in new [ 0 : 3 ] : <NEWLINE> <INDENT> new [ q ] = a / k <NEWLINE> q = q + 1 <NEWLINE> <DEDENT> l = new [ 3 ] <NEWLINE> for a in new [ 3 : 6 ] : <NEWLINE> <INDENT> new [ q ] = a - l * new [ q - 3 ] <NEWLINE> q = q + 1 <NEWLINE> <DEDENT> if new [ 4 ] == 0 : <NEWLINE> <INDENT> y = new [ 5 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = new [ 5 ] / new [ 4 ] <NEWLINE> <DEDENT> x = new [ 2 ] - ( new [ 1 ] * y ) <NEWLINE> print ( <STRING> . format ( x ) , <STRING> . format ( y ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def Print ( array ) : <NEWLINE> <INDENT> for r in range ( len ( array ) ) : <NEWLINE> <INDENT> print ( array [ r ] ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <NL> <DEDENT> def Gauss ( array ) : <NEWLINE> <INDENT> for r in range ( len ( array ) ) : <NEWLINE> <INDENT> array [ r ] . append ( r ) <COMMENT> <NEWLINE> <NL> <DEDENT> for r in range ( len ( array ) ) : <COMMENT> <NEWLINE> <INDENT> array . sort ( key = lambda x : x [ r ] , reverse = True ) <COMMENT> <NEWLINE> div = array [ r ] [ r ] <NEWLINE> for c in range ( r , len ( array ) + 1 ) : <COMMENT> <NEWLINE> for r2 in range ( r + 1 , len ( array ) ) : <COMMENT> <NEWLINE> <INDENT> head = array [ r2 ] [ r ] <NEWLINE> for c in range ( r , len ( array ) + 1 ) : <NEWLINE> <INDENT> array [ r2 ] [ c ] -= head * array [ r ] [ c ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> result = [ 0 ] * len ( array ) <NEWLINE> for r in range ( len ( array ) - 1 , - 1 , - 1 ) : <COMMENT> <NEWLINE> <INDENT> result [ r ] = array [ r ] [ <NEWLINE> <INDENT> len ( array ) ] - sum ( [ result [ x ] * array [ r ] [ x ] for x in range ( r + 1 , len ( array ) ) ] ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> [ a , b , c , d , e , f ] = [ int ( x ) for x in line . split ( ) ] <NEWLINE> result = Gauss ( [ [ a , b , c ] , [ d , e , f ] ] ) <NEWLINE> for i in range ( len ( result ) - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( result [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> . format ( result [ - 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , e . split ( ) ) <NEWLINE> y = ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> x = ( c - b * y ) / a <NEWLINE> print ( round ( x , 3 ) + <STRING> + round ( y , 3 ) ) <NEWLINE> <DEDENT>
[ print ( <STRING> . format ( ( k [ 2 ] - k [ 1 ] * ( ( k [ 0 ] * k [ 5 ] - k [ 2 ] * k [ 3 ] ) / ( k [ 0 ] * k [ 4 ] - k [ 1 ] * k [ 3 ] ) ) ) / k [ 0 ] , ( ( k [ 0 ] * k [ 5 ] - k [ 2 ] * k [ 3 ] ) / ( k [ 0 ] * k [ 4 ] - k [ 1 ] * k [ 3 ] ) ) ) ) for i in sys . stdin for k in [ [ int ( float ( j ) ) for j in i . split ( ) ] ] ] <NEWLINE>
hoe <NEWLINE>
while ( True ) : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> s = line . rstrip ( ) . split ( ) <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> s [ i ] = int ( s [ i ] ) <NEWLINE> <DEDENT> print ( s [ 2 ] * s [ 4 ] - s [ 1 ] * s [ 5 ] ) / ( s [ 0 ] * s [ 4 ] - s [ 1 ] * s [ 3 ] ) , ( s [ 1 ] * s [ 5 ] - s [ 3 ] * s [ 2 ] ) / ( s [ 0 ] * s [ 4 ] - s [ 1 ] * s [ 3 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , i . split ( ) ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> x = abs ( x ) if abs ( x ) < 10e-4 else x <NEWLINE> y = abs ( y ) if abs ( y ) < 10e-4 else y <NEWLINE> print ( <STRING> . format ( x , y ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> P = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> x = ( P [ 2 ] * P [ 4 ] - P [ 1 ] * P [ 5 ] ) / ( P [ 0 ] * P [ 4 ] - P [ 1 ] * P [ 3 ] ) <NEWLINE> y = ( P [ 2 ] * P [ 3 ] - P [ 0 ] * P [ 5 ] ) / ( P [ 1 ] * P [ 3 ] - P [ 0 ] * P [ 4 ] ) <NEWLINE> x = x if x else 0 <NEWLINE> y = y if y else 0 <NEWLINE> print <STRING> . format ( x , y ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> if line is <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , b , c , d , e , f = map ( float , input ( ) . split ( ) ) <NEWLINE> y = ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> x = ( c - b * y ) / a <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
z = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - d * b ) <NEWLINE> y = ( c * d - f * a ) / ( b * d - e * a ) <NEWLINE> z . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> except : <NEWLINE> <INDENT> print ( z ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , i . split ( ) ) <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( f - d * x ) / e <NEWLINE> print <STRING> % ( x , y ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x = 0. ; y = 0. <NEWLINE> delta = abs ( a * e - b * d ) <NEWLINE> x = float ( ( e * c - b * f ) / delta ) <NEWLINE> y = float ( ( a * f - d * c ) / delta ) <NEWLINE> <NL> print <STRING> % ( x , y ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , input ( ) . split ( ) ) <NEWLINE> det = e * a - b * d <NEWLINE> if det != 0 : <NEWLINE> <INDENT> x = ( e * c - b * f ) / det <NEWLINE> y = ( f * a - c * d ) / det <NEWLINE> <DEDENT> print ( <STRING> . format ( x + 0 , y + 0 ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for line in sys . stdin . readlines ( ) <NEWLINE> <INDENT> a , b , c , d , e , f = [ int ( s ) for s in line . split ( ) ] <NEWLINE> x = ( c * e - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <DEDENT>
x = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> c = x [ 2 ] <NEWLINE> d = x [ 3 ] <NEWLINE> e = x [ 4 ] <NEWLINE> f = x [ 5 ] <NEWLINE> g = ( c * e - b * f ) / ( a * e - d * b ) <NEWLINE> h = ( c * d - a * f ) / ( b * d - a * e ) <NEWLINE> print round ( g , 3 ) , round ( h , 3 ) <NEWLINE>
import sys <NEWLINE> from decimal import Decimal <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for input_line in sys . stdin : <NEWLINE> <INDENT> input_line = raw_input ( ) <NEWLINE> x1 = int ( input_line . split ( <STRING> ) [ 0 ] ) <NEWLINE> y1 = int ( input_line . split ( <STRING> ) [ 1 ] ) <NEWLINE> p = int ( input_line . split ( <STRING> ) [ 2 ] ) <NEWLINE> x2 = int ( input_line . split ( <STRING> ) [ 3 ] ) <NEWLINE> y2 = int ( input_line . split ( <STRING> ) [ 4 ] ) <NEWLINE> q = int ( input_line . split ( <STRING> ) [ 5 ] ) <NEWLINE> multiplicand1 , multiplicand2 = calculate1 ( x1 , x2 ) <NEWLINE> after_y1 , after_y2 , after_p , after_q = calculate2 ( y1 , y2 , p , q , multiplicand1 , multiplicand2 ) <NEWLINE> calculate3 ( after_y1 , after_y2 , after_p , after_q , x1 , y1 , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> def calculate1 ( x1 , x2 ) : <NEWLINE> <INDENT> if ( x1 >= 0 and x2 >= 0 ) or ( x1 < 0 and x2 < 0 ) : <NEWLINE> <INDENT> multiplicand1 = - x2 <NEWLINE> multiplicand2 = x1 <NEWLINE> return multiplicand1 , multiplicand2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> multiplicand1 = abs ( x2 ) <NEWLINE> multiplicand2 = abs ( x1 ) <NEWLINE> return multiplicand1 , multiplicand2 <NEWLINE> <NL> <DEDENT> <DEDENT> def calculate2 ( y1 , y2 , p , q , multiplicand1 , multiplicand2 ) : <NEWLINE> <INDENT> after_y1 = Decimal ( y1 * multiplicand1 ) <NEWLINE> after_y2 = Decimal ( y2 * multiplicand2 ) <NEWLINE> after_p = Decimal ( p * multiplicand1 ) <NEWLINE> after_q = Decimal ( q * multiplicand2 ) <NEWLINE> return after_y1 , after_y2 , after_p , after_q <NEWLINE> <NL> <DEDENT> def calculate3 ( after_y1 , after_y2 , after_p , after_q , x1 , y1 , p ) : <NEWLINE> <INDENT> y = Decimal ( after_p + after_q ) / Decimal ( after_y1 + after_y2 ) <NEWLINE> y = round ( y , 3 ) <NEWLINE> x = Decimal ( p - y1 * y ) / Decimal ( x1 ) <NEWLINE> x = round ( x , 3 ) <NEWLINE> print ( <STRING> % ( x , y ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <INDENT> import sys <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> vals = sys . stdin . readline ( ) <NEWLINE> if ( vals is None or vals . strip ( ) == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , b , c , d , e , f = list ( map ( float , vals . strip ( ) . split ( ) ) ) <NEWLINE> temp = a * e - d * b <NEWLINE> print ( temp ) <NEWLINE> x = ( c * e - b * f ) / temp + 0.0 <NEWLINE> y = ( c * d - a * f ) / - temp + 0.0 <NEWLINE> print ( <STRING> % ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> ( a , b , c , d , e , f ) = map ( int , input ( ) . split ( ) ) <NEWLINE> g = ( a * e ) - ( b * d ) <NEWLINE> ans1 = <STRING> . format ( ( ( e * c ) + ( - b * f ) ) / g + 0 ) <NEWLINE> ans2 = <STRING> . format ( ( ( - d * c ) + ( a * f ) ) / g + 0 ) <NEWLINE> print ( ans1 , ans2 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> y = ( - 1 * q [ 0 ] * q [ 5 ] + q [ 2 ] * q [ 3 ] ) / ( - 1 * q [ 0 ] * q [ 4 ] + q [ 1 ] * q [ 3 ] ) <NEWLINE> x = ( q [ 5 ] - q [ 4 ] * y ) / q [ 3 ] <NEWLINE> <NL> if x == - 0 or y == - 0 : <NEWLINE> <INDENT> x == 0 <NEWLINE> y == 0 <NEWLINE> <DEDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from sympy import * <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , s . split ( ) ) <NEWLINE> x , y = symbols ( <STRING> ) <NEWLINE> init_printing ( ) <NEWLINE> solve ( [ a * x + b * y - c ] , [ d * x + e * y - f ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> x = ( a [ 1 ] * a [ 5 ] - a [ 2 ] * a [ 4 ] ) / ( a [ 1 ] * a [ 3 ] - a [ 0 ] * a [ 4 ] ) <NEWLINE> y = ( a [ 2 ] * a [ 3 ] - a [ 0 ] * a [ 5 ] ) / ( a [ 1 ] * a [ 3 ] - a [ 0 ] * a [ 4 ] ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> if y == 0 : <NEWLINE> <INDENT> y = 0 <NEWLINE> <DEDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<NL> def SimultaneousEquation ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , line . split ( ) ) <NEWLINE> y = ( c * d - f * a ) / ( b * d - e * a ) <NEWLINE> x = ( c - b * y ) / a <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> SimultaneousEquation ( ) <NEWLINE>
import sys <NEWLINE> for ab in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , ab . split ( <STRING> ) ) <NEWLINE> if a >= b : <NEWLINE> <INDENT> for g in xrange ( b , 0 , - 1 ) : <NEWLINE> <INDENT> if a % g == 0 and b % g == 0 : <NEWLINE> <INDENT> gcd = g <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for l in xrange ( 1 , b + 1 ) : <NEWLINE> <INDENT> if ( a * l ) % b == 0 : <NEWLINE> <INDENT> lcm = a * l <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for g in xrange ( a , 0 , - 1 ) : <NEWLINE> <INDENT> if a % g == 0 and b % g == 0 : <NEWLINE> <INDENT> gcd = g <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for l in xrange ( 1 , a + 1 ) : <NEWLINE> <INDENT> if ( b * l ) % a == 0 : <NEWLINE> <INDENT> lcm = b * l <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print gcd , lcm <NEWLINE> <DEDENT>
def GcdLCM ( ) : <NEWLINE> <NL> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> x , y = map ( int , line . split ( ) ) <NEWLINE> if x == None : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> gcd = Gcd ( x , y ) <NEWLINE> lcm = int ( x * y / gcd ) <NEWLINE> <NL> print ( <STRING> . format ( gcd , lcm ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def Gcd ( x , y ) : <NEWLINE> <INDENT> while x != 0 : <NEWLINE> <INDENT> x , y = y % x , x <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <NL> <DEDENT> GcdLCM ( ) <NEWLINE>
class GCD ( ) : <NEWLINE> <INDENT> def __init__ ( self , a , b ) : <NEWLINE> <INDENT> self . a = a <NEWLINE> self . b = b <NEWLINE> <NL> <DEDENT> def swap ( self ) : <NEWLINE> <INDENT> temp = self . a <NEWLINE> self . a = self . b <NEWLINE> self . b = temp <NEWLINE> <NL> <DEDENT> def gcd ( self ) : <NEWLINE> <INDENT> if self . b < self . a : <NEWLINE> <INDENT> self . swap ( ) <NEWLINE> <NL> <DEDENT> temp = self . b % self . a <NEWLINE> <NL> if temp == 0 : <NEWLINE> <INDENT> ans = self . a <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> ans = self . b % temp <NEWLINE> <NL> return ans <NEWLINE> <NL> <DEDENT> def lcm ( self ) : <NEWLINE> <INDENT> gcd = self . gcd ( ) <NEWLINE> temp = self . a * self . b <NEWLINE> ans = temp // gcd <NEWLINE> return gcd , ans <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> num = self . lcm ( ) <NEWLINE> print ( <STRING> . format ( num [ 0 ] , num [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) . split ( ) <NEWLINE> <NL> a = int ( n [ 0 ] ) <NEWLINE> b = int ( n [ 1 ] ) <NEWLINE> <NL> data . append ( GCD ( a , b ) ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for array in data : <NEWLINE> <INDENT> array . print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> printf = sys . stdout . write <NEWLINE> ans = [ ] <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a == b : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , abs ( a - b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b , g ) : <NEWLINE> <INDENT> return a * b / g <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for i in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , i . split ( ) ) <NEWLINE> ans . append ( gcd ( a , b ) ) <NEWLINE> ans . append ( lcm ( a , b , gcd ( a , b ) ) ) <NEWLINE> <NL> <DEDENT> for i in xrange ( 0 , len ( ans ) - 2 , 2 ) : <NEWLINE> <INDENT> printf ( str ( ans [ i ] ) + <STRING> + str ( ans [ i + 1 ] ) + <STRING> ) <NEWLINE> <NL> <DEDENT> printf ( str ( ans [ len ( ans ) - 2 ] ) + <STRING> + str ( ans [ len ( ans ) - 1 ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while b : <NEWLINE> a , b = b , a % b <NEWLINE> return a <NEWLINE> <NL> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> for i in range ( max ( [ a , b ] ) , a * b + 1 ) : <NEWLINE> <INDENT> if ( i % a == 0 and i % b == 0 ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return a * b <NEWLINE> <NL> <NL> <DEDENT> for i in sys . stdin : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = [ int ( k ) for k in i . split ( <STRING> ) ] <NEWLINE> g = gcd ( max ( line ) , min ( line ) ) <NEWLINE> print ( str ( g ) + <STRING> + str ( line [ 0 ] * line [ 1 ] / g ) ) <COMMENT> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> raise <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> l = ( map ( int , line . split ( ) ) ) <NEWLINE> l . sort ( ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> for i in range ( 2 , a + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> ans = i <NEWLINE> <DEDENT> <DEDENT> print a * b / ans , ans <NEWLINE> <DEDENT>
print 1 2 <NEWLINE>
import sys <NEWLINE> <NL> nums = [ ] <NEWLINE> <NL> <NL> for line in sys . stdin : <NEWLINE> <INDENT> nums . append ( line ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> input_line = nums [ i ] . split ( <STRING> ) <NEWLINE> a = int ( input_line [ 0 ] ) <NEWLINE> b = int ( input_line [ 1 ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> common_div = [ ] <NEWLINE> <NL> <COMMENT> <NL> if a < b : <NEWLINE> <INDENT> last_num = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last_num = b <NEWLINE> <NL> <DEDENT> for j in range ( 1 , last_num - 1 ) : <NEWLINE> <INDENT> if a % j == 0 and b % j == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> common_div . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> max_common_div = common_div [ len ( common_div ) - 1 ] <NEWLINE> min_common_mpl = int ( ( a * b ) / max_common_div ) <NEWLINE> <NL> print ( str ( max_common_div ) + <STRING> + str ( min_common_mpl ) ) <NEWLINE> <NL> <DEDENT>
def gcd ( a , b ) : <NEWLINE> <INDENT> r = a % b <NEWLINE> while r > 0 : <NEWLINE> <INDENT> a = b <NEWLINE> b = r <NEWLINE> r = a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print gcd ( a , b ) + <STRING> + lcm ( a , b ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for input_line in sys . stdin : <NEWLINE> <INDENT> num1 = int ( input_line . split ( <STRING> ) [ 0 ] ) <NEWLINE> num2 = int ( input_line . split ( <STRING> ) [ 1 ] ) <NEWLINE> <NL> if num1 <= num2 : <NEWLINE> <INDENT> dividend ( num1 , num2 , num1 ) <NEWLINE> <DEDENT> elif num1 > num2 : <NEWLINE> <INDENT> dividend ( num1 , num2 , num2 ) <NEWLINE> <NL> <DEDENT> result . sort ( reverse = True ) <NEWLINE> greatest_common_divisor = result [ 0 ] <NEWLINE> least_common_multiple = num1 * num2 / greatest_common_divisor <NEWLINE> <NL> print ( <STRING> % ( greatest_common_divisor , least_common_multiple ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dividend ( num1 , num2 , num ) : <NEWLINE> <INDENT> for i in range ( num ) . sort ( reverse = True ) : <NEWLINE> <INDENT> divisor = i + 1 <NEWLINE> if num1 % divisor == 0 and num2 % divisor == 0 : <NEWLINE> <INDENT> result . append ( divisor ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> result = [ ] <NEWLINE> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <NL> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> while y > 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def lcm ( x , y ) : <NEWLINE> <INDENT> return x * y / gcd ( x , y ) <NEWLINE> <NL> <DEDENT> print ( gcd ( a , b ) , int ( lcm ( a , b ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ints = raw_input ( ) <NEWLINE> if ints != <STRING> : <NEWLINE> <INDENT> x = map ( int , ints . split ( <STRING> ) ) <NEWLINE> x . sort ( ) <NEWLINE> a = x [ 1 ] <NEWLINE> b = x [ 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> m = a % b <NEWLINE> if m != 0 : <NEWLINE> <INDENT> a = b <NEWLINE> b = m <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> n = x [ 1 ] * x [ 0 ] / b <NEWLINE> print b , n <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import fractions as f <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( str ( f . gcd ( a , b ) ) + <STRING> + str ( a * b // f . gcd ( a , b ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> list = sys . stdin . readlines ( ) <NEWLINE> <NL> e = 0 <NEWLINE> GCD = 0 <NEWLINE> def Euclide ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> tmp = a <NEWLINE> a = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> e = a % b <NEWLINE> return Euclide ( b , e ) <NEWLINE> <NL> <DEDENT> def LCM ( a , b , c ) : <NEWLINE> <INDENT> return int ( a / c * b ) <NEWLINE> <NL> <DEDENT> for i in list : <NEWLINE> <INDENT> a = i [ 0 ] <NEWLINE> b = i [ 1 ] <NEWLINE> GCD = Euclide ( a , b ) <NEWLINE> print ( str ( GCD ) + <STRING> + str ( LCM ( a , b , GCD ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int gcd ( unsigned long num1 , unsigned long num2 ) { <NEWLINE> <INDENT> if ( num2 == 0 ) { <NEWLINE> <INDENT> return num1 ; <NEWLINE> <DEDENT> } return gcd ( num2 , num1 % num2 ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int lcm ( unsigned long n1 , unsigned long n2 ) { <NEWLINE> <INDENT> return n1 * n2 / gcd ( n1 , n2 ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> unsigned long a , b ; <NEWLINE> while ( ~ scanf ( <STRING> , & a , & b ) ) { <NEWLINE> <INDENT> printf ( <STRING> , gcd ( a , b ) , lcm ( a , b ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
import sys <NEWLINE> from fractions import gcd <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print gcd ( a , b ) , a * b / gcd ( a , b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> gcd = 1 <NEWLINE> for i in range ( 1 , a ) : <NEWLINE> <INDENT> if ( a % i == 0 and b % i == 0 ) : <NEWLINE> <INDENT> gcd = i <NEWLINE> <DEDENT> <DEDENT> lcm = int ( a * b / gcd ) <NEWLINE> print ( <STRING> . format ( gcd , lcm ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> while 1 : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> if ( not line ) : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> x , y = map ( int , line . split ( ) ) <NEWLINE> <COMMENT> <NL> if ( x > y ) : <NEWLINE> <INDENT> gcd = x <NEWLINE> t = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = y <NEWLINE> t = x <NEWLINE> <DEDENT> while ( t > 0 ) : <NEWLINE> <INDENT> tmp = gcd % t <NEWLINE> gcd = t <NEWLINE> t = tmp <NEWLINE> <COMMENT> <NL> <DEDENT> lcm = x * y / gcd <NEWLINE> print str ( gcd ) + <STRING> + str ( lcm ) <NEWLINE> <DEDENT>
def readint ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> yield map ( int , line . split ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> [ x , y ] = [ max ( x , y ) , min ( x , y ) ] <NEWLINE> z = x % y <NEWLINE> while z > 0 : <NEWLINE> <INDENT> [ x , y , z ] = [ y , z , x % y ] <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> for [ x , y ] in readint ( ) : <NEWLINE> <INDENT> GCD = gcd ( x , y ) <NEWLINE> mx = x / GCD <NEWLINE> print GCD , mx * y <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , sorted ( raw_input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> for i in range ( a , 1 , - 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> GCD = i <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if ( b * i ) % a == 0 : <NEWLINE> <INDENT> LCM = b * i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , [ GCD , LCM ] ) ) [ : - 1 ] <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> i = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print gcd ( * i ) , lcm ( * i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def euc ( li ) : <NEWLINE> <INDENT> if ( li [ 0 ] == 0 or li [ 1 ] == 0 ) : <NEWLINE> <INDENT> return li [ 1 ] <NEWLINE> <DEDENT> return euc ( ( li [ 0 ] - li [ 1 ] , li [ 1 ] ) if li [ 0 ] > li [ 1 ] else ( li [ 1 ] - li [ 0 ] , li [ 0 ] ) ) <NEWLINE> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> [ a , b ] = [ int ( x ) for x in line . split ( ) ] <NEWLINE> gcd = euc ( [ a , b ] ) <NEWLINE> print gcd , a * b / gcd <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> def gcd ( a , b ) : <NEWLINE> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( b , a % b ) <NEWLINE> <DEDENT> g = gcd ( a , b ) <NEWLINE> l = a * b / g <NEWLINE> print g , l <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> small , large = sorted ( int ( n ) for n in line . split ( ) ) <NEWLINE> for i in ( n for n in xrange ( small , 0 , - 1 ) if not small % n ) : <NEWLINE> <INDENT> if not large % i : <NEWLINE> <INDENT> gcd = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( 2 , small + 1 ) : <NEWLINE> <INDENT> if not i * large % small : <NEWLINE> <INDENT> lcm = i * large <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( gcd , lcm ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> temp = [ ] <NEWLINE> largest = 1 <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b = [ int ( x ) for x in line . split ( ) ] <NEWLINE> if a > b : <NEWLINE> <INDENT> x , y = a , b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = b , a <NEWLINE> <DEDENT> i = x <NEWLINE> while i > 1 : <NEWLINE> <INDENT> if ( x % i ) == 0 and ( y % i ) == 0 : <NEWLINE> <INDENT> x = x / i <NEWLINE> y = y / i <NEWLINE> largest *= i <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> smallest = largest * ( a / largest ) * ( b / largest ) <NEWLINE> print ( <STRING> % ( largest , smallest ) ) <NEWLINE> largest = 1 <NEWLINE> <DEDENT>
<INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> list = [ int ( x ) for x in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> list . sort ( lambda x , y : y - x ) <NEWLINE> gcd = lcm = 0 <NEWLINE> m = list [ 0 ] <NEWLINE> n = list [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> r = m % n <NEWLINE> if r == 0 : <NEWLINE> <INDENT> gcd = n <NEWLINE> break <NEWLINE> <DEDENT> m = n <NEWLINE> n = r <NEWLINE> <DEDENT> lcm = list [ 0 ] * list [ 1 ] / gcd <NEWLINE> print ( str ( gcd ) + <STRING> + str ( lcm ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> def gcd ( a , b ) : <NEWLINE> <INDENT> while a % b : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return b <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> return a * b / gcd ( a , b ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a , b = max ( a , b ) , min ( a , b ) <NEWLINE> print gcd ( a , b ) , lcm ( a , b ) <NEWLINE> <DEDENT>
def gcd ( li ) : <NEWLINE> <INDENT> a = max ( li ) <NEWLINE> b = min ( li ) <NEWLINE> while b > 0 : <NEWLINE> <INDENT> a , b = b , a % b <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def lcm ( li ) : <NEWLINE> <INDENT> return li [ 0 ] * li [ 1 ] / gcd ( li ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> li = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( <STRING> % ( gcd ( li ) , lcm ( li ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b = sorted ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> gcd = 1 <NEWLINE> d = 2 <NEWLINE> while a >= d : <NEWLINE> <INDENT> amod , bmod = a % d , b % d <NEWLINE> if amod == 0 and bmod == 0 ; <NEWLINE> <INDENT> gcd *= d <NEWLINE> a , b = a / d , b / d <NEWLINE> d = 2 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> lcm = gcd * a * b <NEWLINE> print gcd , lcm <NEWLINE> <DEDENT>
import sys <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> return gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> r = [ list ( map ( int , line . split ( ) ) ) for line in sys . stdin ] <NEWLINE> for i in r : <NEWLINE> <INDENT> o = gcd ( i [ 0 ] , i [ i ] ) <NEWLINE> p = i [ 0 ] * i [ 1 ] / o <NEWLINE> print ( o , p ) <NEWLINE> <NL> <DEDENT>
def pd ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> ans = [ ] <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> while n % i == 0 : <NEWLINE> <INDENT> n /= i <NEWLINE> ans . append ( i ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> if n > 1 : <NEWLINE> <INDENT> ans . append ( n ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> def gcd ( a , b ) : <NEWLINE> <INDENT> gcd = 1 <NEWLINE> pd_a = pd ( a ) <NEWLINE> pd_b = pd ( b ) <NEWLINE> for i in pd_a : <NEWLINE> <INDENT> if i in pd_b : <NEWLINE> <INDENT> pd_b . remove ( i ) <NEWLINE> gcd *= i <NEWLINE> <DEDENT> <DEDENT> return int ( gcd ) <NEWLINE> <NL> <DEDENT> def lcm ( a , b ) : <NEWLINE> <INDENT> lcm = a <NEWLINE> pd_a = pd ( a ) <NEWLINE> pd_b = pd ( b ) <NEWLINE> for i in pd_a : <NEWLINE> <INDENT> if i in pd_b : <NEWLINE> <INDENT> pd_b . remove ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in pd_b : <NEWLINE> <INDENT> lcm *= j <NEWLINE> <DEDENT> return int ( lcm ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if not s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a , b = [ int ( i ) for i in s . split ( <STRING> ) ] <NEWLINE> print ( gcd ( a , b ) , lcm ( a , b ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> global gcd <NEWLINE> if b == 0 : <NEWLINE> <INDENT> gcd = a : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd = gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> gcd = 1 <NEWLINE> lcm = 1 <NEWLINE> a , b = map ( int , line . split ( ) ) <NEWLINE> gcd ( a , b ) <NEWLINE> lcm = a * b / gcd / gcd <NEWLINE> print <STRING> % ( gcd , lcm ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> from fractions import gcd <NEWLINE> [ print ( <STRING> . format ( gcd ( k [ 0 ] , k [ 1 ] ) , ( k [ 0 ] * k [ 1 ] ) // gcd ( k [ 0 ] , k [ 1 ] ) ) ) for i in sys . stdin for k in [ [ int ( j ) for j in i . split ( ) ] ] ] <NEWLINE>
mport sys <NEWLINE> <NL> a = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( line ) <NEWLINE> <NL> <DEDENT> for n in a : <NEWLINE> <INDENT> inl = n . split ( ) <NEWLINE> num1 = int ( inl [ 0 ] ) <NEWLINE> check = 1 <NEWLINE> list = [ ] <NEWLINE> while check <= math . sqrt ( num1 ) : <NEWLINE> <INDENT> if num1 % check == 0 : <NEWLINE> <INDENT> list . append ( check ) <NEWLINE> <DEDENT> check += 1 <NEWLINE> <DEDENT> list . sort ( ) <NEWLINE> list . reverse ( ) <NEWLINE> num2 = int ( inl [ 1 ] ) <NEWLINE> for i in list : <NEWLINE> <INDENT> if num2 % i == 0 : <NEWLINE> <INDENT> gud = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> lcm = num1 * num2 / gud <NEWLINE> print gud , lcm <NEWLINE> <DEDENT>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> tmp = sys . stdin . readline ( ) <NEWLINE> while tmp : <NEWLINE> <INDENT> tmp = sys . stdin . readline ( ) . split ( <STRING> ) <NEWLINE> a = 1 <NEWLINE> b = 2 <NEWLINE> if a > b : <NEWLINE> <INDENT> c = a <NEWLINE> d = b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = b <NEWLINE> d = a <NEWLINE> <NL> <NL> <NL> <DEDENT> tmp = sys . stdin . readline ( ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def intinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def get_gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : return get_gcd ( y , x ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if y == 0 : return x <NEWLINE> return get_gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> data . append ( line . split ( ) ) <NEWLINE> <NL> <DEDENT> N = len ( data ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( data [ i ] [ 0 ] ) ; b = int ( data [ i ] [ 1 ] ) <NEWLINE> gcd = get_gcd ( a , b ) <NEWLINE> lcm = ( a // gcd ) * b <NEWLINE> print ( <STRING> % ( a , b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from math import gcd <NEWLINE> from sys import stdin <NEWLINE> <NL> for line in stdin : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in line . split ( ) ] <NEWLINE> g = gcd ( a , b ) <NEWLINE> print ( g , int ( a * b / g ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> a1 = a <NEWLINE> b1 = b <NEWLINE> while b != 0 : <NEWLINE> <INDENT> c = a % b <NEWLINE> a = b <NEWLINE> b = c <NEWLINE> <DEDENT> print ( a , a1 * b1 // a ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def calc ( a , b ) : <NEWLINE> <INDENT> yakusuu = [ ] <NEWLINE> for i in range ( 1 , a + 1 ) : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> yakusuu . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> maxi = 1 <NEWLINE> for j in yakusuu : <NEWLINE> <INDENT> if b % j == 0 : <NEWLINE> <INDENT> maxi = j <NEWLINE> <NL> <DEDENT> <DEDENT> mini = maxi * a / maxi * b / maxi <NEWLINE> print maxi , int ( mini ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> a , b = b , a <COMMENT> <NEWLINE> <DEDENT> calc ( a , b ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def isprime ( n ) : <NEWLINE> <INDENT> for i in xrange ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> outList = [ ] <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> List = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> [ a , b ] = List <NEWLINE> <NL> <COMMENT> <NL> LCM = 1 <NEWLINE> for i in xrange ( 2 , min ( a , b ) ) : <NEWLINE> <INDENT> if not isprime ( i ) : continue <NEWLINE> while ( a % i == 0 and b % i == 0 ) : <NEWLINE> <INDENT> LCM *= i <NEWLINE> a /= i <NEWLINE> b /= i <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> GCD = List [ 0 ] * b <NEWLINE> <NL> print LCM , GCD <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def gcd ( m , n ) : <NEWLINE> <INDENT> r = m % n <NEWLINE> if r == 0 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( n , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> m = max ( a , b ) <NEWLINE> n = min ( a , b ) <NEWLINE> print ( gcd ( m , n ) m * n // gcd ( m , n ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def gcm ( a , b ) : <NEWLINE> <INDENT> if a < b : a , b = b , a <NEWLINE> if ( a % b == 0 ) : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcm ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for s in stdin : <NEWLINE> <INDENT> a , b = map ( int , s . split ( ) ) <NEWLINE> c = gcm ( a , b ) <NEWLINE> print <STRING> % ( c , a / c * b ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> lines = input ( ) <NEWLINE> print ( lines . reverse ( ) ) <NEWLINE>
<INDENT> print ( input ( ) [ : : - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> l = line . rstrip ( <STRING> ) . split ( <STRING> ) <NEWLINE> l . reverse ( ) <NEWLINE> print <STRING> . join ( l ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> seq = raw_input ( ) . strip ( ) <NEWLINE> print seq [ : : - 1 ] <NEWLINE> <DEDENT>
line = input ( ) <NEWLINE> reversed ( line ) <NEWLINE> print line <NEWLINE>
str1 = raw_input ( ) print <STRING> . join ( reversed ( str1 ) ) <NEWLINE>
print ( input ( ) [ : : - 3 ] ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> IN = input ( ) <NEWLINE> if IN == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( IN [ : : - 1 ] ) <NEWLINE> <DEDENT>
string = input ( <STRING> ) <NEWLINE> size = len ( string ) <NEWLINE> st = [ ] <NEWLINE> for i in range ( size ) : <NEWLINE> <INDENT> st . append ( string ( size - i ) ) <NEWLINE> <DEDENT> print ( st ) <NEWLINE>
print ( imput ( ) [ : : - 1 ] ) <NEWLINE>
<NL> line = raw_input ( ) <NEWLINE> <NL> print line . reverse ( ) <NEWLINE>
date = str ( input ( ) ) . reverse ( ) <NEWLINE> print ( date ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> res = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> res += s [ len ( s ) - i - 1 ] <NEWLINE> <DEDENT> print res <NEWLINE> <DEDENT>
print ( input [ : : - 1 ] ) <NEWLINE>
text = raw_input ( <STRING> ) <NEWLINE> n = len ( text ) <NEWLINE> rev = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> rev . append ( text [ ( n - 1 ) - i ] ) <NEWLINE> <DEDENT> ans = <STRING> . join ( rev ) <NEWLINE> print ans <NEWLINE>
s = raw_input ( ) <NEWLINE> s . reverse ( ) <NEWLINE> print s [ : : - 1 ] <NEWLINE>
import sys <NEWLINE> s = sys . stdin . readline ( ) <NEWLINE> print s [ : : - 1 ] <NEWLINE>
line = input ( ) <NEWLINE> print ( line [ len ( line ) , 0 , - 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> print sys . stdin . read ( ) [ : : - 1 ] <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> s = sys . stdin . readline ( ) <NEWLINE> print s [ : : - 1 ] <NEWLINE>
print ( input ( ) . reversed ) <NEWLINE>
import sys <NEWLINE> <NL> rawinput = raw_input ( ) ; <NEWLINE> <NL> strlist = [ ] <NEWLINE> <NL> for temp in rawinput : <NEWLINE> <INDENT> strlist . append ( temp ) <NEWLINE> <NL> <DEDENT> strlist . reverse ( ) <NEWLINE> <NL> for temp in strlist : <NEWLINE> <INDENT> sys . stdout . write ( temp ) <NEWLINE> <DEDENT>
import argparse <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> <NL> parser = argparse . ArgumentParser ( ) <NEWLINE> parser . add_argument ( <STRING> , help = <STRING> ) <NEWLINE> args = parser . parse_args ( ) <NEWLINE> <NL> if args . filename : <NEWLINE> <INDENT> with open ( args . filename ) as f : <NEWLINE> <INDENT> str = f . read ( ) <NEWLINE> str = str [ : : - 1 ] <NEWLINE> print ( str ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> for i in range ( 1 ) : <NEWLINE> <INDENT> print ( input ( ) [ : : - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> string = <STRING> <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> string = line <NEWLINE> <NL> <DEDENT> print string [ : : - 1 ] <NEWLINE>
print raw input ( ) [ : : - 1 ] <NEWLINE>
a = raw_input ( ) <NEWLINE> [ : : - 1 ] <NEWLINE> print a <NEWLINE>
print ( input ( ) . reverse ( ) ) <NEWLINE>
<COMMENT> <NL> <NL> sentence = input ( ) <NEWLINE> sentence . __reversed__ ( ) <NEWLINE> print ( sentence ) <NEWLINE>
while True : <NEWLINE> <INDENT> st = list ( input ( ) ) <NEWLINE> if len ( st ) == 0 : break <NEWLINE> print ( <STRING> . join ( reversed ( st ) ) ) <NEWLINE> <DEDENT>
line = raw_input ( ) <NEWLINE> print <STRING> . join ( reversed ( list ( raw_input ( ) ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> print ( sys . stdin [ : : - 1 ] ) <NEWLINE>
<NL> <NL> import sys <NEWLINE> <NL> <NL> def str_reverse ( str ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for c in str : <NEWLINE> <INDENT> r . insert ( 0 , c ) <NEWLINE> <DEDENT> return <STRING> . join ( r ) <NEWLINE> <NL> <NL> <DEDENT> str = sys . stdin . readline ( ) <NEWLINE> <NL> print str_reverse ( str ) <NEWLINE>
print input ( ) [ : : - 1 ] <NEWLINE>
x = raw_input ( ) <NEWLINE> <NL> n = 100000 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> n *= 1.05 <NEWLINE> mod = n % 1000 <NEWLINE> if mod != 0 : <NEWLINE> <INDENT> n = n + 1000 - mod <NEWLINE> <DEDENT> x -= 1 <NEWLINE> <NL> <DEDENT> print ( int ( n ) ) <NEWLINE>
<INDENT> import math <NEWLINE> def int_ceil ( src , range ) : <NEWLINE> <INDENT> return int ( math . ceil ( src / float ( range ) ) * range ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> week = int ( input ( ) ) <NEWLINE> debt = 100000 <NEWLINE> for _ in range ( week ) : <NEWLINE> <INDENT> risi = debt * 0.05 <NEWLINE> debt = int_ceil ( debt + risi , 1000 ) <NEWLINE> <DEDENT> print ( debt ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> debt = 100000 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> debt = debt * 1.05 <NEWLINE> round = debt % 1000 <NEWLINE> if round != 0 : <NEWLINE> <INDENT> debt = ( debt // 1000 + 1 ) * 1000 <NEWLINE> <DEDENT> <DEDENT> print ( int ( debt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> result = 100000 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> result = result * 1.05 <NEWLINE> if result % 1000 == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = result - ( result % 1000 ) + 1000 <NEWLINE> result = result ( int ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE>
import math <NEWLINE> debt = 100000 <NEWLINE> for x in range ( 0 , int ( input ( ) ) ) : <NEWLINE> <INDENT> debt = math . ceil ( debt * 1.05 , - 3 ) <NEWLINE> <NL> <DEDENT> print ( int ( debt ) ) <NEWLINE>
n = input ( ) <NEWLINE> loan = 10 ** 5 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> loan += loan * 0.05 <NEWLINE> if loan % 1000 != 0 : <NEWLINE> <INDENT> loan -= loan % 1000 <NEWLINE> loan += 10 ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> loan -= loan % 1000 <NEWLINE> <DEDENT> <DEDENT> print ( int ( loan ) <NEWLINE>
ef Round ( ip , dg ) : <COMMENT> <NEWLINE> <INDENT> ip = ip / 10 ** dg <NEWLINE> if ( ip - int ( ip ) != 0 ) : <NEWLINE> <INDENT> return ( int ( ip ) + 1 ) * 10 ** dg <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return int ( ip ) * 10 ** dg <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> sum = 100000 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> sum = Round ( sum * 1.05 ) <NEWLINE> <DEDENT> print ( sum ) <NEWLINE>
import math <NEWLINE> s = int ( imput ( ) ) <NEWLINE> m = 100000 <NEWLINE> for i in range ( 1 : s ) : <NEWLINE> <INDENT> m = m . ceil ( ( m * 1.05 ) / 1000 ) * 1000 <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE>
import math <NEWLINE> debt = 100000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> debt = math . ceil ( debt * 1.05 / 1000 ) * 1000 <NEWLINE> <DEDENT> print int ( debt ) <NEWLINE>
import math <NEWLINE> debt = 100000 <NEWLINE> n = int ( raw_inpu ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> debt = math . ceil ( debt * 1.05 , 3 ) <NEWLINE> <DEDENT> print debt <NEWLINE>
n = input ( ) <NEWLINE> ans = 100000 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans *= 1.05 <NEWLINE> if ( ans % 1000 ) != 0 : <NEWLINE> <DEDENT>
import math <NEWLINE> price = 100000.0 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> price = ceil ( ( price * 1.05 ) / 1000 ) * 1000 <NEWLINE> <DEDENT>
import math <NEWLINE> for i in range ( int ( input ( n ) ) ) : <NEWLINE> <INDENT> n = math . ceil ( ( n * 1.05 ) / 1000 ) * 1000 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> inp = input ( ) <NEWLINE> x = 100000 <NEWLINE> for i in xrange ( inp ) : <NEWLINE> <INDENT> x = x * 1.05 <NEWLINE> if int ( x % 1000 ) != 0 : <NEWLINE> <INDENT> x += 1000 - int ( x % 1000 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print int ( x ) <NEWLINE>
from math import ceil <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( ( int ( ceil ( 10 * ( 1.05 ) ** n ) ) * 10000 ) <NEWLINE>
n = input ( ) <NEWLINE> a = 100000 <NEWLINE> while x in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> a * 1.05 <NEWLINE> a / 1000 * 1000 <NEWLINE> print a <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = 100 <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r = math . ceil ( r * 1.05 ) <NEWLINE> <DEDENT> print ( r * 1000 ) <NEWLINE>
import sys <NEWLINE> for n in sys . stdin : print len ( [ None for a in range ( 10 ) for b in range ( 10 ) for c in range ( 10 ) for d in range ( 10 ) if a + b + c + d == N ] ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> sum = [ 0 ] * 37 <NEWLINE> for a in range ( 10 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> sum [ a + b + c + d ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> print sum [ int ( line ) ] <NEWLINE> <DEDENT>
import sys <NEWLINE> a = [ 0 ] * 51 <NEWLINE> for i in range ( 51 ) : <NEWLINE> <INDENT> a [ i ] = sum ( [ 1 for a in x for b in x for c in x for d in x if a + b + c + d == e ] ) ) <NEWLINE> <DEDENT> for e in sys . stdin : <NEWLINE> <INDENT> print ( a [ int ( e ) ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> s = range ( 0 , 10 ) <NEWLINE> chk = list ( itertools . product ( s , repeat = 4 ) ) <NEWLINE> for j in sys . stdin : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for k in chk : <NEWLINE> <INDENT> if sum ( k ) == int ( j ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def count_pattern ( i ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> for a in xrange ( 10 ) : <NEWLINE> <INDENT> for b in xrange ( 10 ) : <NEWLINE> <INDENT> for c in xrange ( 10 ) : <NEWLINE> <INDENT> for d in xrange ( 10 ) : <NEWLINE> <INDENT> if ( a + b + c + d ) == i : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return n <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print count_pattern ( int ( s ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> x = 0 <NEWLINE> if n < 37 : <NEWLINE> <INDENT> for a in range ( 10 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> if a + b + c + d == n : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print x <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def count ( num ) : <NEWLINE> <INDENT> l1 = [ ] <NEWLINE> for a in range ( 10 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> l1 . append ( [ a , b , c , d ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> l1 = list ( filter ( lambda x : sum ( x ) == num , l1 ) ) <NEWLINE> return ( len ( l1 ) ) <NEWLINE> <DEDENT> import sys <NEWLINE> length = len ( sys . stdin . readlines ( ) ) <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> print ( count ( int ( input ( ) ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> for l in range ( 10 ) : <NEWLINE> <INDENT> if i + j + k + l == n : <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> def main ( num ) : <NEWLINE> <INDENT> if num >= 19 : <NEWLINE> <INDENT> num = 19 - num + 17 <NEWLINE> <DEDENT> res = 1 <NEWLINE> gro1 = 3 <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> if i == num : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> if i == 0 : <NEWLINE> <INDENT> gro2 = 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gro2 += 1 <NEWLINE> <DEDENT> res += gro1 <NEWLINE> gro1 += gro2 <NEWLINE> <NL> <DEDENT> for i in range ( 8 , 19 ) : <NEWLINE> <INDENT> if i == num : <NEWLINE> <INDENT> return res <NEWLINE> <DEDENT> gro2 -= 3 <NEWLINE> res += gro1 <NEWLINE> gro1 += gro2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( main ( ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> counter = 0 <NEWLINE> for a in range ( 10 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> if a + b + c + d == n : <NEWLINE> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( counter ) <NEWLINE> <DEDENT>
lst = [ 0 for i in range ( 50 ) ] <NEWLINE> for a in range ( 10 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> lst [ a + b + c + d ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while i : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( lst [ int ( input ( ) ) ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> if n > 36 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> elif n == 36 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> b = n <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if n - i == 0 : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> if n - i - j == 0 : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <COMMENT> <NL> break <NEWLINE> <DEDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> b = n - i - j - k <NEWLINE> if b >= 0 and b <= 9 : <NEWLINE> <INDENT> a = a + 1 <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <DEDENT> elif b > 9 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT> return 0 <NEWLINE>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print len ( = [ 1 for i in range ( 10 ) for j in range ( 10 ) for k in range ( 10 ) for l in range ( 10 ) if i + j + k + l == n ] <NEWLINE> <DEDENT>
import sys <NEWLINE> s = [ 0 ] * 51 <NEWLINE> for a in range ( 10 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> s [ a + b + c + d ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for l in sys . stdin : print x [ int ( l ) ] <NEWLINE>
import sys <NEWLINE> values = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> values . append ( int ( line ) ) <NEWLINE> <DEDENT> ans = [ 1 for i in range ( 10 ) for j in range ( 10 ) for k in range ( 10 ) for l in range ( 10 ) if n == i + j + k + l ] <NEWLINE> print ( ans . count ( 1 ) ) <NEWLINE>
import sys <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for a in xrange ( 10 ) : <NEWLINE> <INDENT> for b in xrange ( 10 ) : <NEWLINE> <INDENT> for c in xrange ( 10 ) : <NEWLINE> <INDENT> for d in xrange ( 10 ) : <NEWLINE> <INDENT> if a + b + c + d == N : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
<NL> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> <NL> <NL> count = 0 <NEWLINE> for a in range ( 10 ) : <NEWLINE> <INDENT> for b in range ( 10 ) : <NEWLINE> <INDENT> for c in range ( 10 ) : <NEWLINE> <INDENT> for d in range ( 10 ) : <NEWLINE> <INDENT> if a + b + c + d == x : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <NL> <DEDENT> except ValueError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> for l in range ( 10 ) : <NEWLINE> <INDENT> if i + j + k + l == n : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> l = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> res = 0 <NEWLINE> for element in itertools . combinations_with_replacement ( l , 5 ) : <NEWLINE> <INDENT> if sum ( element ) == N : <NEWLINE> res += 1 <NEWLINE> <DEDENT> print res <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def keta_sum ( n ) : <NEWLINE> <INDENT> a = int ( n * 0.001 ) <NEWLINE> b = int ( n * 0.01 ) % 10 <NEWLINE> c = int ( n * 0.1 ) % 10 <NEWLINE> d = n % 10 <NEWLINE> return a + b + c + d <NEWLINE> <NL> <DEDENT> while 2 > 1 : <NEWLINE> <INDENT> n_try = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for n in range ( 10000 ) : <NEWLINE> <INDENT> if n_try == keta_sum ( n ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> for j in range ( 1 , 10 ) : <NEWLINE> <INDENT> for k in range ( 1 , 10 ) : <NEWLINE> <INDENT> for l in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i + j + k + l == n : c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT> exception : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> for n in sys . stdin . readline ( ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for a in xrange ( 10 ) : <NEWLINE> <INDENT> for b in xrange ( 10 ) : <NEWLINE> <INDENT> for c in xrange ( 10 ) : <NEWLINE> <INDENT> for d in xrange ( 10 ) : <NEWLINE> <INDENT> if a + b + c + d == int ( n ) : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ret <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> cnt = 0 ; <NEWLINE> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> for j in range ( 0 , 10 ) : <NEWLINE> <INDENT> for k in range ( 0 , 10 ) : <NEWLINE> <INDENT> for l in range ( 0 , 10 ) : <NEWLINE> <INDENT> if n == i + j + k + l : cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print cnt <NEWLINE> <DEDENT>
def get_input ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield <STRING> . join ( raw_input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ar = [ 0 ] * 50 <NEWLINE> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> for k in range ( 10 ) : <NEWLINE> <INDENT> for l in range ( 10 ) : <NEWLINE> <INDENT> ar [ i + j + k + l ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in list ( get_input ( ) ) : <NEWLINE> <NL> <INDENT> print ar [ int ( a ) ] <NEWLINE> <DEDENT>
import itertools <NEWLINE> while True : <NEWLINE> <INDENT> try : n = int ( input ( ) ) <NEWLINE> except EOEError : break <NEWLINE> ans = 0 <NEWLINE> for ( i , j , k ) in itertools . product ( range ( 10 ) , range ( 10 ) , range ( 10 ) ) : <NEWLINE> <INDENT> ans += ( 0 <= n - ( i + j + k ) <= 9 ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> e = int ( e ) ; x = range ( 10 ) ; ff = 0 <NEWLINE> <DEDENT> ff += 1 for a in x for b in x for c in x for d in x if a + b + c + d == e <NEWLINE> print ( ff ) <NEWLINE>
while True : <NEWLINE> <INDENT> ans = 0 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> for j in xrange ( 10 ) : <NEWLINE> <INDENT> for k in xrange ( 10 ) : <NEWLINE> <INDENT> for l in xrange ( 10 ) : <NEWLINE> <INDENT> if i + j + k + l == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
import sys <NEWLINE> m = 10 ** 6 ; a = [ 1 ] * m ; a [ 0 : 2 ] = 0 , 0 <NEWLINE> for i in range ( 2 , 999 ) : <NEWLINE> <INDENT> if a [ i ] > 0 : <NEWLINE> <INDENT> for j in range ( i * 2 , , i ) : a [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : a [ i ] += a [ i - 1 ] <NEWLINE> for e in sys . stdin : print ( a [ int ( e ) ] ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> DATA_NUM = 1000000 <NEWLINE> primes = [ 2 ] <NEWLINE> for i in range ( 3 , DATA_NUM ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for p in primes : <NEWLINE> <INDENT> if i % p == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> count = 0 <NEWLINE> while primes [ count ] <= int ( line ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> print count <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> primes = [ 2 , 3 ] <NEWLINE> for n in range ( 5 , 999999 , 2 ) : <NEWLINE> <INDENT> isprime = True <NEWLINE> for i in range ( len ( primes ) ) : <NEWLINE> <INDENT> if primes [ i ] ** 2 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % primes [ i ] == 0 : <NEWLINE> <INDENT> isprime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if isprime : <NEWLINE> <INDENT> primes . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> numbers = [ ] <NEWLINE> count = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> numbers . append ( int ( line ) ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> counts = [ ] <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> counts . append ( 0 ) <NEWLINE> <NL> <DEDENT> for prime in primes : <NEWLINE> <INDENT> if prime > 999999 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( count ) : <NEWLINE> <INDENT> if prime <= numbers [ i ] : <NEWLINE> <INDENT> counts [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for count in counts : <NEWLINE> <INDENT> print ( count ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> c = 0 <NEWLINE> ps = [ False for i in range ( n ) ] <NEWLINE> for i in xrange ( 2 , n ) : <NEWLINE> <INDENT> ps [ i ] = True <NEWLINE> <DEDENT> for i in xrange ( 2 , int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> if ps [ i ] : <NEWLINE> <INDENT> for j in xrange ( i ** 2 , n , i ) : <NEWLINE> <INDENT> ps [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> if ps [ i ] is True : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> nums = [ 1 ] * 1000000 <NEWLINE> nums [ : 2 ] = [ 0 , 0 ] <NEWLINE> <NL> cnt = 0 <NEWLINE> while cnt <= math . sqrt ( n ) : <NEWLINE> <INDENT> flg = nums [ cnt ] <NEWLINE> if flg == 1 : <NEWLINE> <INDENT> k = 2 <NEWLINE> while k * cnt <= n : <NEWLINE> <INDENT> nums [ k * cnt ] = 0 <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> <NL> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> print sum ( nums [ : n + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> def sieve ( n ) : <NEWLINE> <INDENT> num = [ 1 ] * n <NEWLINE> num [ 0 ] = num [ 1 ] = 0 <NEWLINE> for i in xrange ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if num [ i ] : <NEWLINE> <INDENT> for j in xrange ( i ** 2 , n , i ) : <NEWLINE> <INDENT> num [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return num . count ( 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> hoge = sieve ( int ( line ) ) <NEWLINE> print hoge <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> a = [ 0 , 0 ] + [ 1 ] * 10 ** 6 <NEWLINE> for i in range ( 999 ) : <NEWLINE> <INDENT> if a [ i ] : a [ i * 2 : : i ] = [ 0 for j in a [ i * 2 : : i ] ] <NEWLINE> <DEDENT> for e in sys . stdin : print ( int ( e ) - len ( [ i for i in li [ : int ( e ) + 1 ] if i ] ) ) <NEWLINE>
import sys , math <NEWLINE> def prime ( m ) : <NEWLINE> <INDENT> N = range ( 1 , m + 2 , 2 ) <NEWLINE> r = int ( m ** .5 ) <NEWLINE> h = len ( N ) <NEWLINE> N [ 0 ] = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> x = N [ i ] <NEWLINE> if x > r : break <NEWLINE> if x and i + x < h : N [ i + x : h : x ] = [ 0 ] * ( ( h - 1 - i - x ) / x + 1 ) <NEWLINE> <DEDENT> N [ 0 ] = 2 <NEWLINE> return filter ( None , N ) <NEWLINE> <DEDENT> A = map ( int , sys . stdin ) <NEWLINE> n = max ( A ) + 1 <NEWLINE> B = [ 0 ] * n <NEWLINE> for e in prime ( n ) : <NEWLINE> <INDENT> for i in range ( e , n ) : B [ i ] += 1 <NEWLINE> <DEDENT> for e in A : print B [ e ] <NEWLINE>
<COMMENT> <NL> <NL> prime_number_list = [ ] <NEWLINE> <NL> def is_prime ( target_num ) : <NEWLINE> <INDENT> if target_num in prime_number_list : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> i = 2 <NEWLINE> while i * i <= target_num : <NEWLINE> <INDENT> if target_num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def count_prime_numbers ( target_num_list ) : <NEWLINE> <INDENT> prime_count = 0 <NEWLINE> counted_num = 0 <NEWLINE> prime_count_map = { } <NEWLINE> for i in range ( 2 , target_num_list [ len ( target_num_list ) - 1 ] + 1 ) : <NEWLINE> <INDENT> if is_prime ( i ) : <NEWLINE> <INDENT> prime_number_list . append ( i ) <NEWLINE> prime_count += 1 <NEWLINE> <DEDENT> if i >= target_num_list [ counted_num ] : <NEWLINE> <INDENT> prime_count_map [ target_num_list [ counted_num ] ] = prime_count <NEWLINE> counted_num += 1 <NEWLINE> <DEDENT> <DEDENT> return prime_count_map <NEWLINE> <NL> <DEDENT> input_list = [ ] <NEWLINE> sorted_input_list = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> input_str = raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> input_list . append ( int ( input_str ) ) <NEWLINE> sorted_input_list . append ( int ( input_str ) ) <NEWLINE> <NL> <DEDENT> sorted_input_list . sort ( ) <NEWLINE> <NL> prime_counts = count_prime_numbers ( sorted_input_list ) <NEWLINE> <NL> for i in input_list : <NEWLINE> <INDENT> print prime_counts [ i ] <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> n = int ( i ) <NEWLINE> list = [ p for p in range ( 2 , n ) if 0 not in [ p % d for d in range ( 2 , p ) ] ] <NEWLINE> <NL> print len ( list ) <NEWLINE> <DEDENT>
import sys <NEWLINE> ifprime = [ 1 ] * ( 1000000 ) <NEWLINE> ifprime [ 0 ] = ifprime [ 1 ] = 0 <NEWLINE> a = 2 <NEWLINE> while a <= num : <NEWLINE> <INDENT> if ifprime [ a ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> b = a * a <NEWLINE> while b <= num : <NEWLINE> <INDENT> ifprime [ b ] = 0 <NEWLINE> b += a <NEWLINE> <DEDENT> <DEDENT> a += 1 <NEWLINE> <DEDENT> for n in sys . stdin : <NEWLINE> <INDENT> print sum ( ifprime [ : int ( n ) ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> prime = [ ] <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> isprime = 1 <NEWLINE> sqrt = int ( math . sqrt ( i ) ) <NEWLINE> for j in prime : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> isprime = 0 <NEWLINE> break <NEWLINE> <DEDENT> if j > sqrt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if isprime : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print len ( prime ) + 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> MAX = 999999 <NEWLINE> L = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 ] <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 2 : return True <NEWLINE> if n % 2 == 0 : return False <NEWLINE> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_prime_2 ( n ) : <NEWLINE> <INDENT> a = int ( n ** 0.5 ) <NEWLINE> for i in L : <NEWLINE> <INDENT> if i > a : return True <NEWLINE> if n % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def prime_count ( n ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> if n >= 2 : result += 1 <NEWLINE> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if is_prime_2 ( i ) : result += 1 <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def prime_list ( n ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if n >= 2 : result . append ( 2 ) <NEWLINE> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if is_prime ( i ) : result . append ( i ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> L2 = prime_list ( MAX ) <NEWLINE> <NL> def prime_count_2 ( n ) : <NEWLINE> <INDENT> for i , v in enumerate ( n ) : <NEWLINE> <INDENT> if n > v : return i <NEWLINE> <DEDENT> return len ( L2 ) <NEWLINE> <NL> <DEDENT> for n in sys . stdin : <NEWLINE> <INDENT> print ( prime_count_2 ( int ( n ) ) ) <NEWLINE> <DEDENT>
LIMIT = 10000000 <NEWLINE> <NL> isPrime = [ True for _ in range ( LIMIT ) ] <NEWLINE> <NL> isPrime [ 0 ] = isPrime [ 1 ] = False <NEWLINE> <NL> for i in range ( 2 , int ( LIMIT ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if isPrime [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , LIMIT , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> countPrime = [ 0 for _ in range ( LIMIT ) ] <NEWLINE> <NL> for i in range ( 1 , LIMIT ) : <NEWLINE> <INDENT> countPrime [ i ] = countPrime [ i - 1 ] + isPrime [ i ] <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( countPrime [ n ] ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> isPrime = [ - 1 ] * ( n + 1 ) <NEWLINE> isPrime [ 0 ] , isPrime [ 1 ] = False , False <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> j = 2 <NEWLINE> while j * i <= n : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> isPrime [ j * i ] = False <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> isPrime [ i ] = True <NEWLINE> i = isPrime . index ( - 1 ) <NEWLINE> <DEDENT> ans . append ( isPrime . count ( True ) + isPrime . count ( - 1 ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for num in ans : <NEWLINE> <INDENT> print num <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> m = 999999 <NEWLINE> l = [ False ] * m <NEWLINE> l [ 1 ] = True <NEWLINE> l [ 2 ] = True <NEWLINE> for i in range ( 5 , m + 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 or i % 3 == 0 : continue <NEWLINE> for e in range ( 2 , int ( math . sqrt ( i ) + 1 ) ) : <NEWLINE> <INDENT> if i % e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l [ i - 1 ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : n = int ( input ( ) ) <NEWLINE> except : break <NEWLINE> print ( len ( [ i for i in l [ : n : ] if i ] ) ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> j = 0 <NEWLINE> n = input ( ) <NEWLINE> ans = [ 1 ] * ( n + 1 ) ; <NEWLINE> ans [ 0 ] = ans [ 1 ] = 0 ; <NEWLINE> for i in xrange ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if i * 2 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans [ i ] != 0 : <NEWLINE> <INDENT> for j in xrange ( 2 * i , n + 1 , i ) : <NEWLINE> <INDENT> ans [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in xrange ( 2 * 2 , n + 1 , 2 ) : <NEWLINE> <INDENT> ans [ k ] = 0 <NEWLINE> <DEDENT> print sum ( ans ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> era = [ True ] * ( n ) <NEWLINE> for i in xrange ( 2 , n ) : <NEWLINE> <INDENT> if ( era [ i - 1 ] ) : <NEWLINE> <INDENT> for j in xrange ( i * i - 1 , n , i ) : <NEWLINE> <INDENT> era [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print era [ 1 : n ] . count ( True ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
- - - - : - - - F1 * scratch * All L1 ( Fundamental ) - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <NEWLINE> Loading subst - jis ... done <NEWLINE> import math <NEWLINE> <NL> r = 999999 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 for i in range ( r ) ] <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * ( i + 1 ) - 1 , r , i + 1 ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> print sum ( p [ : n ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> R = max ( n ) + 1 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * R <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> i = 2 <NEWLINE> while i * i <= R : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i : : i ] = [ 0 for x in range ( 2 * i , R , i ) ] <NEWLINE> <DEDENT> i += p [ i + 1 : ] . index ( 1 ) + 1 <NEWLINE> <DEDENT> for i in n : <NEWLINE> <INDENT> print sum ( p [ : i + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from bisect import bisect_right <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> max_number = 1000000 <NEWLINE> prime_flag_list = [ True ] * max_number <NEWLINE> <NL> <COMMENT> <NL> prime_flag_list [ 0 ] = False <NEWLINE> prime_flag_list [ 1 ] = False <NEWLINE> <NL> <COMMENT> <NL> prime_flag_list [ 4 : : 2 ] = [ False ] * len ( prime_flag_list [ 4 : : 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 3 , int ( max_number ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> prime_flag_list [ i * i : : i ] = [ False ] * len ( prime_flag_list [ i * i : : i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> prime_list = [ i for i in range ( 2 , max_number ) if prime_flag_list [ i ] ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> input = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print bisect . bisect_right ( prime_list , input ) <NEWLINE> <DEDENT>
def sieve ( n ) : <NEWLINE> <INDENT> a = range ( n ) <NEWLINE> a [ 0 ] , a [ 1 ] = None , None <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i ** 2 >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if a [ i ] is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i ** 2 , n , i ) : <NEWLINE> <INDENT> a [ j ] = None <NEWLINE> <DEDENT> <DEDENT> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] is not None : <NEWLINE> <INDENT> a [ j ] = a [ i ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return a [ 0 : j ] <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> print len ( sieve ( int ( raw_input ( ) ) + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
def sieve ( n ) : <NEWLINE> <INDENT> p = [ True ] * ( n + 1 ) <NEWLINE> p [ 0 ] = p [ 1 ] = False <NEWLINE> for i in range ( 2 , n + 1 , 2 ) : <NEWLINE> <INDENT> if p [ i ] == True : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> if n < 2 : return 0 <NEWLINE> c = 1 <NEWLINE> for i in range ( 3 , n + 1 , 2 ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> p = sieve ( 1e6 ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( solve ( n ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> r = 999999 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> prime = [ 1 for i in range ( r ) ] <NEWLINE> prime [ 0 ] = 0 <NEWLINE> for i in range ( 2 , r / 2 ) : <NEWLINE> <INDENT> prime [ 2 * i - 1 ] = 0 <NEWLINE> <DEDENT> for i in range ( 3 , sqrt , 2 ) : <NEWLINE> <INDENT> for j in range ( 2 * i , r , i ) <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> print sum ( prime [ : n ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> a = [ 1 ] * 500000 <NEWLINE> for i in range ( 3 , 999 , 2 ) : <NEWLINE> <INDENT> x = i * i ; if a [ i ] : a [ x // 2 : : i ] = [ 0 ] * len ( a [ x // 2 : : i ] ) <NEWLINE> <DEDENT> for e in map ( int , sys . stdin ) : print ( [ e - 1 , sum ( a [ : ( e + 1 ) // 2 ] ) + 1 ] [ e > 4 ] ) <NEWLINE>
import sys <NEWLINE> <INDENT> lalala = 1000000 // 6 + 1 <NEWLINE> <DEDENT> f = [ 1 , 0 , 0 , 0 , 1 , 0 ] * lalala <NEWLINE> f = [ 0 , 0 , 1 , 1 ] + f [ 3 : - 2 ] <NEWLINE> <NL> i = 5 <NEWLINE> while i < 1000 : <NEWLINE> <INDENT> if f [ i ] == 1 : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j <= 1000000 : <NEWLINE> <INDENT> f [ j ] = 0 <NEWLINE> j += i + i <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> for n in sys . stdin : <NEWLINE> <INDENT> i = int ( n ) <NEWLINE> print ( sum ( f [ : i + 1 ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> lst = [ 0 for _ in xrange ( 999999 ) ] <NEWLINE> <NL> def is_prime ( num ) : <NEWLINE> <INDENT> if num % 2 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> for x in range ( 3 , int ( num ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if num % x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> lst [ 1 ] = 0 <NEWLINE> lst [ 2 ] = 1 <NEWLINE> for idx in range ( 3 , len ( lst ) ) : <NEWLINE> <INDENT> lst [ idx ] = is_prime ( idx ) + lst [ idx - 1 ] <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> print lst [ int ( line ) ] <NEWLINE> <DEDENT>
def prime ( n ) : <NEWLINE> <INDENT> seq = list ( range ( 2 , n + 1 ) ) <NEWLINE> while len ( seq ) > 0 : <NEWLINE> <INDENT> prime = seq . pop ( 0 ) <NEWLINE> yield prime <NEWLINE> seq = [ i for i in seq if not i % prime == 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> print len ( list ( prime ( n ) ) ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n , p = input ( ) , 0 <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for x in xrange ( 1 , n + 1 , 2 ) : <NEWLINE> <INDENT> for y in xrange ( 3 , int ( x ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> print p <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def prime_list ( n ) : <NEWLINE> <INDENT> limit = int ( n ** 0.5 ) + 1 <NEWLINE> lis = range ( 1 , n + 1 , 2 ) <NEWLINE> lis [ 0 ] = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if len ( lis ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = lis . pop ( 0 ) <NEWLINE> yield p <NEWLINE> if p <= limit : <NEWLINE> <INDENT> lis = [ x for x in lis if x % p != 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def primes_number ( n ) : <NEWLINE> <INDENT> primes = [ ] <NEWLINE> for p in prime_list ( n ) : <NEWLINE> <INDENT> primes . append ( p ) <NEWLINE> <DEDENT> return len ( primes ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> print primes_number ( n ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> <NL> def prime ( q ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in xrange ( 1 , q + 1 ) : <NEWLINE> <INDENT> if i == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if pow ( 2 , i - 1 , i ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for i in sys . stdin : <NEWLINE> <INDENT> x = int ( i ) <NEWLINE> print prime ( x ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def pi ( n ) : <NEWLINE> <INDENT> m = int ( math . sqrt ( n ) ) <NEWLINE> keys = [ n / i for i in range ( 1 , m + 1 ) ] <NEWLINE> keys += range ( keys [ - 1 ] - 1 , 0 , - 1 ) <NEWLINE> h = { i : i - 1 for i in keys } <NEWLINE> for i in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> if h [ i ] > h [ i - 1 ] : <NEWLINE> <INDENT> hp = h [ i - 1 ] <NEWLINE> i2 = i * i <NEWLINE> for j in keys : <NEWLINE> <INDENT> if j < i2 : break <NEWLINE> h [ j ] -= h [ j / i ] - hp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return h [ n ] <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> i = int ( raw_input ( ) ) <NEWLINE> print pi ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> m = 166666 ; s = [ 1 ] * m ; t = [ 1 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( 2 ) : <NEWLINE> <INDENT> if ( s [ i ] , t [ i ] ) [ j ] : <NEWLINE> <INDENT> k = 6 * i + [ 5 , 7 ] [ j ] ; n = [ i + k , k - i - 2 ] <NEWLINE> s [ n [ i ] : : k ] = [ 0 ] * len ( s [ n [ i ] : : k ] ) <NEWLINE> t [ n [ 1 - i ] : : k ] = [ 0 ] * len ( t [ n [ 1 - i ] : : k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for e in map ( int , sys . stdin ) : <NEWLINE> <INDENT> print ( [ e - 1 , sum ( s [ : ( e + 1 ) // 6 ] ) + sum ( t [ : ( e - 1 ) // 6 ] ) + 2 ] [ e > 3 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def judge_prime ( n ) : <NEWLINE> <INDENT> if n == 2 : return True <NEWLINE> if n < 2 : return False <NEWLINE> return pow ( 2 , n - 1 , n ) == 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> if judge_prime ( i + 1 ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def prime ( n ) : <NEWLINE> <INDENT> s = [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> p = [ ] <NEWLINE> while s [ 0 ] < n ** 0.5 : <NEWLINE> <INDENT> p . append ( s [ 0 ] ) <NEWLINE> for ss in s : <NEWLINE> <INDENT> if ss % p [ - 1 ] == 0 : <NEWLINE> <INDENT> s . remove ( ss ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> p . extend ( s ) <NEWLINE> return p <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> inp = [ int ( n ) for n in sys . stdin ] <NEWLINE> for n in inp : <NEWLINE> <INDENT> n_pn = len ( prime ( n ) ) <NEWLINE> print n_pn <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> r = max ( n ) + 1 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i + 1 : : i + 1 ] = [ 0 ] * range ( 2 * i + 1 , r , i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in n : <NEWLINE> <INDENT> print sum ( p [ : i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> for n in sys . stdin : <NEWLINE> <INDENT> prime = [ ] <NEWLINE> n = int ( n ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if all ( i % p != 0 for p in prime ) : <NEWLINE> <INDENT> prime += [ i ] <NEWLINE> <DEDENT> <DEDENT> print len ( prime ) <NEWLINE> <DEDENT>
rom bisect import bisect <NEWLINE> R = 1000000 <NEWLINE> p = [ 1 ] * R <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> p [ 4 : : 2 ] = [ 0 ] * len ( p [ 4 : : 2 ] ) <NEWLINE> for i in xrange ( 3 , int ( R ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ i * i : : i ] = [ 0 ] * len ( p [ i * i : : i ] ) <NEWLINE> <DEDENT> <DEDENT> prime = [ i for i in xrange ( 2 , R ) if p [ i ] ] <NEWLINE> while True : <NEWLINE> <INDENT> try : print bisect ( prime , input ( ) ) <NEWLINE> except : break <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> primes = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 , 1009 , 1013 , 1019 , 1021 , 1031 , 1033 , 1039 , 1049 , 1051 , 1061 , 1063 , 1069 , 1087 , 1091 , 1093 , 1097 , 1103 , 1109 , 1117 , 1123 , 1129 , 1151 , 1153 , 1163 , 1171 , 1181 , 1187 , 1193 , 1201 , 1213 , 1217 , 1223 , 1229 , 1231 , 1237 , 1249 , 1259 , 1277 , 1279 , 1283 , 1289 , 1291 , 1297 , 1301 , 1303 , 1307 , 1319 , 1321 , 1327 , 1361 , 1367 , 1373 , 1381 , 1399 , 1409 , 1423 , 1427 , 1429 , 1433 , 1439 , 1447 , 1451 , 1453 , 1459 , 1471 , 1481 , 1483 , 1487 , 1489 , 1493 , 1499 , 1511 , 1523 , 1531 , 1543 , 1549 , 1553 , 1559 , 1567 , 1571 , 1579 , 1583 , 1597 , 1601 , 1607 , 1609 , 1613 , 1619 , 1621 , 1627 , 1637 , 1657 , 1663 , 1667 , 1669 , 1693 , 1697 , 1699 , 1709 , 1721 , 1723 , 1733 , 1741 , 1747 , 1753 , 1759 , 1777 , 1783 , 1787 , 1789 , 1801 , 1811 , 1823 , 1831 , 1847 , 1861 , 1867 , 1871 , 1873 , 1877 , 1879 , 1889 , 1901 , 1907 , 1913 , 1931 , 1933 , 1949 , 1951 , 1973 , 1979 , 1987 , 1993 , 1997 , 1999 , 2003 , 2011 , 2017 , 2027 , 2029 , 2039 , 2053 , 2063 , 2069 , 2081 , 2083 , 2087 , 2089 , 2099 , 2111 , 2113 , 2129 , 2131 , 2137 , 2141 , 2143 , 2153 , 2161 , 2179 , 2203 , 2207 , 2213 , 2221 , 2237 , 2239 , 2243 , 2251 , 2267 , 2269 , 2273 , 2281 , 2287 , 2293 , 2297 , 2309 , 2311 , 2333 , 2339 , 2341 , 2347 , 2351 , 2357 , 2371 , 2377 , 2381 , 2383 , 2389 , 2393 , 2399 , 2411 , 2417 , 2423 , 2437 , 2441 , 2447 , 2459 , 2467 , 2473 , 2477 , 2503 , 2521 , 2531 , 2539 , 2543 , 2549 , 2551 , 2557 , 2579 , 2591 , 2593 , 2609 , 2617 , 2621 , 2633 , 2647 , 2657 , 2659 , 2663 , 2671 , 2677 , 2683 , 2687 , 2689 , 2693 , 2699 , 2707 , 2711 , 2713 , 2719 , 2729 , 2731 , 2741 , 2749 , 2753 , 2767 , 2777 , 2789 , 2791 , 2797 , 2801 , 2803 , 2819 , 2833 , 2837 , 2843 , 2851 , 2857 , 2861 , 2879 , 2887 , 2897 , 2903 , 2909 , 2917 , 2927 , 2939 , 2953 , 2957 , 2963 , 2969 , 2971 , 2999 , 3001 , 3011 , 3019 , 3023 , 3037 , 3041 , 3049 , 3061 , 3067 , 3079 , 3083 , 3089 , 3109 , 3119 , 3121 , 3137 , 3163 , 3167 , 3169 , 3181 , 3187 , 3191 , 3203 , 3209 , 3217 , 3221 , 3229 , 3251 , 3253 , 3257 , 3259 , 3271 , 3299 , 3301 , 3307 , 3313 , 3319 , 3323 , 3329 , 3331 , 3343 , 3347 , 3359 , 3361 , 3371 , 3373 , 3389 , 3391 , 3407 , 3413 , 3433 , 3449 , 3457 , 3461 , 3463 , 3467 , 3469 , 3491 , 3499 , 3511 , 3517 , 3527 , 3529 , 3533 , 3539 , 3541 , 3547 , 3557 , 3559 , 3571 , 3581 , 3583 , 3593 , 3607 , 3613 , 3617 , 3623 , 3631 , 3637 , 3643 , 3659 , 3671 , 3673 , 3677 , 3691 , 3697 , 3701 , 3709 , 3719 , 3727 , 3733 , 3739 , 3761 , 3767 , 3769 , 3779 , 3793 , 3797 , 3803 , 3821 , 3823 , 3833 , 3847 , 3851 , 3853 , 3863 , 3877 , 3881 , 3889 , 3907 , 3911 , 3917 , 3919 , 3923 , 3929 , 3931 , 3943 , 3947 , 3967 , 3989 , 4001 , 4003 , 4007 , 4013 , 4019 , 4021 , 4027 , 4049 , 4051 , 4057 , 4073 , 4079 , 4091 , 4093 , 4099 , 4111 , 4127 , 4129 , 4133 , 4139 , 4153 , 4157 , 4159 , 4177 , 4201 , 4211 , 4217 , 4219 , 4229 , 4231 , 4241 , 4243 , 4253 , 4259 , 4261 , 4271 , 4273 , 4283 , 4289 , 4297 , 4327 , 4337 , 4339 , 4349 , 4357 , 4363 , 4373 , 4391 , 4397 , 4409 , 4421 , 4423 , 4441 , 4447 , 4451 , 4457 , 4463 , 4481 , 4483 , 4493 , 4507 , 4513 , 4517 , 4519 , 4523 , 4547 , 4549 , 4561 , 4567 , 4583 , 4591 , 4597 , 4603 , 4621 , 4637 , 4639 , 4643 , 4649 , 4651 , 4657 , 4663 , 4673 , 4679 , 4691 , 4703 , 4721 , 4723 , 4729 , 4733 , 4751 , 4759 , 4783 , 4787 , 4789 , 4793 , 4799 , 4801 , 4813 , 4817 , 4831 , 4861 , 4871 , 4877 , 4889 , 4903 , 4909 , 4919 , 4931 , 4933 , 4937 , 4943 , 4951 , 4957 , 4967 , 4969 , 4973 , 4987 , 4993 , 4999 , 5003 , 5009 , 5011 , 5021 , 5023 , 5039 , 5051 , 5059 , 5077 , 5081 , 5087 , 5099 , 5101 , 5107 , 5113 , 5119 , 5147 , 5153 , 5167 , 5171 , 5179 , 5189 , 5197 , 5209 , 5227 , 5231 , 5233 , 5237 , 5261 , 5273 , 5279 , 5281 , 5297 , 5303 , 5309 , 5323 , 5333 , 5347 , 5351 , 5381 , 5387 , 5393 , 5399 , 5407 , 5413 , 5417 , 5419 , 5431 , 5437 , 5441 , 5443 , 5449 , 5471 , 5477 , 5479 , 5483 , 5501 , 5503 , 5507 , 5519 , 5521 , 5527 , 5531 , 5557 , 5563 , 5569 , 5573 , 5581 , 5591 , 5623 , 5639 , 5641 , 5647 , 5651 , 5653 , 5657 , 5659 , 5669 , 5683 , 5689 , 5693 , 5701 , 5711 , 5717 , 5737 , 5741 , 5743 , 5749 , 5779 , 5783 , 5791 , 5801 , 5807 , 5813 , 5821 , 5827 , 5839 , 5843 , 5849 , 5851 , 5857 , 5861 , 5867 , 5869 , 5879 , 5881 , 5897 , 5903 , 5923 , 5927 , 5939 , 5953 , 5981 , 5987 , 6007 , 6011 , 6029 , 6037 , 6043 , 6047 , 6053 , 6067 , 6073 , 6079 , 6089 , 6091 , 6101 , 6113 , 6121 , 6131 , 6133 , 6143 , 6151 , 6163 , 6173 , 6197 , 6199 , 6203 , 6211 , 6217 , 6221 , 6229 , 6247 , 6257 , 6263 , 6269 , 6271 , 6277 , 6287 , 6299 , 6301 , 6311 , 6317 , 6323 , 6329 , 6337 , 6343 , 6353 , 6359 , 6361 , 6367 , 6373 , 6379 , 6389 , 6397 , 6421 , 6427 , 6449 , 6451 , 6469 , 6473 , 6481 , 6491 , 6521 , 6529 , 6547 , 6551 , 6553 , 6563 , 6569 , 6571 , 6577 , 6581 , 6599 , 6607 , 6619 , 6637 , 6653 , 6659 , 6661 , 6673 , 6679 , 6689 , 6691 , 6701 , 6703 , 6709 , 6719 , 6733 , 6737 , 6761 , 6763 , 6779 , 6781 , 6791 , 6793 , 6803 , 6823 , 6827 , 6829 , 6833 , 6841 , 6857 , 6863 , 6869 , 6871 , 6883 , 6899 , 6907 , 6911 , 6917 , 6947 , 6949 , 6959 , 6961 , 6967 , 6971 , 6977 , 6983 , 6991 , 6997 , 7001 , 7013 , 7019 , 7027 , 7039 , 7043 , 7057 , 7069 , 7079 , 7103 , 7109 , 7121 , 7127 , 7129 , 7151 , 7159 , 7177 , 7187 , 7193 , 7207 , 7211 , 7213 , 7219 , 7229 , 7237 , 7243 , 7247 , 7253 , 7283 , 7297 , 7307 , 7309 , 7321 , 7331 , 7333 , 7349 , 7351 , 7369 , 7393 , 7411 , 7417 , 7433 , 7451 , 7457 , 7459 , 7477 , 7481 , 7487 , 7489 , 7499 , 7507 , 7517 , 7523 , 7529 , 7537 , 7541 , 7547 , 7549 , 7559 , 7561 , 7573 , 7577 , 7583 , 7589 , 7591 , 7603 , 7607 , 7621 , 7639 , 7643 , 7649 , 7669 , 7673 , 7681 , 7687 , 7691 , 7699 , 7703 , 7717 , 7723 , 7727 , 7741 , 7753 , 7757 , 7759 , 7789 , 7793 , 7817 , 7823 , 7829 , 7841 , 7853 , 7867 , 7873 , 7877 , 7879 , 7883 , 7901 , 7907 , 7919 , 7927 , 7933 , 7937 , 7949 , 7951 , 7963 , 7993 , 8009 , 8011 , 8017 , 8039 , 8053 , 8059 , 8069 , 8081 , 8087 , 8089 , 8093 , 8101 , 8111 , 8117 , 8123 , 8147 , 8161 , 8167 , 8171 , 8179 , 8191 , 8209 , 8219 , 8221 , 8231 , 8233 , 8237 , 8243 , 8263 , 8269 , 8273 , 8287 , 8291 , 8293 , 8297 , 8311 , 8317 , 8329 , 8353 , 8363 , 8369 , 8377 , 8387 , 8389 , 8419 , 8423 , 8429 , 8431 , 8443 , 8447 , 8461 , 8467 , 8501 , 8513 , 8521 , 8527 , 8537 , 8539 , 8543 , 8563 , 8573 , 8581 , 8597 , 8599 , 8609 , 8623 , 8627 , 8629 , 8641 , 8647 , 8663 , 8669 , 8677 , 8681 , 8689 , 8693 , 8699 , 8707 , 8713 , 8719 , 8731 , 8737 , 8741 , 8747 , 8753 , 8761 , 8779 , 8783 , 8803 , 8807 , 8819 , 8821 , 8831 , 8837 , 8839 , 8849 , 8861 , 8863 , 8867 , 8887 , 8893 , 8923 , 8929 , 8933 , 8941 , 8951 , 8963 , 8969 , 8971 , 8999 , 9001 , 9007 , 9011 , 9013 , 9029 , 9041 , 9043 , 9049 , 9059 , 9067 , 9091 , 9103 , 9109 , 9127 , 9133 , 9137 , 9151 , 9157 , 9161 , 9173 , 9181 , 9187 , 9199 , 9203 , 9209 , 9221 , 9227 , 9239 , 9241 , 9257 , 9277 , 9281 , 9283 , 9293 , 9311 , 9319 , 9323 , 9337 , 9341 , 9343 , 9349 , 9371 , 9377 , 9391 , 9397 , 9403 , 9413 , 9419 , 9421 , 9431 , 9433 , 9437 , 9439 , 9461 , 9463 , 9467 , 9473 , 9479 , 9491 , 9497 , 9511 , 9521 , 9533 , 9539 , 9547 , 9551 , 9587 , 9601 , 9613 , 9619 , 9623 , 9629 , 9631 , 9643 , 9649 , 9661 , 9677 , 9679 , 9689 , 9697 , 9719 , 9721 , 9733 , 9739 , 9743 , 9749 , 9767 , 9769 , 9781 , 9787 , 9791 , 9803 , 9811 , 9817 , 9829 , 9833 , 9839 , 9851 , 9857 , 9859 , 9871 , 9883 , 9887 , 9901 , 9907 , 9923 , 9929 , 9931 , 9941 , 9949 , 9967 , 9973 , 10007 , 10009 , 10037 , 10039 , 10061 , 10067 , 10069 , 10079 , 10091 , 10093 , 10099 , 10103 , 10111 , 10133 , 10139 , 10141 , 10151 , 10159 , 10163 , 10169 , 10177 , 10181 , 10193 , 10211 , 10223 , 10243 , 10247 , 10253 , 10259 , 10267 , 10271 , 10273 , 10289 , 10301 , 10303 , 10313 , 10321 , 10331 , 10333 , 10337 , 10343 , 10357 , 10369 , 10391 , 10399 , 10427 , 10429 , 10433 , 10453 , 10457 , 10459 , 10463 , 10477 , 10487 , 10499 , 10501 , 10513 , 10529 , 10531 , 10559 , 10567 , 10589 , 10597 , 10601 , 10607 , 10613 , 10627 , 10631 , 10639 , 10651 , 10657 , 10663 , 10667 , 10687 , 10691 , 10709 , 10711 , 10723 , 10729 , 10733 , 10739 , 10753 , 10771 , 10781 , 10789 , 10799 , 10831 , 10837 , 10847 , 10853 , 10859 , 10861 , 10867 , 10883 , 10889 , 10891 , 10903 , 10909 , 10937 , 10939 , 10949 , 10957 , 10973 , 10979 , 10987 , 10993 , 11003 , 11027 , 11047 , 11057 , 11059 , 11069 , 11071 , 11083 , 11087 , 11093 , 11113 ] <NEWLINE> <NL> <NL> def isprime ( number ) : <NEWLINE> <INDENT> global primes <NEWLINE> <NL> if number <= primes [ - 1 ] : <NEWLINE> <INDENT> return number in primes <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if math . sqrt ( number ) > primes [ - 1 ] : <NEWLINE> <INDENT> improve_primes ( primes [ - 1 ] + 2 , number ) <NEWLINE> <DEDENT> for prime in primes : <NEWLINE> <INDENT> if number % prime == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> primes . append ( number ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def improve_primes ( start , end ) : <NEWLINE> <INDENT> global primes <NEWLINE> <NL> if start >= end : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for prime in primes : <NEWLINE> <INDENT> if not ( start % prime == 0 ) : <NEWLINE> <INDENT> adds . append ( start ) <NEWLINE> <DEDENT> <DEDENT> print primes <NEWLINE> improve ( start + 2 , end ) <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> N = int ( line ) <NEWLINE> count = 0 <NEWLINE> for x in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> if isprime ( x ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> count = 1 <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( 2 , i ) : <NEWLINE> <INDENT> if i == j + 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> break <NEWLINE> <DEDENT> elif i % j == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if n < 2 or n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> i = 3 <NEWLINE> while i <= math . sqrt ( n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for x in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if is_prime ( x ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
% cat test . py <NEWLINE> n = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : n . append ( int ( raw_input ( ) ) ) <NEWLINE> except : break <NEWLINE> <NL> <DEDENT> R = max ( n ) + 10 <NEWLINE> p = [ 1 ] * R <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> p [ 4 : : 2 ] = [ 0 for i in range ( 4 , R , 2 ) ] <NEWLINE> for i in range ( 3 , int ( R ** 0.5 ) , 2 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i : : i ] = [ 0 ] * len ( p [ 2 * i : : i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print p <NEWLINE> for i in n : <NEWLINE> <INDENT> print sum ( p [ : i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif n <= 3 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif ( n % 2 == 0 or n % 3 == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> i = 5 <NEWLINE> while ( ( i * i ) <= n ) : <NEWLINE> <INDENT> if ( n % i == 0 or n % ( i + 2 ) == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> i += 6 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> def count_prime ( x ) : <NEWLINE> <INDENT> temp = 0 <NEWLINE> if ( x > 2 ) : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> for i in range ( 3 , x + 1 , 2 ) : <NEWLINE> <INDENT> if ( is_prime ( i ) == 1 ) : <NEWLINE> <INDENT> temp += 1 <NEWLINE> <DEDENT> <DEDENT> return temp <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for input in sys . stdin : <NEWLINE> <INDENT> l . append ( input ) <NEWLINE> <DEDENT> print l <NEWLINE> for input in l : <NEWLINE> <INDENT> print count_prime ( int ( input ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> x = 500000 <NEWLINE> f = [ 0 , 1 ] * xx <NEWLINE> i = 3 <NEWLINE> <NL> while i * i <= 2 * xx : <NEWLINE> <INDENT> if f [ i ] == 1 : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j <= 2 * xx : <NEWLINE> <INDENT> f [ j ] = 0 <NEWLINE> j += i + i <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> f . pop ( 0 ) <NEWLINE> f . pop ( 1 ) <NEWLINE> <NL> for n in sys . stdin : <NEWLINE> <INDENT> i = int ( n ) <NEWLINE> if i < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( f [ : i - 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def get_primes ( max_number ) : <COMMENT> <NEWLINE> <NL> <INDENT> if max_number == 2 : <NEWLINE> <INDENT> return [ 2 ] <NEWLINE> <DEDENT> elif max_number < 3 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <NL> <DEDENT> numbers = range ( 1 , max_number + 2 , 2 ) <NEWLINE> nroot = math . floor ( max_number ** 0.5 ) <NEWLINE> n = len ( numbers ) <NEWLINE> numbers [ 0 ] = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> x = numbers [ i ] <NEWLINE> if x > nroot : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if x and i + x < n : <NEWLINE> <INDENT> for j in range ( i + x , n + 1 , x ) : <NEWLINE> <INDENT> numbers [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> x = [ 2 ] + filter ( None , numbers [ 1 : ] ) <NEWLINE> return x <NEWLINE> <NL> <DEDENT> n = [ ] <NEWLINE> i = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n . append ( [ i , input ( ) , 0 ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> n = sorted ( n , key = lambda x : x [ 1 ] ) <NEWLINE> for i , e in enumerate ( get_primes ( n [ - 1 ] [ 1 ] ) ) : <NEWLINE> <INDENT> for j in range ( len ( n ) ) : <NEWLINE> <INDENT> if e <= n [ j ] [ 1 ] : <NEWLINE> <INDENT> n [ j ] [ 2 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = sorted ( n , key = lambda x : x [ 0 ] ) <NEWLINE> for e in n : <NEWLINE> <INDENT> print e [ 2 ] <NEWLINE> <DEDENT>
def euclid ( m , n ) : <NEWLINE> <INDENT> while m % n > 0 : <NEWLINE> <INDENT> r = m % n <NEWLINE> m , n = n , r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> <DEDENT> def isprime_euclid2 ( N ) : <NEWLINE> <NL> <INDENT> if N == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif N >= 3 : <NEWLINE> <INDENT> euclid_list = [ ] <NEWLINE> for k in range ( 1 , int ( round ( math . sqrt ( N ) ) ) + 1 ) : <NEWLINE> <INDENT> euclid_list . append ( euclid ( N , k ) ) <NEWLINE> <DEDENT> temp = set ( euclid_list ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> import math <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if isprime_euclid2 ( k ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> rand = random . randint <NEWLINE> <NL> def prime ( n ) : <NEWLINE> <INDENT> if n == 2 : return True <NEWLINE> if n < 2 or n & 1 == 0 : return False <NEWLINE> return pow ( 2 , n - 1 , n ) == 1 <NEWLINE> <NL> <DEDENT> a = [ prime ( i ) for i in range ( 1000000 ) ] <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> i = int ( s ) <NEWLINE> print ( a [ : i + 1 ] . count ( True ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def sieve ( n ) : <NEWLINE> <INDENT> p = 0 <NEWLINE> primes = [ ] <NEWLINE> is_prime = [ True ] * ( n + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if ( is_prime [ i ] ) : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> p += 1 <NEWLINE> for j in range ( i * 2 , n , i ) : <COMMENT> <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> if ( __name__ == <STRING> ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sieve ( n ) + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> count = 0 <NEWLINE> primes = [ 2 , 3 ] <NEWLINE> <NL> for n in xrange ( 5 , 1000001 , 2 ) : <NEWLINE> <INDENT> isprime = True <NEWLINE> for i in xrange ( 1 , len ( primes ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if primes [ i ] * primes [ i ] > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> if n % primes [ i ] == 0 : <NEWLINE> <INDENT> isprime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if isprime : <NEWLINE> <INDENT> primes . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> datas = [ ] <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> datas . append ( int ( line ) ) <NEWLINE> <NL> <DEDENT> for data in datas : <NEWLINE> <INDENT> count = 0 <NEWLINE> for prime in primes : <NEWLINE> <INDENT> if prime <= data : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
import sys <NEWLINE> N = 999999 <NEWLINE> lis = [ ] <NEWLINE> if N >= 2 : <NEWLINE> <INDENT> lis . append ( 2 ) <NEWLINE> <DEDENT> if N >= 3 : <NEWLINE> <INDENT> lis . append ( 3 ) <NEWLINE> <DEDENT> if N >= 5 : <NEWLINE> <INDENT> for i in xrange ( 5 , N + 1 , 2 ) : <NEWLINE> <INDENT> for item in lis : <NEWLINE> <INDENT> if item > ( i ** 0.5 ) : <NEWLINE> <INDENT> lis . append ( i ) <NEWLINE> break <NEWLINE> <DEDENT> if i % item == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = [ 0 ] * 999999 <NEWLINE> for item in lis : <NEWLINE> <INDENT> dp [ item - 1 ] += 1 <NEWLINE> <DEDENT> for i in xrange ( 1 , 999999 ) : <NEWLINE> <INDENT> dp [ i ] += dp [ i - 1 ] <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> num = int ( line ) <NEWLINE> print dp [ line - 1 ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sieve = map ( lambda x : False , range ( 2 , n + 1 ) ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if sieve [ i - 2 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * 2 , n + 1 , i ) : <NEWLINE> <INDENT> sieve [ j - 2 ] = True <NEWLINE> <DEDENT> <DEDENT> print sieve . count ( False ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> def primes ( n ) : <NEWLINE> <INDENT> f = [ ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if i > 2 and i % 2 == 0 : <NEWLINE> <INDENT> f . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> i = 3 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if f [ i ] == 1 : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j <= n : <NEWLINE> <INDENT> f [ j ] = 0 <NEWLINE> j += i + i <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <DEDENT> return f [ 2 : ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ps = primes ( 100 ) <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> print ( i , sum ( ps [ : i - 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = 10 ** 5 <NEWLINE> p = [ 1 ] * n <NEWLINE> p [ 0 ] , p [ 1 ] = 0 , 0 <NEWLINE> for i in xrange ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> for j in xrange ( i ** 2 , n , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in xrange ( 2 , n ) : <NEWLINE> <INDENT> p [ i ] += p [ i - 1 ] <NEWLINE> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> print p [ int ( line ) ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> List = [ i % j != 0 for j in range ( 3 , int ( i ** .5 ) + 1 , 2 ) ] <NEWLINE> if i != 1 and all ( List ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> list1 = range ( 2 , n + 1 ) <NEWLINE> list2 = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> i = list1 . pop ( 0 ) <NEWLINE> list2 . append ( i ) <NEWLINE> for x in list1 : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> list1 . remove ( x ) <NEWLINE> <DEDENT> <DEDENT> if len ( list1 ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if i ** 2 > sorted ( list1 , lambda n1 , n2 : n2 - n1 ) [ 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( len ( list2 + list1 ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> LIMIT = 1000000 <NEWLINE> is_prime = [ True ] * ( LIMIT + 1 ) <NEWLINE> p = 2 <NEWLINE> while p ** 2 <= LIMIT : <NEWLINE> <INDENT> if is_prime [ p ] : <NEWLINE> <INDENT> for i in range ( p * 2 , n + 1 , p ) : <NEWLINE> <INDENT> is_prime [ i ] = False <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> <NL> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> n = int ( line . strip ( ) ) <NEWLINE> if n <= 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> continue <NEWLINE> <DEDENT> if n == 2 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> continue <NEWLINE> <DEDENT> num_prime = 1 <NEWLINE> for i in range ( 3 , n + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> num_prime += 1 <NEWLINE> <DEDENT> <DEDENT> print ( num_prime ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> l = [ True ] * 100000 <NEWLINE> for i in range ( 2 , 100000 ) : <NEWLINE> <INDENT> if ( l [ i - 1 ] ) : <NEWLINE> <INDENT> for j in range ( i ** 2 - 1 , 100000 , i ) : <NEWLINE> <INDENT> l [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n = [ int ( line ) for line in sys . stdin ] <NEWLINE> for nn in n : <NEWLINE> <INDENT> print ( l [ 1 : int ( n ) ] . count ( True ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math as mas <NEWLINE> <NL> def sieve ( n ) : <NEWLINE> <INDENT> p = [ True for i in range ( n + 1 ) ] <NEWLINE> p [ 0 ] = p [ 1 ] = False <NEWLINE> end = int ( n ** 0.5 ) <NEWLINE> for i in range ( 2 , end + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> sosu = sieve ( 1000010 ) <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> print ( sum ( sosu [ t ] for t in range ( int ( i ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
n = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : n . append ( int ( raw_input ( ) ) ) <NEWLINE> except : break <NEWLINE> <DEDENT> R = max ( n ) + 1 <NEWLINE> p = [ 1 ] * R <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> p [ 4 : : 2 ] = [ 0 for i in range ( 4 , R , 2 ) ] <NEWLINE> for i in range ( 3 , int ( R ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i : : i ] = [ 0 ] * ( ( R - 2 * i + 1 ) / i ) <NEWLINE> <DEDENT> <DEDENT> for i in n : <NEWLINE> <INDENT> print sum ( p [ : i + 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> f = [ 0 , 1 ] * 500000 <NEWLINE> i = 3 <NEWLINE> while i * i <= 2 * xx : <NEWLINE> <INDENT> if f [ i ] == 1 : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j <= 2 * xx : <NEWLINE> <INDENT> f [ j ] = 0 <NEWLINE> j += i + i <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> f . pop ( 0 ) <NEWLINE> f . pop ( 1 ) <NEWLINE> <NL> for n in sys . stdin : <NEWLINE> <INDENT> i = int ( n ) <NEWLINE> if i < 2 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( f [ : i - 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT>
prime = [ False ] * 1000000 <NEWLINE> np = [ 0 ] * 1000000 <NEWLINE> for i in range ( 2 , 1000 ) : <NEWLINE> <INDENT> if not prime [ i ] <NEWLINE> for j in range ( i * 2 , 1000000 , i ) : <NEWLINE> <INDENT> prime [ j ] = True <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( prime [ 2 : n + 1 ] ) ) <NEWLINE> <DEDENT>
LIMIT = 10000000 <NEWLINE> <NL> isPrime = [ True for _ in range ( LIMIT ) ] <NEWLINE> <NL> isPrime [ 0 ] = isPrime [ 1 ] = False <NEWLINE> <NL> for i in range ( 2 , int ( LIMIT ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if isPrime [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , LIMIT , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if isPrime [ i ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import bisect <NEWLINE> from math import sqrt <NEWLINE> import sys <NEWLINE> primes = deque ( [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 ] ) <NEWLINE> append = primes . append <NEWLINE> for i in range ( 21 , 1000000 , 2 ) : <NEWLINE> <INDENT> for j in range ( 3 , int ( sqrt ( i ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for l in sys . stdin : <NEWLINE> <INDENT> print ( bisect . bisect ( primes , int ( l ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def prime_list ( n ) : <NEWLINE> <INDENT> l = range ( 2 , n + 1 ) <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> l = filter ( lambda x : x == i or x % i != 0 , l ) <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> return l <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l = prime_list ( 999999 ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> print len ( [ x for x in l if x <= n ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def isprime ( n ) : <NEWLINE> <INDENT> for i in xrange ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> limit = 1000000 <NEWLINE> ansList = [ 0 ] * limit <COMMENT> <NEWLINE> cnt = 0 <NEWLINE> for i in xrange ( 2 , limit ) : <NEWLINE> <INDENT> if isprime ( i ) : cnt += 1 <NEWLINE> ansList [ i - 1 ] = cnt <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> List = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> n = List [ 0 ] <NEWLINE> print ansList [ n - 1 ] <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def sieve_of_erastosthenes ( num ) : <NEWLINE> <INDENT> input_list = [ False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range ( num ) ] <NEWLINE> input_list [ 0 ] = input_list [ 1 ] = False <NEWLINE> input_list [ 2 ] = input_list [ 3 ] = input_list [ 5 ] = True <NEWLINE> sqrt = math . sqrt ( num ) <NEWLINE> <NL> for serial in range ( 3 , num , 2 ) : <NEWLINE> <NL> <INDENT> if serial >= sqrt : <NEWLINE> <COMMENT> <NL> <INDENT> return sum ( input_list ) <NEWLINE> <NL> <DEDENT> for s in range ( serial ** 2 , num , serial ) : <NEWLINE> <INDENT> input_list [ s ] = False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( sieve_of_erastosthenes ( n ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> d = int ( s ) <NEWLINE> prime_list = range ( d ) [ 2 : ] <NEWLINE> for e in prime_list : <NEWLINE> <INDENT> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> i += 1 <NEWLINE> f = e * i <NEWLINE> if f > d : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if f in prime_list : <NEWLINE> <INDENT> prime_list . remove ( f ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print len ( prime_list ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = [ 1 ] * 500000 <NEWLINE> [ a [ ( i * i ) // 2 : : i ] = [ 0 ] * len ( a [ ( i * i ) // 2 : : i ] ) for i in range ( 3 , 999 , 2 ) if a [ i // 2 ] ] <NEWLINE> [ print ( [ e - 1 , sum ( a [ : ( e + 1 ) // 2 ] ) ] [ e > 3 ] ) for e in map ( int , sys . stdin ) ] <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> from array import array <NEWLINE> <NL> M = 1000000 <NEWLINE> B = int ( math . sqrt ( M ) + 1 ) // 6 + 1 <NEWLINE> N = M // 6 <NEWLINE> N1 = N + 1 if M % 6 == 5 else N <NEWLINE> N2 = N + 1 if M % 6 >= 1 else N <NEWLINE> l = array ( <STRING> , [ 1 ] ) * N1 <NEWLINE> m = array ( <STRING> , [ 1 ] ) * N2 <NEWLINE> i = 5 <NEWLINE> ini = 4 <NEWLINE> for p in range ( B ) : <NEWLINE> <INDENT> if l [ p ] == 1 : <NEWLINE> <INDENT> l [ p + i : : i ] = [ 0 ] * len ( l [ p + i : : i ] ) <NEWLINE> m [ ini - 1 : : i ] = [ 0 ] * len ( m [ ini - 1 : : i ] ) <NEWLINE> <DEDENT> if m [ p ] == 1 : <NEWLINE> <INDENT> m [ p + i + 2 : : i + 2 ] = [ 0 ] * len ( m [ p + i + 2 : : i + 2 ] ) <NEWLINE> l [ ini + 1 : : i + 2 ] = [ 0 ] * len ( l [ ini + 1 : : i + 2 ] ) <NEWLINE> <DEDENT> i += 6 <NEWLINE> ini += 5 <NEWLINE> <NL> <DEDENT> for i in sys . stdin : <NEWLINE> <INDENT> n = int ( i ) <NEWLINE> r = n - 1 if n < 3 else sum ( l [ 0 : ( n + 1 ) // 6 ] ) + sum ( m [ 0 : ( n - 1 ) // 6 ] ) + 2 <NEWLINE> print ( r ) <NEWLINE> <DEDENT>
def sieve ( n ) : <NEWLINE> <INDENT> a = [ 1 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , n + 1 , i ) : <NEWLINE> <INDENT> a [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return a [ 2 : ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> print len ( filter ( lambda x : x , sieve ( n ) ) ) <NEWLINE> <DEDENT> except ( EOFError ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n_list = map ( int , sys . stdin . readlines ( ) ) <NEWLINE> n_max = max ( n_list ) <NEWLINE> <NL> pn_candidates = range ( 2 , n_max + 1 ) <NEWLINE> pn_list = [ ] <NEWLINE> <NL> while pn_candidates != [ ] : <NEWLINE> <INDENT> pn = pn_candidates [ 0 ] <NEWLINE> pn_list . append ( pn ) <NEWLINE> pn_candidates = [ x for x in pn_candidates [ 1 : ] if x % pn != 0 ] <NEWLINE> <NL> <DEDENT> for n in n_list : <NEWLINE> <INDENT> print len ( [ pn for pn in pn_list if pn <= n ] ) <NEWLINE> <DEDENT>
t = [ ] <NEWLINE> for n in range ( 2 , 10000 ) : <NEWLINE> <INDENT> for x in range ( 2 , n ) : <NEWLINE> <INDENT> if n % x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for b in range ( 100000 ) : <NEWLINE> <INDENT> if t [ b ] >= a : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print len ( ( t [ 0 : b ] ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
IsPrimes = [ True ] * 1000002 <NEWLINE> IsPimes [ 0 ] , IsPimes [ 1 ] = False , False <NEWLINE> <NL> for i in range ( 2 , 1001 ) : <NEWLINE> <INDENT> if IsPrime [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 1000001 , i ) <NEWLINE> <INDENT> IsPrime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = [ 0 ] * 1000001 <NEWLINE> <NL> for i in range ( 1000001 ) : <NEWLINE> <INDENT> if IsPimes [ i ] : <NEWLINE> <INDENT> cnt [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , 1000001 ) : <NEWLINE> <INDENT> cnt [ i ] += cnt [ i - 1 ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> print cnt [ n ] <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> n = 999999 <NEWLINE> prime = [ 1 ] * ( n + 1 ) <NEWLINE> ( prime [ 0 ] , prime [ 1 ] ) = ( 0 , 0 ) <NEWLINE> for i in xrange ( 2 , n + 1 ) : <NEWLINE> <INDENT> if i * i < n + 1 : <NEWLINE> <INDENT> for j in xrange ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for inp in sys . stdin : <NEWLINE> <INDENT> print prime [ : inp - 1 ] . count ( 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = [ 0 , 0 ] + [ 1 ] * 10 ** 6 <NEWLINE> for i in range ( 999 ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> for j in range ( i * 2 , m , i ) : a [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> for e in sys . stdin : print ( sum ( a [ : int ( e ) + 1 ] ) ) <NEWLINE>
import sys <NEWLINE> n = 10 ** 5 + 1 <NEWLINE> s = [ True ] * n <NEWLINE> s [ 0 ] = False <NEWLINE> s [ 1 ] = False <NEWLINE> for x in xrange ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if s [ x ] : <NEWLINE> <INDENT> for i in xrange ( x + x , n , x ) : <NEWLINE> <INDENT> s [ i ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for x in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a = int ( x ) <NEWLINE> cnt = 0 <NEWLINE> for i in xrange ( a ) : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> <DEDENT> print cnt <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def isprime ( n ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if isprime ( i ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print cnt <NEWLINE> <DEDENT>
import sys <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> li = [ x for x in range ( 2 , n + 1 ) ] <NEWLINE> pr = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> pr . append ( li [ 0 ] ) <NEWLINE> li = [ x for x in li if x % li [ 0 ] != 0 ] <NEWLINE> if li [ - 1 ] < pr [ - 1 ] ** 2 : return pr + li <NEWLINE> <DEDENT> <DEDENT> for n in sys . stdin : <NEWLINE> <INDENT> print len ( f ( int ( n ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> r = max ( n ) + 1 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i + 1 , r , i + 1 ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in n : <NEWLINE> <INDENT> print sum ( p [ : i ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def Eratos ( n ) : <NEWLINE> <INDENT> primes = [ 2 ] <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> num = [ 2 * i + 1 for i in range ( 1 , n / 2 ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = [ 2 * i + 1 for i in range ( 1 , ( n + 1 ) / 2 ) ] <NEWLINE> <DEDENT> tmp = [ ] <NEWLINE> <NL> top = 1 <NEWLINE> while top < math . sqrt ( n ) : <NEWLINE> <INDENT> top = num [ 0 ] <NEWLINE> for i in range ( 1 , len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] % top != 0 : <NEWLINE> <INDENT> tmp . append ( num [ i ] ) <NEWLINE> <DEDENT> <DEDENT> num = tmp <NEWLINE> tmp = [ ] <NEWLINE> primes . append ( top ) <NEWLINE> <DEDENT> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> primes . append ( num [ i ] ) <NEWLINE> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> def list_count ( list_a , n ) : <NEWLINE> <INDENT> cont = 0 <NEWLINE> for i in range ( len ( list_a ) ) : <NEWLINE> <INDENT> if list_a [ i ] > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cont += 1 <NEWLINE> <DEDENT> <DEDENT> return cont <NEWLINE> <NL> <DEDENT> primes = Eratos ( 1000000 ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( list_count ( primes , n ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
num = 1000000 <NEWLINE> prime = [ 1 ] * 1000000 <NEWLINE> prime [ 0 ] = 0 <NEWLINE> prime [ 1 ] = 0 <NEWLINE> i = 2 <NEWLINE> ans = 0 <NEWLINE> while i < 1000000 : <NEWLINE> <INDENT> if prime [ i ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> if i < 1000 : <NEWLINE> <INDENT> j = i * i <NEWLINE> while j < 1000000 : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> prime [ i ] = ans <NEWLINE> i += 1 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) : <NEWLINE> print prime [ n ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
m = 10 * 6 ; a = [ 0 ] + [ 1 ] * m <NEWLINE> for i in range ( 999 ) : <NEWLINE> <INDENT> if a [ i ] : a [ i * 2 + 1 : : i + 1 ] = [ 0 for e in range ( len ( li [ i * 2 + 1 : : i + 1 ] ) ) ] <NEWLINE> <DEDENT> for e in sys . stdin : print ( len ( [ i for i in li [ : int ( e ) ] if i ] ) ) <NEWLINE>
import math <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if y2 == y1 or y3 == y1 : <NEWLINE> <INDENT> if y2 == y1 : <NEWLINE> <INDENT> a2 = - ( x3 - x1 ) / ( y3 - y1 ) <NEWLINE> b2 = ( ( y3 + y1 ) - a2 * ( x1 + x3 ) ) / 2 <NEWLINE> a , b , c , d , e , f = 0 , 1 , ( x1 + x2 ) / 2 , - a2 , 1 , b2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a1 = - ( x2 - x1 ) / ( y2 - y1 ) <NEWLINE> b1 = ( ( y2 + y1 ) - a2 * ( x1 + x2 ) ) / 2 <NEWLINE> a , b , c , d , e , f = - a1 , 1 , b1 , 0 , 1 , ( x1 + x3 ) / 2 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a1 = - ( x2 - x1 ) / ( y2 - y1 ) <NEWLINE> a2 = - ( x3 - x1 ) / ( y3 - y1 ) <NEWLINE> b1 = ( ( y2 + y1 ) - a1 * ( x1 + x2 ) ) / 2 <NEWLINE> b2 = ( ( y3 + y1 ) - a2 * ( x1 + x3 ) ) / 2 <NEWLINE> a , b , c , d , e , f = - a1 , 1 , b1 , - a2 , 1 , b2 <NEWLINE> <DEDENT> py = ( a * f - c * d ) / ( a * e - b * d ) <NEWLINE> px = ( c * e - f * b ) / ( a * e - b * d ) <NEWLINE> r = math . sqrt ( ( px - x1 ) ** 2 + ( py - y1 ) ** 2 ) <NEWLINE> print <STRING> . format ( px , py , r ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def take2 ( iterable ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> yield next ( iterable ) , next ( iterable ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> def cross ( v1 , v2 ) : <NEWLINE> <INDENT> return v1 . real * v2 . imag - v1 . imag * v2 . real <NEWLINE> <COMMENT> <NL> <DEDENT> def get_intersection ( p1 , p2 , p3 , p4 ) : <NEWLINE> <INDENT> a1 = p4 - p2 <NEWLINE> b1 = p2 - p3 <NEWLINE> b2 = p1 - p2 <NEWLINE> s1 = cross ( a1 , b2 ) / 2 <NEWLINE> s2 = cross ( a1 , b1 ) / 2 <NEWLINE> return p1 + ( p3 - p1 ) * s1 / ( s1 + s2 ) <NEWLINE> <NL> <DEDENT> n = int ( f . readline ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p1 , p2 , p3 = [ x + y * 1j for x , y in take2 ( map ( float , f . readline ( ) . split ( ) ) ) ] <NEWLINE> p12 = ( p1 + p2 ) / 2 <NEWLINE> p13 = ( p1 + p3 ) / 2 <NEWLINE> pxy = get_intersection ( p12 , p13 , p12 + ( p2 - p1 ) * 1j , p13 + ( p1 - p3 ) * 1j ) <NEWLINE> r = abs ( pxy - p1 ) <NEWLINE> print ( <STRING> . format ( pxy . real , pxy . imag , r ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> px = ( ( y2 - y3 ) * ( x1 * x1 + y1 * y1 ) + ( y3 - y1 ) * ( x2 * x2 + y2 * y2 ) + ( y1 - y2 ) * ( x3 * x3 + y3 * y3 ) ) / ( 2 * ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) ) <NEWLINE> py = ( ( x2 - x3 ) * ( x1 * x1 + y1 * y1 ) + ( x3 - x1 ) * ( x2 * x2 + y2 * y2 ) + ( x1 - x2 ) * ( x3 * x3 + y3 * y3 ) ) / ( 2 * ( y1 * ( x2 - x3 ) + y2 * ( x3 - x1 ) + y3 * ( x1 - x2 ) ) ) <NEWLINE> <NL> r = math . sqrt ( pow ( ( x1 - px ) , 2 ) + pow ( ( y1 - py ) , 2 ) ) <NEWLINE> <NL> print <STRING> % ( px , py , r ) <NEWLINE> <DEDENT>
def perpendicular_bisector ( p , q ) : <NEWLINE> <INDENT> x = ( q [ 0 ] - p [ 0 ] ) <NEWLINE> y = ( q [ 1 ] - p [ 1 ] ) <NEWLINE> return ( 2 * x , 2 * y , - x ** 2 - y ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> def gauss_jordan_elimination ( Array ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = len ( Array ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> return ( True , Array ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M = len ( Array [ 0 ] ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> for i in range ( len ( Array ) ) : <NEWLINE> <INDENT> A . append ( Array [ i ] [ : ] ) <NEWLINE> <NL> <DEDENT> pivot = 0 <NEWLINE> L = min ( N , M ) <NEWLINE> while pivot < L : <NEWLINE> <INDENT> pivot_v = A [ pivot ] [ pivot ] <NEWLINE> pivot_row = pivot <NEWLINE> for i in range ( pivot + 1 , L ) : <NEWLINE> <INDENT> v = max ( A [ i ] [ pivot ] , - A [ i ] [ pivot ] ) <NEWLINE> if pivot_v < v : <NEWLINE> <INDENT> pivot_row = i <NEWLINE> pivot_v = v <NEWLINE> <DEDENT> <DEDENT> if pivot_row > pivot : <NEWLINE> <INDENT> for i in range ( M ) : <NEWLINE> <INDENT> A [ pivot ] [ i ] , A [ pivot_row ] [ i ] = A [ pivot_row ] [ i ] , A [ pivot ] [ i ] <NEWLINE> <DEDENT> <DEDENT> if pivot_v == 0 : <NEWLINE> <INDENT> return ( <STRING> , A ) <NEWLINE> <DEDENT> inv_pivot = 1 / A [ pivot ] [ pivot ] <NEWLINE> A [ pivot ] [ pivot ] = 1 <NEWLINE> for i in range ( pivot + 1 , M ) : <NEWLINE> <INDENT> A [ pivot ] [ i ] *= inv_pivot <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> if i == pivot : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> t = - 1 * A [ i ] [ pivot ] <NEWLINE> A [ i ] [ pivot ] = 0 <NEWLINE> for j in range ( pivot + 1 , M ) : <NEWLINE> <INDENT> A [ i ] [ j ] += t * A [ pivot ] [ j ] <NEWLINE> <DEDENT> <DEDENT> pivot += 1 <NEWLINE> <DEDENT> return ( <STRING> , A ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <NL> a = list ( perpendicular_bisector ( ( x1 , y1 ) , ( x2 , y2 ) ) ) <NEWLINE> b = list ( perpendicular_bisector ( ( x1 , y1 ) , ( x3 , y3 ) ) ) <NEWLINE> c = [ a , b ] <NEWLINE> state , c = gauss_jordan_elimination ( c ) <NEWLINE> x = c [ 0 ] [ 2 ] <NEWLINE> y = c [ 1 ] [ 2 ] <NEWLINE> r = ( ( x - x1 ) ** 2 + ( y - y1 ) ** 2 ) ** 0.5 <NEWLINE> print ( round ( x , 3 ) , round ( y , 3 ) , round ( r , 3 ) ) <NEWLINE> <DEDENT>
import fractions <NEWLINE> <NL> <NL> def calc ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> return 2 * ( x2 - x1 ) , 2 * ( y2 - y1 ) , x2 ** 2 + y2 ** 2 - x1 ** 2 - y1 ** 2 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <NEWLINE> cx1 , cy1 , z1 = calc ( x1 , y1 , x2 , y2 ) <NEWLINE> cx2 , cy2 , z2 = calc ( x1 , y1 , x3 , y3 ) <NEWLINE> gcd = fractions . gcd ( cx1 , cx2 ) <NEWLINE> r1 , r2 = cx2 // gcd , cx1 // gcd <NEWLINE> dcy = r1 * cy1 - r2 * cy2 <NEWLINE> dz = r1 * z1 - r2 * z2 <NEWLINE> y = dz / dcy <NEWLINE> x = ( z1 - cy1 * y ) / cx1 <NEWLINE> r = ( ( x - x1 ) ** 2 + ( y - y1 ) ** 2 ) ** 0.5 <NEWLINE> print ( * map ( lambda x : <STRING> . format ( round ( x , 3 ) ) , ( x , y , r ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a = int ( raw_input ( ) ) <NEWLINE> <NL> while a > 0 : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a1 = 2 * ( x2 - x1 ) <NEWLINE> b1 = 2 * ( y2 - y1 ) <NEWLINE> c1 = x1 * x1 - x2 * x2 + y1 * y1 - y2 * y2 <NEWLINE> a2 = 2 * ( x3 - x1 ) <NEWLINE> b2 = 2 * ( y3 - y1 ) <NEWLINE> c2 = x1 * x1 - x3 * x3 + y1 * y1 - y3 * y3 <NEWLINE> <NL> X = ( b1 * c2 - b2 * c1 ) / ( a1 * b2 - a2 * b1 ) <NEWLINE> Y = ( c1 * a2 - c2 * a1 ) / ( a1 * b2 - a2 * b1 ) <NEWLINE> <NL> R = math . sqrt ( ( X - x1 ) * ( X - x1 ) + ( Y - y1 ) * ( Y - y1 ) ) <NEWLINE> <NL> print <STRING> % ( X , Y , R ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> data = [ 0 for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> data [ i ] = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> for ( x1 , y1 , x2 , y2 , x3 , y3 ) in data : <NEWLINE> <INDENT> det = 4 * x2 * y3 - 4 * y2 * x3 <NEWLINE> px = ( ( x2 ** 2 + y2 ** 2 ) * 2 * y3 - ( x3 ** 2 + y3 ** 2 ) * 2 * y2 ) / det <NEWLINE> py = ( 2 * x2 * ( x3 ** 2 + y3 ** 2 ) - 2 * x3 * ( x2 ** 2 + y2 ** 2 ) ) / det <NEWLINE> r = ( ( px - x1 ) ** 2 + ( py - y1 ) ** 2 ) ** .5 <NEWLINE> print <STRING> . format ( px , py , r ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> a = math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> b = math . sqrt ( ( x1 - x3 ) ** 2 + ( y1 - y3 ) ** 2 ) <NEWLINE> c = math . sqrt ( ( x2 - x3 ) ** 2 + ( y2 - y3 ) ** 2 ) <NEWLINE> s = ( a + b + c ) / 2 <NEWLINE> ss = math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) <NEWLINE> sina = 2 * ss / b / c <NEWLINE> <NL> r = a / sina / 2 <NEWLINE> <NL> a = a * a <NEWLINE> b = b * b <NEWLINE> c = c * c <NEWLINE> px = ( a * ( b + c - a ) * x3 + b * ( a + c - b ) * x2 + c * ( a + b - c ) * x1 ) / 16 / ss ** 2 <NEWLINE> py = ( a * ( b + c - a ) * y3 + b * ( a + c - b ) * y2 + c * ( a + b - c ) * y1 ) / 16 / ss ** 2 <NEWLINE> <NL> print <STRING> % ( px , py , r ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import cmath <NEWLINE> <NL> class Point ( object ) : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . point = complex ( x , y ) <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . point . real , self . point . imag ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Triangle ( Point ) : <NEWLINE> <INDENT> def __init__ ( self , a , b , c ) : <NEWLINE> <INDENT> self . a = a <NEWLINE> self . b = b <NEWLINE> self . c = c <NEWLINE> <COMMENT> <NL> self . edgeA = abs ( b . point - c . point ) <NEWLINE> self . edgeB = abs ( c . point - a . point ) <NEWLINE> self . edgeC = abs ( a . point - b . point ) <NEWLINE> <COMMENT> <NL> self . angleA = Triangle . angle ( self . edgeA , self . edgeB , self . edgeC ) <NEWLINE> self . angleB = Triangle . angle ( self . edgeB , self . edgeC , self . edgeA ) <NEWLINE> self . angleC = Triangle . angle ( self . edgeC , self . edgeA , self . edgeB ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def angle ( A , B , C ) : <NEWLINE> <INDENT> return cmath . acos ( ( B * B + C * C - A * A ) / ( 2 * B * C ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def circumscribedCircleRadius ( self ) : <NEWLINE> <INDENT> return abs ( ( self . edgeA / cmath . sin ( self . angleA ) ) / 2 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def circumscribedCircleCenter ( self ) : <NEWLINE> <INDENT> A = cmath . sin ( 2 * self . angleA ) <NEWLINE> B = cmath . sin ( 2 * self . angleB ) <NEWLINE> C = cmath . sin ( 2 * self . angleC ) <NEWLINE> X = ( self . a . point . real * A + self . b . point . real * B + self . c . point . real * C ) / ( A + B + C ) <NEWLINE> Y = ( self . a . point . imag * A + self . b . point . imag * B + self . c . point . imag * C ) / ( A + B + C ) <NEWLINE> return complex ( X , Y ) <NEWLINE> <NL> <DEDENT> <DEDENT> line = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> p1 = Point ( line [ 0 ] , line [ 1 ] ) <NEWLINE> p2 = Point ( line [ 2 ] , line [ 3 ] ) <NEWLINE> p3 = Point ( line [ 4 ] , line [ 5 ] ) <NEWLINE> T = Triangle ( p1 , p2 , p3 ) <NEWLINE> center = T . circumscribedCircleCenter ( ) <NEWLINE> print ( <STRING> . format ( center . real , center . imag , T . circumscribedCircleRadius ( ) ) ) <NEWLINE>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> x = ( ( a * a + b * b ) * ( d - f ) + ( c * c + d * d ) * ( f - b ) + ( e * e + f * f ) * ( b - d ) ) / 2 / ( a * ( d - f ) + c * ( f - b ) + e * ( b - d ) ) <NEWLINE> y = ( ( a * a + b * b ) * ( c - d ) + ( c * c + d * d ) * ( e - a ) + ( e * e + f * f ) * ( a - c ) ) / 2 / ( b * ( c - e ) + d * ( e - a ) + f * ( a - c ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def equation ( A ) : <NEWLINE> <INDENT> n = len ( A ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = i <NEWLINE> while A [ j ] [ i ] == 0 : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> A [ i ] = [ e / A [ i ] [ i ] for e in A [ i ] ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if j == i : continue <NEWLINE> tmp = A [ j ] [ i ] <NEWLINE> for k in range ( n + 1 ) : <NEWLINE> <INDENT> A [ j ] [ k ] -= tmp * A [ i ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> def f003 ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> seq = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> x = seq . pop ( 0 ) <NEWLINE> y = seq . pop ( 0 ) <NEWLINE> A . append ( [ x , y , 1 , - ( x ** 2 + y ** 2 ) ] ) <NEWLINE> <DEDENT> equation ( A ) <NEWLINE> <NL> x0 , y0 = - A [ 0 ] [ 3 ] / 2 , - A [ 1 ] [ 3 ] / 2 <NEWLINE> r = ( ( x - x0 ) ** 2 + ( y - y0 ) ** 2 ) ** .5 <NEWLINE> <DEDENT> return x0 , y0 , r <NEWLINE> <NL> <DEDENT> x0 , y0 , r = f003 ( ) <NEWLINE> print <STRING> % ( x0 , y0 , r ) <NEWLINE>
import math <NEWLINE> deta = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> h1 = math . sqrt ( ( deta [ 2 ] - deta [ 0 ] ) ** 2 + ( deta [ 3 ] - deta [ 1 ] ) ** 2 ) <NEWLINE> h2 = math . sqrt ( ( deta [ 4 ] - deta [ 2 ] ) ** 2 + ( deta [ 5 ] - deta [ 3 ] ) ** 2 ) <NEWLINE> h3 = math . sqrt ( ( deta [ 0 ] - deta [ 4 ] ) ** 2 + ( deta [ 1 ] - deta [ 5 ] ) ** 2 ) <NEWLINE> sub = ( h1 + h2 + h3 ) / 2 <NEWLINE> s = math . sqrt ( sub * ( sub - h1 ) * ( sub - h2 ) * ( sub - h3 ) ) <NEWLINE> sum = ( ( h1 * h2 * h3 ) / s ) / 4 <NEWLINE> <NL> a = 2 * deta [ 2 ] - 2 * deta [ 0 ] <NEWLINE> b = 2 * deta [ 3 ] - 2 * deta [ 1 ] <NEWLINE> c = - ( deta [ 0 ] ** 2 + deta [ 1 ] ** 2 - ( deta [ 2 ] ** 2 ) - ( deta [ 3 ] ** 2 ) ) <NEWLINE> d = 2 * deta [ 4 ] - 2 * deta [ 2 ] <NEWLINE> e = 2 * deta [ 5 ] - 2 * deta [ 3 ] <NEWLINE> f = - ( deta [ 2 ] ** 2 + deta [ 3 ] ** 2 - ( deta [ 4 ] ** 2 ) - ( deta [ 5 ] ** 2 ) ) <NEWLINE> <NL> x = ( e * c - b * f ) / ( a * e - b * d ) <NEWLINE> y = ( a * f - c * d ) / ( a * e - b * d ) <NEWLINE> print ( <STRING> . format ( x , y , sum ) ) <NEWLINE>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , input ( ) . split ( ) ) <NEWLINE> x = ( ( a * a + b * b ) * ( d - f ) + ( c * c + d * d ) * ( f - b ) + ( e * e + f * f ) * ( b - d ) ) / 2 / ( a * ( d - f ) + c * ( f - b ) + e * ( b - d ) ) <NEWLINE> y = ( ( a * a + b * b ) * ( c - e ) + ( c * c + d * d ) * ( e - a ) + ( e * e + f * f ) * ( a - c ) ) / 2 / ( b * ( c - e ) + d * ( e - a ) + f * ( a - c ) ) <NEWLINE> print ( <STRING> % ( x , y , ( ( x - a ) ** 2 + ( y - b ) ** 2 ) ** .5 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def length ( a , b ) : <NEWLINE> <INDENT> return ( ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> <NL> <DEDENT> def solve_sim_equ ( a , b , c , d , e , f ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if a == 0 and d == 0 : <NEWLINE> <INDENT> if b == 0 and e == 0 : <NEWLINE> <INDENT> return 0. , 0. <NEWLINE> <DEDENT> if b != 0 : <NEWLINE> <INDENT> return 0. , c / b + 0. <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0. , f / e + 0. <NEWLINE> <DEDENT> <DEDENT> elif b == 0 and e == 0 : <NEWLINE> <INDENT> if a != 0 : <NEWLINE> <INDENT> return 0. , d / a + 0. <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0. , a / d + 0. <NEWLINE> <NL> <DEDENT> <DEDENT> if b == 0 : <NEWLINE> <INDENT> a , d = d , a <NEWLINE> b , e = e , b <NEWLINE> c , f = f , c <NEWLINE> <DEDENT> g = e / b <NEWLINE> x = ( g * c - f ) / ( g * a - d ) <NEWLINE> y = ( c - a * x ) / b <NEWLINE> return x + 0. , y + 0. <NEWLINE> <NL> <NL> <DEDENT> def circumscribed_circle ( x , y , z ) : <NEWLINE> <INDENT> def get_equ_coef ( p , q ) : <NEWLINE> <INDENT> h_x = ( p [ 0 ] + q [ 0 ] ) / 2 <NEWLINE> h_y = ( p [ 1 ] + q [ 1 ] ) / 2 <NEWLINE> a = q [ 1 ] - p [ 1 ] <NEWLINE> b = p [ 0 ] - q [ 0 ] <NEWLINE> c = b * h_x - a * h_y <NEWLINE> return b , - a , c <NEWLINE> <DEDENT> coef = get_equ_coef ( x , y ) + get_equ_coef ( y , z ) <NEWLINE> center = solve_sim_equ ( * coef ) <NEWLINE> r = length ( center , x ) <NEWLINE> return center , r <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> vs = [ float ( v ) for v in input ( ) . split ( ) ] <NEWLINE> a = ( vs [ 0 ] , vs [ 1 ] ) <NEWLINE> b = ( vs [ 2 ] , vs [ 3 ] ) <NEWLINE> c = ( vs [ 4 ] , vs [ 5 ] ) <NEWLINE> center , r = circumscribed_circle2 ( a , b , c ) <NEWLINE> print ( <STRING> . format ( center [ 0 ] , center [ 1 ] , r ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def heron ( a , b , c ) : <NEWLINE> <INDENT> s = 0.5 * ( a + b + c ) <NEWLINE> return ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ** 0.5 <NEWLINE> <NL> <DEDENT> def gaishin ( a , b , c , z1 , z2 , z3 , s ) : <NEWLINE> <INDENT> p = ( a ** 2 * ( b ** 2 + c ** 2 - a ** 2 ) * z1 + b ** 2 * ( c ** 2 + a ** 2 - b ** 2 ) * z2 + c ** 2 * ( a ** 2 + b ** 2 - c ** 2 ) * z3 ) / ( 16 * s ** 2 ) <NEWLINE> return p <NEWLINE> <NL> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> l1 = ( ( x2 - x3 ) ** 2 + ( y2 - y3 ) ** 2 ) ** 0.5 <NEWLINE> l2 = ( ( x3 - x1 ) ** 2 + ( y3 - y1 ) ** 2 ) ** 0.5 <NEWLINE> l3 = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 <NEWLINE> s = heron ( l1 , l2 , l3 ) <NEWLINE> px = gaishin ( l1 , l2 , l3 , x1 , x2 , x3 , s ) <NEWLINE> py = gaishin ( l1 , l2 , l3 , y1 , y2 , y3 , s ) <NEWLINE> r = ( ( px - x1 ) ** 2 + ( py - y1 ) ** 2 ) ** 0.5 <NEWLINE> print <STRING> % ( px , py , r ) <NEWLINE> <DEDENT>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> a , b , c , d , e , f = map ( float , input ( ) . split ( ) ) <NEWLINE> s , t , u = a * a + b * b , c * c + d * d , e * e + f * f <NEWLINE> x = ( s * ( d - f ) + t * ( f - b ) + u * ( b - d ) ) / 2 / ( a * ( d - f ) + c * ( f - b ) + e * ( b - d ) ) <NEWLINE> y = ( s * ( c - e ) + t * ( e - a ) + u * ( a - c ) ) / 2 / ( b * ( c - e ) + d * ( e - a ) + f * ( a - c ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <NEWLINE> x4 , y4 = 0.5 * ( x2 + x3 ) , 0.5 * ( y2 + y3 ) <NEWLINE> xg , yg = 2 / 3 * ( 2 * x1 + x4 ) , 2 / 3 * ( 2 * y1 + y4 ) <NEWLINE> xo , yo = ( x1 + x2 + x3 ) / 3 , ( y1 + y2 + y3 ) / 3 <NEWLINE> r = ( ( xo - x1 ) ** 2 + ( yo - y1 ) ** 2 ) ** 0.5 <NEWLINE> print ( xg , yg , r ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> A1 = 2 * ( x2 - x1 ) <NEWLINE> B1 = 2 * ( y2 - y1 ) <NEWLINE> C1 = x2 ** 2 + y2 ** 2 - x1 ** 2 - y1 ** 2 <NEWLINE> A2 = 2 * ( x3 - x2 ) <NEWLINE> <INDENT> B2 = 2 * ( y3 - y2 ) <NEWLINE> C2 = x3 ** 2 + y3 ** 2 - x2 ** 2 - y2 ** 2 <NEWLINE> <DEDENT> <DEDENT>
from math import sqrt <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> A1 = 2 * ( x2 - x1 ) <NEWLINE> B1 = 2 * ( y2 - y1 ) <NEWLINE> C1 = x2 ** 2 + y2 ** 2 - x1 ** 2 - y1 ** 2 <NEWLINE> A2 = 2 * ( x3 - x2 ) <NEWLINE> B2 = 2 * ( y3 - y2 ) <NEWLINE> C2 = x3 ** 2 + y3 ** 2 - x2 ** 2 - y2 ** 2 <NEWLINE> x = ( C1 * B2 - C2 * B1 ) / ( A1 * B2 - A2 * B1 ) <NEWLINE> y = ( A1 * C2 - A2 * C1 ) / ( A1 * B2 - A2 * B1 ) <NEWLINE> R = sqrt ( ( x1 - x ) ** 2 + ( y1 - y ) ** 2 ) <NEWLINE> print <STRING> % ( x , y , R ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for data in sys . stdin : <NEWLINE> <INDENT> if n <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n - - <NEWLINE> x1 , y1 , x2 , y2 , x3 , y3 = map ( float , data . split ( ) ) <NEWLINE> a1 = x2 - x1 <NEWLINE> b1 = y2 - y1 <NEWLINE> a2 = x3 - x1 <NEWLINE> b2 = y3 - y1 <NEWLINE> px = ( b2 * ( a1 * a1 + b1 * b1 ) - b1 * ( a2 * a2 + b2 * b2 ) ) / ( 2 * ( a1 * b2 - a2 * b1 ) ) <NEWLINE> py = ( a1 * ( a2 * a2 + b2 * b2 ) - a2 * ( a1 * a1 + b1 * b1 ) ) / ( 2 * ( a1 * b2 - a2 * b1 ) ) <NEWLINE> r = math . sqrt ( px * px + py * py ) <NEWLINE> px += x1 <NEWLINE> py += y1 <NEWLINE> print ( <STRING> . format ( px , py , r ) ) <NEWLINE> <DEDENT>
def play ( ) : <NEWLINE> <INDENT> result_dic = { } <NEWLINE> for i in range ( tate ) : <NEWLINE> <INDENT> depart = i + 1 <NEWLINE> arrival = drawing_lots [ depart ] [ 0 ] <NEWLINE> arrival = aaa ( depart , arrival ) <NEWLINE> result_dic [ arrival ] = depart <NEWLINE> <NL> <DEDENT> for k in sorted ( result_dic ) : <NEWLINE> <INDENT> print ( result_dic [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def aaa ( depart , arrival ) : <NEWLINE> <INDENT> offset = 0 <NEWLINE> for offset , point in enumerate ( drawing_lots [ arrival ] ) : <NEWLINE> <INDENT> if point == depart : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if offset + 1 <= len ( drawing_lots [ arrival ] ) - 1 : <NEWLINE> <INDENT> depart = arrival <NEWLINE> arrival = drawing_lots [ arrival ] [ offset + 1 ] <NEWLINE> return aaa ( depart , arrival ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return arrival <NEWLINE> <NL> <DEDENT> <DEDENT> tate = int ( raw_input ( ) ) <NEWLINE> yoko = int ( raw_input ( ) ) <NEWLINE> <NL> drawing_lots = { } <NEWLINE> for num in range ( tate ) : <NEWLINE> <INDENT> drawing_lots [ num + 1 ] = [ ] <NEWLINE> <NL> <DEDENT> for i in range ( yoko ) : <NEWLINE> <INDENT> horizontal_line = raw_input ( ) . split ( <STRING> ) <NEWLINE> left_num = int ( horizontal_line [ 0 ] ) <NEWLINE> right_num = int ( horizontal_line [ 1 ] ) <NEWLINE> drawing_lots [ left_num ] . append ( right_num ) <NEWLINE> drawing_lots [ right_num ] . append ( left_num ) <NEWLINE> <NL> <DEDENT> play ( ) <NEWLINE>
import sys <NEWLINE> re = range ( int ( raw_input ( ) ) ) <NEWLINE> for li in sys . stdin : <NEWLINE> <INDENT> [ a , b ] = [ int ( x ) for x in li . split ( <STRING> ) ] <NEWLINE> tmp = re [ a - 1 ] <NEWLINE> re [ a - 1 ] = re [ b - 1 ] <NEWLINE> re [ b - 1 ] = tmp <NEWLINE> <DEDENT> for i in re : <NEWLINE> <INDENT> print i + 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> <COMMENT> <NL> lineNumber = 0 <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> lineNumber += 1 <NEWLINE> <NL> <COMMENT> <NL> List = map ( float , line . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if lineNumber == 1 : <NEWLINE> <INDENT> w = List [ 0 ] <NEWLINE> array = [ i for i in xrange ( 1 , w + 1 ) ] <NEWLINE> contiune <NEWLINE> <DEDENT> if lineNumber == 2 : continue <NEWLINE> <NL> <COMMENT> <NL> [ a , b ] = List <NEWLINE> a -= 1 ; b -= 1 <NEWLINE> <NL> <COMMENT> <NL> buf = array [ a ] <NEWLINE> array [ a ] = array [ b ] <NEWLINE> array [ b ] = buf <NEWLINE> <NL> <DEDENT> for i in xrange ( w ) : <NEWLINE> <INDENT> print array [ i ] <NEWLINE> <NL> <DEDENT>
def swap ( a , b , x ) : <NEWLINE> <INDENT> if x < > a and x < > b : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> elif x == a : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> elif x == b : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> w = raw_input ( ) <NEWLINE> n = raw_input ( ) <NEWLINE> <NL> result = range ( 1 , w + 1 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( lambda x : int ( x ) , raw_input ( ) . split ( <STRING> ) <NEWLINE> result = [ swap ( a , b , x ) for x in result ] <NEWLINE> <NL> <DEDENT> for x in result : <NEWLINE> <INDENT> print x <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> w = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = [ i for i in range ( 1 , w + 1 ) ] <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> l [ a ] , l [ b ] = l [ b ] , l [ a ] <NEWLINE> <NL> <DEDENT> print ( * l , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE>
w = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> amida = [ ] <NEWLINE> <NL> for i in range ( 0 , w + 1 ) : <NEWLINE> <INDENT> amida . append ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> ai , bi = map ( int , input ( ) . split ( ) ) <NEWLINE> aa = amida [ ai ] <NEWLINE> bb = amida [ bi ] <NEWLINE> amida [ ai ] = bb <NEWLINE> amida [ bi ] = aa <NEWLINE> <NL> <DEDENT> for i in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> print ( w [ i ] ) <NEWLINE> <NL> <DEDENT>
w = int ( input ( ) ) <NEWLINE> l = [ i + 1 for i in range ( w ) ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = [ int ( i ) - 1 for i in input ( ) . split ( <STRING> ) ] <NEWLINE> t = l [ a ] <NEWLINE> l [ a ] = l [ b ] <NEWLINE> l [ b ] = t <NEWLINE> <DEDENT> for i in w : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
w = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> nums = list ( range ( w + 1 ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> nums [ a ] , nums [ b ] = nums [ b ] , nums [ a ] <NEWLINE> <DEDENT> for x in nums [ 1 : ] : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT>
a = list ( range ( int ( input ( ) ) + 1 ) ) <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : s , t = map ( int , input ( ) . split ( <STRING> ) ) ; a [ s ] , a [ t ] = a [ t ] , a [ s ] <NEWLINE> for s in a : s * print ( s ) <NEWLINE>
l = xrange ( 1 , input ( ) + 1 ) <NEWLINE> for a , b in [ map ( int , raw_input ( ) . split ( <STRING> ) ) for i in xrange ( input ( ) ) ] : l [ a - 1 ] , l [ b - 1 ] = l [ b - 1 ] , l [ a - 1 ] <NEWLINE> for i in l : print i <NEWLINE>
w = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> l = list ( range ( 1 , w + 1 ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a -= 1 <NEWLINE> b - = 1 <NEWLINE> l [ a ] , l [ b ] = l [ b ] , l [ a ] <NEWLINE> <DEDENT> for x in l : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> tate = int ( input ( ) ) <NEWLINE> yoko = int ( input ( ) ) <NEWLINE> arr = [ i + 1 for i in range ( tate ) ] <NEWLINE> for j in range ( yoko ) : <NEWLINE> <INDENT> rep1 , rep2 = input ( ) . split ( ) ; <NEWLINE> rep1 = int ( rep1 ) - 1 <NEWLINE> rep2 = int ( rep2 ) - 1 <NEWLINE> arr [ rep1 ] , arr [ rep2 ] = arr [ rep2 ] , arr [ rep1 ] <NEWLINE> <NL> <DEDENT> for k in range ( tate ) : <NEWLINE> <INDENT> print ( arr [ k ] ) <NEWLINE> <DEDENT>
w = int ( raw_input ( ) ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> s = [ i + 1 for i in range ( w ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> tmp = s [ a - 1 ] <NEWLINE> s [ a - 1 ] = s [ b - 1 ] <NEWLINE> s [ b - 1 ] = tmp <NEWLINE> <NL> <DEDENT> for i in s : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
a = [ i + 1 for i in range ( int ( input ( ) ) ) ] <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> a [ s ] , a [ t ] = a [ t ] , a [ s ] <NEWLINE> <DEDENT> for s in a : print ( s + 1 ) <NEWLINE>
w = int ( raw_input ( ) ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> l = [ i for i in range ( 1 , w + 1 ) ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> l [ a - 1 ] , l [ b - 1 ] = l [ b - 1 ] , l [ a - 1 ] <NEWLINE> n -= 1 <NEWLINE> <DEDENT> for i in l : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> w = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> array = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> array . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> a , b = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = array [ i ] <NEWLINE> a . append ( s [ 0 ] ) <NEWLINE> b . append ( s [ 1 ] ) <NEWLINE> a [ i ] , b [ i ] = int ( a [ i ] ) , int ( b [ i ] ) <NEWLINE> <NL> <DEDENT> lines = [ ] <NEWLINE> k = 0 <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> lines . append ( k ) <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tmp1 = lines [ a [ i ] - 1 ] <NEWLINE> tmp2 = lines [ b [ i ] - 1 ] <NEWLINE> lines [ a [ i ] - 1 ] = tmp2 <NEWLINE> lines [ b [ i ] - 1 ] = tmp1 <NEWLINE> <NL> <DEDENT> for i in range ( len ( lines ) ) : <NEWLINE> <INDENT> print ( lines [ i ] + 1 ) <NEWLINE> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> tate = int ( raw_input ( ) ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( 1 , tate + 1 ) : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <NL> <DEDENT> print result <NEWLINE> <NL> yoko = int ( raw_input ( ) ) <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x1 , x2 = map ( int , line . split ( <STRING> ) ) <NEWLINE> x1 -= 1 <NEWLINE> x2 -= 1 <NEWLINE> temp = result [ x2 ] <NEWLINE> result [ x2 ] = result [ x1 ] <NEWLINE> result [ x1 ] = temp <NEWLINE> <NL> <DEDENT> for num in result : <NEWLINE> <INDENT> print num <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> import math <NEWLINE> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> tate = int ( raw_input ( ) ) <NEWLINE> result = [ ] <NEWLINE> for i in range ( 1 , tate + 1 ) : <NEWLINE> <INDENT> result . append ( i ) <NEWLINE> <NL> <DEDENT> print result <NEWLINE> <NL> yoko = int ( raw_input ( ) ) <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x1 , x2 = map ( int , line . split ( <STRING> ) ) <NEWLINE> x1 -= 1 <NEWLINE> x2 -= 1 <NEWLINE> temp = result [ x2 ] <NEWLINE> result [ x2 ] = result [ x1 ] <NEWLINE> result [ x1 ] = temp <NEWLINE> <NL> <DEDENT> for num in result : <NEWLINE> <INDENT> print num <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<INDENT> w = int ( raw_input ( ) ) <NEWLINE> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> r = range ( 1 , w + 1 ) <NEWLINE> for i in a : <NEWLINE> <INDENT> tmp = r [ i [ 0 ] - 1 ] <NEWLINE> r [ i [ 0 ] - 1 ] = r [ i [ 1 ] - 1 ] <NEWLINE> r [ i [ 1 ] - 1 ] = tmp <NEWLINE> for i in r : <NEWLINE> print i <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> w = int ( raw_input ( ) ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> ans = [ ] <NEWLINE> ans = [ j for j in range ( 1 , w + 1 ) ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , ( raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> ans [ a - 1 ] , ans [ b - 1 ] = ans [ b - 1 ] , ans [ a - 1 ] <NEWLINE> <DEDENT> for item in ans : <NEWLINE> <INDENT> print item <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def side ( p1 , p2 , p3 ) : return ( p3 [ 1 ] - p1 [ 1 ] ) * ( p2 [ 0 ] - p1 [ 0 ] ) - ( p2 [ 1 ] - p1 [ 1 ] ) * ( p3 [ 0 ] - p1 [ 0 ] ) > 0 <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> x = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> p1 = x [ 0 : 2 ] <NEWLINE> p2 = x [ 2 : 4 ] <NEWLINE> p3 = x [ 4 : 6 ] <NEWLINE> p0 = x [ 6 : ] <NEWLINE> print [ <STRING> , <STRING> ] [ ( side ( p1 , p2 , p0 ) == side ( p2 , p3 , p0 ) and side ( p2 , p3 , p0 ) == side ( p3 , p1 , p0 ) ) ] <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , line . split ( ) ) <NEWLINE> AB = [ x2 - x1 , y2 - y1 ] <NEWLINE> BP = [ xp - x2 , yp - y2 ] <NEWLINE> BC = [ x3 - x2 , y3 - y2 ] <NEWLINE> CP = [ xp - x3 , yp - y3 ] <NEWLINE> CA = [ x1 - x3 , y1 - y3 ] <NEWLINE> BP = [ xp - x1 , yp - y1 ] <NEWLINE> c1 = AB [ 0 ] * BP [ 1 ] - AB [ 1 ] * BP [ 0 ] <NEWLINE> c2 = BC [ 0 ] * CP [ 1 ] - BC [ 1 ] * CP [ 0 ] <NEWLINE> c3 = CA [ 0 ] * AP [ 1 ] - CA [ 1 ] * AP [ 0 ] <NEWLINE> if ( c1 > 0 and c2 > 0 and c3 > 0 ) or ( c1 < 0 and c2 < 0 and c3 < 0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> a = ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 <NEWLINE> b = ( x1 - x3 ) ** 2 + ( y1 - y3 ) ** 2 <NEWLINE> c = ( x2 - x3 ) ** 2 + ( y2 - y3 ) ** 2 <NEWLINE> xa = ( x3 - xp ) ** 2 + ( y3 - yp ) ** 2 <NEWLINE> xb = ( x2 - xp ) ** 2 + ( y2 - yp ) ** 2 <NEWLINE> xc = ( x1 - xp ) ** 2 + ( y1 - yp ) ** 2 <NEWLINE> cosa = ( a - b + c ) / ( 2 * math . sqrt ( b ) * math . sqrt ( c ) ) <NEWLINE> cosb = ( b - a + c ) / ( 2 * math . sqrt ( a ) * math . sqrt ( c ) ) <NEWLINE> cosc = ( c - a + b ) / ( 2 * math . sqrt ( a ) * math . sqrt ( b ) ) <NEWLINE> cos1 = ( xc - xa + xc ) / ( 2 * math . sqrt ( xa ) * math . sqrt ( b ) ) <NEWLINE> cos2 = ( xa - c + xb ) / ( 2 * math . sqrt ( xb ) * math . sqrt ( c ) ) <NEWLINE> cos3 = ( xb - a + xc ) / ( 2 * math . sqrt ( xc ) * math . sqrt ( a ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if cos1 < cosa or cos2 < cosb or cos3 < cosc : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x = [ x1 , x2 , x3 , x1 ] <NEWLINE> y = [ y1 , y2 , y3 , y1 ] <NEWLINE> x = list ( map ( lambda i : i - xp , x ) ) <NEWLINE> y = list ( map ( lambda i : i - yp , y ) ) <NEWLINE> s = lambda a1 , a2 , b1 , b2 : abs ( a1 * b2 - a2 * b1 ) <NEWLINE> sum = sum ( s ( x [ i ] , y [ i ] , x [ i + 1 ] , y [ i + 1 ] ) for i in range ( 3 ) ) <NEWLINE> S = s ( x [ 1 ] - x [ 0 ] , y [ 1 ] - y [ 0 ] , x [ 2 ] - x [ 0 ] , y [ 2 ] - y [ 0 ] ) <NEWLINE> if sum == S : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> list = map ( float , line . split ( <STRING> ) ) <NEWLINE> x = list [ 0 : 6 : 2 ] <NEWLINE> y = list [ 1 : 6 : 2 ] <NEWLINE> xp = list [ 6 ] <NEWLINE> yp = list [ 7 ] <NEWLINE> xv = [ x [ a % 3 ] - x [ ( a + 1 ) % 3 ] for a in xrange ( 4 ) ] <NEWLINE> yv = [ y [ a % 3 ] - y [ ( a + 1 ) % 3 ] for a in xrange ( 4 ) ] <NEWLINE> xpv = [ xp - x [ a ] for a in xrange ( 3 ) ] <NEWLINE> ypv = [ yp - y [ a ] for a in xrange ( 3 ) ] <NEWLINE> cross = [ xv [ i ] * ypv [ i ] - yv [ i ] * xpv [ i ] for i in xrange ( 3 ) ] <NEWLINE> sorted ( cross ) <NEWLINE> if ( cross [ 2 ] > 0 and cross [ 0 ] > 0 ) or ( cross [ 2 ] < 0 and cross [ 0 ] < 0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
global r <NEWLINE> <NL> def checker ( x1 , y1 , x2 , y2 , xp , yp ) : <NEWLINE> <INDENT> vec = ( x2 - x1 ) * ( yp - y1 ) - ( y2 - y1 ) * ( xp - x1 ) <NEWLINE> if vec > 0 : <NEWLINE> <INDENT> return int ( 1 ) <NEWLINE> <DEDENT> elif vec < 0 : <NEWLINE> <INDENT> return int ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> r += int ( checker ( x1 , y1 , x2 , y2 , xp , yp ) ) <NEWLINE> r += int ( checker ( x2 , y2 , x3 , y3 , xp , yp ) ) <NEWLINE> r += int ( checker ( x3 , y3 , x1 , y1 , xp , yp ) ) <NEWLINE> if r == 3 or r == - 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def linecheck ( x1 , y1 , x2 , y2 , xp , yp ) : <NEWLINE> <INDENT> if yp - y1 > ( xp - x1 ) * ( y2 - y1 ) / ( x2 - x1 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif yp - y1 < ( xp - x1 ) * ( y2 - y1 ) / ( x2 - x1 ) : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if x1 == x2 : <NEWLINE> <INDENT> if ( x1 < xp and xp < x3 ) or ( x1 > xp and xp > x3 ) : <NEWLINE> <INDENT> judge = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge = 1 <NEWLINE> <DEDENT> judge *= linecheck ( x1 , y1 , x3 , y3 , xp , yp ) * linecheck ( x2 , y2 , x3 , y3 , xp , yp ) <NEWLINE> <DEDENT> elif x2 == x3 : <NEWLINE> <INDENT> if ( x1 < xp and xp < x3 ) or ( x1 > xp and xp > x3 ) : <NEWLINE> <INDENT> judge = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge = 1 <NEWLINE> <DEDENT> judge *= linecheck ( x1 , y1 , x2 , y2 , xp , yp ) * linecheck ( x1 , y1 , x3 , y3 , xp , yp ) <NEWLINE> <DEDENT> elif x3 == x1 : <NEWLINE> <INDENT> if ( x1 < xp and xp < x2 ) or ( x1 > xp and xp > x2 ) : <NEWLINE> <INDENT> judge = - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge = 1 <NEWLINE> <DEDENT> judge *= linecheck ( x1 , y1 , x2 , y2 , xp , yp ) * linecheck ( x2 , y2 , x3 , y3 , xp , yp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge = linecheck ( x1 , y1 , x2 , y2 , xp , yp ) * linecheck ( x1 , y1 , x3 , y3 , xp , yp ) * linecheck ( x2 , y2 , x3 , y3 , xp , yp ) <NEWLINE> <NL> <DEDENT> if judge > 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif judge < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import numpy <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> AB = numpy . array ( [ x2 - x1 , y2 - y1 ] ) <NEWLINE> AP = numpy . array ( [ xp - x1 , yp - y1 ] ) <NEWLINE> BC = numpy . array ( [ x3 - x2 , y3 - y2 ] ) <NEWLINE> BP = numpy . array ( [ xp - x2 , yp - y2 ] ) <NEWLINE> CA = numpy . array ( [ x1 - x3 , y1 - y3 ] ) <NEWLINE> CP = numpy . array ( [ xp - x3 , yp - y3 ] ) <NEWLINE> <COMMENT> <NL> if ( numpy . cross ( AB , AP ) < 0 and numpy . cross ( BC , BP ) < 0 and numpy . cross ( CA , CP ) < 0 ) or ( numpy . cross ( AB , AP ) > 0 and numpy . cross ( BC , BP ) > 0 and numpy . cross ( CA , CP ) > 0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def dot ( a , b ) : <NEWLINE> <INDENT> return ( a . real * b . real - a . imag * b . imag ) <NEWLINE> <DEDENT> def cross ( a , b ) : <NEWLINE> <INDENT> return ( a . real * b . imag - a . imag * b . real ) <NEWLINE> <NL> <DEDENT> EPS = 10 ** ( - 7 ) <NEWLINE> <NL> def isIntersectedLS ( a1 , a2 , b1 , b2 ) : <NEWLINE> <INDENT> return ( ( cross ( a2 - a1 , b1 - a1 ) * cross ( a2 - a1 , b2 - a1 ) ) < EPS and <NEWLINE> <INDENT> ( cross ( b2 - b1 , a1 - b1 ) * cross ( b2 - b1 , a2 - b1 ) ) < EPS ) <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y = [ [ 0. for i in xrange ( 3 ) ] for j in xrange ( 2 ) ] <NEWLINE> a = [ ] <NEWLINE> z = ( 0 , 0 ) <NEWLINE> line = raw_input ( ) . split ( ) <NEWLINE> if line == [ ] : break <NEWLINE> x [ 0 ] , y [ 0 ] , x [ 1 ] , y [ 1 ] , x [ 2 ] , y [ 2 ] , z [ 0 ] , z [ 1 ] = map ( float , line ) <NEWLINE> for i in xrange ( 3 ) : <NEWLINE> <INDENT> a . append ( ( x [ i ] + ( y [ i ] ) * 1j ) ) <NEWLINE> <DEDENT> c = ( sum ( x ) / 3 ) + ( sum ( y ) / 3 ) * 1j <NEWLINE> p = z [ 0 ] + z [ 1 ] * 1j <NEWLINE> <NL> for i in xrange ( 3 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if isIntersectedLS ( a [ i - 1 ] , a [ i ] , c , p ) is True : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def cross ( a , b ) : <NEWLINE> <INDENT> return ( a . conjugate ( ) * b ) . real <NEWLINE> <DEDENT> def dot ( a , b ) : <NEWLINE> <INDENT> return ( a . conjugate ( ) * b ) . imag <NEWLINE> <NL> <DEDENT> def ccw ( a , b , c ) : <NEWLINE> <INDENT> x = b - a <NEWLINE> y = c - a ; <NEWLINE> if cross ( x , y ) > 0 : return 1 <NEWLINE> if cross ( x , y ) < 0 : return - 1 <NEWLINE> if dot ( x , y ) < 0 : return 2 <NEWLINE> if abs ( x ) < abs ( y ) : return - 2 <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> def solve ( l , p ) : <NEWLINE> <INDENT> x = ccw ( l [ 0 ] [ 0 ] , l [ 0 ] [ 1 ] , p ) <NEWLINE> if x != 0 : <NEWLINE> <INDENT> x = int ( x / abs ( x ) ) <NEWLINE> <DEDENT> for i in l [ 1 : ] : <NEWLINE> <INDENT> y = ccw ( i [ 0 ] , i [ 1 ] , p ) <NEWLINE> if y != 0 : <NEWLINE> <INDENT> y = int ( y / abs ( y ) ) <NEWLINE> <DEDENT> if x != y : <NEWLINE> <INDENT> print <STRING> <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> ax , ay , bx , by , cx , cy , px , py = map ( float , line . split ( ) ) <NEWLINE> a = complex ( ax , ay ) <NEWLINE> b = complex ( bx , by ) <NEWLINE> c = complex ( cx , cy ) <NEWLINE> p = complex ( px , py ) <NEWLINE> solve ( [ ( a , b ) , ( b , c ) , ( c , a ) ] , p ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <NL> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = [ float ( p ) for p in input ( ) . split ( ) ] <NEWLINE> <NL> x_vector_1to2 = x2 - x1 ; <NEWLINE> y_vector_1to2 = y2 - y1 ; <NEWLINE> x_vector_1to3 = x3 - x1 ; <NEWLINE> y_vector_1to3 = y3 - y1 ; <NEWLINE> x_vector_p = xp - x1 ; <NEWLINE> y_vector_p = yp - y1 ; <NEWLINE> <NL> def renritu ( p , q , r , s , t , u ) : <COMMENT> <NEWLINE> <INDENT> a = p ; b = q ; c = r ; d = s ; e = t ; f = u ; <NEWLINE> a1 = a * d ; b1 = b * d ; c1 = c * d ; d1 = d * a ; e1 = e * a ; f1 = f * a ; <NEWLINE> res_y = b1 - e1 ; <NEWLINE> if res_y != 0 : <NEWLINE> <INDENT> res_y = ( c1 - f1 ) / res_y ; <NEWLINE> res_x = ( c - b * res_y ) / a ; <NEWLINE> return ( res_x , res_y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( - 1 , - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> res = renritu ( x_vector_1to2 , x_vector_1to3 , x_vector_p , y_vector_1to2 , y_vector_1to3 , y_vector_p ) <NEWLINE> if res [ 0 ] >= 0 and res [ 1 ] >= 0 and ( res [ 0 ] + res [ 1 ] ) <= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def checker ( x1 , y1 , x2 , y2 , xp , yp ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> vec = ( x2 - x1 ) * ( yp - y1 ) - ( y2 - y1 ) * ( xp - x1 ) <NEWLINE> if vec > 0 : <NEWLINE> <INDENT> r = 1 <NEWLINE> return r <NEWLINE> <DEDENT> elif vec < 0 : <NEWLINE> <INDENT> r = - 1 <NEWLINE> return r <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , xp , yp = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> r = 0 <NEWLINE> r += int ( checker ( x1 , y1 , x2 , y2 , xp , yp ) ) <NEWLINE> r += int ( checker ( x2 , y2 , x3 , y3 , xp , yp ) ) <NEWLINE> r += int ( checker ( x3 , y3 , x1 , y1 , xp , yp ) ) <NEWLINE> if r == 3 or r == - 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
g = lambda a , b : abs ( a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> t = input ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l = [ float ( i ) for i in t . split ( ) ] <NEWLINE> ba = [ l [ 0 ] - l [ 2 ] , l [ 1 ] - l [ 3 ] ] <NEWLINE> ab = [ - i for i in ba ] <NEWLINE> cb = [ l [ 2 ] - l [ 4 ] , l [ 3 ] - l [ 5 ] ] <NEWLINE> bc = [ - i for i in cb ] <NEWLINE> ca = [ l [ 0 ] - l [ 4 ] , l [ 1 ] - l [ 5 ] ] <NEWLINE> ac = [ - i for i in ca ] <NEWLINE> ap = [ l [ 6 ] - l [ 0 ] , l [ 7 ] - l [ 1 ] ] <NEWLINE> bp = [ l [ 6 ] - l [ 2 ] , l [ 7 ] - l [ 3 ] ] <NEWLINE> cp = [ l [ 6 ] - l [ 4 ] , l [ 7 ] - l [ 5 ] ] <NEWLINE> if g ( ab , ac ) < g ( ab , ap ) or g ( ba , bc ) < g ( ba , bp ) or g ( ca , cb ) < g ( ca , cp ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import math <NEWLINE> import cmath <NEWLINE> <NL> class Point ( object ) : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . point = complex ( x , y ) <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . point . real , self . point . imag ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Triangle ( Point ) : <NEWLINE> <INDENT> def __init__ ( self , a , b , c ) : <NEWLINE> <INDENT> self . a = a <NEWLINE> self . b = b <NEWLINE> self . c = c <NEWLINE> <NL> <COMMENT> <NL> self . edgeA = abs ( b . point - c . point ) <NEWLINE> self . edgeB = abs ( c . point - a . point ) <NEWLINE> self . edgeC = abs ( a . point - b . point ) <NEWLINE> <NL> <COMMENT> <NL> self . angleA = Triangle . angle ( self . edgeA , self . edgeB , self . edgeC ) <NEWLINE> self . angleB = Triangle . angle ( self . edgeB , self . edgeC , self . edgeA ) <NEWLINE> self . angleC = Triangle . angle ( self . edgeC , self . edgeA , self . edgeB ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def angle ( A , B , C ) : <NEWLINE> <INDENT> return cmath . acos ( ( B * B + C * C - A * A ) / ( 2 * B * C ) ) . real <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> eps = 0.0001 <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> line = [ float ( x ) for x in line . split ( ) ] <NEWLINE> p1 = Point ( line [ 0 ] , line [ 1 ] ) <NEWLINE> p2 = Point ( line [ 2 ] , line [ 3 ] ) <NEWLINE> p3 = Point ( line [ 4 ] , line [ 5 ] ) <NEWLINE> P = Point ( line [ 6 ] , line [ 7 ] ) <NEWLINE> t1 = Triangle ( p1 , p2 , P ) <NEWLINE> t2 = Triangle ( p2 , p3 , P ) <NEWLINE> t3 = Triangle ( p3 , p1 , P ) <NEWLINE> if ( math . degrees ( t1 . angleC + t2 . angleC + t3 . angleC ) <= 360 + eps ) and ( math . degrees ( t1 . angleC + t2 . angleC + t3 . angleC ) >= 360 - eps ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> train = int ( raw_input ( ) ) <NEWLINE> if train == 0 : <NEWLINE> <INDENT> print ( l . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( train ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a != 0 : ans . append ( a ) <NEWLINE> elif a == 0 : <NEWLINE> <INDENT> print ans [ - 1 ] <NEWLINE> del ans [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> except EOFError : break <NEWLINE> <DEDENT>
import sys <NEWLINE> cars = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> car = int ( line ) <NEWLINE> if car : <NEWLINE> <INDENT> cars . append ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cars . pop ( ) ) <NEWLINE> <DEDENT> <DEDENT>
lis = [ ] <NEWLINE> lis . append ( input ( ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if inp == 0 : <NEWLINE> <INDENT> print lis [ - 1 ] <NEWLINE> del lis [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( inp ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> stack = [ ] <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> a = int ( i . split ( <STRING> ) [ 0 ] ) <NEWLINE> if a > 0 : <NEWLINE> <INDENT> stack . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> list = [ ] <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if float ( i ) != 0 : <NEWLINE> <INDENT> list . append ( float ( i ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print int ( list . pop ( ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> lis = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> print lis [ - 1 ] <NEWLINE> lis . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( d ) <NEWLINE> <DEDENT> <DEDENT>
rail = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n != 0 : <NEWLINE> <INDENT> rail . append ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print rail . pop ( ) <NEWLINE> <DEDENT> <DEDENT>
garage = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print ( garage . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> garage . append ( num ) <NEWLINE> <DEDENT> <DEDENT>
bottom = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> carnum = input ( ) <NEWLINE> if carnum == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif carnum == 0 : <NEWLINE> <INDENT> bottom . pop ( ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nottom . append ( carnum ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> lst = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> num = int ( line . strip ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print lst . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( num ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> s = [ int ( input ( ) ) ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> print ( s . pop ( ) ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( int ( n ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> lst = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> num = int ( line . split ( ) ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> print lst . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( num ) <NEWLINE> <DEDENT> <DEDENT> sys . exit ( 0 ) <NEWLINE>
tracks = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> c0 = raw_input ( ) <NEWLINE> c = int ( c0 ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print tracks . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tracks . append ( c ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> garage = deque ( ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> came = int ( raw_input ( ) ) <NEWLINE> if came == 0 : <NEWLINE> <INDENT> print garage . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> garage . append ( came ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> if s != 0 : <NEWLINE> <INDENT> a . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a . pop ( ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> syako = [ ] <NEWLINE> number = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> if number != 0 : <NEWLINE> <INDENT> syako . append ( number ) <NEWLINE> <DEDENT> elif number == 0 : <NEWLINE> <INDENT> print syako . pop ( ) <NEWLINE> <DEDENT> number = input ( ) <NEWLINE> if number == EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> arr = [ ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( arr [ - 1 ] ) <NEWLINE> arr = arr [ : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> arr . append ( n ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 0 <NEWLINE> x = d <NEWLINE> while x < 600 : <NEWLINE> <INDENT> ans += ( x ** 2 ) * dx += d <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def f ( x ) : <NEWLINE> <INDENT> return x ** 2 <NEWLINE> <NL> <DEDENT> def integral ( d ) : <NEWLINE> <INDENT> s = f ( d ) * d <NEWLINE> for i in range ( 600 // d - 1 ) : <NEWLINE> <INDENT> s += f ( d * ( i + 1 ) ) * d <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> print ( integral ( line ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> S = lambda s : sum ( [ ( ( i * s ) ** 2 ) * s for i in range ( int ( 600 / s ) ) ] ) <NEWLINE> [ print ( S [ int ( line ) ] ) for line in sys . stdin ] <NEWLINE> <NL>
import sys <NEWLINE> <NL> for d in map ( int , sys . stdin ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for x in range ( d , 600 , d ) : <NEWLINE> <INDENT> sum += ( x ** 2 ) * d <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> d = raw_input ( ) <NEWLINE> if d != <STRING> : <NEWLINE> <INDENT> size = 0 <NEWLINE> d = int ( d ) <NEWLINE> fd = d <NEWLINE> for x in range ( 1 , 600 / d ) : <NEWLINE> <INDENT> size += d * ( fd ** 2 ) <NEWLINE> fd += d <NEWLINE> <DEDENT> print size <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for d in int ( sys . stdin ) : <NEWLINE> <INDENT> print sum ( [ d * x * x for x in range ( d , 600 , d ) ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> dd = raw_input ( ) <NEWLINE> d = int ( dd ) <NEWLINE> i = 1 <NEWLINE> ans = 0 <NEWLINE> while i * d < 600 : <NEWLINE> <INDENT> ans += ( i * d ) * ( i * d ) * d <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rects = map ( lambda x : d * x * x , range ( d , 600 , d ) ) <NEWLINE> print reduce ( lambda x , y : x + y , rects ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> result = 0 <NEWLINE> d = int ( line ) <NEWLINE> x = d <NEWLINE> while x < 600 : <NEWLINE> <INDENT> result += x ** 2 * d <NEWLINE> <DEDENT> print result <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> a = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( line ) <NEWLINE> <NL> <DEDENT> for n in a : <NEWLINE> <INDENT> num = int ( n ) <NEWLINE> x = 0 <NEWLINE> are = 0 <NEWLINE> while x < 600 : <NEWLINE> <INDENT> are += ( x ** 2 ) * num <NEWLINE> x += num <NEWLINE> <NL> <DEDENT> <DEDENT> print area <NEWLINE>
t = 0 <NEWLINE> while t == 0 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ( d * ( ( i * d ) ** 2 ) for i in range ( int ( 600 / d ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
for i in xrange ( input ( ) ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a + b if len ( str ( a + b ) ) <= 80 else <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> x = str ( a + b ) <NEWLINE> print ( <STRING> if len ( x ) > 80 else a + b ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = int ( input ( ) ) + int ( input ( ) ) <NEWLINE> if la >= 10 ** 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
line_num = int ( raw_input ( ) ) <NEWLINE> for n in range ( line_num ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> b = raw_input ( ) <NEWLINE> ov = 0 <NEWLINE> if len ( a ) > 80 or len ( b ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> ov = 1 <NEWLINE> <DEDENT> filled_a , filled_b = a . zfill ( 80 ) , b . zfill ( 80 ) <NEWLINE> rlist_a = map ( int , list ( filled_a ) [ : : - 1 ] ) <NEWLINE> rlist_b = map ( int , list ( filled_b ) [ : : - 1 ] ) <NEWLINE> rlist_sum = [ ] <NEWLINE> for n in range ( 80 ) : <NEWLINE> <INDENT> rlist_sum . append ( rlist_a [ n ] + rlist_b [ n ] ) <NEWLINE> <DEDENT> for n in range ( 79 ) : <NEWLINE> <INDENT> if rlist_sum [ n ] > 9 : <NEWLINE> <INDENT> rlist_sum [ n ] -= 10 <NEWLINE> rlist_sum [ n + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> if rlist_sum [ 79 ] > 9 : <NEWLINE> <INDENT> if ov < 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> else <NEWLINE> <INDENT> list_sum = [ ] <NEWLINE> f = 0 <NEWLINE> for n in rlist_sum [ : : - 1 ] : <NEWLINE> <INDENT> if f > 0 : <NEWLINE> <INDENT> list_sum . append ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if n > 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> list_sum . append ( n ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , list_sum ) ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> s = str ( a + b ) <NEWLINE> if ( len ( s ) <= 80 ) : print str ( a + b ) <NEWLINE> else print <STRING> <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> if str ( a + b ) > 80 : <NEWLINE> <INDENT> print overflow <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> ds = int ( raw_input ( ) ) <NEWLINE> list = [ long ( x . strip ( ) ) for x in sys . stdin . readlines ( ) ] <NEWLINE> print list <NEWLINE> for i in xrange ( ds ) : <NEWLINE> <INDENT> sum = str ( list [ i * 2 ] + list [ i * 2 + 1 ] ) <NEWLINE> if len ( sum ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print sum <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> count = int ( input ( ) ) <NEWLINE> for a in range ( count ) : <NEWLINE> <INDENT> q , w = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> t = q + w <NEWLINE> if t > 10 ** 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print t <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( 0 , n ) ; <NEWLINE> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> b = int ( raw_input ( ) ) <NEWLINE> ans = str ( a + b ) <NEWLINE> <NL> if len ( ans ) > 80 ; <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print sum <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) , <NEWLINE> b = input ( ) <NEWLINE> c = a + b <NEWLINE> if len ( a ) > 80 or len ( b ) > 80 or len ( c ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> <DEDENT>
<NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> ans = x + y <NEWLINE> if len ( str ( ans ) ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ans <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> N = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> s = str ( a + b ) <NEWLINE> limit = <STRING> + <STRING> * 79 <NEWLINE> if len ( s ) <= limit : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import sys <NEWLINE> <NL> for cnt , line in enumerate ( sys . stdin ) : <NEWLINE> <NL> <INDENT> if cnt == 0 : continue <NEWLINE> <NL> if cnt % 2 == 1 : <NEWLINE> <INDENT> a = int ( line ) <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = int ( line ) <NEWLINE> <NL> <DEDENT> if math . log10 ( a ) > 79 or math . log10 ( b ) > 79 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = a + b <NEWLINE> if math . log10 ( c ) > 79 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print c <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = sum ( [ int ( input ( ) ) for _ in range ( n ) ] ) <NEWLINE> print ( a if a < 10 ** 80 else <STRING> ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> <NL> def align_digit ( a , b ) : <NEWLINE> <INDENT> la , lb = len ( a ) , len ( b ) <NEWLINE> if la < lb : <NEWLINE> <INDENT> a = a . zfill ( lb ) <NEWLINE> <DEDENT> elif lb < la : <NEWLINE> <INDENT> b = b . zfill ( la ) <NEWLINE> <DEDENT> return a , b <NEWLINE> <NL> <NL> <DEDENT> def split_to_ints ( s , n = 10 ) : <NEWLINE> <INDENT> length = len ( s ) <NEWLINE> return [ int ( s [ i - n : i ] ) for i in range ( length , 0 , - n ) ] <NEWLINE> <NL> <NL> <DEDENT> def add ( a , b , n = 10 ) : <NEWLINE> <INDENT> a , b = align_digit ( a , b ) <NEWLINE> print ( a , b ) <NEWLINE> ints_a = split_to_ints ( a , n ) <NEWLINE> ints_b = split_to_ints ( b , n ) <NEWLINE> carry = 0 <NEWLINE> result = [ ] <NEWLINE> <NL> zipped = list ( zip ( ints_a , ints_b ) ) [ : : - 1 ] <NEWLINE> print ( zipped ) <NEWLINE> for i , ( int_a , int_b ) in enumerate ( zipped ) : <NEWLINE> <INDENT> s = int_a + int_b + carry <NEWLINE> carry = int ( s / ( 10 ** n ) ) <NEWLINE> if i != len ( zipped ) - 1 : <NEWLINE> <INDENT> result . append ( str ( s % ( 10 ** ( n - 1 ) ) ) . zfill ( n ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result . append ( str ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> ret = str ( int ( <STRING> . join ( reversed ( result ) ) ) ) <NEWLINE> if len ( ret ) > 80 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n_input = int ( input ( ) ) <NEWLINE> for i in range ( n_input ) : <NEWLINE> <INDENT> a , b = input ( ) , input ( ) <NEWLINE> print ( add ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ int ( x . strip ( ) ) for x in sys . stdin . readlines ( ) ] <NEWLINE> n = lines [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> a , b = lines [ 2 * i + 1 ] , lines [ 2 * i + 2 ] <NEWLINE> if len ( str ( a + b ) ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import sys <NEWLINE> <NL> num = input ( ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> num1 = [ ] <NEWLINE> s = input ( ) <NEWLINE> t = input ( ) <NEWLINE> u = s + u <NEWLINE> if len ( str ( u ) ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print u <NEWLINE> <DEDENT> <DEDENT>
for x in range ( input ( ) ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> x = x [ : : - 1 ] <NEWLINE> y = raw_input ( ) <NEWLINE> y = y [ : : - 1 ] <NEWLINE> z = [ 0 ] * 81 <NEWLINE> for i in xrange ( len ( x ) ) : <NEWLINE> <INDENT> z [ i ] = int ( x [ i ] ) <NEWLINE> <DEDENT> for j in xrange ( len ( y ) ) : <NEWLINE> <INDENT> z [ j ] = z [ j ] + int ( y [ j ] ) <NEWLINE> <DEDENT> for k in xrange ( max ( len ( x ) , len ( y ) ) ) : <NEWLINE> <INDENT> sum = z [ k ] <NEWLINE> z [ k ] = sum % 10 <NEWLINE> z [ k + 1 ] += sum / 10 <NEWLINE> <DEDENT> z . reverse ( ) <NEWLINE> for j in xrange ( len ( z ) ) : <NEWLINE> <INDENT> if z [ 0 ] == 0 : <NEWLINE> <INDENT> z . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , z ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> result = long ( raw_input ( ) ) + long ( raw_input ( ) ) <NEWLINE> if math . log10 ( result ) + 1 > 80 : print <STRING> <NEWLINE> else : print result <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = int ( input ( ) ) + int ( input ( ) ) <NEWLINE> if len ( str ( s ) ) >= 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s = int ( input ( ) ) + int ( input ( ) ) <NEWLINE> print ( <STRING> iflen ( str ( s ) ) > 80 else s ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> n = int ( raw_input ( ) ) ; <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = int ( raw_input ( ) ) ; <NEWLINE> b = int ( raw_input ( ) ) ; <NEWLINE> if math . log10 ( a + b ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a + b ; <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a + b ) <NEWLINE>
for _ in range ( int ( input ( ) ) : <NEWLINE> <INDENT> a = int ( input ( ) ) + int ( input ( ) ) <NEWLINE> print ( a if a < 10 ** 80 else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> lineNumber = 0 <NEWLINE> out = False <NEWLINE> <COMMENT> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> lineNumber += 1 <NEWLINE> <NL> <COMMENT> <NL> if lineNumber == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> List = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> if lineNumber % 2 == 0 : a = line . strip ( ) <NEWLINE> else : b = line . strip ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> if lineNumber % 2 == 1 : <NEWLINE> <INDENT> if not out : out = True <NEWLINE> else : print <STRING> , <NEWLINE> <NL> maxlen = max ( len ( a ) , len ( b ) ) <NEWLINE> if maxlen > 80 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> continue <NEWLINE> <NL> <DEDENT> upper = 0 <NEWLINE> c = <STRING> <NEWLINE> for i in xrange ( 1 , maxlen + 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> buf = int ( a [ - i ] ) + int ( b [ - i ] ) + upper <NEWLINE> upper = buf / 10 <NEWLINE> buf %= 10 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> buf = int ( a [ - i ] ) + upper <NEWLINE> upper = buf / 10 <NEWLINE> buf %= 10 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> buf = int ( b [ - i ] ) + upper <NEWLINE> upper = buf / 10 <NEWLINE> buf %= 10 <NEWLINE> <DEDENT> <DEDENT> c = str ( buf ) + c <NEWLINE> <NL> <DEDENT> if upper != 0 : c = str ( upper ) + c <NEWLINE> <NL> if len ( c ) > 80 : print <STRING> , <NEWLINE> else : print c , <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if len ( str ( a + b ) ) > 80 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( str ( a ) ) > 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( str ( b ) ) > 80 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a + b ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import itertools <NEWLINE> <NL> dataset_num = int ( input ( ) ) <NEWLINE> <NL> class Overflow ( Exception ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> for _ in range ( dataset_num ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> k1 = input ( ) <NEWLINE> k2 = input ( ) <NEWLINE> k1_val = [ 0 ] * 80 <NEWLINE> k2_val = [ 0 ] * 80 <NEWLINE> <NL> if len ( k1 ) > 80 or len ( k2 ) > 80 : <NEWLINE> <INDENT> raise Overflow ( ) <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( reversed ( k1 ) ) : <NEWLINE> <INDENT> k1_val [ i ] = int ( x ) <NEWLINE> <NL> <DEDENT> for i , x in enumerate ( reversed ( k2 ) ) : <NEWLINE> <INDENT> k2_val [ i ] = int ( x ) <NEWLINE> <NL> <DEDENT> res = [ 0 ] * 80 <NEWLINE> for i in range ( 0 , 80 ) : <NEWLINE> <INDENT> res [ i ] += k1_val [ i ] + k2_val [ i ] <NEWLINE> if res [ i ] >= 10 : <NEWLINE> <INDENT> res [ i + 1 ] += 1 <NEWLINE> res [ i ] -= 10 <NEWLINE> <DEDENT> <DEDENT> sumstr = <STRING> . join ( [ str ( x ) for x in itertools . dropwhile ( lambda x : x == 0 , reversed ( res ) ) ] ) <NEWLINE> if len ( sumstr ) > 80 : <NEWLINE> <INDENT> raise Overflow ( ) <NEWLINE> <NL> <DEDENT> print ( sumstr ) <NEWLINE> <DEDENT> except Overflow : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ int ( x . strip ( ) ) for x in sys . stdin . readlines ( ) if x != <STRING> ] <NEWLINE> n = lines [ 0 ] <NEWLINE> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> a , b = lines [ 2 * i + 1 ] , lines [ 2 * i + 2 ] <NEWLINE> if len ( str ( a + b ) ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a + b <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( a + b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> sum = a + b <NEWLINE> if str ( sum ) . length ( ) > 80 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( sum ) <NEWLINE> <DEDENT> <DEDENT>
a = input ( ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> if len ( x + y ) > 80 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print x + y <NEWLINE> <DEDENT> <DEDENT>
import turtle <NEWLINE> k = turtle . Turtle ( ) <NEWLINE> k . speed ( 0 ) <NEWLINE> k . left ( 90 ) <NEWLINE> while True : <NEWLINE> <INDENT> x = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if x [ 0 ] == 0 and x [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k . fd ( x [ 0 ] ) <NEWLINE> k . right ( x [ 1 ] ) <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> print int ( k . xcor ( ) ) <NEWLINE> print int ( k . ycor ( ) ) <NEWLINE>
import math <NEWLINE> x = 0.0 <NEWLINE> y = 0.0 <NEWLINE> while True : <NEWLINE> <INDENT> m , r = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if m == 0 and r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> theta += r <NEWLINE> rad = theta / 180 * math . pi <NEWLINE> x += m * math . cos ( rad ) <NEWLINE> y += m * math . sin ( rad ) <NEWLINE> <NL> <DEDENT> print int ( x ) <NEWLINE> print int ( y ) <NEWLINE>
import math <NEWLINE> x , y , r = 0 , 0 , 90 <NEWLINE> while True : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( m , n ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y += m * math . sin ( math . radians ( r ) ) <NEWLINE> y <NEWLINE> x += m * math . cos ( math . radians ( r ) ) <NEWLINE> r -= n <NEWLINE> <DEDENT> print ( int ( x ) ) <NEWLINE> print ( int ( y ) ) <NEWLINE>
import math <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> r = 90 <NEWLINE> while True : <NEWLINE> <INDENT> d , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == 0 and t == 0 : <NEWLINE> <INDENT> print ( int ( x ) , int ( y ) , sep = <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> x += math . cos ( math . radians ( r ) ) * d <NEWLINE> y += math . sin ( math . radians ( r ) ) * d <NEWLINE> r -= t <NEWLINE> <DEDENT>
import sys , math <NEWLINE> x = y = r = 0 <NEWLINE> m = 3.14 / 180 <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> h , w = map ( int , l . split ( <STRING> ) ) <NEWLINE> x += h * math . sin ( r * m ) <NEWLINE> y += h * math . cos ( r * m ) <NEWLINE> r += w <NEWLINE> <DEDENT> print <STRING> % ( x , y ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from math import * <NEWLINE> <NL> lineNumber = 0 <NEWLINE> coord = [ 0 , 0 ] <NEWLINE> theta = 0.5 * pi <NEWLINE> <COMMENT> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> lineNumber += 1 <NEWLINE> <NL> <COMMENT> <NL> if lineNumber == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> List = map ( float , line . strip ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> forward = List [ 0 ] <NEWLINE> d_theta = List [ 1 ] / 180.0 * pi <NEWLINE> <NL> <COMMENT> <NL> coord [ 0 ] += forward * cos ( theta ) <NEWLINE> coord [ 1 ] += forward * sin ( theta ) <NEWLINE> theta += d_theta <NEWLINE> <NL> <DEDENT> print int ( ceil ( coord [ 0 ] ) ) <NEWLINE> print int ( ceil ( coord [ 1 ] ) ) <NEWLINE>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> input = raw_input ( ) <NEWLINE> for i in range ( 0 , 26 ) : <NEWLINE> <INDENT> str = <STRING> <NEWLINE> for c in input : <NEWLINE> <INDENT> if c . isalpha ( ) : <NEWLINE> <INDENT> c = chr ( ord ( c ) + i ) <NEWLINE> if ord ( c ) > ord ( <STRING> ) : <NEWLINE> <INDENT> c = chr ( ord ( <STRING> ) - ord ( <STRING> ) + ord ( c ) - 1 ) <NEWLINE> <DEDENT> <DEDENT> str += c <NEWLINE> <DEDENT> for word in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> if ( str . find ( word ) != - 1 ) : <NEWLINE> <INDENT> print str <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
alpha = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sent = <STRING> <NEWLINE> word = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( word ) ) <NEWLINE> <INDENT> for j in range ( len ( word [ i ] ) <NEWLINE> <INDENT> for al in alpha : <NEWLINE> <INDENT> if al == word [ i ] : <NEWLINE> <INDENT> word [ i ] = al <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sent += word + <STRING> <NEWLINE> <DEDENT> sent = sent ( : lent ( sent ) - 1 ) <NEWLINE> print sent <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def casar ( s , n ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for c in ( 65 , 97 ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> d [ chr ( i + c ) ] = chr ( ( i + n ) % 26 + c ) <NEWLINE> <NL> <DEDENT> <DEDENT> return <STRING> . join ( [ d . get ( c , c ) for c in s ] ) <NEWLINE> <NL> <NL> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> encrypttxt = raw_input ( ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> t = casar ( encrypttxt , i ) <NEWLINE> if <STRING> in t or <STRING> in t or <STRING> in t : <NEWLINE> <INDENT> print t <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> import sys <NEWLINE> <NL> def move ( i , string ) : <NEWLINE> <INDENT> lis = [ ] <NEWLINE> for e in string : <NEWLINE> <INDENT> if e == <STRING> : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ord ( e ) + i > 122 : <NEWLINE> <INDENT> lis . append ( chr ( ord ( e ) + i - 26 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( chr ( ord ( e ) + i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> st = <STRING> . join ( lis ) <NEWLINE> if st in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def move2 ( i , string ) : <NEWLINE> <INDENT> lis = [ ] <NEWLINE> for e in string : <NEWLINE> <INDENT> if e == <STRING> : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ord ( e ) + i > 122 : <NEWLINE> <INDENT> lis . append ( chr ( ord ( e ) + i - 26 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( chr ( ord ( e ) + i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> st = <STRING> . join ( lis ) <NEWLINE> return st <NEWLINE> <NL> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> flag = False <NEWLINE> i = 0 <NEWLINE> d = map ( str , s . split ( ) ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> for e in d : <NEWLINE> <INDENT> if move ( i , e ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print move2 ( i , s ) <NEWLINE> <DEDENT>
alpha = <STRING> <NEWLINE> alp_num = dict ( zip ( alpha , range ( 26 ) ) ) <NEWLINE> num_alp = dict ( zip ( range ( 26 ) , alpha ) ) <NEWLINE> alp_num [ <STRING> ] = <STRING> ; num_alp [ <STRING> ] = <STRING> ; alp_num [ <STRING> ] = <STRING> ; num_alp [ <STRING> ] = <STRING> <NEWLINE> while True : <NEWLINE> <NL> <INDENT> cipher = raw_input ( ) <NEWLINE> if len ( cipher ) != 0 : <NEWLINE> <INDENT> numcipher = [ alp_num [ val ] for val in cipher ] <NEWLINE> while True : <NEWLINE> <INDENT> cipher = <STRING> <NEWLINE> for val in numcipher : cipher += str ( num_alp [ val ] ) <NEWLINE> if <STRING> in cipher or <STRING> in cipher or <STRING> in cipher : <NEWLINE> <INDENT> print cipher ; break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> numcipher2 = [ ] <NEWLINE> for val in numcipher : <NEWLINE> <INDENT> if val == <STRING> : numcipher2 . append ( <STRING> ) <NEWLINE> elif val == <STRING> : numcipher2 . append ( <STRING> ) <NEWLINE> elif val == 25 : numcipher2 . append ( 0 ) <NEWLINE> else : numcipher2 . append ( val + 1 ) <NEWLINE> <DEDENT> numcipher = numcipher2 <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : break <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if <STRING> in c or <STRING> in c or <STRING> in b : <NEWLINE> <INDENT> print ( c ) <NEWLINE> <DEDENT> for i in range ( 1 , 26 ) : <NEWLINE> <INDENT> c = <STRING> <NEWLINE> for j in b : <NEWLINE> <INDENT> if ( j == <STRING> ) : <NEWLINE> <INDENT> c += ( <STRING> ) <NEWLINE> <DEDENT> elif ( str . isalpha ( j ) == 1 ) : <NEWLINE> <INDENT> c += ( chr ( ord ( j ) + 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += j <NEWLINE> <DEDENT> <DEDENT> if <STRING> in c or <STRING> in c or <STRING> in c : <NEWLINE> <INDENT> print ( c ) <NEWLINE> break <NEWLINE> <DEDENT> b = c <NEWLINE> <DEDENT> <DEDENT>
import sys , string <NEWLINE> a = string . ascii_lowercase <NEWLINE> t = string . maketrans ( a , a [ 1 : ] + a [ 0 ] ) <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> s = s . strip ( ) <NEWLINE> while not ( <STRING> in s or <STRING> in s or <STRING> in s ) : <NEWLINE> <INDENT> s = s . translate ( t ) <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def this ( word ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> t = [ ] <NEWLINE> for c in word : <NEWLINE> <INDENT> t . append ( ord ( c ) - ord ( <STRING> [ i ] ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> if ( t [ 0 ] == t [ 1 ] and t [ 1 ] == t [ 2 ] and t [ 2 ] == t [ 3 ] ) : <NEWLINE> <INDENT> return t [ 0 ] <NEWLINE> <DEDENT> return 30 <NEWLINE> <NL> <DEDENT> def that ( word ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> t = [ ] <NEWLINE> for c in word : <NEWLINE> <INDENT> t . append ( ord ( c ) - ord ( <STRING> [ i ] ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> if ( t [ 0 ] == t [ 1 ] and t [ 1 ] == t [ 2 ] and t [ 2 ] == t [ 3 ] ) : <NEWLINE> <INDENT> return t [ 0 ] <NEWLINE> <DEDENT> return 30 <NEWLINE> <NL> <DEDENT> def the ( word ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> t = [ ] <NEWLINE> for c in word : <NEWLINE> <INDENT> t . append ( ord ( c ) - ord ( <STRING> [ i ] ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> if ( t [ 0 ] == t [ 1 ] and t [ 1 ] == t [ 2 ] ) : <NEWLINE> <INDENT> return t [ 0 ] <NEWLINE> <DEDENT> return 30 <NEWLINE> <NL> <DEDENT> for string in sys . stdin : <NEWLINE> <INDENT> for word in string . split ( <STRING> ) : <NEWLINE> <INDENT> if ( len ( word ) == 3 ) : <NEWLINE> <INDENT> if the ( word ) < 30 : <NEWLINE> <INDENT> x = the ( word ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ( len ( word ) == 4 ) : <NEWLINE> <INDENT> if this ( word ) < 30 : <NEWLINE> <INDENT> x = this ( word ) <NEWLINE> break <NEWLINE> <DEDENT> if that ( word ) < 30 : <NEWLINE> <INDENT> x = that ( word ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> alpha = <STRING> <NEWLINE> result = <STRING> <NEWLINE> for c in string : <NEWLINE> <INDENT> if c in alpha : <NEWLINE> <INDENT> result += alpha [ alpha . find ( c ) - x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += c <NEWLINE> <DEDENT> <DEDENT> print result [ : - 1 ] <NEWLINE> <DEDENT>
import sys <NEWLINE> def rot ( s ) : <NEWLINE> <INDENT> A = <STRING> <NEWLINE> x = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> try : x += A [ A . index ( c ) + 1 ] <NEWLINE> except : x += c <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> w = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for l in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> f = 1 <NEWLINE> while f : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if w [ i ] in s : <NEWLINE> <INDENT> f = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : w [ i ] = rot ( w [ i ] ) <NEWLINE> <DEDENT> else : c += 1 <NEWLINE> <DEDENT> while c - 26 : <NEWLINE> <INDENT> s = rot ( s ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> print s [ : - 1 ] <NEWLINE> <DEDENT>
import sys <NEWLINE> A = <STRING> <NEWLINE> def decode ( s ) : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> if c in <STRING> : x += c <NEWLINE> else : x += A [ A . index ( c ) + 1 ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> for s in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> if <STRING> in s or <STRING> in s or <STRING> in s : break <NEWLINE> s = decode ( s ) <NEWLINE> <DEDENT> <DEDENT> print s [ : - 1 ] <NEWLINE>
import string , sys <NEWLINE> <NL> alpha = <STRING> <NEWLINE> tbl = string . maketrans ( alpha [ : - 1 ] , alpha [ 1 : ] ) <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> while <STRING> not in s or <STRING> not in s or <STRING> not in s : <NEWLINE> <INDENT> s = s . translate ( tbl ) <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> alpha = <STRING> <NEWLINE> tbl = string . maketrans ( alpha [ : - 1 ] , alpha [ 1 : ] ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> sentence = raw_input ( ) <NEWLINE> while <STRING> not in sentence or <STRING> not in sentence or <STRING> not in sentence : <NEWLINE> <INDENT> sentence = sentence . translate ( tbl ) <NEWLINE> <DEDENT> print sentence <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def ascii2num ( ascii ) : <NEWLINE> <INDENT> return ord ( ascii ) - 96 <NEWLINE> <NL> <DEDENT> def num2ascii ( num ) : <NEWLINE> <INDENT> return chr ( num + 96 ) <NEWLINE> <NL> <DEDENT> def slide ( word , num ) : <NEWLINE> <INDENT> return <STRING> . join ( [ num2ascii ( ( ascii2num ( ascii ) + num ) % 26 ) if ascii != <STRING> else <STRING> for ascii in word ] ) <NEWLINE> <NL> <DEDENT> def includekeyword ( words ) : <NEWLINE> <INDENT> for word in words : <NEWLINE> <INDENT> if word in keywords : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> keywords = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <NL> decode = [ ] <NEWLINE> for row in stdin : <NEWLINE> <INDENT> words = row . split ( ) <NEWLINE> for num in range ( 1 , 27 ) : <NEWLINE> <INDENT> tmp = [ slide ( word , num ) for word in words ] <NEWLINE> if includekeyword ( tmp ) : <NEWLINE> <INDENT> decode = tmp <NEWLINE> print ( <STRING> . join ( decode ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys , string <NEWLINE> alpha = <STRING> <NEWLINE> t = string . maketrans ( alpha [ : - 1 ] , alpha [ 1 : ] ) <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> while not ( <STRING> in s or <STRING> in s or <STRING> in s ) : <NEWLINE> <INDENT> s = s . translate ( t ) <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT>
import sys , string <NEWLINE> alpha = <STRING> <NEWLINE> tbl = string . maketrans ( alpha [ : - 1 ] , alpha [ 1 : ] ) <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> while not ( <STRING> in s or <STRING> in s or <STRING> in s ) : <NEWLINE> <INDENT> s = s . translate ( tbl ) <NEWLINE> <DEDENT> print s [ : - 1 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> from string import ascii_lowercase , whitespace <NEWLINE> <NL> def datasets ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> yield line <NEWLINE> <NL> <DEDENT> <DEDENT> hints = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> inclement_chars = lambda cs , n : <STRING> . join ( <NEWLINE> <INDENT> [ succ_char ( c , n ) <NEWLINE> if all ( [ c not in case for case in ( whitespace , <STRING> , <STRING> ) ] ) <NEWLINE> else c <NEWLINE> for c in cs ] ) <NEWLINE> <NL> <DEDENT> make_picklist = lambda s : [ inclement_chars ( s , n ) for n in range ( 1 , 27 ) ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for problem in datasets ( ) : <NEWLINE> <INDENT> picklist = make_picklist ( problem ) <NEWLINE> for n , candidate in enumerate ( picklist , 1 ) : <NEWLINE> <INDENT> if any ( [ case in candidate for case in hints ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print picklist [ n - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def succ_char ( c , n ) : <NEWLINE> <INDENT> succ_ord = ord ( c ) + n <NEWLINE> z = ord ( <STRING> ) <NEWLINE> if succ_ord > z : <NEWLINE> <INDENT> succ_ord = ord ( <STRING> ) + ( succ_ord - z - 1 ) <NEWLINE> <DEDENT> return chr ( succ_ord ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> dic = [ { } for i in range ( 26 ) ] <NEWLINE> alpha = <STRING> <NEWLINE> <NL> def makedic ( ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> tmp = alpha [ i : ] + alpha [ : i ] <NEWLINE> for j in range ( 26 ) : <NEWLINE> <INDENT> dic [ i ] [ alpha [ j ] ] = tmp [ j ] <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> def crack ( word ) : <NEWLINE> <INDENT> for i in range ( 26 ) : <NEWLINE> <INDENT> s = [ ] <NEWLINE> for c in word : <NEWLINE> <INDENT> s . append ( dic [ i ] [ c ] ) <NEWLINE> <DEDENT> s = <STRING> . join ( s ) <NEWLINE> if s == <STRING> or s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> makedic ( ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = raw_input ( ) . strip ( <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for e in s . split ( ) : <NEWLINE> <INDENT> lene = len ( e ) <NEWLINE> if lene == 3 or lene == 4 : <NEWLINE> <INDENT> offset = crack ( e ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> x = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> if <STRING> <= c and c <= <STRING> : x . append ( dic [ offset ] [ c ] ) <NEWLINE> else : x . append ( c ) <NEWLINE> <DEDENT> print <STRING> . join ( x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def c1 ( c ) : <NEWLINE> <INDENT> alph = <STRING> <NEWLINE> if c in alph : <NEWLINE> <INDENT> return alph [ ( alph . find ( c ) + 1 ) % 26 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return c <NEWLINE> <NL> <DEDENT> <DEDENT> for string in sys . stdin : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> af_string = <STRING> <NEWLINE> for c in string : <NEWLINE> <INDENT> af_string += c1 ( c ) <NEWLINE> <DEDENT> if af_string . find ( <STRING> ) != - 1 or af_string . find ( <STRING> ) != - 1 or af_string . find ( <STRING> ) != - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> string = af_string <NEWLINE> <DEDENT> print af_string <NEWLINE> <DEDENT>
import sys <NEWLINE> def decode ( s ) : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> if c in <STRING> : <NEWLINE> <INDENT> x += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += chr ( ord ( c ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> return x . replace ( chr ( ord ( <STRING> ) + 1 ) , <STRING> ) <NEWLINE> <NL> <DEDENT> for s in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> for i in xrange ( ord ( <STRING> ) - ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> if <STRING> in s or <STRING> in s or <STRING> in s : <NEWLINE> <INDENT> print s [ : - 1 ] <NEWLINE> break <NEWLINE> s = decode ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = raw_input ( ) . split ( ) <NEWLINE> b = [ i for i in a if len ( i ) == 3 or len ( i ) == 4 ] <NEWLINE> c = [ i for i in b if ord ( i [ 0 ] ) - ord ( i [ 1 ] ) == 12 ] <NEWLINE> s = [ ord ( <STRING> ) - ord ( c [ 0 ] [ 0 ] ) , 1 ] if c [ 0 ] [ 0 ] < <STRING> else [ ord ( c [ 0 ] [ 0 ] ) - ord ( <STRING> ) , 0 ] <NEWLINE> q = <STRING> <NEWLINE> for g , i in enumerate ( a ) : <NEWLINE> <INDENT> if g == 0 : pass <NEWLINE> else : q += <STRING> <NEWLINE> for j in i : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> q += <STRING> <NEWLINE> <DEDENT> elif s [ 1 ] == 0 : <NEWLINE> <INDENT> q += chr ( ord ( j ) - s [ 0 ] ) <NEWLINE> <DEDENT> elif s [ 0 ] == 1 : <NEWLINE> <INDENT> q += chr ( ord ( j ) + s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print q <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def inp ( i ) : <NEWLINE> <INDENT> split_word = i . split ( ) <NEWLINE> return split_word <NEWLINE> <NL> <DEDENT> def rot ( split_word ) : <NEWLINE> <INDENT> for i in xrange ( len ( split_word ) ) : <NEWLINE> <INDENT> tako = <STRING> <NEWLINE> if len ( split_word [ i ] ) == 4 or len ( split_word [ i ] ) == 3 : <NEWLINE> <INDENT> num = ord ( split_word [ i ] [ 0 ] ) - ord ( <STRING> ) <NEWLINE> for j in xrange ( len ( split_word [ i ] ) ) : <NEWLINE> <INDENT> tako += chr ( ord ( split_word [ i ] [ j ] ) - num ) <NEWLINE> <DEDENT> if tako == <STRING> or tako == <STRING> or tako == <STRING> : <NEWLINE> <INDENT> return proce ( split_word , num ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> num = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def proce ( split_word , num ) : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> for i in xrange ( len ( split_word ) ) : <NEWLINE> <INDENT> for j in xrange ( len ( split_word [ i ] ) ) : <NEWLINE> <INDENT> if split_word [ i ] [ j ] < ord ( <STRING> ) or ord ( <STRING> ) < split_word [ i ] [ j ] : <NEWLINE> <INDENT> ans += split_word [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += str ( chr ( ord ( split_word [ i ] [ j ] ) - num ) ) <NEWLINE> <DEDENT> <DEDENT> ans += <STRING> <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> word = inp ( i ) <NEWLINE> ans = rot ( word ) <NEWLINE> print ans [ 0 : ( len ( ans ) - 1 ) ] <NEWLINE> <DEDENT> <DEDENT>
def rot ( s ) : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> tmp = ord ( c ) - ord ( <STRING> ) <NEWLINE> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> x += chr ( ( tmp + 1 ) % 26 + ord ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x += c <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def check ( s ) : <NEWLINE> <INDENT> for word in s . split ( ) : <NEWLINE> <INDENT> if word == <STRING> or word == <STRING> or word == <STRING> : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> else return False <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> f = False <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if check ( s ) : break <NEWLINE> else : s = rot ( s ) <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
b = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> while 1 : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for y in range ( 26 ) : <NEWLINE> <INDENT> for x in b : <NEWLINE> <INDENT> if x in a : <NEWLINE> <INDENT> print a <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> a = list ( a ) <NEWLINE> for x in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ x ] == <STRING> : <NEWLINE> <INDENT> a [ x ] = <STRING> <NEWLINE> <DEDENT> elif <STRING> <= a [ x ] < <STRING> : <NEWLINE> <INDENT> a [ x ] = chr ( ord ( a [ x ] ) + 1 ) <NEWLINE> <DEDENT> <DEDENT> a = <STRING> . join ( a ) <NEWLINE> <DEDENT> <DEDENT>
import sys , string <NEWLINE> rot1 = string . maketrans ( <STRING> , <STRING> ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> if line . count ( <STRING> ) or line . count ( <STRING> ) or line . count ( <STRING> ) : <NEWLINE> <INDENT> print line <NEWLINE> break <NEWLINE> <DEDENT> line = line . translate ( rot1 ) <NEWLINE> <DEDENT> <DEDENT>
b = <STRING> <NEWLINE> try : <NEWLINE> <INDENT> b += raw_input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> import string <NEWLINE> t = string . maketrans ( <STRING> , <STRING> ) <NEWLINE> while not ( <STRING> in b or <STRING> in b or <STRING> in b ) : <NEWLINE> <INDENT> b = b . translate ( t ) <NEWLINE> <DEDENT> print b <NEWLINE>
from __future__ import ( absolute_import , division , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> from string import ascii_lowercase as letters , maketrans <NEWLINE> <NL> table = maketrans ( letters , letters [ 1 : ] + letters [ : 1 ] ) <NEWLINE> for line in stdin : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> line = line . translate ( table ) <NEWLINE> if <STRING> in line or <STRING> in line or <STRING> in line : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( line ) <NEWLINE> <DEDENT>
print ( <STRING> . join ( map ( str , sorted ( map ( int , input ( ) ) ) ) ) ) <NEWLINE>
x = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> x . sort ( ) <NEWLINE> x . reverse ( ) <NEWLINE> output = <STRING> <NEWLINE> for val in x : <NEWLINE> <INDENT> output += str ( val ) + <STRING> <NEWLINE> <DEDENT> output . strip ( ) <NEWLINE> print output <NEWLINE>
print ( * reversed ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
for i in sorted ( map ( int , raw_input ( ) . split ( ) ) ) [ : : - 1 ] : print i , <NEWLINE> print <STRING> <NEWLINE>
print <STRING> . join ( map ( str , sorted ( map ( int , raw_input ( ) . split ( ) ) ) [ : : - 1 ] ) ) ) <NEWLINE>
print <STRING> . join ( map ( str , sorted ( map ( int , raw_input ( ) . strip ( ) . sprit ( <STRING> ) ) , lambda x , y : y - x ) ) ) <NEWLINE>
data = raw_input ( ) . split ( <STRING> ) <NEWLINE> data = sorted ( map ( int , data ) ) [ : : - 1 ] <NEWLINE> print <STRING> . join ( data ) <NEWLINE>
print ( * sorted ( map ( int , input ( ) . spilt ( ) ) ) [ : : - 1 ] ) <NEWLINE>
l = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) ; <NEWLINE> print <STRING> . join ( sorted ( l , lambda x , y : y - x ) ) ; <NEWLINE>
<STRING> <NEWLINE> <NL> from sys import stdin <NEWLINE> <NL> a = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> print ( <STRING> . join ( a [ : : - 1 ] ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> a = list ( map ( int , ( input ( ) . split ( ) ) ) ) <NEWLINE> a = sorted ( a , reverse = True ) <NEWLINE> for i in range ( 4 ) : print ( a [ i ] , end = <STRING> ) <NEWLINE> print ( a [ 4 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for input_line in sys . stdin : <NEWLINE> <INDENT> input_line = raw_input ( ) . split ( ) <NEWLINE> input_line . sort ( reverse = True ) <NEWLINE> print <STRING> . join ( input_line ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> line = raw_input ( ) <NEWLINE> l = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> l . sort ( ) <NEWLINE> l . reverse ( ) <NEWLINE> out = <STRING> . join ( l ) <NEWLINE> print out <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> a = a [ : : - 1 ] <NEWLINE> print ( <STRING> % tuple ( a ) ) <NEWLINE>
<COMMENT> <NL> <NL> print ( <STRING> . join ( sorted ( [ input ( ) . split ( ) ] , reverse = True ) ) ) <NEWLINE>
n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n . sort ( revers = True ) <NEWLINE> for i in n : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT>
a = sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
l = list ( map ( int , input ( ) . split ) ) <NEWLINE>
<NL> <NL> import sys <NEWLINE> <NL> lineNumber = 0 <NEWLINE> <COMMENT> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> lineNumber += 1 <NEWLINE> <NL> <COMMENT> <NL> List = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> List = List . sort ( ) . reverse ( ) <NEWLINE> <NL> print <STRING> % ( List [ 0 ] , List [ 1 ] , List [ 2 ] , List [ 3 ] , List [ 4 ] ) <NEWLINE> <DEDENT>
print ( <STRING> . join ( sorted ( [ int ( i ) for i in input ( ) . split ( ) ] , reverse = True ) ) ) <NEWLINE>
for e in sorted ( map ( int , input ( ) . split ( ) ) ) [ : : - 1 ] : <NEWLINE> <INDENT> print e , <NEWLINE> <DEDENT> print <NEWLINE>
n = map ( int , raw_imput ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> n . sort ( ) <NEWLINE> n . reverse ( ) <NEWLINE> for i in n : <NEWLINE> <INDENT> ans . append ( str ( i ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
ans = 1 <NEWLINE> for i in range ( 1 , int ( raw_input ( ) + 1 ) : <NEWLINE> <INDENT> ans *= i <NEWLINE> <DEDENT> print ans <NEWLINE>
<NL> import math <NEWLINE> <NL> num = int ( input ) <NEWLINE> print ( math . factorial ( num ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> ans = 1 <NEWLINE> for i in range ( 1 , s + 1 ) <NEWLINE> <INDENT> ans *= i <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
from math import factorial <NEWLINE> print ( factorial ( int ( input ( ) ) ) <NEWLINE>
from math import factorial <NEWLINE> n = int ( input ( ) ) <NEWLINE> print factorial ( n ) <NEWLINE>
n = input ( ) <NEWLINE> answer = 1 <NEWLINE> while != 1 : <NEWLINE> <INDENT> answer *= n <NEWLINE> n -= 1 <NEWLINE> <DEDENT> print answer <NEWLINE>
<COMMENT> <NL> x = input ( ) <NEWLINE> def f ( n ) : <NEWLINE> <INDENT> if n == 0 : return 1 <NEWLINE> return f ( n - 1 ) * n <NEWLINE> <DEDENT> print ( f ( int ( n ) ) ) <NEWLINE>
def factorial ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n * factorial ( n - 1 ) <NEWLINE> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> print ( factorial ( n ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> d = s . upper ( ) <NEWLINE> print d <NEWLINE> <DEDENT>
print raw_input ( ) . to_upper ( ) <NEWLINE>
s = raw_input ( ) . split ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in s : <NEWLINE> <INDENT> ans . append ( i . upper ( ) ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
input_line = raw_input ( ) <NEWLINE> for char in input_line : <NEWLINE> <INDENT> print char . upper ( ) , <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def datasets ( ) : <NEWLINE> <INDENT> s = raw_input ( ) . strip ( ) <NEWLINE> yield s <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for s in datasets ( ) : <NEWLINE> <INDENT> import s . lower ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys , string <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> print string . upper ( s ) <NEWLINE> <DEDENT>
ls = raw_input ( ) . split ( ) <NEWLINE> for k in range ( len ( ls ) ) : <NEWLINE> <INDENT> ls [ k ] = ls [ k ] . upper ( ) <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , [ k for k in ls ] ) ) <NEWLINE>
x = input ( ) . upper ( ) <NEWLINE> print x <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> param = sys . stdin . readline ( ) <NEWLINE> print param . upper ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> b = [ ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> b . append ( a [ i ] . upper ( ) ) <NEWLINE> <DEDENT> print <STRING> . join ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = list ( map ( float , raw_input ( ) . split ( ) ) ) <NEWLINE> if abs ( ( ( y2 - y1 ) * ( x4 - x3 ) - ( x2 - x1 ) * ( y4 - y3 ) ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if abs ( x2 - x1 ) * ( y4 - y3 ) - ( x4 - x3 ) * ( y2 - y1 ) ) < 1e-10 else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if x1 == x2 or x3 == x4 : <NEWLINE> <INDENT> if x1 == x2 and x3 == x4 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> if y1 == y2 or y3 == y4 : <NEWLINE> <INDENT> if y1 == y2 and y3 == y4 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> a1 = ( y2 - y1 ) / ( x2 - x1 ) <NEWLINE> b1 = y1 - a1 * x1 <NEWLINE> a2 = ( y4 - y3 ) / ( x4 - x3 ) <NEWLINE> b2 = y3 - a2 * x3 <NEWLINE> if ( a1 == a2 ) and ( b1 != b2 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Point ( object ) : <NEWLINE> <INDENT> x = 0.0 <NEWLINE> y = 0.0 <NEWLINE> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <DEDENT> def __sub__ ( left , right ) : <NEWLINE> <INDENT> return Point ( left . x - right . x , left . y - right . y ) <NEWLINE> <COMMENT> <NL> <DEDENT> def __mul__ ( left , right ) : <NEWLINE> <INDENT> return left . x * right . y - left . y * right . x <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) = [ float ( i ) for i in raw_input ( ) . split ( ) ] <NEWLINE> a = Point ( x1 , y1 ) <NEWLINE> b = Point ( x2 , y2 ) <NEWLINE> c = Point ( x3 , y3 ) <NEWLINE> d = Point ( x4 , y4 ) <NEWLINE> ab = a - b <NEWLINE> cd = c - d <NEWLINE> if ( a * b == 0.0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ( a * ( Point - b ) == 0.0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = range ( int ( raw_input ( ) ) ) <NEWLINE> for i in N : <NEWLINE> <INDENT> a , w , b , x , c , y , d , z = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> print [ <STRING> , <STRING> ] [ ( w - x ) * ( c - d ) = ( y - z ) * ( a - b ) ] <NEWLINE> <DEDENT>
<INDENT> for i in xrange ( input ( ) ) : <NEWLINE> <INDENT> grad1 , grad2 = 0 , 0 <NEWLINE> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> grad1 , grad2 = ( y1 - y2 ) * ( x3 - x4 ) , ( y3 - y4 ) * ( x1 - x2 ) <NEWLINE> if grad1 - grad2 == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> for l in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> if x1 - x2 == 0 and x3 - x4 == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x1 - x2 != 0 and x3 - x4 == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x1 - x2 == 0 and x3 - x4 != 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( x1 - x2 ) / ( y1 - y2 ) == ( x3 - x4 ) / ( y3 - y4 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> if x2 - x1 == 0.0 and x4 - x3 == 0.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y2 - y1 == 0.0 and y4 - y3 == 0.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ( y2 - y1 ) * ( x4 - x3 ) / ( y4 - y3 ) / ( x2 - x1 ) == 1.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
for i in range ( input ( ) ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( lambda x : return <STRING> % x , raw_input ( ) . split ( ) ) <NEWLINE> if ( y1 - y2 ) * ( x3 - x4 ) == ( y3 - y4 ) * ( x1 - x2 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> zahyou = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> a = ( zahyou [ 3 ] - zahyou [ 1 ] ) / ( zahyou [ 2 ] - zahyou [ 0 ] ) <NEWLINE> b = ( zahyou [ 7 ] - zahyou [ 5 ] ) / ( zahyou [ 6 ] - zahyou [ 4 ] ) <NEWLINE> if a == b or a == - b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) + 1 <NEWLINE> for val in range ( 1 , n ) : <NEWLINE> <INDENT> x = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( x [ 0 ] - x [ 2 ] ) / ( x [ 1 ] - x [ 3 ] ) == ( x [ 4 ] - x [ 6 ] ) / ( x [ 5 ] - x [ 7 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> z1 = ( y1 - y2 ) / ( x1 - x2 ) <NEWLINE> z2 = ( y3 - y4 ) / ( x3 - x4 ) <NEWLINE> if z1 == z2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> num = input ( ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> d = map ( float , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = d [ 0 ] , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] , d [ 5 ] , d [ 6 ] , d [ 7 ] <NEWLINE> ab = [ x2 - x1 , y2 - y1 ] <NEWLINE> cd = [ x4 - x3 , y4 - y3 ] <NEWLINE> if ab [ 0 ] == 0 and cd [ 0 ] == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ab [ 1 ] / ab [ 0 ] == cd [ 1 ] / cd [ 0 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> def take2 ( iterable ) : <NEWLINE> <INDENT> i = iter ( iterable ) <NEWLINE> while True : <NEWLINE> <INDENT> yield next ( i ) + next ( i ) * 1j <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( f . readline ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> xy = [ xiyi for xiyi in take2 ( map ( float , f . readline ( ) . split ( ) ) ) ] <NEWLINE> a , b , c , d = xy <NEWLINE> temp = ( a - b ) / ( c - d ) <NEWLINE> if abs ( temp . imag ) < 0.001 : <NEWLINE> <INDENT> temp = ( a - b ) / ( a - c ) <NEWLINE> if abs ( temp . imag ) < 0.001 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> class point : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> xa , ya , xb , yb , xc , yc , xd , yd = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> a = point ( xa , ya ) <NEWLINE> b = point ( xb , yb ) <NEWLINE> c = point ( xc , yc ) <NEWLINE> d = point ( xd , yd ) <NEWLINE> if ( a . y - b . y ) / ( a . x - b . x ) - ( c . y - d . y ) / ( c . x - d . x ) < 1e-9 : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT>
for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a , b , c , d , e , f , g , h = map ( float , input ( ) . split ( ) ) <NEWLINE> <NL> if abs ( ( c - a ) * ( h - f ) - ( d - b ) * ( g - e ) ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> input ( ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> <NL> def parallelism ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <NEWLINE> <INDENT> if x2 - x1 == 0.0 or x4 - x3 == 0.0 : <NEWLINE> <INDENT> return x2 - x1 == 0.0 and x4 - x3 == 0.0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( ( y2 - y1 ) / ( x2 - x1 ) ) == ( ( y4 - y3 ) / ( x4 - x3 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> lines = sys . stdin . readlines ( ) <NEWLINE> lines . pop ( 0 ) <NEWLINE> <NL> for line in lines : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = tuple ( map ( float , line . split ( <STRING> ) ) ) <NEWLINE> if parallelism ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> class Point_Class ( ) : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> <DEDENT> def slope ( p1 , p2 ) : <NEWLINE> <INDENT> return ( p2 . y - p1 . y ) / ( p2 . x - p1 . x ) if p2 . x != p1 . x else sys . intmax <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> p1 = Point_Class ( x1 , y1 ) <NEWLINE> p2 = Point_Class ( x2 , y2 ) <NEWLINE> p3 = Point_Class ( x3 , y3 ) <NEWLINE> p4 = Point_Class ( x4 , y4 ) <NEWLINE> print <STRING> if slope ( p1 , p2 ) == slope ( p3 , p4 ) else <STRING> <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if float ( y1 - y0 ) / ( x1 - x0 ) == float ( y3 - y2 ) / ( x3 - x2 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> <NL> for n in range ( N ) : <NEWLINE> <INDENT> data = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> slopes = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> _x1 = data . pop ( 0 ) <NEWLINE> _y1 = data . pop ( 0 ) <NEWLINE> _x2 = data . pop ( 0 ) <NEWLINE> _y2 = data . pop ( 0 ) <NEWLINE> <NL> if _x1 != _x2 : <NEWLINE> <INDENT> slopes . append ( ( _y1 - _y2 ) / ( _x1 - _x2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( slopes ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( slopes ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif abs ( slopes [ 0 ] - slopes [ 1 ] ) < 1e-10 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
num = input ( ) <NEWLINE> <NL> <NL> for i in range ( num ) : <NEWLINE> <INDENT> x = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if x [ 1 ] - x [ 3 ] == 0 or x [ 5 ] - x [ 7 ] == 0 : <NEWLINE> <INDENT> if x [ 1 ] - x [ 3 ] == 0 and x [ 5 ] - x [ 7 ] == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( x [ 0 ] - x [ 2 ] ) / ( x [ 1 ] - x [ 3 ] ) == ( x [ 4 ] - x [ 6 ] ) / ( x [ 5 ] - x [ 7 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> def parallel ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : <NEWLINE> <INDENT> print <STRING> if ( y1 - y2 ) / ( x1 - x2 ) == ( y3 - y4 ) / ( x3 - x4 ) else <STRING> <NEWLINE> <NL> <DEDENT> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> l = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> parallel ( l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] , l [ 4 ] , l [ 5 ] , l [ 6 ] , l [ 7 ] ) <NEWLINE> <DEDENT>
from __future__ import ( absolute_import , division , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> def gradient ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> return ( y1 - y2 ) / ( x1 - x2 ) <NEWLINE> <NL> <DEDENT> for n in xrange ( int ( stdin . readline ( ) ) ) : <NEWLINE> <INDENT> p = [ float ( s ) for s in stdin . readline ( ) . split ( ) ] <NEWLINE> if gradient ( * p [ : 4 ] ) == gradient ( * p [ 4 : ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> def grouping ( nums ) : <NEWLINE> <INDENT> it = iter ( nums ) <NEWLINE> L = [ next ( nums ) ] <NEWLINE> minus = L [ 0 ] < 0 <NEWLINE> for n in it : <NEWLINE> <INDENT> if ( n < 0 and minus ) or ( n >= 0 and not minus ) : <NEWLINE> <INDENT> L [ - 1 ] += n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( n ) <NEWLINE> minus = not minus <NEWLINE> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <DEDENT> def collect ( nl ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> while len ( nl ) > 1 : <NEWLINE> <INDENT> nl = grouping ( nl [ i ] + nl [ i + 1 ] for i in xrange ( 0 , len ( nl ) , 2 ) ) <NEWLINE> if nl [ - 1 ] <= 0 : <NEWLINE> <INDENT> nl . pop ( ) <NEWLINE> if not len ( nl ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if nl [ 0 ] >= 0 : <NEWLINE> <INDENT> result += nl [ 0 ] <NEWLINE> nl . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> L = grouping ( int ( stdin . readline ( ) ) for _ in xrange ( n ) ) <NEWLINE> if L [ 0 ] <= 0 : <NEWLINE> <INDENT> L . pop ( 0 ) <NEWLINE> <DEDENT> if L [ - 1 ] <= 0 : <NEWLINE> <INDENT> L . pop ( ) <NEWLINE> <NL> <DEDENT> val = max ( L ) <NEWLINE> idx = L . index ( val ) <NEWLINE> <NL> val += collect ( list ( reversed ( L [ : idx ] ) ) ) <NEWLINE> val += collect ( L [ idx + 1 : ] ) <NEWLINE> print ( val ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> numbers = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> if max ( numbers ) <= 0 : <NEWLINE> <INDENT> return max ( numbers ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> tmp += numbers [ j ] <NEWLINE> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> b = [ ] <NEWLINE> while a != [ ] : <NEWLINE> <INDENT> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] * a [ i + 1 ] < 0 : <NEWLINE> <INDENT> b . append ( sum ( a [ : i + 1 ] ) ) <NEWLINE> a [ : i + 1 ] = [ ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b . append ( sum ( a ) ) <NEWLINE> a = [ ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , len ( b ) ) : <NEWLINE> <INDENT> if b [ i - 1 ] > 0 : <NEWLINE> <INDENT> b [ i ] += b [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( max ( b ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = int ( raw_input ( ) ) <NEWLINE> <DEDENT> r = a [ 0 ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> r = max ( r , sum ( a [ i : j ] ) ) <NEWLINE> <DEDENT> <DEDENT> print r <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> num , ans = [ ] , [ ] <NEWLINE> if x == 0 : break <NEWLINE> else : <NEWLINE> <INDENT> for j in xrange ( x ) : <NEWLINE> <INDENT> num . append ( input ( ) ) <NEWLINE> <DEDENT> for j in xrange ( x ) : <NEWLINE> <INDENT> if num [ j ] > 0 : <NEWLINE> <INDENT> for k in xrange ( j + 1 , x + 1 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> ans . append ( sum ( num [ j : k ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print max ( ans ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> sums = [ ] <NEWLINE> a , b , c = 0 , 0 , input ( ) <NEWLINE> for i in xrange ( n - 1 ) : <NEWLINE> <INDENT> sums . append ( a + b + c ) <NEWLINE> a , b , c = b , c , input ( ) <NEWLINE> <DEDENT> print max ( sums ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) ) <NEWLINE> dp [ i ] = ( max ( dp [ i ] + a , a ) ) <NEWLINE> <DEDENT> print ( max ( dp ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> dp = [ a [ 0 ] ] <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> dp . append ( max ( dp [ i - 1 ] + a [ i ] , a [ i ] ) ) <NEWLINE> <NL> <DEDENT> print ( max ( dp ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if ( n == 0 ) : break <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> ans = - 100001 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , sum ( a [ i : j ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> terms = int ( raw_input ( ) ) <NEWLINE> if terms == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> data = [ ] <NEWLINE> for i in xrange ( terms ) : <NEWLINE> <INDENT> data . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> print ( max_sum_sequence ( data ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def max_sum_sequence ( data ) : <NEWLINE> <INDENT> max = 0 <NEWLINE> num_data = len ( data ) <NEWLINE> for l in xrange ( num_data + 1 ) : <NEWLINE> <INDENT> sum = max_at_length ( data , l ) <NEWLINE> if sum > max : <NEWLINE> <INDENT> max = sum <NEWLINE> <NL> <DEDENT> <DEDENT> return max <NEWLINE> <NL> <NL> <DEDENT> def max_at_length ( data , length ) : <NEWLINE> <INDENT> max = 0 <NEWLINE> num_data = len ( data ) <NEWLINE> for begin in xrange ( num_data ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in xrange ( begin , begin + length ) : <NEWLINE> <INDENT> if i >= num_data : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> sum += data [ i ] <NEWLINE> <NL> <DEDENT> if sum > max : <NEWLINE> <INDENT> max = sum <NEWLINE> <NL> <DEDENT> <DEDENT> return max <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> s = [ ] <NEWLINE> x = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x . append ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> s . append ( sum ( x [ i : j + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print max ( s ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> def max_sum_seq ( lis ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> lis = compress ( lis ) <NEWLINE> l = len ( lis ) <NEWLINE> for n in range ( 1 , l + 1 ) : <NEWLINE> <INDENT> for s in every_slice ( lis , n ) : <NEWLINE> <INDENT> sm = sum ( s ) <NEWLINE> if sm > m : <NEWLINE> <INDENT> m = sm <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return m <NEWLINE> <NL> <DEDENT> def every_slice ( lis , n ) : <NEWLINE> <INDENT> l = len ( lis ) <NEWLINE> for i in range ( l - n + 1 ) : <NEWLINE> <INDENT> yield lis [ i : i + n ] <NEWLINE> <NL> <DEDENT> <DEDENT> def compress ( tmp_lst ) : <NEWLINE> <INDENT> lim = len ( tmp_lst ) <NEWLINE> lst = [ ] <NEWLINE> index = 0 <NEWLINE> while index < lim : <NEWLINE> <INDENT> tmp = tmp_lst [ index ] <NEWLINE> index += 1 <NEWLINE> while tmp > 0 and index < lim and tmp * tmp_lst [ index ] > 0 : <NEWLINE> <INDENT> tmp += tmp_lst [ index ] <NEWLINE> index += 1 <NEWLINE> <DEDENT> lst . append ( tmp ) <NEWLINE> <DEDENT> return lst <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lis = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lis . append ( int ( sys . stdin . readline ( ) ) ) <NEWLINE> <DEDENT> print max_sum_seq ( lis ) <NEWLINE> <DEDENT>
- - - - : - - - F1 * scratch * All L1 ( Fundamental ) - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <NEWLINE> Loading subst - jis ... done <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> break <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> a [ i ] = int ( raw_input ( ) ) <NEWLINE> max = - 1e10 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> sum = 0 <NEWLINE> <INDENT> for j in range ( i + 1 : len ( a ) ) : <NEWLINE> sum += a [ j ] <NEWLINE> <INDENT> if sum > max : <NEWLINE> <DEDENT> <DEDENT> max = sum <NEWLINE> print max <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> r = [ input ( ) for i in xrange ( n ) ] <NEWLINE> print r <NEWLINE> for i in xrange ( 1 , n ) : <NEWLINE> <INDENT> r [ i ] = max ( r [ i - 1 ] + r [ i ] , r [ i ] ) <NEWLINE> print r <NEWLINE> <DEDENT> print max ( r ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ input ( ) for i in xrange ( n ) ] <NEWLINE> m = - 100000 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( n + 1 ) : <NEWLINE> <INDENT> m = max ( m , sum ( a [ i : j ] ) ) <NEWLINE> <DEDENT> <DEDENT> print m <NEWLINE> <DEDENT>
while int ( input ( ) ) != 0 : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum = sum + int ( input ( ) ) <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
def take ( n , iterable ) : <NEWLINE> <INDENT> start , end = 0 , n <NEWLINE> while True : <NEWLINE> <INDENT> chunk = iterable [ start : end ] <NEWLINE> if len ( chunk ) < n : <NEWLINE> <INDENT> raise StopIteration ( ) <NEWLINE> <DEDENT> yield chunk <NEWLINE> start += 1 <NEWLINE> end += 1 <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if not num : break <NEWLINE> data = [ int ( input ( ) ) for _ in range ( num ) ] <NEWLINE> print ( max ( ( sum ( chunk ) for i in range ( 1 , num + 1 ) for chunk in take ( i , data ) ) ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ int ( raw_input ( ) ) for _ in xrange ( n ) ] <NEWLINE> max_a = - 1000000 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> if max_a < sum ( a [ i : j ] ) : <NEWLINE> <INDENT> max_a = sum ( a [ i : j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> A = [ int ( raw_input ( ) ) for _ in xrange ( n ) ] <NEWLINE> if all ( a <= 0 for a in A ) : <NEWLINE> <INDENT> print max ( a ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> r = 0 <NEWLINE> tmp = 0 <NEWLINE> ans = 0 <NEWLINE> while r < n : <NEWLINE> <INDENT> tmp += A [ r ] <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> l = r <NEWLINE> tmp = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = max ( ans , tmp ) <NEWLINE> <DEDENT> r += 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> a [ i ] = max ( a [ i - 1 ] + a [ i ] , a [ i ] ) <NEWLINE> <NL> <DEDENT> print ( max ( a ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lis = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> d = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = max ( d + n , n ) <NEWLINE> lis . append ( d ) <NEWLINE> <DEDENT> <DEDENT> print max ( lis ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> max = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmax = max + int ( raw_input ( ) ) <NEWLINE> if tmax > max : <NEWLINE> <INDENT> max = tmax <NEWLINE> <DEDENT> <DEDENT> print tmax <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> import math <NEWLINE> <NL> <NL> class Circle : <NEWLINE> <INDENT> def __init__ ( self , x , y , r ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> def distance ( self , other ) : <NEWLINE> <INDENT> dx = self . x - other . x <NEWLINE> dy = self . y - other . y <NEWLINE> return math . sqrt ( dx ** 2 + dy ** 2 ) <NEWLINE> <NL> <DEDENT> def intersection ( self , other ) : <NEWLINE> <INDENT> d = self . distance ( other ) <NEWLINE> if self . r > d + other . r : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif other . r > d + self . r : <NEWLINE> <INDENT> return - 2 <NEWLINE> <DEDENT> elif d = < self . r + other . r : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> sys . stdin . readline ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> ( xa , ya , ra , xb , yb , rb ) = tuple ( map ( float , line . split ( <STRING> ) ) ) <NEWLINE> ca = Circle ( xa , ya , ra ) <NEWLINE> cb = Circle ( xb , yb , rb ) <NEWLINE> print ca . intersection ( cb ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> xa , ya , ra , xb , yb , rb = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> d = math . sqrt ( ( xa - xb ) ** 2 + ( ya - yb ) ** 2 ) <NEWLINE> if d + rb <= ra : <NEWLINE> <INDENT> print 2 <NEWLINE> <DEDENT> elif : d + ra <= rb : <NEWLINE> <INDENT> print - 2 <NEWLINE> <DEDENT> elif : d > ra + rb : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> xa , ya , ra , xb , ya , rb = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> dist = math . sqrt ( ( yb - ya ) ** 2 + ( xb - xa ) ** 2 ) <NEWLINE> if dist > ( ra + rb ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif abs ( ra - rb ) <= dist <= ( ra + rb ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif dist < abs ( ra - rb ) : <NEWLINE> if ra > rb : <NEWLINE> <INDENT> return 2 <NEWLINE> else : <NEWLINE> return - 2 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = input ( ) <NEWLINE> answers = [ ] <NEWLINE> for val in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> x = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> d = math . sqrt ( ( x [ 0 ] - x [ 3 ] ) ** 2 - ( x [ 1 ] - x [ 4 ] ) ** 2 ) ) <NEWLINE> math . fabs ( d ) <NEWLINE> s = x [ 2 ] + x [ 5 ] <NEWLINE> r = math . fabs ( x [ 2 ] - x [ 5 ] ) <NEWLINE> if r >= d : <NEWLINE> <INDENT> if x [ 2 ] > x [ 5 ] : <NEWLINE> <INDENT> answers . append ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answers . append ( - 2 ) <NEWLINE> <DEDENT> <DEDENT> elif s < d : <NEWLINE> <INDENT> answers . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answers . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> for val in answers : <NEWLINE> <INDENT> print val <NEWLINE> <DEDENT>
<NL> <NL> import math <NEWLINE> <NL> <NL> num = int ( input ( ) ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> ax , ay , ar , bx , by , br = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> d = ( ax - bx ) * ( ax - bx ) + ( ay * by ) ( ay * by ) <NEWLINE> if d < abs ( br - ar ) : <NEWLINE> <INDENT> if ar > br : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( - 2 ) <NEWLINE> <DEDENT> <DEDENT> elif d <= ar + br : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> a , b = input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> % ( int ( a ) / int ( b ) , int ( a ) % int ( b ) , float ( a ) / int ( b ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x1 , y1 , r1 , x2 , y2 , r2 = map ( float , input ( ) . split ( ) ) <NEWLINE> d = ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 <NEWLINE> if r1 - r2 > d : <NEWLINE> <INDENT> if r1 == r2 + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif r2 - r1 > d : <NEWLINE> <INDENT> if r2 == r1 + d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif d < r1 + r2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif r1 + r2 == d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif d > r1 + r2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <NL> <INDENT> g = 9.8 <NEWLINE> l = 4.9 <NEWLINE> <NL> v = float ( raw_input ( ) ) <NEWLINE> t = v / g <NEWLINE> <NL> y = l * t * t <NEWLINE> <NL> n = y / 5 + 1 <NEWLINE> <NL> <NL> print int ( math . ceil ( n ) ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ~ <NEWLINE> ~ <NEWLINE> ~ <NEWLINE> ~ <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> v = raw_input ( ) <NEWLINE> <INDENT> y = ( float ( v ) ) ** 2 / 19.6 <NEWLINE> print int ( y / 5 + 2 ) <NEWLINE> <DEDENT> <DEDENT> except : break <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> v = int ( input ( ) ) <NEWLINE> f = 2 <NEWLINE> g = 9.8 <NEWLINE> while True : <NEWLINE> <INDENT> F = f * 5 - 5 <NEWLINE> if sqrt ( 2 * g * F ) >= v : <NEWLINE> <INDENT> print ( f ) <NEWLINE> break <NEWLINE> <DEDENT> f += 1 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> thv = float ( raw_input ( ) ) <NEWLINE> for i in range ( 1 , 20 ) : <NEWLINE> <INDENT> y = 5 * ( i - 1 ) <NEWLINE> t = math . sqrt ( y / 4.9 ) <NEWLINE> v = 9.8 * t <NEWLINE> if v >= thv : <NEWLINE> <INDENT> print i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from math import ceil <NEWLINE> <NL> while True : <NEWLINE> <INDENT> v = input ( ) <NEWLINE> if not v : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> v = float ( v ) <NEWLINE> print ( ceil ( v * v / 98 + 1 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> [ print ( i ) for i in [ math . ceil ( ( ( 4.9 * ( a / 9.8 ) ** 2 ) + 5 ) / 5 ) for a in float ( input ( ) ) ] ] <NEWLINE> <NL>
import sys , math <NEWLINE> for v in sys . stdin : <NEWLINE> <INDENT> print int ( math . ceil ( v ** 2 / 2 / 9.8 / 5 ) ) + 1 <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> flag = 0 <NEWLINE> v = float ( input ( ) ) <NEWLINE> t = v / 9.8 <NEWLINE> y = 4.9 * t ** 2 <NEWLINE> N = 0 <NEWLINE> while y > 5 * ( N - 1 ) : <NEWLINE> <INDENT> N += 1 <NEWLINE> <DEDENT> print ( N ) <NEWLINE> flag += 1 <NEWLINE> if flag == 50 : break <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> y = 4.9 * ( float ( input ( ) ) / 9.8 ) ** 2 <NEWLINE> N = 1 <NEWLINE> while N * 5 - 5 < y : <NEWLINE> <INDENT> N += 1 <NEWLINE> <DEDENT> print ( N ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if not a : break <NEWLINE> b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> hit , blow = 0 , 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : hit += 1 <NEWLINE> if a [ i ] in b : blow += 1 <NEWLINE> <DEDENT> print hit , blow - hit <NEWLINE> <DEDENT>
def check ( ) : <NEWLINE> <INDENT> count1 = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if A [ i ] == B [ i ] : <NEWLINE> <INDENT> count1 += 1 <NEWLINE> <DEDENT> <DEDENT> count2 = 0 <NEWLINE> for v in B : <NEWLINE> <INDENT> if v in A : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> <DEDENT> <DEDENT> Hit = count1 <NEWLINE> Blow = count2 - count1 <NEWLINE> <NL> print Hit , Blow <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> A = list ( raw_input ( ) . split ( ) ) <NEWLINE> B = list ( raw_input ( ) . split ( ) ) <NEWLINE> check ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> e = iter ( map ( lambda a : a . split ( ) , sys . stdin ) ) <NEWLINE> for a , b in zip ( e , e ) : <NEWLINE> <INDENT> h = 0 ; for s , t in zip ( a , b ) : h += s == t <NEWLINE> print ( h , 4 - len ( set ( a ) - set ( b ) ) - h ) <NEWLINE> <DEDENT>
a = [ * map ( int , input ( ) . split ( <STRING> ) ) ] <NEWLINE> b = [ * map ( int , input ( ) . split ( <STRING> ) ) ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] == b [ i ] : <NEWLINE> <INDENT> hit += 1 <NEWLINE> elif a [ i ] == b [ i - 1 ] : <NEWLINE> <INDENT> blow += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( hit , blow ) <NEWLINE>
<NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> listA = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> listB = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> hit = 0 <NEWLINE> blw = 0 <NEWLINE> for tB in listB : <NEWLINE> <INDENT> if ( tB in listA ) and ( listB . index ( tB ) == listA . index ( tB ) ) : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> elif ( tB in listA ) and ( listB . index ( tB ) != listA . index ( tB ) ) : <NEWLINE> <INDENT> blw += 1 <NEWLINE> <DEDENT> <DEDENT> print hit , blw <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> hit = blow = 0 <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <NL> <INDENT> if ( a [ i ] == b [ i ] ) : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <NL> <DEDENT> elif ( a [ i ] in b ) : <NEWLINE> <INDENT> blow += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print hit , blow <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> l1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> hit = blow = 0 <NEWLINE> for i in l1 : <NEWLINE> <INDENT> for s in l2 : <NEWLINE> <INDENT> if i == s : <NEWLINE> <INDENT> if l1 . index ( i ) == l2 . index ( s ) : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> blow += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( hit , blow ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> <NL> def main ( a , b ) : <NEWLINE> <INDENT> hit = 0 <NEWLINE> blow = 0 <NEWLINE> <NL> for a_e , b_e in zip ( a , b ) : <NEWLINE> <INDENT> if a_e == b_e : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> elif a_e in b : <NEWLINE> <INDENT> blow += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( hit , blow , sep = <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> b = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> <NL> if a and b : <NEWLINE> <INDENT> main ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> hit = 0 <NEWLINE> blow = 0 <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> for a_ , b_ in zip ( a , b ) : <NEWLINE> <INDENT> if a_ == b_ : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <DEDENT> elif a_ in b : <NEWLINE> <INDENT> blow += 1 <NEWLINE> <DEDENT> <DEDENT> print ( hit , blow ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> v = iter ( sys . stdin . readlines ( ) ) <NEWLINE> for i , j in v , v : <NEWLINE> <INDENT> a , b = list ( i . sprit ( ) ) , list ( j . split ( ) ) <NEWLINE> k = len ( [ n for n in a for m in b if n == m ] ) <NEWLINE> l = len ( set ( a ) & set ( b ) ) <NEWLINE> print ( l , k - l ) <NEWLINE> <DEDENT>
import sys <NEWLINE> e = iter ( sys . stdin ) <NEWLINE> for a , b in zip ( e , e ) : <NEWLINE> <INDENT> a , b = a . split ( ) , b . split ( ) <NEWLINE> for s , t in zip ( a , b ) : h += s == t <NEWLINE> print ( h , 4 - len ( set ( a ) - set ( b ) ) - h ) <NEWLINE> <DEDENT>
import sys <NEWLINE> p = [ [ 0 for a in range ( 10 ) ] for b in range ( 10 ) ] <NEWLINE> def smallink ( x , y ) : <NEWLINE> <INDENT> return [ ( x + i , y + j ) for i in range ( - 1 , 2 , 1 ) for j in range ( - 1 , 2 , 1 ) if abs ( i ) + abs ( j ) <= 1 and x + i >= 0 and y + j >= 0 ] <NEWLINE> <DEDENT> def ink ( x , y ) : <NEWLINE> <INDENT> return [ ( x + i , y + j ) for i in range ( - 1 , 2 , 1 ) for j in range ( - 1 , 2 , 1 ) if x + i >= 0 and y + j >= 0 ] <NEWLINE> <DEDENT> def bigink ( x , y ) : <NEWLINE> <INDENT> return [ ( x + i , y + j ) for i in range ( - 2 , 3 , 1 ) for j in range ( - 2 , 3 , 1 ) if abs ( i ) + abs ( j ) <= 2 and x + i >= 0 and y + j >= 0 ] <NEWLINE> <NL> <DEDENT> for dataset in sys . stdin : <NEWLINE> <INDENT> x , y , size = map ( int , dataset . split ( <STRING> ) ) <NEWLINE> if size == 1 : <NEWLINE> <INDENT> L = smallink ( x , y ) <NEWLINE> <DEDENT> elif size == 2 : <NEWLINE> <INDENT> L = ink ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = bigink ( x , y ) <NEWLINE> <DEDENT> while len ( L ) != 0 : <NEWLINE> <INDENT> point = L . pop ( 0 ) <NEWLINE> p [ point [ 0 ] ] [ point [ 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> max = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> if ( p [ i ] [ j ] > max ) : <NEWLINE> <INDENT> max = p [ i ] [ j ] <NEWLINE> <DEDENT> if ( p [ i ] [ j ] == 0 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> print max <NEWLINE>
<NL> import sys <NEWLINE> <NL> <NL> class Paper : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . paper = [ [ 0 for x in range ( 10 ) ] for y in range ( 10 ) ] <NEWLINE> <NL> <DEDENT> def white_space ( self ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for x in range ( 10 ) : <NEWLINE> <INDENT> for y in range ( 10 ) : <NEWLINE> <INDENT> if self . paper [ x ] [ y ] == 0 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def most_dark ( self ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for x in range ( 10 ) : <NEWLINE> <INDENT> for y in range ( 10 ) : <NEWLINE> <INDENT> if self . paper [ x ] [ y ] > s : <NEWLINE> <INDENT> s = self . paper [ x ] [ y ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def drop ( self , x , y , size ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> if size == 1 : <NEWLINE> <INDENT> r . append ( ( x , y ) ) <NEWLINE> r . append ( ( x - 1 , y ) ) <NEWLINE> r . append ( ( x + 1 , y ) ) <NEWLINE> r . append ( ( x , y - 1 ) ) <NEWLINE> r . append ( ( x , y + 1 ) ) <NEWLINE> <DEDENT> elif size == 2 : <NEWLINE> <INDENT> r = [ ( i , j ) for i in range ( x - 1 , x + 2 ) for j in range ( y - 1 , y + 2 ) ] <NEWLINE> <DEDENT> elif size == 3 : <NEWLINE> <INDENT> r = [ ( i , j ) for i in range ( x - 1 , x + 2 ) for j in range ( y - 1 , y + 2 ) ] <NEWLINE> r . append ( ( x - 2 , y ) ) <NEWLINE> r . append ( ( x + 2 , y ) ) <NEWLINE> r . append ( ( x , y - 2 ) ) <NEWLINE> r . append ( ( x , y + 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> r = filter ( self . out_of_paper , r ) <NEWLINE> try : <NEWLINE> <INDENT> for p in r : <NEWLINE> <INDENT> self . paper [ p [ 0 ] ] [ p [ 1 ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> return self <NEWLINE> <NL> <DEDENT> def out_of_paper ( p ) : <NEWLINE> <INDENT> if p [ 0 ] >= 0 and p [ 1 ] >= 0 : <NEWLINE> <INDENT> True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> False <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> paper = Paper ( ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> ( x , y , size ) = tuple ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> paper . drop ( x , y , size ) <NEWLINE> <DEDENT> print paper . white_space ( ) <NEWLINE> print paper . most_dark ( ) <NEWLINE>
<COMMENT> <NL> paper = [ [ 0 for i in range ( 14 ) ] for i in range ( 14 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y , s = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> x += 2 ; y += 2 <NEWLINE> if s == 1 : <NEWLINE> <INDENT> paper [ x ] [ y ] += 1 <NEWLINE> for i in range ( - 1 , 2 , 2 ) : <NEWLINE> <INDENT> paper [ x + i ] [ y ] += 1 <NEWLINE> paper [ x ] [ y + 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif s == 2 : <NEWLINE> <INDENT> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for j in range ( - 1 , 2 ) : <NEWLINE> <INDENT> paper [ x + i ] [ y + j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> paper [ x + 2 ] [ y ] += 1 ; paper [ x - 2 ] [ y ] += 1 <NEWLINE> paper [ x ] [ y + 2 ] += 1 ; paper [ x ] [ y - 2 ] += 1 <NEWLINE> for i in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for j in range ( - 1 , 2 ) : <NEWLINE> <INDENT> paper [ x + i ] [ y + j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> white = 0 <NEWLINE> max = 0 <NEWLINE> for i in range ( 2 , 12 ) : <NEWLINE> <INDENT> for j in range ( 2 , 12 ) : <NEWLINE> <INDENT> if paper [ i ] [ j ] == 0 : <NEWLINE> <INDENT> white += 1 <NEWLINE> elif paper [ i ] [ j ] > max : <NEWLINE> max = paper [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> % ( white ) <NEWLINE> print <STRING> % ( max ) <NEWLINE>
mass = [ [ 0 for p in xrange ( 14 ) ] for q in xrange ( 14 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y , size = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if size == 1 : <NEWLINE> <INDENT> mass [ x - 2 ] [ y - 2 ] += 0 ; mass [ x - 1 ] [ y - 2 ] += 0 ; mass [ x ] [ y - 2 ] += 0 ; mass [ x + 1 ] [ y - 2 ] += 0 ; mass [ x + 2 ] [ y - 2 ] += 0 <NEWLINE> mass [ x - 2 ] [ y - 1 ] += 0 ; mass [ x - 1 ] [ y - 1 ] += 0 ; mass [ x ] [ y - 1 ] += 1 ; mass [ x + 1 ] [ y - 1 ] += 0 ; mass [ x + 2 ] [ y - 1 ] += 0 <NEWLINE> mass [ x - 2 ] [ y ] += 0 ; mass [ x - 1 ] [ y ] += 1 ; mass [ x ] [ y ] += 1 ; mass [ x + 1 ] [ y ] += 1 ; mass [ x + 2 ] [ y ] += 0 <NEWLINE> mass [ x - 2 ] [ y + 1 ] += 0 ; mass [ x - 1 ] [ y + 1 ] += 0 ; mass [ x ] [ y + 1 ] += 1 ; mass [ x + 1 ] [ y + 1 ] += 0 ; mass [ x + 2 ] [ y + 1 ] += 0 <NEWLINE> mass [ x - 2 ] [ y + 2 ] += 0 ; mass [ x - 1 ] [ y + 2 ] += 0 ; mass [ x ] [ y + 2 ] += 0 ; mass [ x + 1 ] [ y + 2 ] += 0 ; mass [ x + 2 ] [ y + 2 ] += 0 <NEWLINE> <DEDENT> elif size == 2 : <NEWLINE> <INDENT> mass [ x - 2 ] [ y - 2 ] += 0 ; mass [ x - 1 ] [ y - 2 ] += 0 ; mass [ x ] [ y - 2 ] += 0 ; mass [ x + 1 ] [ y - 2 ] += 0 ; mass [ x + 2 ] [ y - 2 ] += 0 <NEWLINE> mass [ x - 2 ] [ y - 1 ] += 0 ; mass [ x - 1 ] [ y - 1 ] += 1 ; mass [ x ] [ y - 1 ] += 1 ; mass [ x + 1 ] [ y - 1 ] += 1 ; mass [ x + 2 ] [ y - 1 ] += 0 <NEWLINE> mass [ x - 2 ] [ y ] += 0 ; mass [ x - 1 ] [ y ] += 1 ; mass [ x ] [ y ] += 1 ; mass [ x + 1 ] [ y ] += 1 ; mass [ x + 2 ] [ y ] += 0 <NEWLINE> mass [ x - 2 ] [ y + 1 ] += 0 ; mass [ x - 1 ] [ y + 1 ] += 1 ; mass [ x ] [ y + 1 ] += 1 ; mass [ x + 1 ] [ y + 1 ] += 1 ; mass [ x + 2 ] [ y + 1 ] += 0 <NEWLINE> mass [ x - 2 ] [ y + 2 ] += 0 ; mass [ x - 1 ] [ y + 2 ] += 0 ; mass [ x ] [ y + 2 ] += 0 ; mass [ x + 1 ] [ y + 2 ] += 0 ; mass [ x + 2 ] [ y + 2 ] += 0 <NEWLINE> <DEDENT> elif size == 3 : <NEWLINE> <INDENT> mass [ x - 2 ] [ y - 2 ] += 0 ; mass [ x - 1 ] [ y - 2 ] += 0 ; mass [ x ] [ y - 2 ] += 1 ; mass [ x + 1 ] [ y - 2 ] += 0 ; mass [ x + 2 ] [ y - 2 ] += 0 <NEWLINE> mass [ x - 2 ] [ y - 1 ] += 0 ; mass [ x - 1 ] [ y - 1 ] += 1 ; mass [ x ] [ y - 1 ] += 1 ; mass [ x + 1 ] [ y - 1 ] += 1 ; mass [ x + 2 ] [ y - 1 ] += 0 <NEWLINE> mass [ x - 2 ] [ y ] += 1 ; mass [ x - 1 ] [ y ] += 1 ; mass [ x ] [ y ] += 1 ; mass [ x + 1 ] [ y ] += 1 ; mass [ x + 2 ] [ y ] += 1 <NEWLINE> mass [ x - 2 ] [ y + 1 ] += 0 ; mass [ x - 1 ] [ y + 1 ] += 1 ; mass [ x ] [ y + 1 ] += 1 ; mass [ x + 1 ] [ y + 1 ] += 1 ; mass [ x + 2 ] [ y + 1 ] += 0 <NEWLINE> mass [ x - 2 ] [ y + 2 ] += 0 ; mass [ x - 1 ] [ y + 2 ] += 0 ; mass [ x ] [ y + 2 ] += 1 ; mass [ x + 1 ] [ y + 2 ] += 0 ; mass [ x + 2 ] [ y + 2 ] += 0 <NEWLINE> <DEDENT> <DEDENT> except : break <NEWLINE> <DEDENT> white = 0 <NEWLINE> max = 0 <NEWLINE> for p in xrange ( 2 , 12 ) : <NEWLINE> <INDENT> for val in xrange ( 2 , 12 ) : <NEWLINE> <INDENT> if mass [ p ] [ q ] == 0 : white += 1 <NEWLINE> if mass [ p ] [ q ] > figure : max = mass [ p ] [ q ] <NEWLINE> <DEDENT> <DEDENT> print white <NEWLINE> print max <NEWLINE>
import sys <NEWLINE> <NL> drops = [ None , <NEWLINE> <INDENT> [ ( 0 , 0 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] , <NEWLINE> [ ( 0 , 0 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , - 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) ] , <NEWLINE> [ ( 0 , 0 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , - 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) , ( - 2 , 0 ) , ( 2 , 0 ) , ( 0 , - 2 ) , ( 0 , 2 ) ] ] <NEWLINE> <NL> <DEDENT> B = [ [ 0 for j in xrange ( 10 ) ] for i in xrange ( 10 ) ] <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> x , y , s = map ( int , line . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> for dx , dy in drops [ s ] : <NEWLINE> <INDENT> nx , ny = x + dx , y + dy <NEWLINE> if ( 0 <= nx <= 9 or 0 <= ny <= 9 ) : <NEWLINE> <INDENT> B [ ny ] [ nx ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> emp , m = 0 , 0 <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> for j in xrange ( 10 ) : <NEWLINE> <INDENT> if B [ i ] [ j ] == 0 : <NEWLINE> <INDENT> emp += 1 <NEWLINE> <DEDENT> m = max ( m , B [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print emp <NEWLINE> print m <NEWLINE>
import sys <NEWLINE> def ink ( x , y , size ) : <NEWLINE> <INDENT> global P <NEWLINE> P [ y ] [ x ] += 1 <NEWLINE> for d in [ - 1 , 1 ] : <NEWLINE> <INDENT> P [ y + d ] [ x ] += 1 <NEWLINE> P [ y ] [ x + d ] += 1 <NEWLINE> <DEDENT> if size == 1 : return <NEWLINE> for d in [ - 1 , 1 ] : <NEWLINE> <INDENT> P [ y + d ] [ x + d ] += 1 <NEWLINE> P [ y + d ] [ x - d ] += 1 <NEWLINE> <DEDENT> if size == 2 : return <NEWLINE> for d in [ - 2 , 2 ] : <NEWLINE> <INDENT> P [ y + d ] [ x ] += 1 <NEWLINE> P [ y ] [ x + d ] += 1 <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> R = range ( 14 ) <NEWLINE> A = [ - 1 : 1 ] <NEWLINE> P = [ [ 0 for i in R ] for j in R ] <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> x , y , size = map ( int , s . split ( <STRING> ) ) <NEWLINE> ink ( x + 2 , y + 2 , size ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> m = 0 <NEWLINE> for e in P [ 2 : - 2 ] : <NEWLINE> <INDENT> x = e [ 2 : - 2 ] <NEWLINE> c += x . count ( 0 ) <NEWLINE> m = max ( max ( x ) , m ) <NEWLINE> <DEDENT> print c <NEWLINE> print m <NEWLINE>
paper = [ [ 0 for _ in range ( 14 ) ] for _ in range ( 14 ) ] <NEWLINE> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> x += 2 <NEWLINE> y += 2 <NEWLINE> paper [ x ] [ y ] += 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> paper [ x + dx [ i ] ] [ y + dy [ i ] ] += 1 <NEWLINE> <DEDENT> if s >= 2 : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> paper [ x + dx [ i ] + dx [ ( i + 1 ) % 4 ] ] [ y + dy [ i ] + dy [ ( i + 1 ) % 4 ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> if s >= 3 : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> paper [ x + 2 * dx [ i ] ] [ y + 2 * dy [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> paper = paper [ 2 : 12 ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> paper [ i ] = paper [ i ] [ 2 : 12 ] <NEWLINE> <DEDENT> print ( sum ( paper [ i ] . count ( 0 ) for i in range ( 10 ) ) ) <NEWLINE> print ( max ( paper [ i ] [ j ] for i in range ( 10 ) for j in range ( 10 ) ) ) <NEWLINE>
p = np . zeros ( ( 14 , 14 ) , dtype = int ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x_inp , y_inp , s = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> x = x_inp + 2 <NEWLINE> y = y_inp + 2 <NEWLINE> if s == 1 : <NEWLINE> <INDENT> p [ y - 1 ] [ x ] += 1 <NEWLINE> p [ y ] [ x - 1 : x + 2 ] += 1 <NEWLINE> p [ y + 1 ] [ x ] += 1 <NEWLINE> <DEDENT> elif s == 2 : <NEWLINE> <INDENT> p [ y - 1 ] [ x - 1 : x + 2 ] += 1 <NEWLINE> p [ y ] [ x - 1 : x + 2 ] += 1 <NEWLINE> p [ y + 1 ] [ x - 1 : x + 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ y - 2 ] [ x ] += 1 <NEWLINE> p [ y - 1 ] [ x - 1 : x + 2 ] += 1 <NEWLINE> p [ y ] [ x - 2 : x + 3 ] += 1 <NEWLINE> p [ y + 1 ] [ x - 1 : x + 2 ] += 1 <NEWLINE> p [ y + 2 ] [ x ] += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> p_trim = p [ 2 : 12 , 2 : 12 ] <NEWLINE> print ( len ( np . where ( p_trim == 0 ) [ 0 ] ) ) <NEWLINE> print ( np . max ( p_trim ) ) <NEWLINE> <NL>
<NL> dates = [ ] <NEWLINE> youbi = [ ] <NEWLINE> <NL> for i in range ( 1 , 13 ) : <NEWLINE> <INDENT> if i == 1 or i == 3 or i == 5 or i == 7 or i == 8 or i == 10 or i == 12 : <NEWLINE> <INDENT> for j in range ( 1 , 32 ) : <NEWLINE> <INDENT> dates . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> elif i == 4 or i == 6 or i == 9 or i == 11 : <NEWLINE> <INDENT> for j in range ( 1 , 31 ) : <NEWLINE> <INDENT> dates . append ( [ i , j ] ) <NEWLINE> <DEDENT> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> for j in range ( 1 , 30 ) : <NEWLINE> <INDENT> dates . append ( [ i , j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> x = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if x == [ 0 , 0 ] : <NEWLINE> <INDENT> for yo in youbi : <NEWLINE> <INDENT> print yo <NEWLINE> <DEDENT> <DEDENT> elif dates . index ( x ) % 7 == 0 : <NEWLINE> <INDENT> youbi . append ( <STRING> ) <NEWLINE> <DEDENT> elif dates . index ( x ) % 7 == 1 : <NEWLINE> <INDENT> youbi . append ( <STRING> ) <NEWLINE> <DEDENT> elif dates . index ( x ) % 7 == 2 : <NEWLINE> <INDENT> youbi . append ( <STRING> ) <NEWLINE> <DEDENT> elif dates . index ( x ) % 7 == 3 : <NEWLINE> <INDENT> youbi . append ( <STRING> ) <NEWLINE> <DEDENT> elif dates . index ( x ) % 7 == 4 : <NEWLINE> <INDENT> youbi . append ( <STRING> ) <NEWLINE> <DEDENT> elif dates . index ( x ) % 7 == 5 : <NEWLINE> <INDENT> youbi . append ( <STRING> ) <NEWLINE> <DEDENT> elif dates . index ( x ) % 7 == 6 : <NEWLINE> <INDENT> youbi . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
ans = { } <NEWLINE> for i in range ( 1 , 13 ) : <NEWLINE> <INDENT> if i % 2 != 0 : <NEWLINE> <INDENT> ans [ str ( i ) ] = 31 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ str ( i ) ] = 30 <NEWLINE> <DEDENT> <DEDENT> ans [ <STRING> ] = 29 <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> day = b <NEWLINE> if a + b == 0 : break ; <NEWLINE> if a == 1 : day = b ; <NEWLINE> elif a == 2 : day += 31 <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> if i == 0 : pass ; <NEWLINE> day += ans [ str ( i ) ] <NEWLINE> <DEDENT> <DEDENT> print [ <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> ] [ day % 7 ] <NEWLINE> <DEDENT> <DEDENT>
days_sum = { 1 : 31 , 2 : 29 , 3 : 31 , 4 : 30 , 5 : 31 , 6 : 30 , 7 : 31 , 8 : 31 , 9 : 30 , <NEWLINE> <INDENT> 10 : 31 , 11 : 30 , 12 : 31 } <NEWLINE> <DEDENT> days2month = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , <NEWLINE> <INDENT> 5 : <STRING> , 6 : <STRING> , 7 : <STRING> } <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> month , day = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if month == 0 and day == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> keika = 0 <NEWLINE> for i in range ( 1 , month ) : <NEWLINE> <INDENT> keika += days_sum [ i ] <NEWLINE> <DEDENT> keika += day <NEWLINE> print days2month [ keika % 7 ] <NEWLINE> <DEDENT>
import datetime <NEWLINE> <NL> weekdays = [ <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> m , d = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> print weekdays [ datetime . date ( 2004 , m , d ) . weekday ( ) ] <NEWLINE> <DEDENT>
y = [ 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] <NEWLINE> dow = [ 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> m , d = map ( int , raw_inpud ( ) . split ( ) ) <NEWLINE> if m == 0 and d == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> n += y [ i ] <NEWLINE> <DEDENT> n -= ( n [ m ] - d + 1 ) <NEWLINE> print dow [ ( n + 3 ) % 7 ] <NEWLINE> <DEDENT>
nm = [ 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 ] <NEWLINE> while True : <NEWLINE> <NL> <INDENT> m , d = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nd = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> nd += nm [ i ] <NEWLINE> <NL> <DEDENT> nd += d <NEWLINE> n = nd % 7 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n == 3 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n == 4 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n == 5 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n == 6 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ~ <NEWLINE> ~ <NEWLINE>
wd = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> md = [ 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> m , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> s = sum ( [ md [ i ] for i in range ( month ) ] ) + day + 2 <NEWLINE> s = wd [ s % 7 ] + <STRING> <NEWLINE> print s <NEWLINE> <DEDENT>
d = { } <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n in d : <NEWLINE> <INDENT> d [ n ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ n ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> a = [ ] <NEWLINE> m = max ( d . value ( ) ) <NEWLINE> for key , value in d : <NEWLINE> <INDENT> if value == m : <NEWLINE> <INDENT> a . append ( key ) <NEWLINE> <DEDENT> <DEDENT> a . sort ( ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
import sys <NEWLINE> c = [ 0 for i in range ( 101 ) ] <NEWLINE> for n in sys . stdin : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> counter [ n ] += 1 <NEWLINE> <DEDENT> m = max ( c ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if c [ i ] == m : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT> <DEDENT>
d = [ 0 ] * 101 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> d [ n ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> tmp = max ( d ) <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> if d [ i ] = tmp : print i <NEWLINE> <DEDENT>
import sys <NEWLINE> arr = [ 0 for i in range ( 0 , 101 ) ] <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> arr [ int ( i ) ] += 1 <NEWLINE> <NL> <DEDENT> max = max ( arr ) <NEWLINE> for i in for ( 0 , 101 ) : <NEWLINE> <INDENT> if arr [ i ] == max : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
a , md = [ ] , [ ] <NEWLINE> c , mx = 1 , 1 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> a = sorted ( a ) <NEWLINE> print ( a ) <NEWLINE> for i in range ( 0 , len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = 1 <NEWLINE> <DEDENT> if mx < c : <NEWLINE> <INDENT> mx = c <NEWLINE> md = [ a [ i ] ] <NEWLINE> <DEDENT> elif mx == c : <NEWLINE> <INDENT> md . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , sorted ( md ) ) ) <NEWLINE>
<COMMENT> <NL> import collections <NEWLINE> array = [ ] <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> array . append ( int ( input ( ) ) ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> count = list ( map ( lambda a : array . count ( a ) , array ) ) <NEWLINE> modes = list ( set ( filter ( lambda a : array . count ( a ) == max ( count ) , array ) ) ) <NEWLINE> print ( * modes , sep = <STRING> ) <NEWLINE>
nums = [ ] <NEWLINE> val = [ ] <NEWLINE> ans = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> nums . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> break : <NEWLINE> <INDENT> num_list = sorted ( list ( set ( nums ) ) ) <NEWLINE> for n in num_list : <NEWLINE> <INDENT> val . append ( nums . count ( n ) ) <NEWLINE> <DEDENT> ans . append ( num_list [ val . index ( max ( val ) ) ] ) <NEWLINE> tmp = max ( val ) <NEWLINE> val . remove ( max ( val ) ) <NEWLINE> num_list . pop ( val . index ( tmp ) ) <NEWLINE> while max ( val ) == tmp : <NEWLINE> <INDENT> ans . append ( num_list [ val . index ( max ( val ) ) ] ) <NEWLINE> num_list . pop ( val . index ( tmp ) ) <NEWLINE> val . remove ( max ( val ) ) <NEWLINE> <DEDENT> for s in ans : <NEWLINE> <INDENT> print s <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> hist = [ 0 for i in range ( 100 ) ] <NEWLINE> <NL> l = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> hist [ input ( ) - 1 ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> for k in filter ( lambda x : max ( hist ) == x [ 1 ] , enumlate ( hist ) ) : <NEWLINE> <INDENT> print k [ 0 ] + 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> array = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : break <NEWLINE> array . append ( int ( a ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> s = set ( array ) <NEWLINE> mx = max ( list ( map ( lambda a : array . count ( a ) , s ) ) ) <NEWLINE> modes = list ( filter ( lambda a : array . count ( a ) == mx ) , sorted ( s ) ) <NEWLINE> print ( * modes , sep = <STRING> ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> cntr = collections . Counter <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> cntr [ int ( line ) ] += 1 <NEWLINE> <DEDENT> lst = [ ] <NEWLINE> for k , v in cntr . items ( ) : <NEWLINE> <INDENT> lst . append ( ( v , k ) ) <NEWLINE> <DEDENT> lst . sort ( ) <NEWLINE> t = len ( lst ) - 1 <NEWLINE> while t > 0 and lst [ t ] [ 0 ] == lst [ t - 1 ] [ 0 ] : <NEWLINE> <INDENT> t -= 1 <NEWLINE> <DEDENT> for i in range ( t , len ( lst ) ) : <NEWLINE> <INDENT> print ( lst [ i ] [ 1 ] ) <NEWLINE> <DEDENT>
kosu = [ 0 ] * 100 <NEWLINE> k = 1 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> kosu [ n - 1 ] += 1 <NEWLINE> <DEDENT> except ( EOFError , ValueError ) : <NEWLINE> <INDENT> ma = max ( kosu ) <NEWLINE> num = kosu . index ( ma ) + k <NEWLINE> print ( num ) <NEWLINE> <NL> <NL> kosu . remove ( max ( kosu ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if ma > max ( kosu ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k += 1 <NEWLINE> num = kosu . index ( ma ) + k <NEWLINE> kosu . remove ( max ( kosu ) ) <NEWLINE> print ( num ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> l = [ ] <NEWLINE> c = list ( [ 0 ] * 100 ) <NEWLINE> for i in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> c [ int ( i - 1 ) ] += 1 <NEWLINE> <DEDENT> m = max ( c ) <NEWLINE> for i in xrange ( c . count ( m ) ) : <NEWLINE> <INDENT> i = c . index ( m ) <NEWLINE> print i + 1 <NEWLINE> c . pop ( i ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import collections <NEWLINE> array = [ 0 ] * 100 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == <STRING> : break <NEWLINE> array [ i ] = int ( a ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> array = filter ( lambda a : a != 0 , array ) <NEWLINE> counter = collections . Counter ( array ) . most_common ( ) <NEWLINE> for a , count in counter : <NEWLINE> <INDENT> if count < counter [ 0 ] [ 1 ] : break <NEWLINE> print ( a ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import dropwhile <NEWLINE> a = [ ] <NEWLINE> for v in sys . stdin : <NEWLINE> <INDENT> a . append ( int ( v ) ) <NEWLINE> <NL> <DEDENT> m = max ( [ a . count ( v ) for v in set ( a ) ] ) <NEWLINE> next ( dropwhile ( lambda x : True , ( print ( v ) for v in set ( a ) if a . count ( v ) == m ) ) ) <NEWLINE>
<COMMENT> <NL> array = [ ] * 100 <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> array [ i ] = int ( a ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> s = set ( array ) <NEWLINE> mx = max ( list ( map ( lambda a : array . count ( a ) , s ) ) ) <NEWLINE> modes = list ( filter ( lambda a : array . count ( a ) == mx , sorted ( s ) ) ) <NEWLINE> print ( * modes , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> a = raw_input ( ) . lower ( ) <NEWLINE> s = a . split ( ) <NEWLINE> ss = <STRING> <NEWLINE> tmp = <STRING> <NEWLINE> n = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> if len ( ss ) < len ( i ) : <NEWLINE> <INDENT> ss = i <NEWLINE> <DEDENT> <DEDENT> for i in s : <NEWLINE> <INDENT> i += <STRING> <NEWLINE> if a . count ( i ) > n : <NEWLINE> <INDENT> n = a . count ( i ) <NEWLINE> tmp = i . trip ( ) <NEWLINE> <DEDENT> <DEDENT> print tmp , ss <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ls = [ ] <NEWLINE> dic = { } <COMMENT> <NEWLINE> <NL> ls = raw_input ( ) . split ( ) <NEWLINE> for k in range ( len ( ls ) ) : <NEWLINE> <INDENT> if ls [ k ] not in dic . keys ( ) : <NEWLINE> <INDENT> dic [ ls [ k ] ] = [ ] <NEWLINE> dic [ ls [ k ] ] . append ( 1 ) <NEWLINE> dic [ ls [ k ] ] . append ( len ( ls [ k ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ ls [ k ] ] [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> a = max ( dic ) <COMMENT> <NEWLINE> b = max ( dic . items ( ) , key = lambda x : x [ 1 ] [ 1 ] ) [ 0 ] <NEWLINE> print <STRING> % ( a , b ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> words = raw_input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> count = { } ; <NEWLINE> for word in words : <NEWLINE> <INDENT> s = count . setdefault ( word , 0 ) ; <NEWLINE> count [ word ] = s + 1 <NEWLINE> <DEDENT> print max ( count . items ( ) , key = lambda x : x [ 1 ] ) [ 0 ] , max ( words , key = lambda x : len ( x ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> rhombus = oblong = 0 <NEWLINE> for line in f : <NEWLINE> <INDENT> a , b , c = map ( int , line . split ( <STRING> ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> rhombus += 1 <NEWLINE> <DEDENT> if a * a + b * b == c * c : <NEWLINE> <INDENT> oblong += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( oblong ) <NEWLINE> print ( rhombus ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> dic = { } <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> d = [ e . lower ( ) for e in map ( str , s . split ( ) ) ] <NEWLINE> for e in d : <NEWLINE> <INDENT> if e in dic : <NEWLINE> <INDENT> dic [ e ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ e ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> sdict = sorted ( dic . items ( ) , key = lambda x : - x [ 1 ] ) <NEWLINE> maxnum = sdict [ 0 ] [ 1 ] <NEWLINE> for i in range ( len ( sdict ) ) : <NEWLINE> <INDENT> if sdict [ i ] [ 1 ] == maxnum : <NEWLINE> <INDENT> print sdict [ i ] [ 0 ] , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> maxlen = max ( [ len ( e ) for e in d ] ) <NEWLINE> longterm = [ e for e in d if len ( e ) == maxlen ] <NEWLINE> for e in longterm : <NEWLINE> <INDENT> print e , <NEWLINE> <DEDENT>
for word in s : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dic [ word ] += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> dic [ word ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m = 0 <NEWLINE> l = 0 <NEWLINE> for word , e in dic . items ( ) : <NEWLINE> <INDENT> if e > m : <NEWLINE> <INDENT> m = e <NEWLINE> w1 = word <NEWLINE> <DEDENT> if len ( word ) > l : <NEWLINE> <INDENT> l = len ( word ) <NEWLINE> w2 = word <NEWLINE> <NL> <DEDENT> <DEDENT> print w1 , w2 <NEWLINE>
import statistics as st <NEWLINE> word1 = [ ] <NEWLINE> word = raw_input ( ) . split ( ) <NEWLINE> for i in xrange ( len ( word ) ) : <NEWLINE> <INDENT> word1 . append ( len ( word [ i ] ) ) <NEWLINE> <DEDENT> for i in xrange ( len ( word ) ) : <NEWLINE> <INDENT> if len ( word [ i ] ) == max ( word1 ) : <NEWLINE> <INDENT> print ( st . mode ( word ) , word [ i ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
def f ( n , s , x ) : <NEWLINE> <INDENT> if n == s == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n == 0 or x == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> a += f ( n - 1 , s - i , i ) <NEWLINE> <DEDENT> return a <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( f ( n , s , 10 ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n , s = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sum ( 1 for nums in itertools . combinations ( [ i for i in range ( 10 ) ] , n ) if sum ( nums ) == s ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> <NL> d = [ i for i in xrange ( 101 ) ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> x = map ( sum , list ( itertools . combinations ( d [ 0 : s + 1 ] , n ) ) ) <NEWLINE> print x . count ( s ) <NEWLINE> <DEDENT>
def move ( move_count , current , flag ) : <NEWLINE> <INDENT> for i in range ( move_count ) : <NEWLINE> <INDENT> n_lis . append ( num_lis [ current + i ] ) <NEWLINE> if flag == n : <NEWLINE> <INDENT> calculate ( ) <NEWLINE> del n_lis [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> move ( move_count , current + i + 1 , flag + 1 ) <NEWLINE> move_count -= 1 <NEWLINE> del n_lis [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def calculate ( ) : <NEWLINE> <INDENT> global count <NEWLINE> if sum ( n_lis ) == s : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num_lis = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <NEWLINE> n_lis = [ ] <NEWLINE> count = 0 <NEWLINE> move ( 8 , 0 , 1 ) <NEWLINE> print count <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> while 1 : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n : print ( sum ( 1 for p in combinations ( range ( 10 ) , n ) if sum ( p ) == s ) ) <NEWLINE> <DEDENT>
def dec2bin ( n , base = 10 ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> x = [ <STRING> , <STRING> ] <NEWLINE> while n > 0 : <NEWLINE> <INDENT> s += x [ n % 2 ] <NEWLINE> n /= 2 <NEWLINE> <DEDENT> return ( s + <STRING> * base ) [ : base ] <NEWLINE> <NL> <DEDENT> x = [ [ 0 for i in range ( 50 ) ] for i in range ( 11 ) ] <NEWLINE> for i in range ( 0 , 2 ** 10 ) : <NEWLINE> <INDENT> tmp = dec2bin ( i ) <NEWLINE> s = 0 <NEWLINE> c = 0 <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if tmp [ j ] == <STRING> : <NEWLINE> <INDENT> s += j <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> x [ c ] [ s ] += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and s == 0 : break <NEWLINE> print x [ n ] [ s ] <NEWLINE> <DEDENT>
x = [ [ 0 ] * 50 for i in range ( 11 ) ] <NEWLINE> for i in range ( 0 , 2 ** 10 ) : <NEWLINE> <INDENT> B = format ( i , <STRING> ) [ : : - 1 ] <NEWLINE> s , c , j = 0 , 0 , 0 <NEWLINE> for e in B : <NEWLINE> <INDENT> if e == <STRING> : s , c = s + j , c + 1 <NEWLINE> j += 1 <NEWLINE> <DEDENT> x [ c ] [ s ] += 1 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and s == 0 : break <NEWLINE> print [ x [ n ] [ s ] , 0 ] [ s >= 50 ] <NEWLINE> <DEDENT>
def div ( n , m ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> return n / m <NEWLINE> <DEDENT> except ZeroDivisionError : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> def degit ( n , m ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> b = - 1 <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> s = div ( n % ( 10 ** ( i + 1 ) ) , ( 10 ** i ) ) <NEWLINE> if ( b < s ) : <NEWLINE> <INDENT> b = s <NEWLINE> r . append ( s ) <NEWLINE> <DEDENT> <DEDENT> if ( len ( r ) == m ) : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> ( n , s ) = [ int ( i ) for i in raw_input ( ) . split ( ) ] <NEWLINE> if ( ( 0 , 0 ) == ( n , s ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in xrange ( 10 ** n ) : <NEWLINE> <INDENT> r = degit ( i , n ) <NEWLINE> if ( r == None ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( len ( r ) != len ( list ( set ( r ) ) ) ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( reduce ( lambda x , y : x + y , r ) == s ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
from itertools import combinations <NEWLINE> while 1 : <NEWLINE> <INDENT> n , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n : print ( sum ( [ 1 for p in combinations ( range ( 10 ) , n ) if sum ( p ) == s ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> w = int ( line ) <NEWLINE> dic = calcWeights ( w ) <NEWLINE> <NL> for k in sorted ( dic . keys ( ) ) : <NEWLINE> <INDENT> if dic [ k ] > 0 : <NEWLINE> <INDENT> print k , <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def calcWeights ( w ) : <NEWLINE> <INDENT> dic = { } <NEWLINE> dic [ 1 ] = w >> 0 & 1 <NEWLINE> dic [ 2 ] = w >> 1 & 1 <NEWLINE> dic [ 4 ] = w >> 2 & 1 <NEWLINE> dic [ 8 ] = w >> 3 & 1 <NEWLINE> dic [ 16 ] = w >> 4 & 1 <NEWLINE> dic [ 32 ] = w >> 5 & 1 <NEWLINE> dic [ 64 ] = w >> 6 & 1 <NEWLINE> dic [ 128 ] = w >> 7 & 1 <NEWLINE> dic [ 256 ] = w >> 8 & 1 <NEWLINE> dic [ 512 ] = w >> 9 & 1 <NEWLINE> <NL> return dic <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> while 1 : print ( * [ int ( b ) * 2 ** i for i , b in enumerate ( bin ( int ( sys . stdin . readline ( ) ) ) [ 2 : ] [ : : - 1 ] ) if int ( b ) ] ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> waight = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for n in sys . stdin : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> n = bin ( n ) [ 2 : ] . zfill ( 10 ) <NEWLINE> for i , x in enumerate ( n [ : : - 1 ] ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> ans . append ( waight [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <STRING> <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( int ( line ) ) <NEWLINE> <DEDENT> for x in a : <NEWLINE> <INDENT> out = 1 <NEWLINE> while x : <NEWLINE> <INDENT> if x & 1 : <NEWLINE> <INDENT> print out , <NEWLINE> <DEDENT> x /= 2 <NEWLINE> out *= 2 <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
import sys <NEWLINE> from math import sqrt <NEWLINE> <NL> nyu = sys . stdin . read ( ) <NEWLINE> nyu = nyu . split ( <STRING> ) <NEWLINE> cheese = map ( float , nyu [ 0 ] . split ( ) ) <NEWLINE> cheese . sort ( ) <NEWLINE> supk = sqrt ( ( cheeze [ 0 ] / 2 ) ** 2 + ( cheeze [ 1 ] / 2 ) ** 2 ) <NEWLINE> nyu = nyu [ 2 : ] <NEWLINE> for k in nyu : <NEWLINE> <INDENT> if k < supk : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> import itertools as iter <NEWLINE> import sys <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> omori = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ] <NEWLINE> x = int ( i ) <NEWLINE> for i in xrange ( 1 , 11 ) : <NEWLINE> <INDENT> for element in iter . combinations ( omori , i ) : <NEWLINE> <INDENT> if sum ( element ) == x : <NEWLINE> <INDENT> for k in xrange ( len ( element ) ) : <NEWLINE> <INDENT> print element [ k ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) ; plumbs = [ ] ; answer = <STRING> <NEWLINE> if n >= 512 : plumbs . insert ( 0 , 512 ) ; n -= 512 <NEWLINE> if n >= 256 : plumbs . insert ( 0 , 256 ) ; n -= 256 <NEWLINE> if n >= 128 : plumbs . insert ( 0 , 128 ) ; n -= 128 <NEWLINE> if n >= 64 : plumbs . insert ( 0 , 64 ) ; n -= 64 <NEWLINE> if n >= 32 : plumbs . insert ( 0 , 32 ) ; n -= 32 <NEWLINE> if n >= 16 : plumbs . insert ( 0 , 16 ) ; n -= 16 <NEWLINE> if n >= 8 : plumbs . insert ( 0 , 8 ) ; n -= 8 <NEWLINE> if n >= 4 : plumbs . insert ( 0 , 4 ) ; n -= 4 <NEWLINE> if n >= 2 : plumbs . insert ( 0 , 2 ) ; n -= 2 <NEWLINE> if n >= 1 : plumbs . insert ( 0 , 1 ) ; n -= 1 <NEWLINE> for val in plumbs : answer += str ( val ) + <STRING> <NEWLINE> answer . rstrip ( ) ; print answer <NEWLINE> <DEDENT> except : break <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> def subset ( a ) : <NEWLINE> <INDENT> for n in range ( 2 ** len ( a ) ) : <NEWLINE> <INDENT> yield [ a [ i ] for i in xrange ( len ( a ) ) if ( n >> i ) & 1 == 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> weights = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ] <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> w = int ( line ) <NEWLINE> for s in subset ( weights ) : <NEWLINE> <INDENT> if sum ( s ) == w : <NEWLINE> <INDENT> for a in s : <NEWLINE> <INDENT> print a , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> nb = format ( n , <STRING> ) <NEWLINE> nb . reverse <NEWLINE> nb += <STRING> * ( 10 - len ( nb ) ) <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> if nb [ i ] == 1 : <NEWLINE> <INDENT> ans . append ( str ( 2 ** ( 9 - i ) ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( ans ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> g = int ( input ( ) ) <NEWLINE> now = 512 <NEWLINE> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> if g == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif g >= now : <NEWLINE> <INDENT> g -= now <NEWLINE> ans . append ( now ) <NEWLINE> <DEDENT> now //= 2 <NEWLINE> <DEDENT> temp = <STRING> <NEWLINE> for i in ans [ : : - 1 ] : <NEWLINE> <INDENT> temp += str ( i ) + <STRING> <NEWLINE> <DEDENT> print ( temp [ : - 1 ] ) <NEWLINE> <DEDENT>
mport math <NEWLINE> <NL> def cal ( x ) : <NEWLINE> <INDENT> a = 10 <NEWLINE> y = [ ] <NEWLINE> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> d = pow ( 2 , ( 10 - i ) ) <NEWLINE> <NL> if x >= d : <NEWLINE> <INDENT> x -= d <NEWLINE> y . append ( d ) <NEWLINE> <DEDENT> <DEDENT> return y <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <NL> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> b = cal ( a ) <NEWLINE> b . reverse ( ) <NEWLINE> <NL> for y in b : <NEWLINE> <INDENT> print y , <NEWLINE> <NL> <DEDENT> print <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> def calc_weights ( weight ) : <NEWLINE> <INDENT> weights_list = [ ] <NEWLINE> counter = 0 <NEWLINE> while weight > 0 : <NEWLINE> <INDENT> if weight % 2 == 0 : <NEWLINE> <INDENT> weight /= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> weights_list . append ( 2 ** counter ) <NEWLINE> <DEDENT> counter += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , weights_list ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> W = int ( input ( ) ) <NEWLINE> calc_weights ( W ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> instr = str ( bin ( int ( input ( ) ) ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( len ( instr ) ) : <NEWLINE> <INDENT> if instr [ - i ] == <STRING> : ans . append ( 1 << i - 1 ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( lambda x : str ( x ) , ans ) ) ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> PI = 3.1415926535898 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> base = 1 <NEWLINE> ans = <STRING> <NEWLINE> while base < n : <NEWLINE> <INDENT> base *= 2 <NEWLINE> <DEDENT> base /= 2 <NEWLINE> res = [ base ] <NEWLINE> n -= base <NEWLINE> while n > 0 : <NEWLINE> <INDENT> base /= 2 <NEWLINE> if n >= base : <NEWLINE> <INDENT> res . append ( base ) <NEWLINE> n -= base <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> <NEWLINE> for x in reversed ( res ) : <NEWLINE> <INDENT> if len ( ans ) > 0 : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> ans += str ( x ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> n1 = n2 = 0 <NEWLINE> for _ in sys . stdin : <NEWLINE> <INDENT> a , b , c = map ( int , line . split ( <STRING> ) ) <NEWLINE> if a ** 2 + b ** 2 == c ** 2 : <NEWLINE> <INDENT> n1 += 1 <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> n2 += 1 <NEWLINE> <DEDENT> <DEDENT> print ( n1 ) <NEWLINE> print ( n2 ) <NEWLINE>
import sys , math <NEWLINE> <NL> rect , rhom = 0 , 0 <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> side = map ( int , s . split ( <STRING> ) ) <NEWLINE> if side [ 0 ] == side [ 1 ] : <NEWLINE> <INDENT> rhom += 1 <NEWLINE> <DEDENT> elif side [ 0 ] ** 2 + side [ 1 ] ** 2 == side [ 2 ] ** 2 : <NEWLINE> <INDENT> rect += 1 <NEWLINE> <DEDENT> <DEDENT> print rect , <STRING> , rhom , <NEWLINE>
rectangles = 0 ; lozenges = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c , = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if a * a + b * b = c * c : rectangle += 1 <NEWLINE> else : <NEWLINE> <INDENT> if a = b : lozenges += 1 <NEWLINE> <DEDENT> <DEDENT> except : break <NEWLINE> <DEDENT> print rectangles ; print lozenges <NEWLINE>
import sys <NEWLINE> rect = 0 <NEWLINE> hisi = 0 <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x , y , z = map ( int , line . split ( <STRING> ) ) <NEWLINE> if x ** 2 + y ** 2 == z ** 2 : rect += 1 <NEWLINE> elif x == y : hisi += 1 <NEWLINE> <NL> <DEDENT> print rect , <STRING> , hisi <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> num = [ ] <NEWLINE> cyou , hisi = 0 , 0 <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> num = map ( int , i . split ( <STRING> ) ) <NEWLINE> kaku = math . acos ( num [ 0 ] / num [ 1 ] ) * ( 180 / math . pi ) <NEWLINE> if kaku == 90 : <NEWLINE> <INDENT> cyou += 1 <NEWLINE> <DEDENT> elif num [ 0 ] == num [ 1 ] : <NEWLINE> <INDENT> hisi += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print cyou <NEWLINE> print hisi <NEWLINE>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> ans = [ 0 ] * 2 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a , b , c = map ( int , line . split ( ) ) <NEWLINE> if a ** 2 + b ** 2 == c ** 2 : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> rect_cnt += ( a ** 2 + b ** 2 == c ** 2 ) <NEWLINE> dia_cnt += ( a == b ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( rect_cnt ) <NEWLINE> print ( dia_cnt ) <NEWLINE>
import sys <NEWLINE> rec = rho = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <STRING> <NEWLINE> <INDENT> a , b , c = map ( int , line . split ( <STRING> ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> rho += 1 <NEWLINE> <DEDENT> elif a * a + b * b == c * c : <NEWLINE> <INDENT> rec += 1 <NEWLINE> <DEDENT> <DEDENT> print rec <NEWLINE> print rho <NEWLINE>
hisi = 0 <NEWLINE> tyou = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> if a ** 2 + b ** 2 == c ** 2 : <NEWLINE> <INDENT> tyou += 1 <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> hisi += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( tyou ) <NEWLINE> print ( hisi ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> j = [ int ( a ) ** 2 + int ( b ) ** 2 - int ( c ) ** 2 for line in sys . stdin for a , b , c in line . split ( <STRING> ) ] <NEWLINE> print ( len ( [ i for i in j if not i ] ) ) <NEWLINE> print ( len ( [ i for i in j if i ] ) ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> <NL> def fill_balls ( a ) : <NEWLINE> <INDENT> b = [ 0 ] <NEWLINE> c = [ 0 ] <NEWLINE> for ball in a : <NEWLINE> <INDENT> if b [ - 1 ] == 0 : <NEWLINE> <INDENT> b . append ( ball ) <NEWLINE> <DEDENT> elif b [ - 1 ] < ball and c [ - 1 ] < ball : <NEWLINE> <INDENT> if b [ - 1 ] < c [ - 1 ] : <NEWLINE> <INDENT> c . append ( ball ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b . append ( ball ) <NEWLINE> <DEDENT> <DEDENT> elif b [ - 1 ] < ball : <NEWLINE> <INDENT> b . append ( ball ) <NEWLINE> <DEDENT> elif c [ - 1 ] < ball : <NEWLINE> <INDENT> c . append ( ball ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> sys . stdin . readline ( ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a = map ( int , line . split ( <STRING> ) ) <NEWLINE> print fill_balls ( a ) <NEWLINE> <DEDENT>
def load_balls ( ) : <NEWLINE> <INDENT> LINE_NUM , TOTAL = 0 , 0 <NEWLINE> balls = [ ] <NEWLINE> i = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> line = line . strip ( ) <NEWLINE> LINE_NUM += 1 <NEWLINE> if LINE_NUM == 1 : <NEWLINE> <INDENT> TOTAL = int ( line . strip ( ) ) <NEWLINE> continue <NEWLINE> <DEDENT> balls . append ( [ int ( i ) for i in line . split ( <STRING> ) ] ) <NEWLINE> if LINE_NUM == TOTAL + 1 : break <NEWLINE> <DEDENT> return balls <NEWLINE> <NL> <DEDENT> class VesselClass : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . BALL_NUM = 10 <NEWLINE> self . tmp = [ ] <NEWLINE> self . left = [ 0 ] <NEWLINE> self . right = [ 0 ] <NEWLINE> <NL> <DEDENT> def fill ( self , balls : list ) : <NEWLINE> <INDENT> self . tmp = balls <NEWLINE> <NL> <DEDENT> def DFS ( self ) : <NEWLINE> <INDENT> if len ( self . tmp ) == 0 : print ( <STRING> ) <NEWLINE> elif self . left [ - 1 ] < self . tmp [ 0 ] : <NEWLINE> <INDENT> self . left . append ( self . tmp [ 0 ] ) <NEWLINE> self . tmp . pop ( 0 ) <NEWLINE> self . DFS ( ) <NEWLINE> <DEDENT> elif self . right [ - 1 ] < self . tmp [ 0 ] : <NEWLINE> <INDENT> self . right . append ( self . tmp [ 0 ] ) <NEWLINE> self . tmp . pop ( 0 ) <NEWLINE> self . DFS ( ) <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> balls_list = load_balls ( ) <NEWLINE> Vessel = VesselClass ( ) <NEWLINE> for balls in balls_list : <NEWLINE> <INDENT> Vessel . fill ( balls ) <NEWLINE> Vessel . DFS ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A , B , C = [ ] , [ 0 ] , [ 0 ] <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if A [ i ] > B [ 0 ] : <NEWLINE> <INDENT> B . insert ( 0 , num [ i ] ) <NEWLINE> <DEDENT> elif A [ i ] > C [ 0 ] : <NEWLINE> <INDENT> C . insert ( 0 , num [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( A ) + len ( B ) == 12 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> input = map ( lambda x : x [ : - 1 ] , sys . stdin . readlines ( ) ) <NEWLINE> <NL> <NL> n = int ( input [ 0 ] ) <NEWLINE> <NL> input = input [ 1 : ] <NEWLINE> <NL> input = map ( lambda x : x . split ( <STRING> ) , input ) <NEWLINE> <NL> for i in range ( len ( input ) ) : <NEWLINE> <INDENT> input [ i ] = map ( lambda x : int ( x ) , input [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> A = [ ] <NEWLINE> B = [ ] <NEWLINE> <NL> def a_can_add ( e ) : <NEWLINE> <INDENT> if ( ( len ( A ) != 0 ) and ( A [ - 1 ] < e ) ) or len ( A ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def b_can_add ( e ) : <NEWLINE> <INDENT> if ( ( len ( B ) != 0 ) and ( B [ - 1 ] < e ) ) or len ( B ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def a_add ( e ) : <NEWLINE> <INDENT> if ( len ( A ) != 0 ) and ( A [ - 1 ] < e ) : <NEWLINE> <INDENT> A . append ( e ) <NEWLINE> <DEDENT> elif len ( A ) == 0 : <NEWLINE> <INDENT> A . append ( e ) <NEWLINE> <DEDENT> else : return False <NEWLINE> <NL> <DEDENT> def b_add ( e ) : <NEWLINE> <INDENT> if len ( B ) != 0 and ( B [ - 1 ] < e ) : <NEWLINE> <INDENT> B . append ( e ) <NEWLINE> <DEDENT> elif len ( B ) == 0 : <NEWLINE> <INDENT> B . append ( e ) <NEWLINE> <DEDENT> else : return False <NEWLINE> <NL> <NL> <DEDENT> for i in range ( len ( input ) ) : <NEWLINE> <INDENT> for j in range ( 10 ) : <NEWLINE> <INDENT> if a_can_add ( input [ i ] [ j ] ) : <NEWLINE> <INDENT> a_add ( input [ i ] [ j ] ) <NEWLINE> <DEDENT> elif b_can_add ( input [ i ] [ j ] ) : <NEWLINE> <INDENT> b_add ( input [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( A ) + len ( B ) == 10 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def d ( a ) : <NEWLINE> <INDENT> b , c = 0 , 0 <NEWLINE> for ball in x : <NEWLINE> <INDENT> if b < a : <NEWLINE> <INDENT> b = a <NEWLINE> <DEDENT> elif c < a : <NEWLINE> <INDENT> c = a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> all = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> if d ( all ) else <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr = map ( int , input ( ) . split ( ) ) <NEWLINE> b , c = 0 , 0 <NEWLINE> flag = True <NEWLINE> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> if b < arr [ i ] : <NEWLINE> <INDENT> b = arr [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> if c < arr [ i ] : <NEWLINE> <INDENT> c = arr [ i ] <NEWLINE> continue <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def check ( x ) : <NEWLINE> <INDENT> a , b = 0 , 0 <NEWLINE> for ball in x : <NEWLINE> <INDENT> if a > ball : <NEWLINE> <INDENT> a = ball <NEWLINE> <DEDENT> elif b > ball : <NEWLINE> <INDENT> b = ball <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> all = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> if check ( all ) else print <STRING> <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> b , c = 0 , 0 <NEWLINE> for j in map ( int , raw_input ( ) . split ( ) ) : <NEWLINE> <INDENT> if b [ - 1 ] < j : b = j <NEWLINE> elif c [ - 1 ] < j : c = j <NEWLINE> else : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
ans = 0 <NEWLINE> def solve ( n , left , right ) : <NEWLINE> <INDENT> if n == 10 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a [ n ] > left : <NEWLINE> <INDENT> ans = solve ( n + 1 , a [ n ] , right ) <NEWLINE> <DEDENT> if a [ n ] > right : <NEWLINE> <INDENT> ans = solve ( n + 1 , left , a [ n ] ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> if solve ( 0 , 0 , 0 ) else <STRING> ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a . append ( - 1 ) <NEWLINE> <DEDENT> while ( n != 0 ) : <NEWLINE> <INDENT> b = [ ] <NEWLINE> c = [ ] <NEWLINE> a [ 0 ] , a [ 1 ] , a [ 2 ] , a [ 3 ] , a [ 4 ] , a [ 5 ] , a [ 6 ] , a [ 7 ] , a [ 8 ] , a [ 9 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> b . append ( - 1 ) <NEWLINE> c . append ( - 1 ) <NEWLINE> <DEDENT> j = 1 <NEWLINE> k = 0 <NEWLINE> lenb = 0 <NEWLINE> lenc = 0 <NEWLINE> b [ 0 ] = a [ 0 ] <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if ( a [ i ] > b [ j - 1 ] ) : <NEWLINE> <INDENT> b [ j ] = a [ i ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( k == 0 ) : <NEWLINE> <INDENT> c [ 0 ] = a [ i ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> elif ( a [ i ] > c [ k - 1 ] ) : <NEWLINE> <INDENT> c [ k ] = a [ i ] <NEWLINE> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> if ( b [ i ] != - 1 ) : <NEWLINE> <INDENT> lenb += 1 <NEWLINE> <DEDENT> if ( c [ i ] != - 1 ) : <NEWLINE> <INDENT> lenc += 1 <NEWLINE> <DEDENT> <DEDENT> if ( len ( a ) == ( lenb + lenc ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> left = right = [ ] <NEWLINE> arr = map ( int , input ( ) . split ( ) ) <NEWLINE> for a in arr : <NEWLINE> <INDENT> if len ( left ) == 0 or left [ - 1 ] < a : <NEWLINE> <INDENT> left . append ( a ) <NEWLINE> <DEDENT> elif len ( right ) == 0 or right [ - 1 ] < a : <NEWLINE> <INDENT> right . append ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if len ( arr ) == len ( left ) + len ( right ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> num = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> b = [ ] <NEWLINE> c = [ ] <NEWLINE> flag = 0 <NEWLINE> b . append ( num [ 0 ] ) <NEWLINE> c . append ( int ( 0 ) ) <NEWLINE> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if b [ 0 ] < num [ i ] : <NEWLINE> <INDENT> b . append ( num [ i ] ) <NEWLINE> <DEDENT> elif c [ 0 ] < num [ i ] : <NEWLINE> <INDENT> c . append ( num [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def s ( a ) : <NEWLINE> <INDENT> for i in a : <NEWLINE> <INDENT> if i > b : <NEWLINE> <INDENT> b = i <NEWLINE> <DEDENT> elif i > c : <NEWLINE> <INDENT> c = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> for n in range ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> print <STRING> if s ( map ( int , raw_input ( ) . split ( ) ) ) else <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . aplit ( ) ) ) <NEWLINE> b , c = 0 , 0 <NEWLINE> yes = True <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> if a [ j ] > b : b = a [ j ] <NEWLINE> elif a [ j ] > c : c = a [ j ] <NEWLINE> else : yes = False <NEWLINE> <DEDENT> print ( <STRING> if yes else <STRING> ) <NEWLINE> <DEDENT>
N = input ( ) + 1 <NEWLINE> for val in range ( 1 , N ) : <NEWLINE> <INDENT> branches = [ [ 0 ] for x in range ( 0 , 10 ) ] <NEWLINE> x = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> branches [ 0 ] . append ( x [ 0 ] ) <NEWLINE> branch_num = 1 <NEWLINE> for l in range ( 2 , 10 ) : <NEWLINE> <INDENT> small_num = 0 <NEWLINE> for n in range ( 0 , l ) : <NEWLINE> <INDENT> if branches [ n ] [ 0 ] < x [ ] <NEWLINE> <INDENT> small_num += 1 <NEWLINE> <DEDENT> <DEDENT> if small_num == 0 : <NEWLINE> <INDENT> branches [ l ] . insert [ 0 , x [ l ] ] <NEWLINE> <DEDENT> <DEDENT> branch_num = 0 <NEWLINE> for val in range ( 0 , 10 ) : <NEWLINE> <INDENT> if branches [ val ] [ 0 ] == 0 : <NEWLINE> <INDENT> branch_num += 1 <NEWLINE> <DEDENT> <DEDENT> if blanch_num <= 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> import itertools <NEWLINE> input ( ) <NEWLINE> lis = list ( itertools . product ( [ False , True ] , repeat = 10 ) ) <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> d = map ( int , s . split ( ) ) <NEWLINE> flag = False <NEWLINE> for e in lis : <NEWLINE> <INDENT> l = [ d [ i ] if e [ i ] else - d [ i ] for i in xrange ( 10 ) ] <NEWLINE> m = [ [ e for e in l if e > 0 ] , [ - e for e in l if e < 0 ] ] <NEWLINE> n = 0 <NEWLINE> for e in m : <NEWLINE> <INDENT> n += sum ( [ 1 if e [ i ] > e [ i + 1 ] else 0 for i in range ( len ( e ) - 1 ) ] ) <NEWLINE> <DEDENT> if not n : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if n : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def stackBall ( stackB , stackC , ball ) : <NEWLINE> <INDENT> if len ( ball ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if len ( stackB ) == 0 or stackB [ - 1 ] < ball [ 0 ] : <NEWLINE> <INDENT> stackB . append ( ball . pop ( 0 ) ) <NEWLINE> if stackBall ( stackB , stackC , ball ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> if len ( stackC ) == 0 or stackC [ - 1 ] < ball [ 0 ] : <NEWLINE> <INDENT> stackC . append ( ball . pop ( 0 ) ) <NEWLINE> if stackBall ( stackB , stackC , ball ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> ball = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if stackBall ( [ ] , [ ] , ball ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
x = int ( input ( ) ) <NEWLINE> for _ in range ( x ) : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b , c = 0 , 0 <NEWLINE> flag = True <NEWLINE> for d in num : <NEWLINE> <INDENT> if b < d : <NEWLINE> <INDENT> b = i <NEWLINE> <DEDENT> elif c < i : <NEWLINE> <INDENT> c = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> t = raw_input ( ) . split ( <STRING> ) <NEWLINE> l = [ int ( x ) for x in t [ : 10 ] ] <NEWLINE> v = [ int ( x ) for x in t [ 10 : ] ] <NEWLINE> time = float ( sum ( l ) ) / float ( sum ( v ) ) <NEWLINE> dis = time * float ( v [ 0 ] ) <NEWLINE> <NL> s = 0 <NEWLINE> for ( i , x ) in enumerate ( l ) : <NEWLINE> <INDENT> s += x <NEWLINE> if s >= int ( dis ) : <NEWLINE> <INDENT> print i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> print <NEWLINE> d = map ( float , s . split ( <STRING> ) ) <NEWLINE> dl , v1 , v2 = d [ : - 2 ] , d [ - 2 ] , d [ - 1 ] <NEWLINE> L = sum ( dl ) <NEWLINE> x = L / ( 1 + v2 / v1 ) <NEWLINE> m = 0 <NEWLINE> for i in range ( len ( dl ) ) : <NEWLINE> <INDENT> m += dl [ i ] <NEWLINE> if m >= x : print i + 1 ; break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum_l = sum ( l [ : 10 ] ) <NEWLINE> M = sum_l * l [ 10 ] / ( l [ 10 ] + l [ 11 ] ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> if M <= 0 : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> M -= l [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = 0 <NEWLINE> rail = [ ] <NEWLINE> for x in line [ 0 : 10 ] : <NEWLINE> <INDENT> sum += x <NEWLINE> rail . append ( sum ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> cross = sum * ( line [ 10 ] * 1.0 / ( line [ 10 ] + line [ 11 ] ) ) <NEWLINE> for i , length in enumerate ( rail ) : <NEWLINE> <INDENT> if cross <= length : <NEWLINE> <INDENT> print i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Vector2 : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <DEDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return Vector2 ( self . x + other . x , self . y + other . y ) <NEWLINE> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> return Vector2 ( self . x - other . x , self . y - other . y ) <NEWLINE> <DEDENT> def __mul__ ( self , other ) : <NEWLINE> <INDENT> if isinstance ( other , Vector2 ) : <NEWLINE> <INDENT> return self . x * other . x + self . y * other . y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return Vector2 ( self . x * other , self . y * other ) <NEWLINE> <DEDENT> <DEDENT> def __rmul__ ( self , other ) : <NEWLINE> <INDENT> if not isinstance ( other , Vector2 ) : <NEWLINE> <INDENT> return Vector2 ( self . x * other , self . y * other ) <NEWLINE> <DEDENT> <DEDENT> def abs ( self ) : <NEWLINE> <INDENT> return ( self . x ** 2 + self . y ** 2 ) ** 0.5 <NEWLINE> <DEDENT> def cos ( self , other ) : <NEWLINE> <INDENT> return ( self * other ) / ( self . abs ( ) * other . abs ( ) ) <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . x , self . y ) <NEWLINE> <DEDENT> def __neg__ ( self ) : <NEWLINE> <INDENT> return Vector2 ( - self . x , - self . y ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> _in = input ( ) <NEWLINE> while _in != <STRING> : <NEWLINE> <INDENT> cors = [ float ( cor ) for cor in _in . split ( <STRING> ) ] <NEWLINE> vAB = Vector2 ( cors [ 2 ] - cors [ 0 ] , cors [ 3 ] - cors [ 1 ] ) <NEWLINE> vBC = Vector2 ( cors [ 4 ] - cors [ 2 ] , cors [ 5 ] - cors [ 3 ] ) <NEWLINE> vCD = Vector2 ( cors [ 6 ] - cors [ 4 ] , cors [ 7 ] - cors [ 5 ] ) <NEWLINE> vDA = Vector2 ( cors [ 0 ] - cors [ 6 ] , cors [ 1 ] - cors [ 7 ] ) <NEWLINE> cnv_a = True if ( vAB - vDA ) * ( vAB + vBC ) > 0 else False <NEWLINE> cnv_b = True if ( vBC - vAB ) * ( vBC + vCD ) > 0 else False <NEWLINE> cnv_c = True if ( vCD - vBC ) * ( vCD + vDA ) > 0 else False <NEWLINE> cnv_d = True if ( vDA - vCD ) * ( vDA + vAB ) > 0 else False <NEWLINE> print ( <STRING> if cnv_a and cnv_b and cnv_c and cnv_d else <STRING> ) <NEWLINE> _in = input ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def sign ( x ) : <NEWLINE> <INDENT> if x > 0 : s = 1 <NEWLINE> elif x < 0 : s = - 1 <NEWLINE> else s = 0 <NEWLINE> return s <NEWLINE> <NL> <DEDENT> def f ( p1 , p2 , p3 ) : <NEWLINE> <INDENT> x1 , y1 = p1 <NEWLINE> s = sign ( ( p3 [ 1 ] - y1 ) * ( p2 [ 0 ] - x1 ) - ( p2 [ 1 ] - y1 ) * ( p3 [ 0 ] - x1 ) ) <NEWLINE> return s <NEWLINE> <NL> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> D = map ( float , s . split ( <STRING> ) ) <NEWLINE> p1 = D [ 0 : 2 ] ; p2 = D [ 2 : 4 ] ; p3 = D [ 4 : 6 ] ; p4 = D [ 6 : 8 ] <NEWLINE> print [ <STRING> , <STRING> ] [ f ( p1 , p3 , p2 ) != f ( p1 , p3 , p4 ) and f ( p2 , p4 , p1 ) != f ( p2 , p4 , p3 ) ] <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <NL> def hantei ( xa , ya , xb , yb , xc , yc , xd , yd ) : <NEWLINE> <INDENT> count = [ 0 , 0 , 0 , 0 ] <NEWLINE> a1 = ( ya - yc ) / ( xa - yc ) <NEWLINE> b1 = ya - a1 * xa <NEWLINE> <NL> a2 = ( yb - yd ) / ( xb - xd ) <NEWLINE> b2 = yb - a2 * xb <NEWLINE> <NL> if xb * a1 + b1 > yb : <NEWLINE> <INDENT> count [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ 1 ] += 1 <NEWLINE> <DEDENT> if xd * a1 + b1 > yd : <NEWLINE> <INDENT> count [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ 1 ] += 1 <NEWLINE> <DEDENT> if xa * a2 + b2 > ya : <NEWLINE> <INDENT> count [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ 3 ] += 1 <NEWLINE> <DEDENT> if xc * a2 + b2 > yc : <NEWLINE> <INDENT> count [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count [ 3 ] += 1 <NEWLINE> <NL> <DEDENT> for i in xrange ( 4 ) : <NEWLINE> <INDENT> if count [ i ] != 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> for i in sys . stdin : <NEWLINE> <INDENT> xa , ya , xb , yb , xc , yc , xd , yd = map ( float , i . split ( <STRING> ) ) <NEWLINE> print hantei ( xa , ya , xb , yb , xc , yc , xd , yd ) <NEWLINE> <DEDENT>
def cross ( p0 , p1 , p2 ) : <NEWLINE> <INDENT> dx1 , dx2 = p1 [ 0 ] - p0 [ 0 ] , p2 [ 0 ] - p0 [ 0 ] <NEWLINE> dy1 , dy2 = p1 [ 1 ] - p0 [ 1 ] , p2 [ 1 ] - p0 [ 1 ] <NEWLINE> return dy2 * dx1 - dy1 * dx2 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> l = [ float ( r ) for r in line . split ( <STRING> ) ] <NEWLINE> a , b , c , d = l [ 0 : 2 ] , l [ 2 : 4 ] , l [ 4 : 6 ] , l [ 6 : 8 ] <NEWLINE> print <STRING> if ( cross ( a , c , b ) * cross ( a , c , d ) ) < 0 and ( cross ( b , d , a ) * cross ( b , d , c ) < 0 ) else <STRING> <NEWLINE> <DEDENT>
from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> from collections import namedtuple <NEWLINE> Point = namedtuple ( <STRING> , <STRING> ) <NEWLINE> <NL> def make_test ( p1 , p2 ) : <NEWLINE> <INDENT> gradient = ( p1 . y - p2 . y ) / ( p1 . x - p2 . x ) <NEWLINE> y_intercept = p1 . y - gradient * p1 . x <NEWLINE> return lambda p : gradient * p . x + y_intercept > p . y <NEWLINE> <NL> <DEDENT> for line in stdin : <NEWLINE> <INDENT> it = ( float ( s ) for s in line . split ( <STRING> ) ) <NEWLINE> A , B , C , D = ( Point ( next ( it ) , next ( it ) ) for _ in xrange ( 4 ) ) <NEWLINE> <NL> f = make_test ( A , C ) <NEWLINE> g = make_test ( B , D ) <NEWLINE> if f ( B ) == f ( D ) or g ( A ) == g ( C ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for line in sys . stdin ( ) : <NEWLINE> <INDENT> p = list ( map ( float , line . split ( <STRING> ) ) ) <NEWLINE> v = [ p [ i ] - p [ ( i + 2 ) % 8 ] for i in range ( 8 ) ] <NEWLINE> ip = [ v [ j ] * v [ ( j + 3 ) % 8 ] - v [ j + 1 ] * v [ ( j + 2 ) % 8 ] > 0 for j in range ( 0 , 8 , 2 ) ] <NEWLINE> if sum ( ip ) == 0 or sum ( ip ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> Map = [ ] <NEWLINE> Base = [ ] <NEWLINE> End = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> Map . append ( list ( map ( str , input ( ) ) ) ) <NEWLINE> <DEDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> if Base == [ ] : <NEWLINE> <NL> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if Map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> Base = [ j , i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 7 , - 1 , - 1 ) : <NEWLINE> <INDENT> if End == [ ] : <NEWLINE> <INDENT> for j in range ( 7 , - 1 , - 1 ) : <NEWLINE> <INDENT> if Map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> End = [ j , i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> Yoko = End [ 0 ] - Base [ 0 ] <NEWLINE> Tate = End [ 1 ] - Base [ 1 ] <NEWLINE> if Tate == 1 and Yoko == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Yoko == 0 and Tate == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Tate == 0 and Yoko == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Yoko == - 1 and Tate == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Yoko == 2 and Tate == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Yoko == 1 and Tate == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif Tate == 1 and Yoko == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def f ( D ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> s = 0 <NEWLINE> D = D [ D . index ( <STRING> ) : ] <NEWLINE> for c in D : <NEWLINE> <INDENT> if c == <STRING> : s += i <NEWLINE> i += 1 <NEWLINE> <DEDENT> p = <STRING> [ ptn . index ( s ) ] <NEWLINE> return p <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> D = <STRING> <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> if i < 8 : <NEWLINE> <INDENT> i += 1 <NEWLINE> D += s [ : - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print f ( D ) <NEWLINE> i = 0 <NEWLINE> D = <STRING> <NEWLINE> <DEDENT> <DEDENT> print f ( D ) <NEWLINE>
<COMMENT> <NL> figures = { <NEWLINE> <INDENT> <STRING> : [ [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] ] , <NEWLINE> <STRING> : [ [ <STRING> ] , [ <STRING> ] , [ <STRING> ] , [ <STRING> ] ] , <NEWLINE> <STRING> : [ [ <STRING> , <STRING> , <STRING> , <STRING> ] ] , <NEWLINE> <STRING> : [ [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] ] , <NEWLINE> <STRING> : [ [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] ] , <NEWLINE> <STRING> : [ [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] , [ <STRING> , <STRING> ] ] , <NEWLINE> <STRING> : [ [ <STRING> , <STRING> , <STRING> ] , [ <STRING> , <STRING> , <STRING> ] ] , <NEWLINE> <DEDENT> } <NEWLINE> <NL> <NL> def f1 ( lines ) : <NEWLINE> <INDENT> for n , figure in figures . items ( ) : <NEWLINE> <INDENT> found = f2 ( lines , figure ) <NEWLINE> if found : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def f2 ( lines , figure ) : <NEWLINE> <INDENT> height = len ( figure ) <NEWLINE> width = len ( figure [ 0 ] ) <NEWLINE> for h in range ( 8 - height + 1 ) : <NEWLINE> <INDENT> for w in range ( 8 - width + 1 ) : <NEWLINE> <INDENT> found = f3 ( lines , figure , height , width , h , w ) <NEWLINE> if found : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def f3 ( lines , figure , height , width , h , w ) : <NEWLINE> <INDENT> _figure = [ [ lines [ h + _h ] [ w + _w ] for _w in range ( width ) ] <NEWLINE> <INDENT> for _h in range ( height ) ] <NEWLINE> <DEDENT> if figure == _figure : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> f1 ( [ list ( input ( ) ) for _ in range ( 8 ) ] ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> code = [ raw_input ( ) for _ in range ( 8 ) ] <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> code = <STRING> . join ( code ) <NEWLINE> <NL> str ( code ) <NEWLINE> check = 0 <NEWLINE> for var in range ( 0 , len ( code ) ) : <NEWLINE> <INDENT> if int ( code [ var : var + 1 ] ) == 1 : <NEWLINE> <INDENT> check = var <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if int ( code [ check + 1 : check + 2 ] ) == 1 and int ( code [ check + 8 : check + 9 ] ) == 1 : <NEWLINE> <INDENT> if int ( code [ check + 9 : check + 10 ] ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if int ( code [ check + 7 : check + 8 ] ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> elif int ( code [ check + 1 : check + 2 ] ) == 1 : <NEWLINE> <INDENT> if int ( code [ check + 2 : check + 3 ] ) == 1 and int ( code [ check + 3 : check + 4 ] ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if int ( code [ check + 9 : check + 10 ] ) == 1 and int ( code [ check + 10 : check + 11 ] ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> elif int ( code [ check + 8 : check + 9 ] ) == 1 : <NEWLINE> <INDENT> if int ( code [ check + 16 : check + 17 ] ) == 1 and int ( code [ check + 24 : check + 25 ] ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if int ( code [ check + 7 : check + 8 ] ) == 1 and int ( code [ check + 15 : check + 16 ] ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if int ( code [ check + 9 : check + 10 ] ) == 1 and int ( code [ check + 17 : check + 18 ] ) == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> types = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> data = [ ] <NEWLINE> for i in xrange ( 8 ) : <NEWLINE> <INDENT> data . append ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> check_figure ( data ) <NEWLINE> <NL> <COMMENT> <NL> raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def check_figure ( data ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in xrange ( 8 ) : <NEWLINE> <INDENT> for j in xrange ( 8 ) : <NEWLINE> <INDENT> if data [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> for t in types : <NEWLINE> <INDENT> if check_pattern ( data , pattern ( t , i , j ) ) : <NEWLINE> <INDENT> print t <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def pattern ( p , i , j ) : <NEWLINE> <INDENT> if p == <STRING> : <NEWLINE> <INDENT> return [ ( i , j ) , ( i , j + 1 ) , ( i + 1 , j ) , ( i + 1 , j + 1 ) ] <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> return [ ( i , j ) , ( i + 1 , j ) , ( i + 2 , j ) , ( i + 3 , j ) ] <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> return [ ( i , j ) , ( i , j + 1 ) , ( i , j + 2 ) , ( i , j + 3 ) ] <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> return [ ( i , j ) , ( i + 1 , j - 1 ) , ( i + 1 , j ) , ( i + 2 , j - 1 ) ] <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> return [ ( i , j ) , ( i , j + 1 ) , ( i + 1 , j + 1 ) , ( i + 1 , j + 2 ) ] <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> return [ ( i , j ) , ( i + 1 , j ) , ( i + 1 , j + 1 ) , ( i + 2 , j + 1 ) ] <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> return [ ( i , j ) , ( i , j + 1 ) , ( i + 1 , j - 1 ) , ( i + 1 , j ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def check_pattern ( data , block ) : <NEWLINE> <INDENT> for p in block : <NEWLINE> <INDENT> oob = is_out_of_bounds ( p [ 0 ] , p [ 1 ] ) <NEWLINE> empty = ( data [ p [ 0 ] ] [ p [ 1 ] ] == <STRING> ) <NEWLINE> <NL> if oob or empty : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def is_out_of_bounds ( x , y ) : <NEWLINE> <INDENT> if x < 0 or x >= 8 or y < 0 or y >= 8 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def university ( xxx , pattern ) : <NEWLINE> <INDENT> tate = 0 <NEWLINE> yoko = 1 <NEWLINE> for current_tate in range ( 8 - xxx [ tate ] + 1 ) : <NEWLINE> <INDENT> for current_yoko in range ( 8 - xxx [ yoko ] + 1 ) : <NEWLINE> <INDENT> if absolutely_fantastic ( current_tate , current_yoko ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def absolutely_fantastic ( current_tate , current_yoko ) : <NEWLINE> <INDENT> tate = 0 <NEWLINE> yoko = 1 <NEWLINE> run = [ ] <NEWLINE> for add_tate in range ( xxx [ tate ] ) : <NEWLINE> <INDENT> for add_yoko in range ( xxx [ yoko ] ) : <NEWLINE> <INDENT> run . append ( mapppp [ current_tate + add_tate ] [ current_yoko + add_yoko ] ) <NEWLINE> <DEDENT> <DEDENT> if run == pattern : <NEWLINE> <INDENT> print xxx [ 2 ] <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> A = { ( 2 , 2 , <STRING> ) : [ 1 , 1 , 1 , 1 ] } <NEWLINE> B = { ( 4 , 1 , <STRING> ) : [ 1 , 1 , 1 , 1 ] } <NEWLINE> C = { ( 1 , 4 , <STRING> ) : [ 1 , 1 , 1 , 1 ] } <NEWLINE> D = { ( 3 , 2 , <STRING> ) : [ 0 , 1 , 1 , 1 , 1 , 0 ] } <NEWLINE> E = { ( 2 , 3 , <STRING> ) : [ 1 , 1 , 0 , 0 , 1 , 1 ] } <NEWLINE> F = { ( 3 , 2 , <STRING> ) : [ 1 , 0 , 1 , 1 , 0 , 1 ] } <NEWLINE> G = { ( 2 , 3 , <STRING> ) : [ 0 , 1 , 1 , 1 , 1 , 0 ] } <NEWLINE> lis = [ A , B , C , D , E , F , G ] <NEWLINE> mapppp = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> input_line = raw_input ( ) <NEWLINE> yoko = [ int ( char ) for char in input_line ] <NEWLINE> mapppp . append ( yoko ) <NEWLINE> <DEDENT> for XXX in lis : <NEWLINE> <INDENT> flag = False <NEWLINE> for xxx , pattern in XXX . items ( ) : <NEWLINE> <INDENT> if university ( xxx , pattern ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> raw_input ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> sur = [ list ( map ( int , s . strip ( ) ) ) ] <NEWLINE> if 1 not in sur [ 0 ] : <NEWLINE> <INDENT> sur . pop ( ) <NEWLINE> <DEDENT> for _ in range ( 7 ) : <NEWLINE> <INDENT> sur . append ( list ( map ( int , input ( ) . strip ( ) ) ) ) <NEWLINE> if 1 not in sur [ - 1 ] : <NEWLINE> <INDENT> sur . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( sur ) == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( sur ) == 2 : <NEWLINE> <INDENT> if sur [ 0 ] . index ( 1 ) == sur [ 1 ] . index ( 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif sur [ 0 ] . index ( 1 ) < sur [ 1 ] . index ( 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( sur ) == 3 : <NEWLINE> <INDENT> if sur [ 0 ] . index ( 1 ) > sur [ 2 ] . index ( 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif len ( sur ) == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
ans = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def get ( x ) : <NEWLINE> <INDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> if i < 7 and j < 7 : <NEWLINE> <INDENT> if x [ i ] [ j ] == <STRING> and x [ i + 1 ] [ j ] == <STRING> and x [ i ] [ j + 1 ] == <STRING> and x [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> if i < 5 : <NEWLINE> <INDENT> if x [ i ] [ j ] == <STRING> and x [ i + 1 ] [ j ] == <STRING> and x [ i + 2 ] [ j ] == <STRING> and x [ i + 3 ] [ j ] == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> if j < 5 : <NEWLINE> <INDENT> if x [ i ] [ j ] == <STRING> and x [ i ] [ j + 1 ] == <STRING> and x [ i ] [ j + 2 ] == <STRING> and x [ i ] [ j + 3 ] == <STRING> : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> <DEDENT> if i < 6 and 0 < j : <NEWLINE> <INDENT> if x [ i ] [ j ] == <STRING> and x [ i + 1 ] [ j ] == <STRING> and x [ i + 1 ] [ j - 1 ] == <STRING> and x [ i + 2 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> <DEDENT> if i < 7 and j < 6 : <NEWLINE> <INDENT> if x [ i ] [ j ] == <STRING> and x [ i ] [ j + 1 ] == <STRING> and x [ i + 1 ] [ j + 1 ] == <STRING> and x [ i + 1 ] [ j + 2 ] == <STRING> : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> <DEDENT> if i < 6 and j < 7 : <NEWLINE> <INDENT> if x [ i ] [ j ] == <STRING> and x [ i + 1 ] [ j ] == <STRING> and x [ i + 1 ] [ j + 1 ] == <STRING> and x [ i + 2 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> <DEDENT> if i < 7 and 0 < j < 7 : <NEWLINE> <INDENT> if x [ i ] [ j ] == <STRING> and x [ i ] [ j + 1 ] == <STRING> and x [ i + 1 ] [ j ] == <STRING> and x [ i + 1 ] [ j - 1 ] == <STRING> : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> l . append ( raw_input ( ) ) <NEWLINE> <DEDENT> print ans [ get ( l ) ] <NEWLINE> raw_input ( ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> PI = 3.1415926535898 <NEWLINE> pool = [ ] <NEWLINE> pool . append ( <STRING> ) <NEWLINE> pool . append ( <STRING> ) <NEWLINE> pool . append ( <STRING> ) <NEWLINE> pool . append ( <STRING> ) <NEWLINE> pool . append ( <STRING> ) <NEWLINE> pool . append ( <STRING> ) <NEWLINE> pool . append ( <STRING> ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> pat = <STRING> <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> pat += str ( raw_input ( ) ) <NEWLINE> <DEDENT> flag = False <NEWLINE> tp = <STRING> <NEWLINE> for x in pat : <NEWLINE> <INDENT> if x != <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> tp += x <NEWLINE> <DEDENT> <DEDENT> pat = reversed ( tp ) <NEWLINE> flag = False <NEWLINE> tp = <STRING> <NEWLINE> for x in pat : <NEWLINE> <INDENT> if x != <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> tp += x <NEWLINE> <DEDENT> <DEDENT> pat = tp <NEWLINE> print chr ( pool . index ( pat ) + ord ( <STRING> ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
shapes = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> <NEWLINE> <DEDENT> } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> plane = <STRING> <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> plane += input ( ) <NEWLINE> <NL> <DEDENT> for name in shapes : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> plane . index ( shapes [ name ] ) <NEWLINE> print ( name ) <NEWLINE> break <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
def trim ( ) : <NEWLINE> <INDENT> num = [ ] <NEWLINE> N = [ input ( ) for _ in range ( 8 ) ] <NEWLINE> for x in range ( 8 ) : <NEWLINE> <INDENT> for y in range ( 8 ) : <NEWLINE> <INDENT> if N [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> if not num : <NEWLINE> <INDENT> refer = ( x , y ) <NEWLINE> <DEDENT> num . append ( ( x , y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> num = [ ( x - refer [ 0 ] , y - refer [ 1 ] ) for x , y in num ] <NEWLINE> return num <NEWLINE> <DEDENT> def point ( point ) : <NEWLINE> <INDENT> if point == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ] : print ( <STRING> ) <NEWLINE> if point == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 0 , 3 ) ] : print ( <STRING> ) <NEWLINE> if point == [ ( 1 , 0 ) , ( 2 , 0 ) , ( 3 , 0 ) , ( 4 , 0 ) ] : print ( <STRING> ) <NEWLINE> if point == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) ] : print ( <STRING> ) <NEWLINE> if point == [ ( 0 , 0 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 2 , 1 ) ] : print ( <STRING> ) <NEWLINE> if point == [ ( 0 , 0 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 2 ) ] : print ( <STRING> ) <NEWLINE> if point == [ ( 0 , 0 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 2 , - 1 ) ] : print ( <STRING> ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> point ( trim ) <NEWLINE> <DEDENT> except : break <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> h = 0 <NEWLINE> a = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> tmp = raw_input ( ) <NEWLINE> if int ( tmp ) != 0 : <NEWLINE> a [ h ] = tmp <NEWLINE> h += 1 <NEWLINE> if h == 1 : <NEWLINE> print <STRING> <NEWLINE> <DEDENT> elif h == 2 : <NEWLINE> <INDENT> c = a [ 0 ] . index ( <STRING> ) - a [ 1 ] . index ( <STRING> ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif c == - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> elif h == 3 : <NEWLINE> <INDENT> c = a [ 0 ] . index ( <STRING> ) - a [ 2 ] . index ( <STRING> ) <NEWLINE> print <STRING> if c == 1 else <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> raw_input ( ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> break <NEWLINE> <DEDENT>
import sys <NEWLINE> dic = { <STRING> : [ <STRING> , <STRING> ] , <STRING> : [ <STRING> , <STRING> , <STRING> , <STRING> ] , <STRING> : [ <STRING> ] , <STRING> : [ <STRING> , <STRING> , <STRING> ] , <NEWLINE> <INDENT> <STRING> : [ <STRING> , <STRING> ] , <STRING> : [ <STRING> , <STRING> , <STRING> ] , <STRING> : [ <STRING> , <STRING> ] } <NEWLINE> <DEDENT> s = [ ] <NEWLINE> linecnt = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line == <STRING> or line == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> linecnt += 1 <NEWLINE> if linecnt < 8 : <NEWLINE> <INDENT> s . append ( line . rstrip ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while s [ 0 ] == <STRING> : <NEWLINE> <INDENT> del ( s [ 0 ] ) <NEWLINE> <DEDENT> while s [ len ( s ) - 1 ] == <STRING> : <NEWLINE> <INDENT> del ( s [ len ( s ) - 1 ] ) <NEWLINE> <DEDENT> i = len ( s [ 0 ] ) - 1 <NEWLINE> while i >= 0 : <NEWLINE> <INDENT> for l in xrange ( len ( s ) ) : <NEWLINE> <INDENT> if s [ l ] [ i ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for l in xrange ( len ( s ) ) : <NEWLINE> <INDENT> s [ l ] = s [ l ] [ 0 : i ] + s [ l ] [ i + 1 : len ( s [ l ] ) ] <NEWLINE> <DEDENT> <DEDENT> i -= 1 <NEWLINE> <DEDENT> for d in dic . keys ( ) : <NEWLINE> <INDENT> if dic [ d ] == s : <NEWLINE> <INDENT> print d <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> while len ( s ) > 0 : <NEWLINE> <INDENT> del ( s [ 0 ] ) <NEWLINE> <DEDENT> linecnt = 0 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> string = [ input ( ) for _ in range ( 8 ) ] <NEWLINE> string = [ int ( l ) for line in string for l in line ] + [ 0 ] * 16 <NEWLINE> one = string . index ( 1 ) <NEWLINE> s = string [ one : ] <NEWLINE> ones = [ [ 1 , 8 , 9 ] , [ 8 , 16 , 24 ] , [ 1 , 2 , 3 ] , <NEWLINE> <INDENT> [ 7 , 8 , 15 ] , [ 1 , 9 , 10 ] , [ 8 , 9 , 17 ] , [ 1 , 7 , 8 ] ] <NEWLINE> ans = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> } <NEWLINE> <DEDENT> for k , o in enumerate ( ones ) : <NEWLINE> <INDENT> if all ( [ s [ o [ 0 ] ] , s [ o [ 1 ] ] , s [ o [ 2 ] ] ] ) : <NEWLINE> <INDENT> print ( ans [ k ] ) <NEWLINE> <DEDENT> <DEDENT> input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> road_h = [ [ 0 for i in range ( 6 ) ] for j in range ( 7 ) ] <COMMENT> <NEWLINE> road_v = [ [ 0 for i in range ( 7 ) ] for j in range ( 6 ) ] <COMMENT> <NEWLINE> ax = ay = 1 <NEWLINE> ad_list = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> for i in range ( 9 ) : <NEWLINE> <INDENT> line = str ( raw_input ( ) ) <NEWLINE> if i % 2 == 0 : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if line [ j ] == <STRING> : <NEWLINE> <INDENT> road_h [ 1 + i / 2 ] [ 1 + j ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> if line [ j ] == <STRING> : <NEWLINE> <INDENT> road_v [ 1 + i / 2 ] [ 1 + j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ad = 1 <NEWLINE> ax += 1 <NEWLINE> ans = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> if ax == 1 and ay == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ad == 0 : <COMMENT> <NEWLINE> <INDENT> if road_v [ ay ] [ ax ] : <NEWLINE> <INDENT> ay += 1 <NEWLINE> ad = 3 <NEWLINE> <DEDENT> elif road_h [ ay ] [ ax - 1 ] : <NEWLINE> <INDENT> ax -= 1 <NEWLINE> <DEDENT> elif road_v [ ay - 1 ] [ ax ] : <NEWLINE> <INDENT> ay -= 1 <NEWLINE> ad = 2 <NEWLINE> <DEDENT> <DEDENT> elif ad == 1 : <COMMENT> <NEWLINE> <INDENT> if road_v [ ay - 1 ] [ ax ] : <NEWLINE> <INDENT> ay -= 1 <NEWLINE> ad = 2 <NEWLINE> <DEDENT> elif road_h [ ay ] [ ax ] : <NEWLINE> <INDENT> ax += 1 <NEWLINE> <DEDENT> elif road_v [ ay ] [ ax ] : <NEWLINE> <INDENT> ay += 1 <NEWLINE> ad = 3 <NEWLINE> <DEDENT> <DEDENT> elif ad == 2 : <COMMENT> <NEWLINE> <INDENT> if road_h [ ay ] [ ax - 1 ] : <NEWLINE> <INDENT> ax -= 1 <NEWLINE> ad = 0 <NEWLINE> <DEDENT> elif road_v [ ay - 1 ] [ ax ] : <NEWLINE> <INDENT> ay -= 1 <NEWLINE> <DEDENT> elif road_h [ ay ] [ ax ] : <NEWLINE> <INDENT> ax += 1 <NEWLINE> ad = 1 <NEWLINE> <DEDENT> <DEDENT> elif ad == 3 : <COMMENT> <NEWLINE> <INDENT> if road_h [ ay ] [ ax ] : <NEWLINE> <INDENT> ax += 1 <NEWLINE> ad = 1 <NEWLINE> <DEDENT> elif road_v [ ay ] [ ax ] : <NEWLINE> <INDENT> ay += 1 <NEWLINE> <DEDENT> elif road_h [ ay ] [ ax - 1 ] : <NEWLINE> <INDENT> ax -= 1 <NEWLINE> ad = 0 <NEWLINE> <DEDENT> <DEDENT> ans = ans + ad_list [ ad ] <NEWLINE> <DEDENT> print ans <NEWLINE>
def xxx ( position , direction ) : <NEWLINE> <INDENT> if direction == <STRING> or direction == <STRING> : <NEWLINE> <INDENT> if not ( 0 <= position [ tate ] <= 8 and 0 <= position [ yoko ] <= 3 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> elif direction == <STRING> or direction == <STRING> : <NEWLINE> <INDENT> if not ( 1 <= position [ tate ] <= 7 and 0 <= position [ yoko ] <= 4 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> if ( position [ tate ] == 0 and position [ yoko ] == 0 ) and direction == <STRING> or ( position [ tate ] == 1 and position [ yoko ] == 0 ) and direction == <STRING> : <NEWLINE> <INDENT> result . append ( direction ) <NEWLINE> print <STRING> . join ( result ) <NEWLINE> return True <NEWLINE> <DEDENT> if mapp [ position [ tate ] ] [ position [ yoko ] ] == 1 : <NEWLINE> <INDENT> result . append ( direction ) <NEWLINE> if kyoto ( position , direction ) : return True <NEWLINE> <DEDENT> elif mapp [ position [ tate ] ] [ position [ yoko ] ] == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> def kyoto ( position , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> check_position = position [ tate ] - 1 , position [ yoko ] + 1 <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] , position [ yoko ] + 1 <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] + 1 , position [ yoko ] + 1 <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> check_position = position [ tate ] - 1 , position [ yoko ] - 1 <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] - 2 , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] - 1 , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> check_position = position [ tate ] + 1 , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] , position [ yoko ] - 1 <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] - 1 , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> check_position = position [ tate ] + 1 , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] + 2 , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] + 1 , position [ yoko ] - 1 <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <COMMENT> <NL> check_position = position [ tate ] , position [ yoko ] <NEWLINE> direction = <STRING> <NEWLINE> if xxx ( check_position , direction ) : return True <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> mapp = [ ] <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> mapp . append ( [ int ( char ) for char in raw_input ( ) ] ) <NEWLINE> <DEDENT> tate = 0 <NEWLINE> yoko = 1 <NEWLINE> result = [ ] <NEWLINE> xxx ( ( 0 , 0 ) , <STRING> ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> class Grid : <NEWLINE> <INDENT> def __init__ ( self , lines ) : <NEWLINE> <INDENT> lines = map ( ( lambda line : list ( line ) ) , lines ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( len ( lines ) ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> l . append ( intersperse2 ( lines [ i ] , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . append ( intersperse ( lines [ i ] , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> l . insert ( 0 , [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> l . append ( [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> l = map ( lambda x : self . _outer ( x ) , l ) <NEWLINE> self . grid = l <NEWLINE> <NL> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> for l in self . grid : <NEWLINE> <INDENT> print l <NEWLINE> <DEDENT> return self <NEWLINE> <NL> <DEDENT> def _outer ( self , lis ) : <NEWLINE> <INDENT> if lis [ 0 ] == <STRING> or lis [ 0 ] == <STRING> : <NEWLINE> <INDENT> lis . insert ( 0 , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . insert ( 0 , <STRING> ) <NEWLINE> <DEDENT> if lis [ - 1 ] == <STRING> or lis [ - 1 ] == <STRING> : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( <STRING> ) <NEWLINE> <DEDENT> return lis <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Walker : <NEWLINE> <INDENT> def __init__ ( self , grid , x , y ) : <NEWLINE> <INDENT> self . grid = grid <NEWLINE> self . x = x <NEWLINE> self . y = y <NEWLINE> self . dir = <STRING> <NEWLINE> <NL> <DEDENT> def walk ( self ) : <NEWLINE> <INDENT> if self . left ( ) == <STRING> : <NEWLINE> <INDENT> return self . to_left ( ) <NEWLINE> <DEDENT> elif self . ahead ( ) == <STRING> : <NEWLINE> <INDENT> return self . to_ahead ( ) <NEWLINE> <DEDENT> elif self . right ( ) == <STRING> : <NEWLINE> <INDENT> return self . to_right ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . to_back ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def left ( self ) : <NEWLINE> <INDENT> x = self . x <NEWLINE> y = self . y <NEWLINE> d = self . dir <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y - 1 ] [ x ] <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y + 1 ] [ x ] <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y ] [ x - 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return self . grid . grid [ y ] [ x + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def ahead ( self ) : <NEWLINE> <INDENT> x = self . x <NEWLINE> y = self . y <NEWLINE> d = self . dir <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y ] [ x + 1 ] <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y ] [ x - 1 ] <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y - 1 ] [ x ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return self . grid . grid [ y + 1 ] [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def right ( self ) : <NEWLINE> <INDENT> x = self . x <NEWLINE> y = self . y <NEWLINE> d = self . dir <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y + 1 ] [ x ] <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y - 1 ] [ x ] <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> return self . grid . grid [ y ] [ x + 1 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return self . grid . grid [ y ] [ x - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def to_left ( self ) : <NEWLINE> <INDENT> d = self . dir <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> self . y -= 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . y += 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . x -= 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> self . x += 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def to_ahead ( self ) : <NEWLINE> <INDENT> d = self . dir <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> self . x += 2 <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . x -= 2 <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . y -= 2 <NEWLINE> return <STRING> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> self . y += 2 <NEWLINE> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def to_right ( self ) : <NEWLINE> <INDENT> d = self . dir <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> self . y += 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . y -= 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . x += 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> self . x -= 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def to_backt ( self ) : <NEWLINE> <INDENT> d = self . dir <NEWLINE> if d == <STRING> : <NEWLINE> <INDENT> self . x -= 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . x += 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> self . y -= 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> self . y += 2 <NEWLINE> self . dir = <STRING> <NEWLINE> return <STRING> <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def intersperse ( lis , s ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for a in lis : <NEWLINE> <INDENT> r . append ( a ) <NEWLINE> r . append ( s ) <NEWLINE> <DEDENT> r . pop ( ) <NEWLINE> return r <NEWLINE> <NL> <DEDENT> def intersperse2 ( lis , s ) : <NEWLINE> <INDENT> r = [ ] <NEWLINE> for a in lis : <NEWLINE> <INDENT> r . append ( s ) <NEWLINE> r . append ( a ) <NEWLINE> <DEDENT> r . append ( s ) <NEWLINE> return r <NEWLINE> <NL> <NL> <NL> <DEDENT> lines = sys . stdin . readlines ( ) <NEWLINE> lines = map ( lambda x : x . rstrip ( <STRING> ) , lines ) <NEWLINE> grid = Grid ( lines ) <NEWLINE> <COMMENT> <NL> walker = Walker ( grid , 1 , 1 ) <NEWLINE> path = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> path . append ( walker . walk ( ) ) <NEWLINE> if ( walker . x , walker . y ) == ( 1 , 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( path ) <NEWLINE>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> e = sorted ( map ( int , e . split ( <STRING> ) ) ) <NEWLINE> print ( [ [ <STRING> , <STRING> ] [ e [ 4 ] - e [ 0 ] == 4 or e [ 0 ] * 10 == e [ 1 ] ] , <STRING> , <STRING> , <STRING> , <STRING> , 0 , <STRING> ] [ ( sum ( e . count ( s ) for s in e ) // 2 - 2 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def is_onepair ( x ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if x . count ( x [ i ] ) == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def is_twopair ( x ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for e in x : <NEWLINE> <INDENT> for e2 in x : <NEWLINE> <INDENT> if e == e2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def is_threecard ( x ) : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if x . count ( x [ i ] ) == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def is_straight ( x ) : <NEWLINE> <INDENT> x . sort ( ) <NEWLINE> if x [ 0 ] == 1 and x [ 1 : ] = [ 10 , 11 , 12 , 13 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if x [ i ] + 1 != x [ i + 1 ] : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_fullhouse ( x ) : <NEWLINE> <INDENT> if is_threecard ( x ) and is_onepair ( x ) : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def is_fourcard ( x ) : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> if x . count ( x [ i ] ) == 4 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> hand = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> if is_fourcard ( hand ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_fullhouse ( hand ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_straight ( hand ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_threecard ( hand ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_twopair ( hand ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif is_onepair ( hand ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> hand = sorted ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> kind = len ( set ( hand ) ) <NEWLINE> ma = max ( [ hand . count ( i ) for i in hand ] ) <NEWLINE> if kind == 4 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif kind == 3 : <NEWLINE> <INDENT> if ma == 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> elif kind == 2 : <NEWLINE> <INDENT> if ma == 4 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if hand == [ 1 , 10 , 11 , 12 , 13 ] or hand [ 4 ] - hand [ 0 ] == 4 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def brain ( l ) : <NEWLINE> <INDENT> c = l [ 1 ] - l [ 0 ] <NEWLINE> if 0 < c : <NEWLINE> <INDENT> result . append ( c ) <NEWLINE> del lis [ 0 ] <NEWLINE> del lis [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( l [ 0 ] ) <NEWLINE> del lis [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def cisco ( l ) : <NEWLINE> <INDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> if l [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = 1 <NEWLINE> <DEDENT> elif l [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = 5 <NEWLINE> <DEDENT> elif l [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = 10 <NEWLINE> <DEDENT> elif l [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = 50 <NEWLINE> <DEDENT> elif l [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = 100 <NEWLINE> <DEDENT> elif l [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = 500 <NEWLINE> <DEDENT> elif l [ i ] == <STRING> : <NEWLINE> <INDENT> l [ i ] = 1000 <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> result = [ ] <NEWLINE> try : <NEWLINE> <INDENT> lis = list ( raw_input ( ) ) + [ <STRING> ] <NEWLINE> while lis : <NEWLINE> <INDENT> if not ( lis [ 0 ] == <STRING> or lis [ 1 ] == <STRING> ) : <NEWLINE> <INDENT> l = cisco ( [ lis [ 0 ] , lis [ 1 ] ] ) <NEWLINE> brain ( l ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( lis [ 0 ] ) <NEWLINE> del lis [ 0 ] <NEWLINE> del lis [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> result . append ( sum ( cisco ( lis ) ) ) <NEWLINE> print sum ( result ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
nums = { <STRING> : 1 , <STRING> : 5 , <STRING> : 10 , <STRING> : 50 , <STRING> : 100 , <STRING> : 500 , <STRING> : 1000 } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = nums [ s [ 0 ] ] <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> if num [ s [ i - 1 ] ] < num [ s [ i ] ] : <NEWLINE> <INDENT> ans += num [ s [ i ] ] - 2 * num [ s [ i - 1 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += num [ s [ i ] ] <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> C = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> N = [ 1000 , 900 , 500 , 400 , 100 , 90 , 50 , 40 , 10 , 9 , 5 , 4 , 1 ] <NEWLINE> <NL> def checkio ( data , i = 0 ) : <NEWLINE> <INDENT> return C [ i ] * ( data // N [ i ] ) + checkio ( data % N [ i ] , i + 1 ) if data else <STRING> <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> print ( checkio ( n ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def inp ( ) : <NEWLINE> <INDENT> for line in sys . stdin : <NEWLINE> <INDENT> word = line . split ( ) <NEWLINE> je ( word [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def je ( word ) : <NEWLINE> <INDENT> ans , i = 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> if word [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1000 <NEWLINE> <DEDENT> elif word [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 500 <NEWLINE> <DEDENT> elif word [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 100 <NEWLINE> try : <NEWLINE> <INDENT> if word [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 300 <NEWLINE> i += 1 <NEWLINE> <DEDENT> elif word [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 800 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> except : pass <NEWLINE> <DEDENT> elif word [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 50 <NEWLINE> try : <NEWLINE> <INDENT> if word [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> ans -= 10 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> except : pass <NEWLINE> <DEDENT> elif word [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 10 <NEWLINE> try : <NEWLINE> <INDENT> if word [ i + 1 ] == <STRING> and word [ i + 2 ] == <STRING> : <NEWLINE> <INDENT> ans += 9 <NEWLINE> i += 2 <NEWLINE> <DEDENT> elif word [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 80 <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> except : pass <NEWLINE> <DEDENT> elif word [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 5 <NEWLINE> <DEDENT> elif word [ i ] == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> try : <NEWLINE> <INDENT> if word [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 4 <NEWLINE> i += 1 <NEWLINE> <DEDENT> if word [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> ans += 8 <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> except : pass <NEWLINE> <DEDENT> i += 1 <NEWLINE> if i == len ( word ) : <NEWLINE> <INDENT> print ans <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> inp ( ) <NEWLINE> <DEDENT>
dict = { <STRING> : 1 , <STRING> : 5 , <STRING> : 10 , <STRING> : 50 , <STRING> : 100 , <STRING> : 500 , <STRING> : 1000 } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> roman = raw_input ( ) <NEWLINE> sum = 0 <NEWLINE> value = 1000 <NEWLINE> for i in range ( len ( roman ) ) : <NEWLINE> <INDENT> if value >= dict [ roman [ i ] ] : <NEWLINE> <INDENT> value = dict [ roman [ i ] ] <NEWLINE> sum += value <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> sum -= 2 * value <NEWLINE> value = dict [ roman [ i ] ] <NEWLINE> sum += value <NEWLINE> <DEDENT> <DEDENT> print sum <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def dec_num ( x ) : <NEWLINE> <INDENT> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ i ] == 2 : <NEWLINE> <INDENT> x [ i ] = 5 <NEWLINE> <DEDENT> elif x [ i ] == 3 : <NEWLINE> <INDENT> x [ i ] = 10 <NEWLINE> <DEDENT> elif x [ i ] == 4 : <NEWLINE> <INDENT> x [ i ] = 50 <NEWLINE> <DEDENT> elif x [ i ] == 5 : <NEWLINE> <INDENT> x [ i ] = 100 <NEWLINE> <DEDENT> elif x [ i ] == 6 : <NEWLINE> <INDENT> x [ i ] = 500 <NEWLINE> <DEDENT> elif x [ i ] == 7 : <NEWLINE> <INDENT> x [ i ] = 1000 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def to_index ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x == 5 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif x == 10 : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> elif x == 50 : <NEWLINE> <INDENT> return 4 <NEWLINE> <DEDENT> elif x == 100 : <NEWLINE> <INDENT> return 5 <NEWLINE> <DEDENT> elif x == 500 : <NEWLINE> <INDENT> return 6 <NEWLINE> <DEDENT> elif x == 1000 : <NEWLINE> <INDENT> return 7 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def toNum ( x ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> tmp = x [ 0 ] <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if tmp < x [ i ] : <NEWLINE> <INDENT> result += x [ i ] - tmp <NEWLINE> <DEDENT> elif i <= len ( x ) and x [ i ] < x [ i + 1 ] : <NEWLINE> <INDENT> result += 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result += x [ i ] <NEWLINE> <DEDENT> tmp = x [ i ] <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <NL> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> line = line . translate ( str . maketrans ( <STRING> , <STRING> ) ) <NEWLINE> num = list ( map ( int , ( <STRING> . join ( line ) ) . split ( ) ) ) <NEWLINE> dec_num ( num ) <NEWLINE> print ( toNum ( num ) ) <NEWLINE> <DEDENT>
A2Z = <STRING> <NEWLINE> <NL> def decode ( L1 , L2 , msg ) : <NEWLINE> <INDENT> x = [ ] <NEWLINE> for c in msg : <NEWLINE> <INDENT> if <STRING> <= c <= <STRING> : <NEWLINE> <INDENT> c = L2 [ L1 . index ( c ) ] <NEWLINE> <DEDENT> x . append ( c ) <NEWLINE> <DEDENT> return <STRING> . join ( x ) <NEWLINE> <NL> <DEDENT> def affine ( msg , key ) : <NEWLINE> <INDENT> a , b = key <NEWLINE> L = [ A2Z [ ( i * a + b ) % 26 ] for i in range ( 26 ) ] <NEWLINE> L = <STRING> . join ( L ) <NEWLINE> return decode ( A2Z , L , msg ) <NEWLINE> <NL> <DEDENT> def rot ( msg , a ) : <NEWLINE> <INDENT> if a == 0 : return msg <NEWLINE> a = a % 26 <NEWLINE> L = A2Z [ a : ] + A2Z [ : a ] <NEWLINE> return decode ( A2Z , L , msg ) <NEWLINE> <NL> <DEDENT> def find ( msg ) : <NEWLINE> <INDENT> c0 = ord ( <STRING> ) <NEWLINE> for i in range ( 3 , 26 , 2 ) : <NEWLINE> <INDENT> x = affine ( msg , [ i , 0 ] ) <NEWLINE> a = ( c0 - ord ( x [ 0 ] ) ) % 26 <NEWLINE> x = rot ( x , a ) <NEWLINE> if x in [ <STRING> , <STRING> ] : return [ i , a ] <NEWLINE> <DEDENT> return [ ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> msg = raw_input ( ) <NEWLINE> for w in msg . split ( ) : <NEWLINE> <INDENT> if len ( w ) == 4 : <NEWLINE> <INDENT> key = find ( w ) <NEWLINE> if key != [ ] : break <NEWLINE> <DEDENT> <DEDENT> print affine ( msg , key ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> from string import ascii_lowercase <NEWLINE> from itertools import count <NEWLINE> <NL> def gcd ( m , n ) : <NEWLINE> <INDENT> m , n = sorted ( [ m , n ] ) <NEWLINE> while n : <NEWLINE> <INDENT> m , n = n , m % n <NEWLINE> <DEDENT> return m <NEWLINE> <NL> <DEDENT> def encode ( char , A , B ) : <NEWLINE> <INDENT> return chr ( ( ( A * ( ord ( char ) - 97 ) + B ) % 26 ) + 97 ) <NEWLINE> <NL> <DEDENT> def solve ( words ) : <NEWLINE> <INDENT> for a in ( i for i in count ( 0 ) if gcd ( i , 26 ) == 1 ) : <NEWLINE> <INDENT> for b in range ( 26 ) : <NEWLINE> <INDENT> for word in words : <NEWLINE> <INDENT> that = <STRING> . join ( encode ( c , a , b ) for c in <STRING> ) <NEWLINE> if word == that : <NEWLINE> <INDENT> return ( a , b ) <NEWLINE> <DEDENT> this = <STRING> . join ( encode ( c , a , b ) for c in <STRING> ) <NEWLINE> if word == this : <NEWLINE> <INDENT> return ( a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for _ in range ( int ( stdin . readline ( ) ) ) : <NEWLINE> <INDENT> line = stdin . readline ( ) <NEWLINE> a , b = solve ( [ s for s in line . split ( ) if len ( s ) == 4 ] ) <NEWLINE> d = { encode ( c , a , b ) : c for c in ascii_lowercase } <NEWLINE> d [ <STRING> ] = <STRING> <NEWLINE> print ( <STRING> . join ( d [ c ] for c in line ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dict = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> lsalpha = [ 1 , 3 , 5 , 7 , 9 , 11 , 15 , 17 , 19 , 21 , 23 , 25 ] <NEWLINE> <NL> def deaffine ( alpha , beta , code ) : <NEWLINE> <INDENT> decode = <STRING> <NEWLINE> for chara in code : <NEWLINE> <INDENT> if chara != <STRING> : <NEWLINE> <INDENT> f = dict . index ( chara ) <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> if ( alpha * i + beta ) % 26 == f : <NEWLINE> <INDENT> dechara = dict [ i ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> decode += dechara <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> decode += <STRING> <NEWLINE> <DEDENT> <DEDENT> return decode <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for roop in range ( n ) : <NEWLINE> <INDENT> code = raw_input ( ) <NEWLINE> for alpha in lsalpha : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for beta in range ( 26 ) : <NEWLINE> <INDENT> deaffine ( alpha , beta , code ) <NEWLINE> if decode . count ( <STRING> ) > 0 or decode . count ( <STRING> ) > 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print decode <NEWLINE> <DEDENT>
from itertools import * <NEWLINE> def f ( s ) : <NEWLINE> <INDENT> for t in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> for a , b , c , d in permutations ( s ) : <NEWLINE> <INDENT> for x , y , z in product ( <STRING> , repeat = 3 ) : <NEWLINE> <INDENT> t = <STRING> + t + <STRING> <NEWLINE> if eval ( eval ( t ) ) == 10 : return <STRING> + eval ( t ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : return 0 <NEWLINE> <DEDENT> for e in iter ( input , <STRING> ) : print ( f ( list ( map ( int , e . split ( ) ) ) ) ) <NEWLINE>
from __future__ import division <NEWLINE> import itertools <NEWLINE> <NL> def exp ( a , b , c , d ) : <NEWLINE> <INDENT> L = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> opr = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i , j , k , l in itertools . permutations ( [ a , b , c , d ] ) : <NEWLINE> <INDENT> for o1 , o2 , o3 in itertools . permutations ( opr , 3 ) : <NEWLINE> <INDENT> for st in L : <NEWLINE> <INDENT> r = st % ( i , o1 , j , o2 , k , o3 , l ) <NEWLINE> try : <NEWLINE> <INDENT> t = eval ( r ) <NEWLINE> if t == 10 : <NEWLINE> <INDENT> return r <NEWLINE> <DEDENT> <DEDENT> except ZeroDivisionError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> a , b , c , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == b == c == d == 0 : break <NEWLINE> print exp ( a , b , c , d ) <NEWLINE> <DEDENT>
from itertools import * <NEWLINE> <NL> def find ( X ) : <NEWLINE> <INDENT> for a , b , c , d in permutations ( X ) : <NEWLINE> <INDENT> for x , y , z in product ( <STRING> , repeat = 3 ) : <NEWLINE> <INDENT> for f in ( <STRING> , <STRING> ) : <NEWLINE> <INDENT> t = f % ( a , x , b , y , c , z , d ) <NEWLINE> if eval ( t ) == 10 : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> X = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if X == ( 0 , 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print find ( X ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> def f ( a ) : <NEWLINE> <INDENT> if len ( a ) < 2 : yield ( a [ 0 ] , a [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> for p , s in f ( a [ : i ] ) : <NEWLINE> <INDENT> for q , t in f ( a [ i : ] ) : <NEWLINE> <INDENT> yield ( p + q , <STRING> ) <NEWLINE> yield ( p - q , <STRING> ) <NEWLINE> yield ( p * q , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def s ( a ) : <NEWLINE> <INDENT> for p in itertools . permutations ( a ) : <NEWLINE> <INDENT> for n , s in f ( p ) : <NEWLINE> <INDENT> if n == 10 : print ( s ) ; return 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if sum ( a ) and not s ( a ) : print ( 0 ) <NEWLINE> <DEDENT>
op = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> x = int ( raw_input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> a , b , c , d = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if a == <STRING> and c == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = [ 0 , 1 , 2 , 3 ] <NEWLINE> q = [ a , b , c , d ] <NEWLINE> flag = 0 <NEWLINE> m = [ 0 , 1 , 2 , 3 ] <NEWLINE> m . remove ( ii ) <NEWLINE> for ii in n : <NEWLINE> <INDENT> for jj in m : <NEWLINE> <INDENT> l = [ 0 , 1 , 2 , 3 ] <NEWLINE> l . remove ( ii ) ; l . remove ( jj ) <NEWLINE> for kk in l : <NEWLINE> <INDENT> o = [ 0 , 1 , 2 , 3 ] <NEWLINE> o . remove ( ii ) ; o . remove ( jj ) ; o . remove ( kk ) <NEWLINE> for ll in o : <NEWLINE> <INDENT> for i in op : <NEWLINE> <INDENT> for j in op : <NEWLINE> <INDENT> for k in op : <NEWLINE> <INDENT> if eval ( <STRING> + q [ ii ] + k + q [ jj ] + <STRING> + j + q [ kk ] + <STRING> + i + q [ ll ] + <STRING> ) == x : <NEWLINE> <INDENT> print <STRING> , q [ ii ] , k , q [ jj ] , <STRING> , j , q [ kk ] , <STRING> , i , q [ ll ] , <STRING> <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if eval ( <STRING> + q [ ii ] + k + q [ jj ] + <STRING> + i + <STRING> + q [ kk ] + j + q [ ll ] + <STRING> ) == x : <NEWLINE> <INDENT> print <STRING> , q [ ii ] , k , q [ jj ] , <STRING> , i , <STRING> , q [ kk ] , j , q [ ll ] , <STRING> <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> <DEDENT>
def op ( x , y , i ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> return x + y <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> return x - y <NEWLINE> <DEDENT> elif i == 2 : <NEWLINE> <INDENT> return x * y <NEWLINE> <NL> <DEDENT> <DEDENT> def check ( x , n ) : <NEWLINE> <INDENT> a1 , a2 , a3 , a4 = x [ 0 ] , x [ 1 ] , x [ 2 ] , x [ 3 ] <NEWLINE> s = <STRING> <NEWLINE> for i1 in range ( 3 ) : <NEWLINE> <INDENT> a1 = op ( x [ 0 ] , x [ 1 ] , i1 ) <NEWLINE> for i2 in range ( 3 ) : <NEWLINE> <INDENT> a2 = op ( a1 , x [ 2 ] , i2 ) <NEWLINE> for i3 in range ( 3 ) : <NEWLINE> <INDENT> a3 = op ( a2 , x [ 3 ] , i3 ) <NEWLINE> if a3 == n : <NEWLINE> <INDENT> b1 , b2 , b3 = s [ i1 ] , s [ i2 ] , s [ i3 ] <NEWLINE> s0 = <STRING> <NEWLINE> eq = s0 . format ( x [ 0 ] , b1 , x [ 1 ] , b2 , x [ 2 ] , b3 , x [ 3 ] ) <NEWLINE> return eq <NEWLINE> <DEDENT> <DEDENT> a2 = op ( x [ 2 ] , x [ 3 ] , i2 ) <NEWLINE> for i3 in range ( 3 ) : <NEWLINE> <INDENT> a3 = op ( a1 , a2 , i3 ) <NEWLINE> if a3 == n : <NEWLINE> <INDENT> b1 , b2 , b3 = s [ i1 ] , s [ i3 ] , s [ i2 ] <NEWLINE> s0 = <STRING> <NEWLINE> eq = s0 . format ( x [ 0 ] , b1 , x [ 1 ] , b2 , x [ 2 ] , b3 , x [ 3 ] ) <NEWLINE> return eq <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def permutations ( L ) : <NEWLINE> <INDENT> if L == [ ] : <NEWLINE> <INDENT> return [ [ ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ [ h ] + t for i , h in enumerate ( L ) <NEWLINE> <INDENT> for t in permutations ( L [ : i ] + L [ i + 1 : ] ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = 10 <NEWLINE> op = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == [ 0 , 0 , 0 , 0 ] : break <NEWLINE> x = permutations ( x ) <NEWLINE> for e in x : <NEWLINE> <INDENT> s = check ( e , n ) <NEWLINE> if s != <STRING> : <NEWLINE> <INDENT> print s <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import itertools <NEWLINE> <NL> def calc ( n ) : <NEWLINE> <INDENT> for op in itertools . product ( operators , repeat = 3 ) : <NEWLINE> <INDENT> for form in forms : <NEWLINE> <INDENT> formula = form . format ( op [ 0 ] , op [ 1 ] , op [ 2 ] , n [ 0 ] , n [ 1 ] , n [ 2 ] , n [ 3 ] ) <NEWLINE> if eval ( formula ) == 10 : <NEWLINE> <INDENT> print ( formula ) <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> operators = ( <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> forms = ( <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <DEDENT> ) <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> nums = tuple ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> if nums == ( 0 , 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for n in itertools . permutations ( nums ) : <NEWLINE> <INDENT> if calc ( n ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import itertools , sys <NEWLINE> def f ( a ) : <NEWLINE> <INDENT> if len ( a ) < 2 : yield [ a [ 0 ] ] * 2 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> for p , s in f ( a [ : i ] ) : <NEWLINE> <INDENT> for q , t in f ( a [ i : ] ) : <NEWLINE> <INDENT> yield ( p + q , <STRING> ) <NEWLINE> yield ( p - q , <STRING> ) <NEWLINE> yield ( p * q , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def s ( a ) : <NEWLINE> <INDENT> for p in itertools . permutations ( a ) : <NEWLINE> <INDENT> for n , s in f ( p ) : <NEWLINE> <INDENT> if n == 10 : print ( s ) ; return 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> a = list ( map ( int , e . split ( ) ) ) <NEWLINE> if not s ( a ) : print ( 0 ) <NEWLINE> <DEDENT>
op = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> while True : <NEWLINE> <INDENT> a , b , c , d = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if a == 0 and c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = [ 0 , 1 , 2 , 3 ] <NEWLINE> q = [ str ( a ) , str ( b ) , str ( c ) , str ( d ) ] <NEWLINE> flag = 0 <NEWLINE> for i in op : <NEWLINE> <INDENT> for j in op : <NEWLINE> <INDENT> for k in op : <NEWLINE> <INDENT> for ii in n : <NEWLINE> <INDENT> m = [ 0 , 1 , 2 , 3 ] <NEWLINE> m . remove ( ii ) <NEWLINE> for jj in m : <NEWLINE> <INDENT> l = [ 0 , 1 , 2 , 3 ] <NEWLINE> l . remove ( ii ) ; l . remove ( jj ) <NEWLINE> for kk in l : <NEWLINE> <INDENT> o = [ 0 , 1 , 2 , 3 ] <NEWLINE> o . remove ( ii ) ; o . remove ( jj ) ; o . remove ( kk ) <NEWLINE> for ll in o : <NEWLINE> <INDENT> if eval ( <STRING> + q [ ii ] + k + q [ jj ] + <STRING> + j + q [ kk ] + <STRING> + i + q [ ll ] + <STRING> ) == 10 : <NEWLINE> <INDENT> print <STRING> , q [ ii ] , k , q [ jj ] , <STRING> , j , q [ kk ] , <STRING> , i , q [ ll ] , <STRING> <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if eval ( <STRING> + q [ ii ] + k + q [ jj ] + <STRING> + i + <STRING> + q [ kk ] + j + q [ ll ] + <STRING> ) == 10 : <NEWLINE> <INDENT> print <STRING> , q [ ii ] , k , q [ jj ] , <STRING> , i , <STRING> , q [ kk ] , j , q [ ll ] , <STRING> <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> <DEDENT>
def get ( ) : <NEWLINE> <INDENT> p , w = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> for i in range ( W - w + 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if bag [ i ] > 0 and bag [ i ] + p > bag [ i + w ] : <NEWLINE> <INDENT> bag [ i + w ] = bag [ i ] + p <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p > bag [ w ] : bag [ w ] = p <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> W = int ( raw_input ( ) ) <NEWLINE> if W == 0 : break <NEWLINE> bag = [ 0 ] * ( W + 1 ) <NEWLINE> N = int ( raw_input ( ) ) <NEWLINE> for i in range ( N ) : get ( ) <NEWLINE> w_all = max ( bag ) <NEWLINE> money = bag . index ( w_all ) <NEWLINE> print <STRING> . format ( c , w_all , money ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
while True : <NEWLINE> <COMMENT> <NL> <INDENT> case = 0 <NEWLINE> while True : <NEWLINE> <INDENT> case += 1 <NEWLINE> weight = input ( ) <NEWLINE> if weight == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N = input ( ) <NEWLINE> data = [ [ 0 for i in range ( 2 ) ] for j in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> data [ i ] [ 0 ] , data [ i ] [ 1 ] = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> table = [ [ - 1 for i in range ( weight + 1 ) ] for j in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> table [ i ] [ 0 ] = 0 <NEWLINE> <DEDENT> table [ 0 ] [ data [ 0 ] [ 1 ] ] = data [ 0 ] [ 0 ] <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( weight + 1 ) : <NEWLINE> <INDENT> if table [ i ] [ j ] != - 1 and j + data [ i + 1 ] [ 1 ] <= weight : <NEWLINE> <INDENT> table [ i + 1 ] [ j + data [ i + 1 ] [ 1 ] ] = table [ i ] [ j ] + data [ i + 1 ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sum = max ( table [ N - 1 ] ) <NEWLINE> print <STRING> + str ( case ) + <STRING> <NEWLINE> print sum <NEWLINE> print table [ N - 1 ] . index ( sum ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
num = 1 <NEWLINE> while True : <NEWLINE> <INDENT> maxw = input ( ) <NEWLINE> if maxw == 0 : break <NEWLINE> N = input ( ) <NEWLINE> ws , ps = [ 0 ] * N , [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> ps [ i ] , ws [ i ] = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> ret = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( maxw + 1 ) : <NEWLINE> <INDENT> if ( j + ws [ i ] ) <= maxw : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + ws [ i ] ] = max ( dp [ i + 1 ] [ j + ws [ i ] ] , dp [ i ] [ j ] + ps [ i ] ) <NEWLINE> ret = max ( dp [ i + 1 ] [ j + ws [ i ] ] , ret ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> % num <NEWLINE> print ret <NEWLINE> print dp [ len ( ws ) ] . index ( ret ) <NEWLINE> num += 1 <NEWLINE> <DEDENT>
times = 0 <NEWLINE> while True : <NEWLINE> <INDENT> times += 1 <NEWLINE> W = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> if W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> w = [ 0 ] * n <NEWLINE> v = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v [ i ] , w [ i ] = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> dp = [ [ 0 ] * ( W + 1 ) for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> if j < w [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = dp [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ j - w [ i ] ] + v [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> MIN = 0 <NEWLINE> for i in range ( W + 1 ) : <NEWLINE> <INDENT> if dp [ n ] [ i ] == dp [ n ] [ W ] : <NEWLINE> <INDENT> MIN = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> % times ) <NEWLINE> print ( dp [ n ] [ W ] ) <NEWLINE> print ( MIN ) <NEWLINE> <DEDENT>
def get ( ) : <NEWLINE> <INDENT> p , w = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> for i in range ( W - w , - 1 , - 1 ) : <NEWLINE> <INDENT> if bag [ i ] > 0 and bag [ i ] + p > bag [ i + w ] : <NEWLINE> <INDENT> bag [ i + w ] = bag [ i ] + p <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if p > bag [ w ] : bag [ w ] = p <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> c = 1 <NEWLINE> while True : <NEWLINE> <INDENT> W = int ( raw_input ( ) ) <NEWLINE> if W == 0 : break <NEWLINE> bag = [ 0 ] * ( W + 1 ) <NEWLINE> N = int ( raw_input ( ) ) <NEWLINE> for i in range ( N ) : get ( ) <NEWLINE> w_all = max ( bag ) <NEWLINE> money = bag . index ( w_all ) <NEWLINE> print <STRING> . format ( c , w_all , money ) <NEWLINE> c += 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from itertools import * <NEWLINE> from sys import * <NEWLINE> <NL> def solve ( n , w ) : <NEWLINE> <INDENT> lp , lw = [ ] , [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> s = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> lp . append ( s [ 0 ] ) <NEWLINE> lw . append ( s [ 1 ] ) <NEWLINE> <DEDENT> mp = mw = 0 <NEWLINE> for e in product ( [ 0 , 1 ] , repeat = n ) : <NEWLINE> <INDENT> cw = sum ( [ lw [ i ] for i in range ( len ( e ) ) if e [ i ] ] ) <NEWLINE> cp = sum ( [ lp [ i ] for i in range ( len ( e ) ) if e [ i ] ] ) <NEWLINE> <NL> if cp == mp and mw > cw : mw = cw <NEWLINE> if w >= cw and cp > mp : mp = cp ; mw = cw <NEWLINE> <DEDENT> print mp <NEWLINE> print mw <NEWLINE> <NL> <DEDENT> case = 0 <NEWLINE> while True : <NEWLINE> <INDENT> case += 1 <NEWLINE> w = int ( raw_input ( ) ) <NEWLINE> if w == 0 : break <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> print <STRING> % ( case ) <NEWLINE> solve ( n , w ) <NEWLINE> <DEDENT>
case = 0 <NEWLINE> while True : <NEWLINE> <INDENT> case += 1 <NEWLINE> W = input ( ) <NEWLINE> if W == 0 : break <NEWLINE> print <STRING> . format ( case ) <NEWLINE> dp = [ 0 ] * 1000 <NEWLINE> w = [ 0 ] * 1000 <NEWLINE> v = [ 0 ] * 1000 <NEWLINE> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> v [ i ] , w [ i ] = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( W , - 1 , - 1 ) : <NEWLINE> <INDENT> if j + w [ i ] <= W : <NEWLINE> <INDENT> dp [ j + w [ i ] ] = max ( dp [ j + w [ i ] ] , dp [ j ] + v [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print max ( dp ) <NEWLINE> print dp . index ( max ( dp ) ) <NEWLINE> <DEDENT>
c = 0 <NEWLINE> for W in iter ( input , <STRING> ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> W = int ( W ) <NEWLINE> dp = [ 0 ] * - ~ W <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> v , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> for i in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> if dp [ i ] < dp [ i - w ] + v : dp [ i ] = dp [ i - w ] + v <NEWLINE> <DEDENT> <DEDENT> for i in range ( W + 1 ) : <NEWLINE> <INDENT> if dp [ W ] == dp [ i ] : print ( <STRING> ) ; break <NEWLINE> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> import itertools <NEWLINE> <NL> <NL> class Treasure : <NEWLINE> <INDENT> def __init__ ( self , value , weight ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . weight = weight <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> def solv ( treasures , w_limit ) : <NEWLINE> <INDENT> treasures . sort ( lambda a , b : cmp ( b . value , a . value ) ) <NEWLINE> tvw = ( 0 , 0 ) <NEWLINE> for ts in t_combinations ( treasures ) : <NEWLINE> <INDENT> w = t_sum_weight ( ts ) <NEWLINE> if w <= w_limit : <NEWLINE> <INDENT> v = t_sum_value ( ts ) <NEWLINE> if tvw [ 0 ] < v : <NEWLINE> <INDENT> tvw = ( v , w ) <NEWLINE> <DEDENT> elif tvw [ 0 ] == v : <NEWLINE> <INDENT> if w < tvw [ 1 ] : <NEWLINE> <INDENT> tvw = ( v , w ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return tvw <NEWLINE> <NL> <NL> <DEDENT> def t_combinations ( t ) : <NEWLINE> <INDENT> l = len ( t ) <NEWLINE> for x in range ( l , 0 , - 1 ) : <NEWLINE> <INDENT> for y in itertools . combinations ( t , x ) : <NEWLINE> <INDENT> yield y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def t_sum_weight ( ts ) : <NEWLINE> <INDENT> return sum ( map ( lambda x : x . weight , ts ) ) <NEWLINE> <NL> <NL> <DEDENT> def t_sum_value ( ts ) : <NEWLINE> <INDENT> return sum ( map ( lambda x : x . value , ts ) ) <NEWLINE> <NL> <NL> <DEDENT> def rightest ( tss ) : <NEWLINE> <INDENT> return reduce ( lambda a , b : take_right ( a , b ) , tss ) <NEWLINE> <NL> <NL> <DEDENT> def take_right ( a , b ) : <NEWLINE> <INDENT> if t_sum_weight ( a ) <= t_sum_weight ( b ) : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return b <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> case = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> weight_limit = int ( sys . stdin . readline ( ) ) <NEWLINE> case += 1 <NEWLINE> if weight_limit == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> treasures = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v , w = map ( int , sys . stdin . readline ( ) . split ( <STRING> ) ) <NEWLINE> treasures . append ( Treasure ( v , w ) ) <NEWLINE> <DEDENT> value , weight = solv ( treasures , weight_limit ) <NEWLINE> print <STRING> + str ( case ) + <STRING> <NEWLINE> print value <NEWLINE> print weight <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> from itertools import count , combinations <NEWLINE> <NL> for case in count ( 1 ) : <NEWLINE> <INDENT> W = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> if not W : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> N = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> data = [ ] <NEWLINE> for _ in xrange ( N ) : <NEWLINE> <INDENT> data . append ( [ int ( s ) for s in stdin . readline ( ) . strip ( ) . split ( <STRING> ) ] ) <NEWLINE> <DEDENT> data . sort ( key = lambda ( v , w ) : w ) <NEWLINE> <NL> value , weight = 0 , W <NEWLINE> for i in xrange ( 1 , N + 1 ) : <NEWLINE> <INDENT> for cmb in combinations ( data , i ) : <NEWLINE> <INDENT> tv , tw = 0 , 0 <NEWLINE> for v , w in cmb : <NEWLINE> <INDENT> tv += v <NEWLINE> tw += w <NEWLINE> <DEDENT> if W < tw : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if W >= tw and ( tv > value ) or ( tv == value and tw < weight ) : <NEWLINE> <INDENT> value , weight = tv , tw <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . format ( case , value , weight ) ) <NEWLINE> <DEDENT>
def mlist ( n , * args , ** keys ) : <NEWLINE> <INDENT> if args : <NEWLINE> <INDENT> return [ mlist ( * args , ** keys ) for i in range ( n ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ keys . get ( <STRING> ) ] * n <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> w = int ( raw_input ( ) ) <NEWLINE> if w == 0 : break <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> a , b = zip ( * [ map ( int , raw_input ( ) . split ( <STRING> ) ) for i in range ( 5 ) ] ) <NEWLINE> c = mlist ( 1010 , 1010 ) <NEWLINE> c [ 0 ] [ 0 ] = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( w + 1 ) : <NEWLINE> <INDENT> if c [ i ] [ j ] is None : continue <NEWLINE> c [ i + 1 ] [ j ] = max ( c [ i + 1 ] [ j ] , c [ i ] [ j ] ) <NEWLINE> if j + b [ i ] <= w : <NEWLINE> <INDENT> c [ i + 1 ] [ j + b [ i ] ] = max ( c [ i + 1 ] [ j + b [ i ] ] , c [ i ] [ j ] + a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> mx = max ( c [ n ] ) <NEWLINE> print mx <NEWLINE> print c [ n ] . index ( mx ) <NEWLINE> <DEDENT>
<NL> def dfs ( hands , pair ) : <NEWLINE> <INDENT> hands . sort ( ) <NEWLINE> <NL> if not hands : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> target = hands [ 0 ] <NEWLINE> <COMMENT> <NL> if all ( map ( lambda x : x in hands , range ( target , target + 3 ) ) ) : <NEWLINE> <INDENT> for i in range ( target , target + 3 ) : <NEWLINE> <INDENT> hands . remove ( i ) <NEWLINE> <DEDENT> if dfs ( hands , pair ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( target , target + 3 ) : <NEWLINE> <INDENT> hands . append ( i ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if hands . count ( target ) >= 3 : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> hands . remove ( target ) <NEWLINE> <DEDENT> if dfs ( hands , pair ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> hands . append ( target ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if not pair and hands . count ( target ) >= 2 : <NEWLINE> <INDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> hands . remove ( target ) <NEWLINE> <DEDENT> if dfs ( hands , True ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> hands . append ( target ) <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> for line in filter ( lambda line : line . strip ( ) , stdin . readlines ( ) ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> data = [ int ( ch ) for ch in line . strip ( ) ] <NEWLINE> for num in filter ( lambda x : data . count ( x ) < 4 , range ( 1 , 10 ) ) : <NEWLINE> <INDENT> data_cp = list ( data ) <NEWLINE> data_cp . append ( num ) <NEWLINE> data_cp . sort ( ) <NEWLINE> if dfs ( data_cp , False ) : <NEWLINE> <INDENT> result . append ( num ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( result ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def f ( c , h = 0 ) : <NEWLINE> <INDENT> if 2 in c and sum ( c ) == 2 : return 1 <NEWLINE> if 5 in c : return 0 <COMMENT> <NEWLINE> if 4 in c : <NEWLINE> <INDENT> k = c . index ( 4 ) ; c [ k ] -= 3 <NEWLINE> if f ( c , h + 1 ) : return 1 <NEWLINE> c [ k ] += 3 <NEWLINE> <DEDENT> if 3 in c : <NEWLINE> <INDENT> k = c . index ( 3 ) ; c [ k ] -= 3 <NEWLINE> if f ( c , h + 1 ) : return 1 <NEWLINE> c [ k ] += 3 <NEWLINE> <DEDENT> for i in range ( 7 ) : <NEWLINE> <INDENT> if c [ i ] and c [ i + 1 ] and c [ i + 2 ] : <NEWLINE> <INDENT> c [ i ] -= 1 ; c [ i + 1 ] -= 1 ; c [ i + 2 ] -= 1 <NEWLINE> if f ( c , h + 1 ) : return 1 <NEWLINE> c [ i ] += 1 ; c [ i + 1 ] += 1 ; c [ i + 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> n = <STRING> <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> e = list ( e . strip ( ) ) <NEWLINE> a = [ i for i in n if f ( [ ( e + [ i ] ) . count ( j ) for j in n ] ) ] <NEWLINE> print ( * a if a else 0 ) <NEWLINE> <DEDENT>
def Solve ( c , s ) : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> if max ( c ) > 4 : return False <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> if c [ i ] >= 2 : <NEWLINE> <INDENT> cc = c [ : ] <NEWLINE> cc [ i ] -= 2 <NEWLINE> if Solve ( cc , False ) : return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> check = 0 <NEWLINE> for i in range ( 4 ) : check += c . count ( 3 * i ) <NEWLINE> if check == 9 : return True <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( 7 ) : <NEWLINE> <INDENT> if c [ i ] >= 1 : <NEWLINE> <INDENT> cc = c [ : ] <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> cc [ i + j ] -= 1 <NEWLINE> if cc [ i + j ] < 0 : break <NEWLINE> <DEDENT> if Solve ( cc , False ) : return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> _in = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> try : _in = input ( ) <NEWLINE> except EOFError : break <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> l = ( _in + str ( i + 1 ) ) [ : : 1 ] <NEWLINE> count = [ l . count ( str ( j + 1 ) ) for j in range ( 9 ) ] <NEWLINE> if Solve ( count , True ) : ans . append ( str ( i + 1 ) ) <NEWLINE> <DEDENT> print ( 0 if len ( ans ) == 0 else <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def check ( x , j = 1 ) : <NEWLINE> <INDENT> if sum ( x ) == 0 : return 1 <NEWLINE> i = j <NEWLINE> while x [ i ] == 0 : i += 1 <NEWLINE> y = x [ : ] <NEWLINE> if y [ i ] >= 3 : <NEWLINE> <INDENT> y [ i ] -= 3 <NEWLINE> if check ( y , i ) : return 1 <NEWLINE> <DEDENT> y = x [ : ] <NEWLINE> if i < 8 and y [ i ] > 0 and y [ i + 1 ] > 0 and y [ i + 2 ] > 0 : <NEWLINE> <INDENT> y [ i ] -= 1 <NEWLINE> y [ i + 1 ] -= 1 <NEWLINE> y [ i + 2 ] -= 1 <NEWLINE> if check ( y , i ) : return 1 <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> c = [ 0 ] * 10 <NEWLINE> for e in map ( int , s [ : - 1 ] ) : c [ e ] += 1 <NEWLINE> <NL> f = 0 <NEWLINE> R = range ( 1 , 10 ) <NEWLINE> for i in R : <NEWLINE> <INDENT> c1 = c [ : ] <NEWLINE> if c1 [ i ] >= 4 : continue <NEWLINE> c1 [ i ] += 1 <NEWLINE> for j in R : <NEWLINE> <INDENT> if c1 [ j ] < 2 : continue <NEWLINE> c1 [ j ] -= 2 <NEWLINE> if check ( c1 ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> print i , <NEWLINE> break <NEWLINE> <DEDENT> c1 [ j ] += 2 <NEWLINE> <DEDENT> <DEDENT> print [ <STRING> , <STRING> ] [ f ] , <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> primes = [ 2 ] <NEWLINE> <NL> def solv ( num ) : <NEWLINE> <INDENT> if num < primes [ - 1 ] : <NEWLINE> <INDENT> p1 = filter ( lambda x : x < num , primes ) [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for p in prime_list ( num * 2 ) : <NEWLINE> <INDENT> primes . append ( p ) <NEWLINE> if num < p : <NEWLINE> <INDENT> p2 = p <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if p < num : <NEWLINE> <INDENT> p1 = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ( p1 , p2 ) <NEWLINE> <NL> <NL> <DEDENT> def prime_list ( n ) : <NEWLINE> <INDENT> limit = int ( n ** 0.5 ) + 1 <NEWLINE> lis = range ( 1 , n + 1 , 2 ) <NEWLINE> lis [ 0 ] = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if len ( lis ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = lis . pop ( 0 ) <NEWLINE> yield p <NEWLINE> if p <= limit : <NEWLINE> <INDENT> lis = [ x for x in lis if x % p != 0 ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> number = int ( line ) <NEWLINE> p1 , p2 = solv ( number ) <NEWLINE> print <STRING> . join ( map ( str , [ p1 , p2 ] ) ) <NEWLINE> <DEDENT>
def is_prime ( q ) : <NEWLINE> <INDENT> q = abs ( q ) <NEWLINE> if q == 2 : return True <NEWLINE> if q < 2 or q & 1 == 0 : return False <NEWLINE> return pow ( 2 , q - 1 , q ) == 1 <NEWLINE> <NL> <DEDENT> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = a <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> b -= 1 <NEWLINE> if ( is_prime ( b ) ) : <NEWLINE> <INDENT> print b , <STRING> , <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> while ( True ) : <NEWLINE> <INDENT> a += 1 <NEWLINE> if ( is_prime ( a ) ) : <NEWLINE> <INDENT> print a <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
M = 50100 <NEWLINE> p = [ 1 ] * M ; p [ 0 ] , p [ 1 ] = 0 , 0 ; <NEWLINE> pm = [ 0 ] * M ; pM = [ 0 ] * M ; <NEWLINE> for i in range ( 2 , M ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , M , i ) : p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> num = - 1 <NEWLINE> for i in range ( 1 , M ) : <NEWLINE> <INDENT> pm [ i ] = num <NEWLINE> if p [ i ] : num = i <NEWLINE> <DEDENT> num = - 1 <NEWLINE> for i in range ( M - 1 , 2 , - 1 ) : <NEWLINE> <INDENT> pM [ i ] = num <NEWLINE> if p [ i ] : num = i <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> print pm [ n ] , pM [ n ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> primes = [ 2 ] <NEWLINE> for i in range ( 3 , 50010 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> for p in primes : <NEWLINE> <INDENT> if i % p == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> i = 0 <NEWLINE> while primes [ i ] < n and i < len ( primes ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if primes [ i ] == n : <NEWLINE> <INDENT> s = primes [ i - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = primes [ i ] <NEWLINE> <DEDENT> m = primes [ i + 1 ] <NEWLINE> print s , m <NEWLINE> <DEDENT>
import math <NEWLINE> & <COMMENT> <NEWLINE> r = 50000 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> while True : <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE>
import sys , math <NEWLINE> def sieves ( m ) : <NEWLINE> <INDENT> global S <NEWLINE> S = range ( 1 , m + 1 , 2 ) <NEWLINE> r = int ( m ** .5 ) <NEWLINE> h = len ( S ) <NEWLINE> S [ 0 ] = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> x = S [ i ] <NEWLINE> if x > r : break <NEWLINE> if x and i + x < h : S [ i + x : h : x ] = [ 0 ] * ( ( h - 1 - i - x ) / x + 1 ) <NEWLINE> <DEDENT> S [ 0 ] = 2 <NEWLINE> return <NEWLINE> <DEDENT> m = 50100 <NEWLINE> S = [ ] <NEWLINE> sieves ( m ) <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> for p1 in range ( n / 2 - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if S [ p1 ] : break <NEWLINE> <DEDENT> for p2 in range ( ( n + 1 ) / 2 , m / 2 + 1 ) : <NEWLINE> <INDENT> if S [ p2 ] : break <NEWLINE> <DEDENT> print S [ p1 ] , S [ p2 ] <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> <NL> def sieve ( n ) : <NEWLINE> <INDENT> a = range ( n ) <NEWLINE> a [ : 2 ] = None , None <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i ** 2 >= n : break <NEWLINE> if not a [ i ] : continue <NEWLINE> for i in range ( i ** 2 , n , i ) : <NEWLINE> <INDENT> a [ i ] = None <NEWLINE> <DEDENT> <DEDENT> return [ v for v in a if v ] <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> a = sieve ( 9000 ) <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> i = bisect_right ( a , n ) <NEWLINE> print a [ i - ( 2 if a [ i - 1 ] == n else 1 ) ] , a [ i ] <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> s = c = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> x , y = map ( int line . split ( <STRING> ) ) <NEWLINE> s += x * y <NEWLINE> c += y <NEWLINE> <DEDENT> print ( s , round ( s / c ) ) <NEWLINE>
i , all , sum = 0 , 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> price , n = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> i += 1 ; all += n ; sum += price <NEWLINE> <DEDENT> except <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print sum <NEWLINE> print int ( round ( float ( all ) / i ) ) <NEWLINE>
try : <NEWLINE> <INDENT> result = result2 = count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> result += a * b <NEWLINE> result2 += b <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( result ) <NEWLINE> print ( ( round ( result2 / count + 0.5 ) ) <NEWLINE> <DEDENT>
P_Sum = 0 <NEWLINE> N_Sum = 0 <NEWLINE> Kazu = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> pri , num = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> P_Sum += num * pri <NEWLINE> N_Sum += num <NEWLINE> Kazu += 1 <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( P_Sum ) <NEWLINE> print ( round ( N_Sum / Kazu ) ) <NEWLINE> <DEDENT> <DEDENT>
total = 0 <NEWLINE> s = 0 <NEWLINE> i = 0 <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> total += a * b <NEWLINE> s += b <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> result = s / i <NEWLINE> print ( total ) <NEWLINE> print ( round ( result ) ) <NEWLINE>
a , b = [ ] , [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> x , y = map ( int , line . strip ( ) . split ( <STRING> ) ) <NEWLINE> a , b = a + [ x * y ] , b + [ y ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( sum ( a ) ) <NEWLINE> print ( round ( sum ( b ) / len ( b ) ) ) <NEWLINE>
a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : p , n = input ( ) <NEWLINE> except : break <NEWLINE> a += p * n <NEWLINE> b += n <NEWLINE> c += 1 <NEWLINE> <DEDENT> print a , <STRING> % round ( 1.0 * b / c ) <NEWLINE>
<COMMENT> <NL> <NL> _sum_list = [ ] <NEWLINE> _avg_list = [ ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> _sum , _avg = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> _sum_list . append ( _sum ) <NEWLINE> _avg_list . append ( _avg ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> _sum , _avg = sum ( _sum_list ) , sum ( _avg_list ) / len ( _avg_list ) <NEWLINE> print ( round ( _sum , 1 ) , round ( _avg , 1 ) ) <NEWLINE>
import sys <NEWLINE> a = list ( map ( float , sys . stdin . readline ( ) ) ) <NEWLINE> print ( max ( a ) - min ( a ) ) <NEWLINE>
a = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> h = float ( row_input ( ) ) <NEWLINE> a . append ( h ) <NEWLINE> except : <NEWLINE> break <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> print a [ len ( a ) - 1 ] - a [ 0 ] <NEWLINE>
inputs = [ float ( i ) for i in input ( ) ] <NEWLINE> <NL> print ( max ( inputs ) - min ( inputs ) ) <NEWLINE>
ls = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> data = float ( raw_input ( ) . split ( ) ) <NEWLINE> ls . append ( data ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ls . sort ( ) <NEWLINE> ans = ls [ - 1 ] - ls [ 0 ] <NEWLINE> print ans <NEWLINE>
p = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s , t = raw_input ( ) . split ( <STRING> ) <NEWLINE> <DEDENT> except EOFError as e : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s == p : <NEWLINE> <INDENT> p = t <NEWLINE> <DEDENT> elif t == p : <NEWLINE> <INDENT> p = s <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> % ( chA , ) ) <NEWLINE>
d = { <STRING> : 1 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> swap1 , awap2 = input ( ) . split ( <STRING> ) <NEWLINE> d [ swap1 ] , d [ swap2 ] = d [ swap2 ] , d [ swap1 ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( d . keys ( ) [ d . values ( ) . index ( 1 ) ] ) <NEWLINE> <NL>
ls = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 } <NEWLINE> cup = [ 1 , 0 , 0 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> x , y = map ( str , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> tmp = cup [ ls [ x ] ] <NEWLINE> cup [ ls [ x ] ] = cup [ ls [ y ] ] <NEWLINE> cup [ ls [ y ] ] = cup [ ls [ x ] ] <NEWLINE> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> p = cup . index ( 1 ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> if c == 1 else <STRING> <NEWLINE> <DEDENT>
cups = [ True , False , False ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> l = line . strip ( ) . split ( <STRING> ) <NEWLINE> if <STRING> in l and <STRING> in l : <NEWLINE> <INDENT> cups [ 0 ] , cups [ 1 ] = cups [ 1 ] , cups [ 1 ] <NEWLINE> <DEDENT> elif <STRING> in l and <STRING> in l : <NEWLINE> <INDENT> cups [ 0 ] , cups [ 2 ] = cups [ 2 ] , cups [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cups [ 1 ] , cups [ 2 ] = cups [ 2 ] , cups [ 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if cups [ i ] : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
ball = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( lambda x : ord ( x ) - ord ( <STRING> ) raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if ( a == ball ) : <NEWLINE> <INDENT> ball = b ; <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> print chr ( ball + ord ( <STRING> ) ) <NEWLINE>
d = { <STRING> : True , <STRING> : False , <STRING> : False } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , t = input ( ) . split ( <STRING> ) <NEWLINE> d [ a ] , d [ t ] = d [ t ] , d [ a ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> for k , v in d . items ( ) : <NEWLINE> <INDENT> if v : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
Ans = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if Ans in Pos : <NEWLINE> <INDENT> Ans = Pos [ ( ( Pos . index ( Ans ) ) + 1 ) % 2 ] <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print ( Ans ) <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> c = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <DEDENT> w = [ 48 , 51 , 54 , 57 , 60 , 64 , 69 , 75 , 81 , 91 ] <NEWLINE> for s in map ( float , sys . stdin ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> while w [ i ] < s : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> print c [ i ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def judge_class ( s ) : <NEWLINE> <INDENT> if s <= 48.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 48.00 < s <= 51.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 51.00 < s <= 54.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 54.00 < s <= 57.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 57.00 < s <= 60.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 60.00 < s <= 64.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 64.00 < s <= 69.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 69.00 < s <= 75.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 75.00 < s <= 81.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 81.00 < s <= 91.00 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 91.00 <= s : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> print ( judge_class ( s ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> w = float ( input ( ) ) <NEWLINE> if w <= 48 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 48 <= w <= 51 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 51 <= w <= 54 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 54 <= w <= 57 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 57 <= w <= 60 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 60 <= w <= 64 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 64 <= w <= 69 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 69 <= w <= 75 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 75 <= w <= 81 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> elif 81 <= w <= 91 : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> judge = <STRING> <NEWLINE> <DEDENT> print ( judge ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> w = float ( raw_input ( ) ) <NEWLINE> if w <= 48.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 51.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 54.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 57.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 60 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 64.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 69.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 75.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 81.0 <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif w <= 91.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> weight = float ( input ( ) ) <NEWLINE> <NL> if ( weight <= 48.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 51.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 54.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 57.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 60.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 64.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 69.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 75.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 81.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( weight <= 91.00 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> except ValueError : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT>
d = { } ; <NEWLINE> d [ <STRING> ] = 0 ; <NEWLINE> d [ <STRING> ] = 0 ; <NEWLINE> d [ <STRING> ] = 0 ; <NEWLINE> d [ <STRING> ] = 0 ; <NEWLINE> <NL> while True : <NEWLINE> <INDENT> b = raw_input ( ) . strip ( ) . split ( <STRING> ) [ 1 ] <NEWLINE> d [ b ] += 1 ; <NEWLINE> <NL> <DEDENT> print d [ <STRING> ] <NEWLINE> print d [ <STRING> ] <NEWLINE> print d [ <STRING> ] <NEWLINE> print d [ <STRING> ] <NEWLINE>
import sys <NEWLINE> <NL> A = <STRING> <NEWLINE> B = <STRING> <NEWLINE> AB = A + B <NEWLINE> O = <STRING> <NEWLINE> N = <STRING> <NEWLINE> <NL> b = { A : 0 , B : 0 , AB : 0 , O : 0 } <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> i = s [ s . index ( <STRING> ) + 1 : - 1 ] <NEWLINE> b [ i ] += 1 <NEWLINE> <DEDENT> print b [ A ] , N , b [ B ] , N , b [ AB ] , N , b [ O ] , N <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> dic = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> id , type = map ( int , line . split ( <STRING> ) ) <NEWLINE> dic [ type ] += 1 <NEWLINE> <DEDENT> for key in dic : <NEWLINE> <INDENT> print dic [ key ] <NEWLINE> <DEDENT>
a , p = <STRING> , <STRING> <NEWLINE> t = { a : p , p : a } <NEWLINE> print ( * [ t [ w ] if 5 == len ( w ) and if w in t else t [ w [ : 5 ] ] + w [ 5 : ] if w [ : 5 ] in t else w for w in input ( ) . split ( ) ] ) <NEWLINE>
s = input ( ) . split ( ) <NEWLINE> ss = [ ] <NEWLINE> for w in s : <NEWLINE> <INDENT> a = w . find ( <STRING> ) <NEWLINE> p = w . find ( <STRING> ) <NEWLINE> if a != - 1 : <NEWLINE> <INDENT> w = w . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> elif p != - 1 : <NEWLINE> <INDENT> w = w . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> ss . append ( word ) <NEWLINE> <DEDENT> print ( <STRING> . join ( ss ) ) <NEWLINE>
import re <NEWLINE> ans = [ ] <NEWLINE> for i in l : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> ans . append ( i . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> ans . append ( i . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( ans ) <NEWLINE>
sen = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> ans = [ ] <NEWLINE> for i in sen : <NEWLINE> <INDENT> if len ( i ) >= 5 : <NEWLINE> <INDENT> if i [ 0 : 5 ] == <STRING> : <NEWLINE> <INDENT> if len ( i ) > 5 : <NEWLINE> <INDENT> ans . append ( <STRING> + i [ 5 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . appned ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif i [ 0 : 5 ] == <STRING> : <NEWLINE> <INDENT> if len ( i ) > 5 : <NEWLINE> <INDENT> ans . append ( <STRING> + i [ 5 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
print raw_input ( ) . replace ( <STRING> , <STRING> <COMMENT> <NEWLINE>
while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> li = list ( input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> li1 = int ( <STRING> . join ( sorted ( li ) ) ) <NEWLINE> li2 = int ( <STRING> . join ( sorted ( li , reverse = True ) ) ) <NEWLINE> print ( li2 - li1 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> for i in xrange ( input ( ) ) : <NEWLINE> <INDENT> n = sorted ( raw_input ( ) ) <NEWLINE> x = int ( <STRING> . join ( n [ : : - 1 ] ) ) <NEWLINE> for j in xrange ( len ( n ) ) : <NEWLINE> <INDENT> if n [ i ] == <STRING> : del n [ i ] <NEWLINE> else : break <NEWLINE> <DEDENT> print x - int ( <STRING> . join ( n ) ) <NEWLINE> <DEDENT>
i = int ( raw_input ( ) ) <NEWLINE> <NL> while ( i ) : <NEWLINE> <INDENT> i -= 1 <NEWLINE> st = [ ] <NEWLINE> n = raw_input ( ) <NEWLINE> <NL> for s in n : <NEWLINE> <INDENT> st . append ( s ) <NEWLINE> <NL> <DEDENT> st . sort ( ) <NEWLINE> a = int ( <STRING> . join ( ) ) <NEWLINE> b = int ( <STRING> . join ( st [ : : - 1 ] ) ) <NEWLINE> <NL> print b - a <NEWLINE> <DEDENT>
import math <NEWLINE> <COMMENT> <NL> def fact ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum += math . log ( i ) <NEWLINE> <DEDENT> return math . exp ( sum ) <NEWLINE> <COMMENT> <NL> <DEDENT> def fact2 ( n ) : <NEWLINE> <INDENT> return math . sqrt ( 2 * math . pi * n ) * ( n / math . exp ( 1 ) ) ** n <NEWLINE> <NL> <DEDENT> def mfactorial ( n , _factcache = { } ) : <NEWLINE> <INDENT> if n not in _factcache : <NEWLINE> <INDENT> _factcache [ n ] = math . factorial ( n ) <NEWLINE> <DEDENT> return _factcache [ n ] <NEWLINE> <NL> <NL> <DEDENT> n = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> if tmp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> f = mfactorial ( n [ i ] ) <NEWLINE> k = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if f % ( 10 ** k ) != 0 : <NEWLINE> <INDENT> print ( k - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> for n in sys . stdin : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( 1 , int ( n ) + 1 ) : <NEWLINE> <INDENT> j = i <NEWLINE> while j % 5 == 0 : <NEWLINE> <INDENT> j /= 5 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , i = int ( input ( ) ) , 0 <NEWLINE> if n == 0 : break <NEWLINE> n = str ( math . factorial ( n ) ) [ : : - 1 ] <NEWLINE> while n [ i ] == <STRING> : i += 1 <NEWLINE> print ( i ) <NEWLINE> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> x = math . factorial ( int ( input ( ) ) ) <NEWLINE> n = list ( str ( x ) ) <NEWLINE> con = 0 <NEWLINE> for i in range ( len ( n ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if n [ i ] != <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> con += 1 <NEWLINE> <DEDENT> print ( con ) <NEWLINE> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> e = int ( e ) <NEWLINE> print ( sum ( e // 5 ** ifor i in range ( 1 , 6 ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = 105000 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i + 1 , r , i + 1 ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> prime = [ 0 for i in range ( 10000 ) ] <NEWLINE> j = 0 <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> prime [ j ] = i + 1 <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print sum ( prime [ : n ] ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = 100000 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i + 1 , r , i + 1 ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i , num , sum = 0 , 0 , 0 <NEWLINE> while num < n : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> sum += i + 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
def sieve ( n ) : <NEWLINE> <INDENT> primes = [ True ] * n <NEWLINE> primes [ 0 ] = primes [ 1 ] = False <NEWLINE> for i in xrange ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in xrange ( i * i , n , i ) : <NEWLINE> <INDENT> primes [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return [ i for i in xrange ( n ) if primes [ i ] ] <NEWLINE> <NL> <DEDENT> prime_list = sieve ( 200000 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> prin <NEWLINE> t sum ( prime_list [ : a ] ) <NEWLINE> <DEDENT>
s = [ 0 ] <NEWLINE> M = 10001 <NEWLINE> p = [ 1 ] * M <NEWLINE> S = 0 <NEWLINE> for i in xrange ( 2 , M ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in xrange ( i * i , M , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> S += i ; s . append ( S ) <NEWLINE> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> print s [ n ] <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i + 1 , r , i + 1 ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s = [ 0 for i in range ( 11000 ) ] <NEWLINE> s [ 0 ] = 2 <NEWLINE> k = 1 <NEWLINE> for i in range ( 2 , r ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> s [ k ] = i + 1 + s [ k - 1 ] <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print s [ n - 1 ] <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> prime = [ 0 for i in range ( 11000 <NEWLINE> k = 0 <NEWLINE> r = 105000 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> prime [ k ] = i + 1 <NEWLINE> k += 1 <NEWLINE> l = i <NEWLINE> for j in range ( 2 * i + 1 , r , i + 1 ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( l , r ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> prime [ k ] = i + 1 <NEWLINE> k += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print sum ( prime [ : n ] ) <NEWLINE> <DEDENT>
def pri ( s , n ) : <NEWLINE> <INDENT> tab = [ i for i in range ( n + 1 ) if s [ i ] and i >= 2 ] <NEWLINE> return ( tab ) <NEWLINE> <NL> <DEDENT> s = [ True for _ in range ( 999999 + 1 ) ] <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= 999999 : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> j = i * 2 <NEWLINE> while j <= 999999 : <NEWLINE> <INDENT> s [ j ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> s = pri ( s , 10000 ) <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> sum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> sum += s [ i ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
Primes = [ ] <NEWLINE> def find_nth_prime ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> count = len ( Primes ) <NEWLINE> if count >= n : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if count > 0 : <NEWLINE> <INDENT> num = Primes [ - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = 2 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if is_prime ( num ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> Primes . append ( num ) <NEWLINE> <DEDENT> if count >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> num += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> while True : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> if data == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> find_nth_prime ( data ) <NEWLINE> <COMMENT> <NL> print ( sum ( Primes [ : data ] ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> primes = [ 2 ] <NEWLINE> n = 3 <NEWLINE> while n < 10000 : <NEWLINE> <INDENT> flag = True <NEWLINE> for p in primes : <NEWLINE> <INDENT> if n % p == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> primes . append ( n ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += primes [ i ] <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 2 or n == 3 : return True <NEWLINE> if n % 2 == 0 or n < 2 : return False <NEWLINE> for i in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <COMMENT> <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def make_primes ( ) : <NEWLINE> <INDENT> primes = [ 2 ] <NEWLINE> i = 3 <NEWLINE> while True : <NEWLINE> <INDENT> if is_prime ( i ) : <NEWLINE> <INDENT> primes . append ( i ) <NEWLINE> if len ( primes ) > 105000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> i += 2 <NEWLINE> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> primes = make_primes ( ) <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> subset = primes [ : n ] <NEWLINE> print ( sum ( subset ) ) <NEWLINE> <DEDENT>
isPrime = [ True ] * 10001 <NEWLINE> sum = 0 <NEWLINE> sumPrime = [ sum ] <NEWLINE> def calcPrime ( ) : <NEWLINE> <INDENT> global sum <NEWLINE> isPrime [ 0 ] = isPrime [ 1 ] = False <NEWLINE> for i in range ( len ( isPrime ) ) : <NEWLINE> <INDENT> if ( isPrime [ i ] ) : <NEWLINE> <INDENT> sum += i <NEWLINE> sumPrime . append ( sum ) <NEWLINE> for j in range ( 2 * i , len ( isPrime ) , i ) : <NEWLINE> <INDENT> isPrime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> calcPrime ( ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( sumPrime [ n ] ) <NEWLINE> <DEDENT>
s in sys . stdin : <NEWLINE> <INDENT> a , b , n = map ( int , s . split ( ) ) <NEWLINE> a = a % b <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a *= 10 <NEWLINE> s += a / b <NEWLINE> a %= b <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT>
import math <NEWLINE> r = 10000 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i + 1 , r , i + 1 ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i , num , sum = 0 , 1 , 0 <NEWLINE> while num < n : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> num += 1 <NEWLINE> sum += i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> num = raw_input ( ) . split ( <STRING> ) <NEWLINE> sum = 0 <NEWLINE> x = float ( num [ 0 ] ) / float ( num [ 1 ] ) <NEWLINE> if x < 1 : <NEWLINE> <INDENT> x = x + 1.0 <NEWLINE> <DEDENT> for var in range ( 1 , int ( num [ 2 ] ) + 1 ) : <NEWLINE> <INDENT> sum += int ( str ( x * 10 ** var ) [ var : var + 1 ] ) <NEWLINE> <NL> <DEDENT> print sum <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x = float ( input ( ) ) <NEWLINE> s = x <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> s = s * 2 <NEWLINE> x += s <NEWLINE> <DEDENT> if i % 2 == 1 : <NEWLINE> <INDENT> s = s / 3 <NEWLINE> x += s <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> t = [ a , <NEWLINE> a * 2 , <NEWLINE> a * 2 / 3 , <NEWLINE> a * 2 / 3 * 2 , <NEWLINE> a * 2 / 3 * 2 / 3 , <NEWLINE> a * 2 / 3 * 2 / 3 * 2 , <NEWLINE> a * 2 / 3 * 2 / 3 * 2 / 3 , <NEWLINE> a * 2 / 3 * 2 / 3 * 2 / 3 * 2 , <NEWLINE> a * 2 / 3 * 2 / 3 * 2 / 3 * 2 / 3 , <NEWLINE> a * 2 / 3 * 2 / 3 * 2 / 3 * 2 / 3 * 2 ] <NEWLINE> print ( sum ( t ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = float ( raw_input ( ) ) <NEWLINE> sum = a <NEWLINE> for i in range ( 2 , 11 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> a *= 2.0 <NEWLINE> sum += a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a /= 3.0 <NEWLINE> sum += a <NEWLINE> <DEDENT> <DEDENT> print sum <NEWLINE> <DEDENT>
def sieve ( m ) : <NEWLINE> <INDENT> N = range ( 1 , m + 2 , 2 ) <NEWLINE> r = int ( m ** .5 ) <NEWLINE> h = len ( N ) <NEWLINE> N [ 0 ] = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> x = N [ i ] <NEWLINE> if x > r : break <NEWLINE> if x and i + x < h : N [ i + x : h : x ] = [ 0 ] * ( ( h - 1 - i - x ) / x + 1 ) <NEWLINE> <DEDENT> return N <NEWLINE> <DEDENT> def f0056 ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> if n < 4 : x = 0 <NEWLINE> elif n == 4 : x = 1 <NEWLINE> elif n % 2 == 1 : <NEWLINE> <INDENT> if S [ ( n - 2 ) / 2 ] : <NEWLINE> <INDENT> x = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a = n / 2 <NEWLINE> for e in PRIMES : <NEWLINE> <INDENT> if e > a : break <NEWLINE> if S [ ( n - e ) / 2 ] : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> S = sieve ( 50000 ) <NEWLINE> PRIMES = filter ( None , S ) <NEWLINE> for n in sys . stdin : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> if n == 0 : break <NEWLINE> print f0056 ( n ) <NEWLINE> <DEDENT>
def pri ( t ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i ** 2 <= t : <NEWLINE> <INDENT> if t % i == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> for i in range ( 2 , 50100 ) : <NEWLINE> <INDENT> if pri ( i ) : <NEWLINE> <INDENT> l . append ( i ) <NEWLINE> <DEDENT> <DEDENT> s = 5143 <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> ans = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( s ) : <NEWLINE> <INDENT> if l [ i ] > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n - l [ i ] in l : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
MAX = 50001 <NEWLINE> <NL> is_prime = [ True for _ in range ( MAX ) ] <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( MAX ** ( 1 / 2 ) ) + 1 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> for j in range ( i ** 2 , MAX , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> primes = [ i for i in range ( MAX ) if is_prime [ i ] ] <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in primes_less_than_n : <NEWLINE> <INDENT> if is_prime [ n - i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from itertools import * <NEWLINE> <NL> def sieve ( n ) : <NEWLINE> <INDENT> a = range ( n ) <NEWLINE> a [ : 2 ] = None , None <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i ** 2 >= n : break <NEWLINE> if not a [ i ] : continue <NEWLINE> for i in range ( i ** 2 , n , i ) : <NEWLINE> <INDENT> a [ i ] = None <NEWLINE> <DEDENT> <DEDENT> return [ v for v in a if v ] <NEWLINE> <NL> <DEDENT> def isPrime ( p ) : <NEWLINE> <INDENT> if p < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in count ( 2 ) : <NEWLINE> <INDENT> if i * i > p : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if p % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = sieve ( 50000 ) <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> print 0 <NEWLINE> continue <NEWLINE> <DEDENT> ct = 0 <NEWLINE> for v in a : <NEWLINE> <INDENT> if v > n / 2 : break <NEWLINE> if isPrime ( n - v ) : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <DEDENT> <DEDENT> print ct <NEWLINE> <DEDENT>
import bisect , sys <NEWLINE> from itertools import * <NEWLINE> n = range ( 50001 ) ; a = list ( n ) ; a [ 1 ] = 0 <NEWLINE> for i in range ( 2 , 224 ) : a [ i * 2 : : i ] = [ 0 ] * len ( a [ i * 2 : : i ] ) <NEWLINE> p = list ( compress ( n , a ) ) <NEWLINE> for x in map ( int , sys . stdin ) : <NEWLINE> <INDENT> if x : print ( len ( 1 for d in p [ : bisect . bisect ( p , x // 2 ) ] if a [ x - d ] ) ) <NEWLINE> <DEDENT>
N = 50001 <NEWLINE> lst = [ True ] * N <NEWLINE> lst [ 0 ] = False <NEWLINE> lst [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if lst [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , N , i ) : <NEWLINE> <INDENT> lst [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> primes = [ i for i in range ( 1 , N ) if lst [ i ] ] <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n % 2 == 1 : <NEWLINE> <INDENT> if lst [ n - 2 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> elif n == 4 : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> counter = 0 <NEWLINE> for prime0 in primes : <NEWLINE> <INDENT> prime1 = n - prime0 <NEWLINE> if prime0 <= prime1 and lst [ prime1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( counter ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> MAX = 50001 <NEWLINE> HALF = 25000 <NEWLINE> <NL> prime = [ True ] * MAX <NEWLINE> def sieve ( max ) : <NEWLINE> <INDENT> for i in range ( 4 , max , 2 ) : <NEWLINE> <INDENT> prime [ i ] = False <NEWLINE> <DEDENT> sqrt = int ( max ** 0.5 ) <NEWLINE> print ( <STRING> , sqrt ) <NEWLINE> for i in range ( 3 , sqrt , 2 ) : <NEWLINE> <INDENT> if prime [ i ] is True : <NEWLINE> <INDENT> for j in range ( i * i , max , i ) : <NEWLINE> <INDENT> prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sieve ( MAX ) <NEWLINE> <NL> ans = [ 0 ] * ( MAX * 2 ) <NEWLINE> ans [ 4 ] = 1 <NEWLINE> for i in range ( 3 , MAX , 2 ) : <NEWLINE> <INDENT> if prime [ i ] : ans [ i + 2 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( 3 , HALF , 2 ) : <NEWLINE> <INDENT> if prime [ i ] : <NEWLINE> <INDENT> for j in range ( i , MAX , 2 ) : <NEWLINE> <INDENT> if prime [ j ] : ans [ i + j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( ans [ n ] ) <NEWLINE> <DEDENT>
def enum_prime ( m ) : <NEWLINE> <INDENT> L = [ True for _ in range ( m + 1 ) ] <NEWLINE> L [ 0 ] = L [ 1 ] = False <NEWLINE> <NL> for i in range ( 2 , m + 1 ) : <NEWLINE> <INDENT> if L [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , m + 1 , i ) : <NEWLINE> <INDENT> L [ j ] = False <NEWLINE> <DEDENT> if m < i * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <DEDENT> FLAGS = enum_prime ( 50000 ) <NEWLINE> PRIMES = [ i for i , isprime in enumerate ( FLAGS ) if isprime ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> n2 = n // 2 <NEWLINE> cnt = 0 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for p in PRIMES : <NEWLINE> <INDENT> if p > n2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if FLAGS [ n - p ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif FLAGS [ n - 2 ] : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> r = 50001 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i + 1 : : i + 1 ] = [ 0 for x in range ( 2 * i + 1 , r , i + 1 ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> prime = [ ] <NEWLINE> for i in range ( len ( p ) ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> prime . append ( i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in prime : <NEWLINE> <INDENT> if i > n / 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = n - i <NEWLINE> if prime . count ( m ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> maxnum = 50001 <NEWLINE> primes = [ True ] * maxnum <NEWLINE> primes [ 0 ] = primes [ 1 ] = False <NEWLINE> for i in xrange ( maxnum ) : <NEWLINE> <INDENT> if i >= maxnum ** 0.5 : break <NEWLINE> if not primes [ i ] : continue <NEWLINE> for j in xrange ( i * 2 , maxnum , i ) : primes [ j ] = False <NEWLINE> <NL> <DEDENT> p = [ i for i in xrange ( maxnum ) if primes [ i ] ] <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> d = int ( s ) <NEWLINE> if d == 0 : break <NEWLINE> q = [ i for i in p if i < d / 2 + 1 ] <NEWLINE> print sum ( [ 1 for i in q if primes [ d - i ] ] ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> def solv ( n ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if n % 2 == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> if binary_search ( primes , n - 2 ) : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for p in primes : <NEWLINE> <INDENT> if n / 2 < p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> q = n - p <NEWLINE> <COMMENT> <NL> if binary_search ( primes , q ) : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <NL> <DEDENT> def prime_list ( n ) : <NEWLINE> <INDENT> limit = int ( n ** 0.5 ) + 1 <NEWLINE> lis = range ( 1 , n + 1 , 2 ) <NEWLINE> lis [ 0 ] = 2 <NEWLINE> while True : <NEWLINE> <INDENT> if len ( lis ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = lis . pop ( 0 ) <NEWLINE> yield p <NEWLINE> if p <= limit : <NEWLINE> <INDENT> lis = [ x for x in lis if x % p != 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def binary_search ( lis , x ) : <NEWLINE> <INDENT> if len ( lis ) == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> i = len ( lis ) / 2 <NEWLINE> if lis [ i ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> elif x < lis [ i ] : <NEWLINE> <INDENT> return binary_search ( lis [ : i ] , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return binary_search ( lis [ i + 1 : ] , x ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> primes = [ ] <NEWLINE> for p in prime_list ( 50000 ) : <NEWLINE> <INDENT> primes . append ( p ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> print solv ( n ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> def enum_prime ( m ) : <NEWLINE> <INDENT> L = [ True for _ in xrange ( m + 1 ) ] <NEWLINE> L [ 0 ] = L [ 1 ] = False <NEWLINE> <NL> for i in xrange ( 2 , m + 1 ) : <NEWLINE> <INDENT> if not L [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in xrange ( i + i , m + 1 , i ) : <NEWLINE> <INDENT> L [ j ] = False <NEWLINE> <DEDENT> if m < i * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <DEDENT> P = enum_prime ( 50000 ) <NEWLINE> <NL> for line in stdin : <NEWLINE> <INDENT> if line . startswith ( <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( line ) <NEWLINE> cnt = 0 <NEWLINE> if n % 2 == 0 : <NEWLINE> <INDENT> for p , isprime in enumerate ( P ) : <NEWLINE> <INDENT> if not isprime : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if p + p > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if P [ n - p ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif P [ n - 2 ] : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
N = 50000 + 1 <NEWLINE> p = [ True ] * N <NEWLINE> p [ 0 ] , p [ 1 ] = False , False <NEWLINE> for i in xrange ( 2 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] == True : <NEWLINE> <INDENT> for j in xrange ( i ** 2 , N , i ) : <NEWLINE> <INDENT> p [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> c = 0 <NEWLINE> for i in xrange ( n / 2 + 1 ) : <NEWLINE> <INDENT> if p [ i ] and p [ n - i ] : c += 1 <NEWLINE> <DEDENT> print c <NEWLINE> <DEDENT>
import sys <NEWLINE> def sieve ( m ) : <NEWLINE> <INDENT> N = range ( 1 , m + 2 , 2 ) <NEWLINE> r = int ( m ** .5 ) <NEWLINE> h = len ( N ) <NEWLINE> N [ 0 ] = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> x = N [ i ] <NEWLINE> if x > r : break <NEWLINE> if x and i + x < h : N [ i + x : h : x ] = [ 0 ] * ( ( h - 1 - i - x ) / x + 1 ) <NEWLINE> <DEDENT> return N <NEWLINE> <DEDENT> def f0056 ( n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> b = n / 2 <NEWLINE> if n == 2 or n == 3 : return 1 <NEWLINE> if n % 2 == 1 : <NEWLINE> <INDENT> if n - 2 in PRIMES : x = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for e in PRIMES : <NEWLINE> <INDENT> if e > b : break <NEWLINE> if n - e in PRIMES : x += 1 <NEWLINE> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> SIEVES = sieve ( 50000 ) <NEWLINE> PRIMES = filter ( None , [ 2 ] + SIEVES ) <NEWLINE> for n in sys . stdin : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> if n == 0 : break <NEWLINE> print f0056 ( n ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def make_prime_list ( lim ) : <NEWLINE> <INDENT> lst = [ True for i in xrange ( lim + 1 ) ] <NEWLINE> <NL> num = 2 <NEWLINE> while num ** 2 <= lim : <NEWLINE> <INDENT> for i in xrange ( num * 2 , lim + 1 , num ) : <NEWLINE> <INDENT> lst [ i ] = False <NEWLINE> <DEDENT> num += 1 <NEWLINE> while not lst [ num ] : <NEWLINE> <INDENT> num += 1 <NEWLINE> <DEDENT> <DEDENT> return [ i for i in xrange ( 2 , lim + 1 ) if lst [ i ] ] <NEWLINE> <NL> <DEDENT> def binary_search ( n , prime_list ) : <NEWLINE> <INDENT> rLim = len ( prime_list ) - 1 <NEWLINE> lLim = 0 <NEWLINE> while lLim < rLim : <NEWLINE> <INDENT> middle = ( rLim + lLim ) / 2 <NEWLINE> if prime_list [ middle ] == n : <NEWLINE> <INDENT> return middle <NEWLINE> <DEDENT> elif prime_list [ middle ] < n : <NEWLINE> <INDENT> lLim = middle + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rLim = middle - 1 <NEWLINE> <DEDENT> <DEDENT> while prime_list [ rLim ] < n and rLim < len ( prime_list ) - 1 : <NEWLINE> <INDENT> rLim += 1 <NEWLINE> <DEDENT> return rLim <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> prime_list = make_prime_list ( 50000 ) <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n > 0 : <NEWLINE> <INDENT> count = 0 <NEWLINE> index = 0 <NEWLINE> rev_index = binary_search ( n , prime_list ) <NEWLINE> while index <= rev_index : <NEWLINE> <INDENT> while prime_list [ index ] + prime_list [ rev_index ] > n : <NEWLINE> <INDENT> rev_index -= 1 <NEWLINE> <DEDENT> if prime_list [ index ] + prime_list [ rev_index ] == n : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> index += 1 <NEWLINE> <DEDENT> print count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
n = 50001 <NEWLINE> is_prime = [ True for i in range ( n ) ] <NEWLINE> is_prime [ 0 ] = is_prime [ 1 ] = False <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= n : <NEWLINE> <INDENT> j = i * 2 <NEWLINE> while j < n : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> cnt_pair = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( 3 , n // 2 , 2 ) : <NEWLINE> <INDENT> if is_prime [ i ] : <NEWLINE> <INDENT> for j in range ( i , n - i , 2 ) : <NEWLINE> <INDENT> if is_prime [ j ] : <NEWLINE> <INDENT> cnt_pair [ i + j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( cnt_pair [ n ] ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> lc = lambda n : int ( ( n ** 2 + n + 2 ) / 2 ) <NEWLINE> [ print ( i ) for i in [ lc ( int ( j ) ) for j in sts . stdin ] ] <NEWLINE>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> print ( a ** 2 + a + 2 ) / 2 <NEWLINE> <NL> <DEDENT> except EOFError : break <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> data = int ( raw_input ( ) ) <NEWLINE> print ( countArea ( data ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def countArea ( n ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return countArea ( n - 1 ) + n <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> xA , yA , xB , yB , xC , yC , xD , yD = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> if ( yB - yA ) * ( yD - yC ) + ( xB - xA ) * ( xD - xC ) == 0.0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> else : <NEWLINE> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def solve ( xa , ya1 , xa1 , ya2 , xb1 , yb1 , xb2 , yb2 ) : <NEWLINE> <INDENT> if xb2 < xa1 or xb1 > xa2 or yb2 < ya1 or yb1 > yb2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> xa , ya1 , xa1 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , input ( ) . split ( ) ) <NEWLINE> solve ( xa , ya1 , xa1 , ya2 , xb1 , yb1 , xb2 , yb2 ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> for line in sys . stdin : <NEWLINE> <INDENT> xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , line . split ( <STRING> ) ) <NEWLINE> if ( ( xb1 <= xa1 and xa1 <= xb2 ) or ( xa1 <= xb1 and xb1 <= xa2 ) ) and ( ( yb1 <= ya2 and ya2 <= yb2 ) or ( ya1 <= yb2 and yb2 <= ya2 ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def Check ( xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 ) <NEWLINE> <COMMENT> <NL> <INDENT> if xb1 <= xa1 <= xb2 and yb1 <= ya2 <= yb2 : <NEWLINE> <INDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> if xb1 <= xa2 <= xb2 and yb1 <= ya2 <= yb2 : <NEWLINE> <INDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> if xb1 <= xa1 <= xb2 and yb1 <= ya1 <= yb2 : <NEWLINE> <INDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> if xb1 <= xa2 <= xb2 and yb1 <= ya1 <= yb2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> if Check ( xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 ) else <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> <NL> def take2 ( iterable ) : <NEWLINE> <INDENT> i = iter ( iterable ) <NEWLINE> while True : <NEWLINE> <INDENT> yield next ( i ) , next ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for line in f : <NEWLINE> <INDENT> a1 , a2 , b1 , b2 = [ x + y * 1j for x , y in take2 ( map ( float , line . split ( ) ) ) ] <NEWLINE> <NL> if ( min ( a1 . real , a2 . real ) <= b1 . real <= max ( a1 . real , a2 . real ) or ( min ( a1 . real , a2 . real ) <= b2 . real <= max ( a1 . real , a2 . real ) ) ) and <NEWLINE> ( min ( a1 . imag , a2 . imag ) <= b1 . imag <= max ( a1 . imag , a2 . imag ) or ( min ( a1 . imag , a2 . imag ) <= b2 . imag <= max ( a1 . imag , a2 . imag ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> for line in sys . stdin . readline ( ) : <NEWLINE> <INDENT> xa1 , ya1 , xa2 , ya2 , xb1 , yb1 , xb2 , yb2 = map ( float , line . rstrip ( <STRING> ) . split ( <STRING> ) ) <NEWLINE> if ( ( xb1 <= xa1 and xa1 <= xb2 ) or ( xa1 <= xb1 and xb1 <= xa2 ) ) and ( ( yb1 <= ya2 and ya2 <= yb2 ) or ( ya1 <= yb2 and yb2 <= ya2 ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = [ i + 1 for i in range ( 10 ) ] <NEWLINE> try : b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> except : break <NEWLINE> for i in b : a . remove ( b ) <NEWLINE> print ( <STRING> if sum ( [ 1 for i in a if i <= 20 - sum ( b [ : 2 ] ) ] ) / 7 >= 0.5 else <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> c1 , c2 , c3 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> deck = [ i for i in range ( 1 , 11 ) if i != c1 and i != c2 and i != c3 ] <NEWLINE> if 20 - c1 - c2 > max ( deck ) or 20 - c1 - c2 == c3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l = [ True ] * 11 <NEWLINE> l [ a ] = l [ b ] = l [ c ] = False <NEWLINE> sum = a + b <NEWLINE> over = 0 <NEWLINE> <NL> fpr i in range ( 1 , 11 ) : <NEWLINE> <INDENT> if l [ i ] : <NEWLINE> <INDENT> if sum + i >= 20 : <NEWLINE> <INDENT> over += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if over / 7 < 0.5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def drawone ( f ) : <NEWLINE> <INDENT> v = list ( range ( 1 , 11 ) ) <NEWLINE> for i in f : <NEWLINE> <INDENT> v . remove ( i ) <NEWLINE> <DEDENT> win = 0 <NEWLINE> lose = 0 <NEWLINE> for i in v : <NEWLINE> <INDENT> if i + sum ( f [ : 2 ] ) <= 20 : <NEWLINE> <INDENT> win += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lose += 1 <NEWLINE> <DEDENT> <DEDENT> return ( True if win >= lose else False ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> f = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> if drawone ( f ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for x in sys . stdin : <NEWLINE> <INDENT> a , b , c = list ( map ( int , x . split ( ) ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ len ( set ( range ( 1 , 21 - sum ( a , b ) ) ) - { a , b , c } ) / 7 < .5 ] ) <NEWLINE> <DEDENT>
team = [ 0 for i in range ( 101 ) ] <NEWLINE> point = [ [ 0 for i in range ( 2 ) ] for i in range ( 31 ) ] <NEWLINE> while 1 : <NEWLINE> <INDENT> temp = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if temp [ 0 ] == 0 == temp [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> team [ temp [ 0 ] ] = temp [ 1 ] <NEWLINE> if point [ temp [ 1 ] ] [ 1 ] == 0 : <NEWLINE> <INDENT> point [ temp [ 1 ] ] [ 1 ] = 1 <NEWLINE> for i in range ( temp [ 1 ] + 1 ) : <NEWLINE> <INDENT> point [ i ] [ 0 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> print point [ team [ n ] ] [ 0 ] <NEWLINE> <DEDENT> except EOFerror : <NEWLINE> break <NEWLINE> <DEDENT>
def suicide ( lis ) : <NEWLINE> <INDENT> if len ( lis ) == 1 : <NEWLINE> <INDENT> print lis [ 0 ] <NEWLINE> <DEDENT> pokakito = [ ] <NEWLINE> for i in range ( len ( lis ) - 1 ) : <NEWLINE> <INDENT> check = lis [ i ] + lis [ i + 1 ] <NEWLINE> one = int ( str ( check ) [ - 1 ] ) <NEWLINE> pokakito . append ( one ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> suicide ( pokakito ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lis = [ int ( char ) for char in raw_input ( ) ] <NEWLINE> suicide ( lis ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> while len ( s ) != 1 : <NEWLINE> <INDENT> _new = [ ] <NEWLINE> for i in range ( len ( s ) - 1 ) : <NEWLINE> <INDENT> t = str ( int ( s [ i ] ) + int ( s [ i + 1 ] ) ) <NEWLINE> _new . append ( t if len ( t ) == 1 else t [ 1 ] ) <NEWLINE> <DEDENT> s = <STRING> . join ( _new ) <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> x = map ( int , list ( str ( s ) ) [ : - 1 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> a = len ( x ) <NEWLINE> x = [ ( x [ i ] + x [ i + 1 ] ) % 10 for i in range ( a - 1 ) ] <NEWLINE> if a == 1 : break <NEWLINE> <DEDENT> print x [ 0 ] <NEWLINE> <DEDENT>
import sys <NEWLINE> for rec in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> while len ( d ) > 1 : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for i in range ( 1 , len ( d ) ) : <NEWLINE> <INDENT> tmp . append ( ( d [ i - 1 ] + d [ i ] ) % 10 ) <NEWLINE> <DEDENT> d = tmp <NEWLINE> <DEDENT> print d [ 0 ] <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> numbers = map ( int , raw_input ( ) ) <NEWLINE> dp = [ [ 0 ] * 10 for _ in xrange ( 10 ) ] <NEWLINE> dp [ 0 ] = numbers <NEWLINE> for i in xrange ( 9 ) : <NEWLINE> <INDENT> for j in xrange ( len ( dp [ i ] ) - 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = ( dp [ i ] [ j ] + dp [ i ] [ j + 1 ] ) % 10 <NEWLINE> <DEDENT> <DEDENT> print dp [ - 1 ] [ 0 ] <NEWLINE> <DEDENT>
count = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s_lis1 = list ( raw_input ( ) ) <NEWLINE> s_lis2 = s_lis1 [ : ] <NEWLINE> s_lis2 . reverse ( ) <NEWLINE> if s_lis1 == s_lis2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> print count <NEWLINE> <DEDENT> <DEDENT>
c = 0 <NEWLINE> try : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s [ : : - 1 ] == s : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print c <NEWLINE>
count = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> b = a [ : : - 1 ] <NEWLINE> if a == b : count += 1 <NEWLINE> print count <NEWLINE> <NL> <DEDENT>
from math import * <NEWLINE> PI = 3.1415926535898 <NEWLINE> ans = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> t = <STRING> <NEWLINE> for x in s : <NEWLINE> <INDENT> if x . isdigit ( ) : <NEWLINE> <INDENT> t += x <NEWLINE> <DEDENT> elif len ( t ) > 0 and t [ len ( t ) - 1 ] . isdigit ( ) : <NEWLINE> <INDENT> t += <STRING> <NEWLINE> <DEDENT> <DEDENT> arr = map ( int , t . strip ( ) . split ( <STRING> ) ) <NEWLINE> for x in arr : <NEWLINE> <INDENT> ans += x <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
s = <STRING> . join ( [ s for s in sys . stdin ] ) <NEWLINE> p = re . compile ( <STRING> ) <NEWLINE> x = p . findall ( s ) <NEWLINE> print sum ( map ( int , x ) ) <NEWLINE>
ans = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> memo = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for m in memo : <NEWLINE> <INDENT> ans = ans + m if m . isdigit ( ) else ans + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans . replace ( <STRING> , <STRING> ) . split ( ) ) ) <NEWLINE>
import re <NEWLINE> try : <NEWLINE> <INDENT> ls = num = [ ] <NEWLINE> result = 0 <NEWLINE> while True : <NEWLINE> <INDENT> ls . append ( input ( ) ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> for i in ls : <NEWLINE> <INDENT> for s in range ( re . findall ( <STRING> , i ) ) : <NEWLINE> <INDENT> result += int ( s ) <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
import re , sys <NEWLINE> print sum ( map ( int , re . sub ( <STRING> , <STRING> , sys . stdin . readlines ( ) ) . strip ( ) . split ( ) ) ) <NEWLINE>
import sys <NEWLINE> b = 0 <NEWLINE> a = [ { } , { } ] <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e : b = 1 <NEWLINE> else : c = int ( e . split ( <STRING> ) [ 0 ] ) ; a [ b ] [ c ] = 1 + [ 0 , a [ b ] [ c ] ] [ c in a [ b ] ] <NEWLINE> <DEDENT> for k in sorted ( { * a [ 0 ] } & { * a [ 1 ] } ) : print ( k , a [ 0 ] [ k ] + a [ 1 ] [ k ] ) <NEWLINE>
dt = { } <NEWLINE> def loop ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> c , d = map ( int , line . split ( <STRING> ) ) <NEWLINE> dt [ c ] = [ d ] if c not in dt else dt [ c ] + [ d ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> loop ( ) <NEWLINE> loop ( ) <NEWLINE> for ab in sorted ( dt . items ( ) , key = lambda x : x [ 0 ] ) : <NEWLINE> <INDENT> a , b = ab [ 0 ] , ab [ 1 ] <NEWLINE> if len ( b ) > 1 : <NEWLINE> <INDENT> print ( a , len ( b ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> b = 0 <NEWLINE> a = [ { } , { } ] <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e : b = 1 <NEWLINE> else : c = int ( e . split ( <STRING> ) [ 0 ] ) <NEWLINE> <INDENT> if c in a [ b ] : a [ b ] [ c ] += 1 <NEWLINE> else : a [ b ] [ c ] = 1 <NEWLINE> <DEDENT> <DEDENT> for k in sorted ( { * a [ 0 ] } & { * a [ 1 ] } ) : print ( k , a [ 0 ] [ k ] + a [ 1 ] [ k ] ) <NEWLINE>
old = [ ] <NEWLINE> new = [ ] <NEWLINE> ans = [ ] <NEWLINE> t = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = input ( ) . split ( <STRING> ) [ 0 ] <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> if t : <NEWLINE> <INDENT> t = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if t : <NEWLINE> <INDENT> old . append ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new . append ( n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for o in set ( old ) : <NEWLINE> <INDENT> if o in new : <NEWLINE> <INDENT> s = old . count ( o ) + new . count ( o ) <NEWLINE> ans . append ( [ int ( o ) , int ( s ) ] ) <NEWLINE> <DEDENT> <DEDENT> ans . sort ( ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print ( <STRING> % ( a [ 0 ] , a [ 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> b = 0 <NEWLINE> a = [ { } , { } ] <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e : b = 1 <NEWLINE> else : c_ = e . split ( <STRING> ) ; c = int ( c ) ; a [ b ] . setdefault ( c , 0 ) ; a [ b ] [ c ] += 1 <NEWLINE> <DEDENT> for k in sorted ( { * a [ 0 ] } & { * a [ 1 ] } ) : print ( k , a [ 0 ] [ k ] + a [ 1 ] [ k ] ) <NEWLINE>
import sys <NEWLINE> C = range ( 1000 ) <NEWLINE> m = 0 <NEWLINE> d = [ [ 0 for i in C ] for j in range ( 2 ) ] <NEWLINE> for s in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> if s == <STRING> : m += 1 <NEWLINE> else : <NEWLINE> <INDENT> a , b = map ( int , s . split ( <STRING> ) ) <NEWLINE> d [ m ] [ a ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in C : <NEWLINE> <INDENT> a = d [ 0 ] [ i ] <NEWLINE> b = d [ 1 ] [ i ] <NEWLINE> if a != 0 and b != 0 : print i , a + b <NEWLINE> <DEDENT>
dict1 = { } <NEWLINE> dict2 = { } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> log = raw_input ( ) <NEWLINE> if len ( log ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> log = log . split ( <STRING> ) [ 0 ] <NEWLINE> <NL> if log in dict1 : <NEWLINE> <INDENT> dict1 [ log ] = dict1 [ log ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict1 [ log ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> log = raw_input ( ) <NEWLINE> <NL> log = log . split ( <STRING> ) [ 0 ] <NEWLINE> <NL> if log in dict2 : <NEWLINE> <INDENT> dict2 [ log ] = dict2 [ log ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict2 [ log ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> list = dict1 . keys ( ) <NEWLINE> <NL> for var in list : <NEWLINE> <INDENT> if dict1 [ var ] > 0 and dict2 [ var ] > 0 : <NEWLINE> <INDENT> print var , dict1 [ var ] + dict2 [ var ] <NEWLINE> <DEDENT> <DEDENT>
from collections import Counter <NEWLINE> <NL> cnt = 0 <NEWLINE> trade = Counter ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if not line : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> a , b = map ( int , line . split ( <STRING> ) ) <NEWLINE> trade [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in xrange ( cnt ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> trade [ a ] += 1 <NEWLINE> <NL> <DEDENT> for k , v in sorted ( trade . items ( ) ) : <NEWLINE> <INDENT> print k , v <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> vlines = [ [ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] , [ 0 , 3 , 6 ] , [ 1 , 4 , 7 ] , [ 2 , 5 , 8 ] , [ 0 , 4 , 8 ] , [ 2 , 4 , 6 ] ] <NEWLINE> <NL> for line in f : <NEWLINE> <INDENT> result = <STRING> <NEWLINE> for v in vlines : <NEWLINE> <INDENT> if <STRING> != a and line [ v [ 0 ] ] == line [ v [ 1 ] ] == line [ v [ 2 ] ] : <NEWLINE> <INDENT> result = line [ v [ 0 ] ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <DEDENT>
ok = [ [ 0 , 4 , 8 ] , [ 2 , 4 , 6 ] , [ 0 , 1 , 2 ] , [ 3 , 4 , 5 ] , [ 6 , 7 , 8 ] , [ 0 , 3 , 6 ] , [ 1 , 4 , 7 ] , [ 2 , 5 , 8 ] ] <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if len ( s ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flag = False <NEWLINE> for i in ok : <NEWLINE> <INDENT> if s [ i [ 0 ] ] == s [ i [ 1 ] ] == s [ i [ 2 ] ] and s [ i [ 0 ] ] != <STRING> : <NEWLINE> <INDENT> print ( s [ i [ 0 ] ] ) <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def marubatu ( ) : <NEWLINE> <INDENT> N = list ( input ( ) ) <NEWLINE> for koma in [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> if N [ i : 9 : 3 ] . count ( koma ) == 3 or N [ 3 * i : 3 * i + 3 ] . count ( koma ) == 3 : return koma <NEWLINE> <DEDENT> if N [ 0 : 9 : 4 ] . count ( koma ) == 3 or N [ 2 : 7 : 2 ] . count ( koma ) == 3 : return koma <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> print ( marubatu ( ) ) <NEWLINE> <DEDENT>
l = 12 <NEWLINE> def island ( f , x , y , m ) : <NEWLINE> <INDENT> rf = f [ : ] [ : ] <NEWLINE> if rf [ y ] [ x ] == 1 : <NEWLINE> <INDENT> rf [ y ] [ x ] = m <NEWLINE> for i in [ - 1 , 1 ] : <NEWLINE> <INDENT> if 0 <= x + i <= l - 1 : <NEWLINE> <INDENT> rf = island ( rf , x + i , y , m ) <NEWLINE> <DEDENT> if 0 <= y + i <= l - 1 : <NEWLINE> <INDENT> rf = island ( rf , x , y + i , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return rf <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> f = [ ] <NEWLINE> <NL> for i in range ( l ) : <NEWLINE> <INDENT> f . append ( map ( int , list ( raw_input ( ) ) ) ) <NEWLINE> <DEDENT> for y in range ( l ) : <NEWLINE> <INDENT> for x in range ( l ) : <NEWLINE> <INDENT> f = island ( f , x , y , m ) <NEWLINE> m += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> m , ans = 2 , [ ] <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> for j in range ( l ) : <NEWLINE> <INDENT> ans . append ( f [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print len ( list ( set ( ans ) ) ) - 1 <NEWLINE> <NL> try : raw_input ( ) <NEWLINE> except : break <NEWLINE> <DEDENT>
File Edit Options Buffers Tools Python Help <NEWLINE> def island ( f , x , y , m ) : <NEWLINE> <INDENT> if f [ y ] [ x ] == 1 : <NEWLINE> <INDENT> f [ y ] [ x ] = m <NEWLINE> for i in [ - 1 , 1 ] : <NEWLINE> <INDENT> if 0 <= x + i <= 11 : <NEWLINE> <INDENT> f = island ( f , x + i , y , m ) <NEWLINE> <DEDENT> if 0 <= y + i <= 11 : <NEWLINE> <INDENT> f = island ( f , x , y + i , m ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return f <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> f = [ ] ; m = 2 <NEWLINE> for i in range ( 12 ) : <NEWLINE> <INDENT> f . append ( map ( int , list ( raw_input ( ) ) ) ) <NEWLINE> <DEDENT> for y in range ( 12 ) : <NEWLINE> <INDENT> for x in range ( 12 ) : <NEWLINE> <INDENT> if f [ y ] [ x ] : <NEWLINE> <INDENT> f = island ( f , x , y , m ) <NEWLINE> m += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for i in range ( 12 ) : <NEWLINE> <INDENT> for j in range ( 12 ) : <NEWLINE> <INDENT> ans . append ( f [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> ans = list ( set ( ans ) ) <NEWLINE> print len ( ans ) - 1 * ans . count ( 0 ) <NEWLINE> try : raw_input ( ) <NEWLINE> except : break <NEWLINE> <DEDENT>
def counter ( ) : <COMMENT> <NEWLINE> <INDENT> count = 0 <NEWLINE> <COMMENT> <NL> for x in range ( 12 ) : <NEWLINE> <INDENT> for y in range ( 12 ) : <NEWLINE> <INDENT> if is_data [ x ] [ y ] == 1 : <COMMENT> <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> dfs ( x , y ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <DEDENT> def dfs ( x , y ) : <NEWLINE> <INDENT> if x < 0 or x == len ( is_data [ x ] ) or y < 0 or y == len ( is_data ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if is_data [ x ] [ y ] == 1 : <NEWLINE> <INDENT> is_data [ x ] [ y ] = 0 <NEWLINE> dfs ( x + 1 , y ) <NEWLINE> dfs ( x , y + 1 ) <NEWLINE> dfs ( x - 1 , y ) <NEWLINE> dfs ( x , y - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> is_data = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> s = input ( ) <COMMENT> <NEWLINE> if not s : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> is_data . append ( s ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( is_data ) ) : <NEWLINE> <INDENT> is_data [ i ] = list ( map ( int , is_data [ i ] ) ) <NEWLINE> <DEDENT> is_data = np . array ( is_data ) . reshape ( 12 , 12 ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> print ( counter ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def f ( y , x ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> if m [ y ] [ x ] == 1 : <NEWLINE> <INDENT> m [ y ] [ x ] = c <NEWLINE> f = 1 <NEWLINE> <DEDENT> return f <NEWLINE> <DEDENT> def LR ( y , x , dx ) : <NEWLINE> <INDENT> P = [ ] <NEWLINE> x += dx <NEWLINE> while 0 <= x < 12 and m [ y ] [ x ] != 0 : <NEWLINE> <INDENT> if f ( y , x ) : P += [ ( y , x ) ] <NEWLINE> x += dx <NEWLINE> <DEDENT> return P <NEWLINE> <DEDENT> def UD ( y , x , dy ) : <NEWLINE> <INDENT> P = [ ] <NEWLINE> y += dy <NEWLINE> while 0 <= y < 12 and m [ y ] [ x ] != 0 : <NEWLINE> <INDENT> if f ( y , x ) : P += [ ( y , x ) ] <NEWLINE> y += dy <NEWLINE> <DEDENT> return P <NEWLINE> <DEDENT> def v1 ( buf ) : <NEWLINE> <INDENT> f = 0 <NEWLINE> while len ( buf ) > 0 : <NEWLINE> <INDENT> f = 1 <NEWLINE> y , x = buf . pop ( ) <NEWLINE> m [ y ] [ x ] = c <NEWLINE> <DEDENT> <DEDENT> buf = list ( set ( buf + LR ( y , x , - 1 ) + LR ( y , x , 1 ) + UD ( y , x , - 1 ) + UD ( y , x , 1 ) ) ) <NEWLINE> <INDENT> return f <NEWLINE> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> global c <NEWLINE> buf = [ ] <NEWLINE> c = 2 <NEWLINE> for i in A : <NEWLINE> <INDENT> x = m [ i ] <NEWLINE> while x . count ( 1 ) > 0 : <NEWLINE> <INDENT> buf += [ ( i , x . index ( 1 ) ) ] <NEWLINE> if v1 ( buf ) : c += 1 <NEWLINE> <DEDENT> <DEDENT> return c - 2 <NEWLINE> <DEDENT> A = range ( 12 ) <NEWLINE> m = [ [ 0 for x in A ] for y in A ] <NEWLINE> y = 0 <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> if y < 12 : <NEWLINE> <INDENT> x = 0 <NEWLINE> for e in map ( int , list ( s [ : - 1 ] ) ) : <NEWLINE> <INDENT> m [ y ] [ x ] = e <NEWLINE> x += 1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print solve ( ) <NEWLINE> y = 0 <NEWLINE> <DEDENT> <DEDENT> print solve ( ) <NEWLINE>
ID = 0 <NEWLINE> def dfs ( row , col ) : <NEWLINE> <INDENT> global ID <NEWLINE> if islands [ row ] [ col ] == 1 : <NEWLINE> <INDENT> islandsID [ row ] [ col ] == ID <NEWLINE> if row < 11 : <NEWLINE> <INDENT> dfs ( row + 1 , col ) <NEWLINE> <DEDENT> if row > 0 : <NEWLINE> <INDENT> dfs ( row - 1 , col ) <NEWLINE> <DEDENT> if col < 11 : <NEWLINE> <INDENT> dfs ( row , col + 1 ) <NEWLINE> <DEDENT> if col > 0 : <NEWLINE> <INDENT> dfs ( row , col - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> c = 0 <NEWLINE> islands = [ ] <NEWLINE> islandsID = [ ] <NEWLINE> for i in range ( 12 ) : <NEWLINE> <INDENT> islands . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> for _ in range ( 12 ) : <NEWLINE> <INDENT> islandsID . append ( [ 0 for i in range ( 12 ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> for j in range ( 12 ) : <NEWLINE> <INDENT> if islands [ i ] [ j ] == 1 and islandsID [ i ] [ j ] == 0 : <NEWLINE> <INDENT> ID += 1 <NEWLINE> <DEDENT> dfs ( i , j ) <NEWLINE> <DEDENT> <DEDENT> print ( ID ) <NEWLINE> try : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def dfs ( i , j , m ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> m [ i ] [ j ] = 0 <NEWLINE> for di , dj in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] : <NEWLINE> <INDENT> ni = i + di <NEWLINE> nj = j + dj <NEWLINE> if ni in range ( 12 ) and nj in range ( 12 ) and m [ ni ] [ nj ] == 1 : <NEWLINE> <INDENT> dfs ( ni , nj , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> m = [ ] <NEWLINE> for i in range ( 12 ) : <NEWLINE> <INDENT> m . append ( list ( map ( int , list ( input ( ) ) ) ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( 12 ) : <NEWLINE> <INDENT> for j in range ( 12 ) : <NEWLINE> <INDENT> if m [ i ] [ j ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> dfs ( i , j , m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> input ( ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> while 1 : <NEWLINE> <INDENT> global a , c <NEWLINE> c = np . array ( [ [ 0 ] * 14 ] * 14 ) <NEWLINE> a = np . array ( [ [ 0 ] * 14 ] * 14 ) <NEWLINE> a [ 1 : - 1 , 1 : - 1 ] = [ list ( map ( int , list ( input ( ) ) ) ) for i in range ( 12 ) ] <NEWLINE> <NL> <NL> def dfs ( x , y , n ) : <NEWLINE> <INDENT> if c [ x ] [ y ] == 0 and a [ x ] [ y ] == 1 : <NEWLINE> <INDENT> c [ x ] [ y ] = n <NEWLINE> [ dfs ( x + i , y + j , n ) for i , j in [ ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 0 , 1 ) ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> [ [ dfs ( x , y , 12 * x + y ) for x in range ( 1 , 12 + 1 ) ] for y in range ( 1 , 12 + 1 ) ] <NEWLINE> flat = [ a for b in c for a in b ] <NEWLINE> print ( len ( set ( flat ) ) - 1 ) <NEWLINE> if input ( ) is None : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
dx , dy = [ - 1 , 0 , 1 , 0 ] , [ 0 , - 1 , 0 , 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> ans = 0 <NEWLINE> try : <NEWLINE> <INDENT> m = [ <STRING> * 14 ] + [ <STRING> + raw_input ( ) + <STRING> for i in xrange ( 12 ) ] + [ <STRING> * 14 ] <NEWLINE> f = [ [ False for i in xrange ( 14 ) ] for j in xrange ( 14 ) ] <NEWLINE> for y in xrange ( 1 , 13 ) : <NEWLINE> <INDENT> for x in xrange ( 1 , 13 ) : <NEWLINE> <INDENT> if m [ y ] [ x ] == <STRING> and f [ y ] [ x ] == False : <NEWLINE> <INDENT> q = [ [ x , y ] ] <NEWLINE> f [ y ] [ x ] = True <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> px , py = q . pop ( 0 ) <NEWLINE> for k in xrange ( 4 ) : <NEWLINE> <INDENT> nx = px + dx [ k ] ; ny = py + dy [ k ] ; <NEWLINE> if m [ ny ] [ nx ] == <STRING> and f [ ny ] [ nx ] == False : <NEWLINE> <INDENT> f [ ny ] [ nx ] = True <NEWLINE> q . append ( [ nx , ny ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
dx = [ 0 , 0 , - 1 , 1 ] <NEWLINE> dy = [ 1 , - 1 , 0 , 0 ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> map = [ ] <NEWLINE> count = 0 <NEWLINE> try : <NEWLINE> <INDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> map . append ( [ x for x in input ( ) ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 12 ) : <NEWLINE> <INDENT> for j in range ( 12 ) : <NEWLINE> <INDENT> if map [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dfs ( map , j , i ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs ( map , x , y ) : <NEWLINE> <INDENT> if x < 0 or y < 0 or x >= 12 or y >= 12 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> map [ y ] [ x ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> next_x = x + dx [ i ] <NEWLINE> next_y = y + dy [ i ] <NEWLINE> if next_x >= 0 and next_x < 12 and next_y >= 0 and next_y < 12 : <NEWLINE> <INDENT> if map [ next_y ] [ next_x ] == <STRING> : <NEWLINE> <INDENT> dfs ( map , next_x , next_y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def quartet ( h , w ) : <NEWLINE> <INDENT> global flag <NEWLINE> if 0 <= h <= 11 and 0 <= w <= 11 : <NEWLINE> <INDENT> if mapp [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> mapp [ h ] [ w ] = <STRING> <NEWLINE> flag = True <NEWLINE> bigbang ( h , w ) <NEWLINE> <DEDENT> elif mapp [ h ] [ w ] == <STRING> or mapp [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> def bigbang ( h , w ) : <NEWLINE> <INDENT> quartet ( h , w + 1 ) <NEWLINE> quartet ( h - 1 , w ) <NEWLINE> quartet ( h , w - 1 ) <NEWLINE> quartet ( h + 1 , w ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> mapp = [ ] <NEWLINE> for i in range ( 12 ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> lis = [ ] <NEWLINE> for char in line : <NEWLINE> <INDENT> lis . append ( char ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mapp . append ( lis ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> count = 0 <NEWLINE> for h in range ( 12 ) : <NEWLINE> <INDENT> for w in range ( 12 ) : <NEWLINE> <INDENT> quartet ( h , w ) <NEWLINE> if flag == True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> flag = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print count <NEWLINE> <DEDENT> if raw_input == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> <NL> def deg ( v1 , v2 ) : <NEWLINE> <INDENT> normv1 = math . sqrt ( v1 [ 0 ] ** 2 + v1 [ 1 ] ** 2 ) <NEWLINE> normv2 = math . sqrt ( v2 [ 0 ] ** 2 + v2 [ 1 ] ** 2 ) <NEWLINE> if normv1 == 0 or normv2 == 0 : <NEWLINE> <INDENT> print <STRING> ; exit ( ) <NEWLINE> <DEDENT> return ( v1 [ 0 ] * v2 [ 0 ] + v1 [ 1 ] * v2 [ 1 ] ) / ( normv1 * normv2 ) <NEWLINE> <NL> <DEDENT> def calc_hull ( d ) : <NEWLINE> <INDENT> hull = [ ] <NEWLINE> point_first = d [ 0 ] <NEWLINE> hull . append ( point_first ) <NEWLINE> v = [ 1 , 0 ] <NEWLINE> oldpoint = point_first <NEWLINE> while True : <NEWLINE> <INDENT> minipoint = 0 ; <NEWLINE> minv = [ 0 , 0 ] <NEWLINE> maxcos = - 1 <NEWLINE> for p in d : <NEWLINE> <INDENT> if p == oldpoint : continue <NEWLINE> o = [ p [ i ] - oldpoint [ i ] for i in xrange ( 2 ) ] <NEWLINE> cos = deg ( o , v ) <NEWLINE> if cos > maxcos : <NEWLINE> <INDENT> maxcos = cos <NEWLINE> minv = o <NEWLINE> minpoint = p <NEWLINE> <DEDENT> <DEDENT> if minpoint == point_first : break <NEWLINE> v = minv <NEWLINE> oldpoint = minpoint <NEWLINE> hull . append ( minpoint ) <NEWLINE> <DEDENT> return hull <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> d = [ ] <NEWLINE> for t in xrange ( n ) : <NEWLINE> <INDENT> d . append ( map ( float , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> h = calc_hull ( sorted ( d , key = lambda x : - x [ 1 ] ) ) <NEWLINE> print len ( d ) - len ( calc_hull ( d ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def side ( p1 , p2 ) : <NEWLINE> <INDENT> global D <NEWLINE> y1 , x1 = p1 <NEWLINE> y2 , x2 = p2 <NEWLINE> dy = y2 - y1 <NEWLINE> dx = x2 - x1 <NEWLINE> for p3 in D [ : : - 1 ] : <NEWLINE> <INDENT> if p1 == p3 or p2 == p3 : pass <NEWLINE> y3 , x3 = p3 <NEWLINE> elif ( x3 - x1 ) * dy - dx * ( y3 - y1 ) < 0 : return 0 <NEWLINE> <DEDENT> else : return 1 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> D = sorted ( [ list ( input ( ) ) for i in range ( n ) ] ) <NEWLINE> p = p1 = D [ 0 ] <NEWLINE> D1 = D [ : ] <NEWLINE> while True : <NEWLINE> <INDENT> for p2 in D1 : <NEWLINE> <INDENT> if p1 != p2 and side ( p1 , p2 ) : break <NEWLINE> <DEDENT> p1 = p2 <NEWLINE> D1 . remove ( p2 ) <NEWLINE> if p2 == p : break <NEWLINE> <DEDENT> print len ( D1 ) <NEWLINE> <DEDENT>
def f ( x , y , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> if x1 <= x2 : <NEWLINE> <INDENT> return ( x2 - x1 ) * y - ( y2 - y1 ) * x + x1 * y2 - x2 * y1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return - ( ( x2 - x1 ) * y - ( y2 - y1 ) * x + x1 * y2 - x2 * y1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def DC ( a ) : <NEWLINE> <INDENT> if len ( a ) > 3 : <NEWLINE> <COMMENT> <NL> <INDENT> la = a [ : len ( a ) / 2 ] <NEWLINE> ra = a [ len ( a ) / 2 : ] <NEWLINE> <COMMENT> <NL> la , ra = DC ( la ) , DC ( ra ) <NEWLINE> while f ( ra [ 1 ] [ 0 ] , ra [ 1 ] [ 1 ] , la [ - 1 ] [ 0 ] , la [ - 1 ] [ 1 ] , ra [ 0 ] [ 0 ] , ra [ 0 ] [ 1 ] ) > 0 and len ( ra ) > 1 : <NEWLINE> <INDENT> ra . pop ( 0 ) <NEWLINE> <DEDENT> while f ( la [ - 2 ] [ 0 ] , la [ - 2 ] [ 1 ] , ra [ 0 ] [ 0 ] , ra [ 0 ] [ 1 ] , la [ - 1 ] [ 0 ] , la [ - 1 ] [ 1 ] ) > 0 and len ( la ) > 1 : <NEWLINE> <INDENT> la . pop ( - 1 ) <NEWLINE> <DEDENT> return la + ra <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p . append ( map ( float , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> p = sorted ( p , key = lambda x : x [ 0 ] ) <NEWLINE> print n - len ( DC ( p ) ) <NEWLINE> <DEDENT>
def a ( v1 , v2 ) : <NEWLINE> <INDENT> if v1 [ 0 ] != v2 [ 0 ] : <NEWLINE> <INDENT> return ( v2 [ 1 ] - v1 [ 1 ] ) / ( v2 [ 0 ] - v1 [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( v2 [ 1 ] - v1 [ 1 ] ) * ( 10 ** 10 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dlt ( p , v , sign ) : <NEWLINE> <INDENT> while len ( p ) > 2 : <NEWLINE> <INDENT> if sign * ( a ( v [ p [ - 3 ] ] , v [ p [ - 2 ] ] ) - a ( v [ p [ - 2 ] ] , v [ p [ - 1 ] ] ) ) < 0 : <NEWLINE> <INDENT> del p [ - 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def convex ( v , n ) : <NEWLINE> <INDENT> d , u = [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = dlt ( d + [ i ] , v , 1 ) <NEWLINE> u = dlt ( u + [ i ] , v , - 1 ) <NEWLINE> <DEDENT> return n - len ( set ( d + u ) ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> v = [ map ( float , raw_input ( ) . splirt ( <STRING> ) ) for i in range ( n ) ] <NEWLINE> v = sorted ( sorted ( v , key = lambda x : x [ 1 ] ) ) <NEWLINE> print convex ( v , n ) <NEWLINE> <DEDENT>
<INDENT> upper_hull = get_bounds ( ps ) <NEWLINE> ps . reverse ( ) <NEWLINE> lower_hull = get_bounds ( ps ) <NEWLINE> del upper_hull [ - 1 ] <NEWLINE> del lower_hull [ - 1 ] <NEWLINE> upper_hull . extend ( lower_hull ) <NEWLINE> return upper_hull <NEWLINE> <NL> <DEDENT> def get_bounds ( ps ) : <NEWLINE> <INDENT> qs = [ ] <NEWLINE> for p in ps : <NEWLINE> <INDENT> while len ( qs ) > 1 and ( qs [ - 1 ] - qs [ - 2 ] ) . det ( p - qs [ - 1 ] ) <= 0 : <NEWLINE> <INDENT> del qs [ - 1 ] <NEWLINE> <DEDENT> qs . append ( p ) <NEWLINE> <DEDENT> return qs <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> points = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( float , input ( ) . split ( <STRING> ) ) <NEWLINE> points . append ( Point ( x , y ) ) <NEWLINE> <DEDENT> print ( len ( points ) - len ( convex_hull ( points ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def amida ( A , x ) : <NEWLINE> <INDENT> for e in A : <NEWLINE> <INDENT> if e [ x ] == 1 : x += 1 <NEWLINE> elif e [ x - 1 ] == 1 : x -= 1 <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> def f ( ) : <NEWLINE> <INDENT> for i in range ( d ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == 0 : <NEWLINE> <INDENT> B = [ e [ : ] for e in A ] <NEWLINE> B [ i ] [ j ] = 1 <NEWLINE> if amida ( B , m ) == p : <NEWLINE> <INDENT> print i + 1 , j <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print 1 <NEWLINE> return <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> m = input ( ) <NEWLINE> p = input ( ) <NEWLINE> d = input ( ) <NEWLINE> A = [ ] <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> if s == <STRING> : break <NEWLINE> A += [ [ 0 ] + map ( int , list ( s [ : - 1 ] ) ) + [ 0 ] ] <NEWLINE> <DEDENT> if amida ( A , m ) == p : print 0 <NEWLINE> else : f ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m , x , d = int ( raw_input ( ) ) - 1 , int ( raw_input ( ) ) - 1 , int ( raw_input ( ) ) <NEWLINE> amida = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> amida [ i ] = <STRING> + raw_input ( ) + <STRING> <NEWLINE> <DEDENT> rroot = [ ] <NEWLINE> for i in range ( d - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if amida [ i ] [ x - 1 ] == <STRING> : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> elif amida [ i ] [ x ] == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> rroot . append ( x ) <NEWLINE> <DEDENT> if m == x : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = [ ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> if amida [ i ] [ m - 1 ] == <STRING> : <NEWLINE> <INDENT> m -= 1 <NEWLINE> <DEDENT> elif amida [ i ] [ m ] == <STRING> : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> root . append ( m ) <NEWLINE> <DEDENT> rroot . reverse ( ) <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> if abs ( root [ i ] - rroot [ i ] ) == 1 : <NEWLINE> <INDENT> p = min ( root [ i ] , rroot [ i ] ) <NEWLINE> if int ( amida [ i ] [ p - 1 ] ) + int ( amida [ i ] [ p + 1 ] ) == 0 : <NEWLINE> <INDENT> print i + 1 , p + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if i == d - 1 : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m , goal , d = input ( ) , input ( ) , input ( ) <NEWLINE> step = [ <STRING> ] * d <NEWLINE> for i in xrange ( d ) : <NEWLINE> <INDENT> step [ i ] = <STRING> + raw_input ( ) + <STRING> <NEWLINE> <DEDENT> raw = range ( n + 2 ) <NEWLINE> for i in xrange ( d ) : <NEWLINE> <INDENT> for j in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if step [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> raw [ j ] , raw [ j + 1 ] = raw [ j + 1 ] , raw [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> if not raw [ goal ] == m : <NEWLINE> <INDENT> e = raw [ goal ] <NEWLINE> raw = range ( n + 2 ) <NEWLINE> for i in xrange ( d ) : <NEWLINE> <INDENT> if not ans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if ( raw [ j ] == m and raw [ j + 1 ] == e ) or ( raw [ j ] == e and raw [ j + 1 ] == m ) : <NEWLINE> <INDENT> if step [ i ] [ j - 1 ] == <STRING> and step [ i ] [ j ] == <STRING> and step [ i ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> ans = ( i + 1 , j ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if step [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> raw [ j ] , raw [ j + 1 ] = raw [ j + 1 ] , raw [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans == 0 : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , ans ) ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
import sys <NEWLINE> K = 1024 <NEWLINE> R = range ( K ) <NEWLINE> B = [ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 ] <NEWLINE> C = [ 0 ] * K <NEWLINE> D = [ [ 0 for i in range ( 331 ) ] for j in R ] <NEWLINE> <NL> def init ( ) : <NEWLINE> <INDENT> global C , D <NEWLINE> for i in R : <NEWLINE> <INDENT> s = format ( i , <STRING> ) <NEWLINE> n = s . count ( <STRING> ) <NEWLINE> C [ i ] = n <NEWLINE> if n == 1 : D [ i ] [ B . index ( i ) ] = 1 <NEWLINE> else : <NEWLINE> <INDENT> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ - j - 1 ] == <STRING> : <NEWLINE> <INDENT> dp = n * j <NEWLINE> i2 = i - B [ j ] <NEWLINE> for k in range ( 331 - dp ) : <NEWLINE> <INDENT> D [ i ] [ k + dp ] += D [ i2 ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> init ( ) <NEWLINE> for a in sys . stdin : <NEWLINE> <INDENT> n , s = map ( int , a . split ( ) ) <NEWLINE> x = sum ( [ D [ i ] [ s ] for i in R if C [ i ] == n ] ) <NEWLINE> print x <NEWLINE> <DEDENT>
def mx ( ls , m ) : <NEWLINE> <INDENT> global n <NEWLINE> sum = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sum += ( n - i ) * ls [ - i - 1 ] <NEWLINE> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> def f ( ls , m , s ) : <NEWLINE> <INDENT> global n <NEWLINE> count = 0 <NEWLINE> if m > 0 : <NEWLINE> <INDENT> if mx ( ls , m ) < s : return 0 <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> lls = ls [ : ] <NEWLINE> a = ( n - m + 1 ) * lls . pop ( i ) <NEWLINE> if s - a < 0 : break <NEWLINE> else : count += f ( lls , m - 1 , s - a ) <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 if s == 0 else 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ls = [ i for i in range ( 10 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print f ( ls , n , s ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def oncount ( x ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> while x > 0 : <NEWLINE> <INDENT> r += x & 1 <NEWLINE> x = x >> 1 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> dp = [ [ 0 ] * 331 for i in range ( 1024 ) ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> dp [ 1 << i ] [ i ] = 1 <NEWLINE> <DEDENT> for i in range ( 1024 ) : <NEWLINE> <INDENT> for j in range ( 331 ) : <NEWLINE> <INDENT> t = oncount ( i ) <NEWLINE> for k in range ( 10 ) : <NEWLINE> <INDENT> if 1 & ( i >> k ) : <NEWLINE> <INDENT> x = j - t * k <NEWLINE> if x >= 0 : dp [ i ] [ j ] += dp [ i & ~ ( 1 << k ) ] [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for a in sys . stdin <NEWLINE> <INDENT> n , s = map ( int , a . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if s <= 330 : <NEWLINE> <INDENT> for i in range ( 1024 ) : <NEWLINE> <INDENT> if oncount ( i ) == n : ans += dp [ i ] [ s ] <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
def mx ( ls , m ) : <NEWLINE> <INDENT> global n <NEWLINE> sum = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sum += ( n - i ) * ls [ - i - 1 ] <NEWLINE> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> def mn ( ls , m ) : <NEWLINE> <INDENT> global n <NEWLINE> sum = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> sum += ( n - i ) * ls [ i ] <NEWLINE> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> def f ( ls , m , s ) : <NEWLINE> <INDENT> global n <NEWLINE> count = 0 <NEWLINE> if m > 0 : <NEWLINE> <INDENT> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> lls = ls [ : ] <NEWLINE> a = ( n - m + 1 ) * lls . pop ( i ) <NEWLINE> if s - a < 0 : break <NEWLINE> vmx , vmn = mx ( ls , m ) , mn ( ls , m ) <NEWLINE> if vmx < s or vmn > s : return 0 <NEWLINE> elif vmx == s or vmn == s : return 1 <NEWLINE> else : count += f ( lls , m - 1 , s - a ) <NEWLINE> <DEDENT> return count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 if s == 0 else 0 <NEWLINE> <NL> <DEDENT> <DEDENT> ls = [ i for i in range ( 10 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print f ( ls , n , s ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import itertools , sys <NEWLINE> def f0070 ( A , n , s ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> if s in A : return 1 <NEWLINE> else : return 0 <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> b = s - A [ i ] * n <NEWLINE> if b <= 0 : break <NEWLINE> c += f0070 ( A [ : i ] + A [ i + 1 : ] , n - 1 , b ) <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> for a in sys . stdin : <NEWLINE> <INDENT> c = 0 <NEWLINE> n , s = map ( int , a . split ( ) ) <NEWLINE> c = f0070 ( range ( 10 ) , n , s ) <NEWLINE> print c <NEWLINE> <DEDENT>
import sys <NEWLINE> def f0070 ( A , n , s ) : <NEWLINE> <INDENT> if n == 1 : return s in A <NEWLINE> A = sorted ( A ) <NEWLINE> A1 = A [ : n + 1 ] [ : : - 1 ] <NEWLINE> A2 = A [ - n - 1 : ] <NEWLINE> b1 = 0 <NEWLINE> b2 = 0 <NEWLINE> c = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> b1 += i * A1 [ i ] <NEWLINE> b2 += i * A2 [ i ] <NEWLINE> <DEDENT> if b1 <= s <= b2 : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> c += f0070 ( A [ : i ] + A [ i + 1 : ] , n - 1 , s - A [ i ] * n ) <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <DEDENT> for a in sys . stdin : <NEWLINE> <INDENT> n , s = map ( int , a . split ( ) ) <NEWLINE> print f0070 ( range ( 10 ) , n , s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def f0070 ( A , n , s ) : <NEWLINE> <INDENT> if n == 1 : <NEWLINE> <INDENT> if s in A : f = 1 <NEWLINE> else f = 0 <NEWLINE> return f <NEWLINE> <DEDENT> c = 0 <NEWLINE> A = sorted ( A ) <NEWLINE> A1 = A [ : n ] [ : : - 1 ] <NEWLINE> A2 = A [ - n : ] <NEWLINE> N = range ( n ) <NEWLINE> def f ( A ) : <NEWLINE> <INDENT> return sum ( [ ( i + 1 ) * A [ i ] for i in N ] ) <NEWLINE> <DEDENT> if f ( A1 ) <= s <= f ( A2 ) : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> b = s - A [ i ] * n <NEWLINE> c += f0070 ( A [ : i ] + A [ i + 1 : ] , n - 1 , b ) <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> for a in sys . stdin : <NEWLINE> <INDENT> n , s = map ( int , a . split ( ) ) <NEWLINE> print f0070 ( range ( 10 ) , n , s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> dp = [ [ [ 0 ] * 341 for i in xrange ( ( 1 << 10 ) + 1 ) ] for j in xrange ( 12 ) ] <NEWLINE> <COMMENT> <NL> dp [ 0 ] [ 0 ] [ 0 ] = 1 <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> for j in xrange ( 1 << 10 ) : <NEWLINE> <INDENT> for c in xrange ( 331 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] [ c ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in xrange ( 10 ) : <NEWLINE> <INDENT> if ( j >> k & 1 ) == 0 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j | ( 1 << k ) ] [ ( i + 1 ) * k + c ] += dp [ i ] [ j ] [ c ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ [ 0 ] * 341 for unused in xrange ( 12 ) ] <NEWLINE> for i in xrange ( 11 ) : <NEWLINE> <INDENT> for j in xrange ( 1 << 10 ) : <NEWLINE> <INDENT> for c in xrange ( 331 ) : <NEWLINE> <INDENT> ans [ i ] [ c ] += dp [ i ] [ j ] [ c ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> n , s = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> print ans [ n ] [ s ] <NEWLINE> <DEDENT>
def e ( x , y ) : <NEWLINE> <INDENT> A [ y ] [ x ] = <STRING> <NEWLINE> for t in range ( - 3 , 4 ) : <NEWLINE> <INDENT> if 0 <= x + dx < 8 and A [ y ] [ x + dx ] == <STRING> : e ( x + dx , y ) <NEWLINE> if 0 <= y + dy < 8 and A [ y + dy ] [ x ] == <STRING> : e ( x , y + dy ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> input ( ) <NEWLINE> A = [ list ( input ( ) ) for _ in [ 0 ] * 8 ] <NEWLINE> e ( int ( input ( ) ) - 1 , int ( input ( ) ) - 1 ) <NEWLINE> for r in A : print ( * r , sep = <STRING> ) <NEWLINE> <DEDENT>
def chain ( y , x ) : <NEWLINE> <INDENT> bomb [ y ] [ x ] = <STRING> <NEWLINE> if bomb [ y + 1 ] [ x ] == <STRING> : chain ( y + 1 , x ) <NEWLINE> if bomb [ y + 2 ] [ x ] == <STRING> : chain ( y + 2 , x ) <NEWLINE> if bomb [ y + 3 ] [ x ] == <STRING> : chain ( y + 3 , x ) <NEWLINE> if bomb [ y - 1 ] [ x ] == <STRING> : chain ( y - 1 , x ) <NEWLINE> if bomb [ y - 2 ] [ x ] == <STRING> : chain ( y - 2 , x ) <NEWLINE> if bomb [ y - 3 ] [ x ] == <STRING> : chain ( y - 3 , x ) <NEWLINE> if bomb [ y ] [ x + 1 ] == <STRING> : chain ( y , x + 1 ) <NEWLINE> if bomb [ y ] [ x + 2 ] == <STRING> : chain ( y , x + 2 ) <NEWLINE> if bomb [ y ] [ x + 3 ] == <STRING> : chain ( y , x + 3 ) <NEWLINE> if bomb [ y ] [ x - 1 ] == <STRING> : chain ( y , x - 1 ) <NEWLINE> if bomb [ y ] [ x - 2 ] == <STRING> : chain ( y , x - 2 ) <NEWLINE> if bomb [ y ] [ x - 3 ] == <STRING> : chain ( y , x - 3 ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for d in range ( 0 , n ) : <NEWLINE> <INDENT> raw_input ( ) <NEWLINE> bomb = [ ] <NEWLINE> for _ in range ( 0 , 3 ) : bomb . append ( list ( <STRING> ) ) <NEWLINE> for _ in range ( 0 , 8 ) : bomb . append ( list ( <STRING> + raw_input ( ) + <STRING> ) ) <NEWLINE> for _ in range ( 0 , 3 ) : bomb . append ( list ( <STRING> ) ) <NEWLINE> <NL> x = input ( ) + 2 <NEWLINE> y = input ( ) + 2 <NEWLINE> <NL> chain ( y , x ) <NEWLINE> <NL> print <STRING> . format ( d + 1 ) <NEWLINE> for var in bomb [ 3 : 11 ] : <NEWLINE> <INDENT> for r in var [ 3 : 11 ] : <NEWLINE> <INDENT> print r , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
def bomb ( field , x , y ) : <NEWLINE> <INDENT> rfield = field [ : ] [ : ] <NEWLINE> rfield [ y ] [ x ] = 0 <NEWLINE> for i in range ( - 3 , 4 ) : <NEWLINE> <INDENT> if 0 <= x + i <= 7 : <NEWLINE> <INDENT> if rfield [ y ] [ x + i ] == 1 : <NEWLINE> <INDENT> rfield = bomb ( rfield , x + i , y ) <NEWLINE> <DEDENT> <DEDENT> if 0 <= y + i <= 7 : <NEWLINE> <INDENT> if rfield [ y + i ] [ x ] == 1 : <NEWLINE> <INDENT> rfield = bomb ( rfield , x , y + i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return rfield <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for data in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> dammy = raw_input <NEWLINE> field = [ ] <NEWLINE> for line in range ( 8 ) : <NEWLINE> <INDENT> field . append ( map ( int , list ( raw_input ( ) ) ) ) <NEWLINE> <DEDENT> x = int ( raw_input ( ) ) - 1 <NEWLINE> y = int ( raw_input ( ) ) - 1 <NEWLINE> <NL> <COMMENT> <NL> field = bomb ( field , x , y ) <NEWLINE> <NL> <COMMENT> <NL> print <STRING> % ( data ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , field [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> MAX_Y = 8 <NEWLINE> MAX_X = 8 <NEWLINE> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> raw_input ( ) <NEWLINE> <NL> for i , j in enumerate ( range ( N ) ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> for j in range ( MAX_Y ) : <NEWLINE> <INDENT> input_list = map ( int , raw_input ( ) ) <NEWLINE> data . append ( input_list ) <NEWLINE> <DEDENT> bomb_X = int ( raw_input ( ) ) <NEWLINE> bomb_Y = int ( raw_input ( ) ) <NEWLINE> raw_input ( ) <NEWLINE> <NL> bomb_town = explosion ( data , ( ( bomb_X - 1 , bomb_Y - 1 ) , ) ) <NEWLINE> print ( <STRING> + str ( i + 1 ) + <STRING> ) <NEWLINE> printBomb ( bomb_town ) <NEWLINE> <NL> <DEDENT> <DEDENT> def printBomb ( bomb ) : <NEWLINE> <INDENT> for x in bomb : <NEWLINE> <INDENT> print ( reduce ( lambda x , y : x + y , ( map ( str , x ) ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def isIn ( x , y ) : <NEWLINE> <INDENT> return 0 <= x < MAX_X and 0 <= y < MAX_Y <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def explosion ( data , bomb ) : <NEWLINE> <INDENT> for b in bomb : <NEWLINE> <INDENT> if data [ b [ 1 ] ] [ b [ 0 ] ] == 1 : <NEWLINE> <INDENT> new_bomb = bom ( data , b ) <NEWLINE> burned_data = burned ( data , b ) <NEWLINE> data = explosion ( burned_data , new_bomb ) <NEWLINE> <NL> <DEDENT> <DEDENT> return data <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def burned ( data , b ) : <NEWLINE> <INDENT> data [ b [ 1 ] ] [ b [ 0 ] ] = 0 <NEWLINE> return data <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def bom ( data , b ) : <NEWLINE> <INDENT> bom_area = [ ( - 3 , 0 ) , ( - 2 , 0 ) , ( - 1 , 0 ) , ( 1 , 0 ) , ( 2 , 0 ) , ( 3 , 0 ) , <NEWLINE> <INDENT> ( 0 , - 3 ) , ( 0 , - 2 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 0 , 2 ) , ( 0 , 3 ) ] <NEWLINE> <DEDENT> new_bomb = [ ] <NEWLINE> for x in bom_area : <NEWLINE> <INDENT> bomb = tuple ( [ sum ( x ) for x in zip ( x , b ) ] ) <NEWLINE> if isIn ( * bomb ) : <NEWLINE> <INDENT> new_bomb . append ( bomb ) <NEWLINE> <NL> <DEDENT> <DEDENT> return new_bomb <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = [ 0 , 0 , 0 , 0 , 0 , 0 , 1 , 2 , 3 , - 1 , - 2 , - 3 ] <NEWLINE> y = [ 1 , 2 , 3 , - 1 , - 2 , - 3 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> <NL> def dfs ( ty , tx ) : <NEWLINE> <INDENT> if L [ ty ] [ tx ] == 1 : <NEWLINE> <INDENT> L [ ty ] [ tx ] = 0 <NEWLINE> for i , j in zip ( x , y ) : <NEWLINE> <INDENT> dx , dy = tx + i , ty + j <NEWLINE> if 0 <= dx <= 7 and 0 <= dy <= 7 : <NEWLINE> <INDENT> dfs ( dy , dx ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L = [ map ( int , raw_input ( ) ) for j in range ( 8 ) ] <NEWLINE> ax , ay = input ( ) , input ( ) <NEWLINE> dfs ( ay - 1 , ax - 1 ) <NEWLINE> print <STRING> % ( i + 1 ) <NEWLINE> for j in range ( 8 ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , L [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( data , p ) : <NEWLINE> <INDENT> L = [ ] <NEWLINE> if data [ p [ 1 ] - 1 ] [ p [ 0 ] - 1 ] == <STRING> : <NEWLINE> <INDENT> data [ p [ 1 ] - 1 ] = data [ p [ 1 ] - 1 ] [ : p [ 0 ] - 1 ] + <STRING> + data [ p [ 1 ] - 1 ] [ p [ 0 ] : ] <NEWLINE> L += p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> bakuhu = [ ( p [ 0 ] - 3 , p [ 1 ] ) , ( p [ 0 ] - 2 , p [ 1 ] ) , ( p [ 0 ] - 1 , p [ 1 ] ) , ( p [ 0 ] + 1 , p [ 1 ] ) , ( p [ 0 ] + 2 , p [ 1 ] ) , ( p [ 0 ] + 3 , p [ 1 ] ) , ( p [ 0 ] , p [ 1 ] - 3 ) , ( p [ 0 ] , p [ 1 ] - 2 ) , ( p [ 0 ] , p [ 1 ] - 1 ) , ( p [ 0 ] , p [ 1 ] + 1 ) , ( p [ 0 ] , p [ 1 ] + 2 ) , ( p [ 0 ] , p [ 1 ] + 3 ) ] <NEWLINE> for i in range ( len ( bakuhu ) ) : <NEWLINE> <INDENT> if bakuhu [ i ] [ 0 ] > 0 and bakuhu [ i ] [ 1 ] > 0 and bakuhu [ i ] [ 0 ] < 9 and bakuhu [ i ] [ 1 ] < 9 : <NEWLINE> <INDENT> L . extend ( solve ( data , bakuhu [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> return L <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ndata = input ( ) <NEWLINE> for i in range ( ndata ) : <NEWLINE> <INDENT> raw_input ( ) <NEWLINE> data = [ ] <NEWLINE> for j in range ( 8 ) : <NEWLINE> <INDENT> data . append ( raw_input ( ) ) <NEWLINE> <DEDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> p = ( x , y ) <NEWLINE> L = solve ( data , p ) <NEWLINE> while len ( L ) != 0 : <NEWLINE> <INDENT> x = L . pop ( 0 ) <NEWLINE> y = L . pop ( 0 ) <NEWLINE> data [ y - 1 ] = data [ y - 1 ] [ : x - 1 ] + <STRING> + data [ y - 1 ] [ x : ] <NEWLINE> <DEDENT> print <STRING> + str ( i + 1 ) + <STRING> <NEWLINE> for i in range ( len ( data ) ) : <NEWLINE> <INDENT> print data [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def bomb ( f , x , y ) : <NEWLINE> <INDENT> rf = f [ : ] [ : ] <NEWLINE> rf [ y ] [ x ] = 0 <NEWLINE> for i in [ - 3 , - 2 , - 1 , 1 , 2 , 3 ] : <NEWLINE> <INDENT> if 0 <= x + i <= 7 : <NEWLINE> <INDENT> if rf [ y ] [ x + i ] == 1 : <NEWLINE> <INDENT> rf = bomb ( rf , x + i , y ) <NEWLINE> <DEDENT> <DEDENT> if 0 <= y + i <= 7 : <NEWLINE> <INDENT> if rf [ y + i ] [ x ] == 1 : <NEWLINE> <INDENT> rf = bomb ( rf , x , y + i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return rf <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> for data in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> raw_input ( ) <NEWLINE> f = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> l . append ( [ int ( x ) for x in raw_input ( ) ] ) <NEWLINE> <DEDENT> x = int ( raw_input ( ) ) - 1 <NEWLINE> y = int ( raw_input ( ) ) - 1 <NEWLINE> <COMMENT> <NL> f = bomb ( f , x , y ) <NEWLINE> print <STRING> % ( data ) <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , f [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> input ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> board = [ list ( input ( ) ) for i in range ( 8 ) ] <NEWLINE> sx = int ( input ( ) ) - 1 <NEWLINE> sy = int ( input ( ) ) - 1 <NEWLINE> input ( ) <NEWLINE> <NL> board [ sy ] [ sx ] == 2 <NEWLINE> bomb = [ ] <NEWLINE> n_bomb = [ [ sy , sx ] ] <NEWLINE> points = [ ] <NEWLINE> for j in range ( len ( board ) ) : <NEWLINE> <INDENT> while <STRING> in board [ j ] : <NEWLINE> <INDENT> px = board [ j ] . index ( <STRING> ) <NEWLINE> py = j <NEWLINE> points . append ( [ py , px ] ) <NEWLINE> board [ j ] [ px ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> while len ( n_bomb ) != 0 : <NEWLINE> <INDENT> bomb += n_bomb <NEWLINE> n_bomb = [ ] <NEWLINE> for b in bomb : <NEWLINE> <INDENT> for p in points : <NEWLINE> <INDENT> if ( p [ 0 ] == b [ 0 ] and b [ 1 ] - 3 <= p [ 1 ] <= b [ 1 ] + 3 ) or ( p [ 1 ] == b [ 1 ] and b [ 0 ] - 3 <= p [ 0 ] <= b [ 0 ] + 3 ) : <NEWLINE> <INDENT> points . remove ( p ) <NEWLINE> n_bomb . append ( p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = [ [ <STRING> ] * 8 for j in range ( 8 ) ] <NEWLINE> for p in points : <NEWLINE> <INDENT> ans [ p [ 0 ] ] [ p [ 1 ] ] = <STRING> <NEWLINE> <NL> <DEDENT> print ( <STRING> % str ( i + 1 ) ) <NEWLINE> for p in ans : <NEWLINE> <INDENT> print ( <STRING> . join ( p ) ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( nu , mu , du ) : <NEWLINE> <INDENT> E = [ ] <NEWLINE> vs = [ False ] * nu <NEWLINE> vs [ 0 ] = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> min_dist , ind = float ( <STRING> ) , float ( <STRING> ) <NEWLINE> for i in xrange ( len ( du ) ) : <NEWLINE> <INDENT> p_from = du [ i ] [ 0 ] <NEWLINE> p_to = du [ i ] [ 1 ] <NEWLINE> if vs [ p_from ] and vs [ p_to ] : <NEWLINE> <INDENT> du . pop ( i ) <NEWLINE> break <NEWLINE> <DEDENT> if ( vs [ p_from ] and not vs [ p_to ] ) or ( not vs [ p_from ] and vs [ p_to ] ) : <NEWLINE> <INDENT> if min_dist > du [ i ] [ 2 ] : <NEWLINE> <INDENT> min_dist , ind , pf , pt = du [ i ] [ 2 ] , i , p_from , p_to <NEWLINE> <DEDENT> <DEDENT> <DEDENT> E . append ( min_dist ) <NEWLINE> vs [ pf ] = vs [ pt ] = True <NEWLINE> du . pop ( ind ) <NEWLINE> if all ( vs ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print sum ( E ) / 100 - len ( E ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> m = input ( ) <NEWLINE> data = [ ] <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> data . append ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> solve ( n , m , data ) <NEWLINE> <DEDENT>
n , m = int ( raw_input ( ) ) , int ( raw_input ( ) ) <NEWLINE> s = [ map ( int , raw_input ( ) . split ( <STRING> ) ) for i in range ( m ) ] <NEWLINE> s = sorted ( s , key = lambda x : x [ 2 ] ) <NEWLINE> ls = range ( n ) <NEWLINE> ref = ls [ : ] <NEWLINE> ans = 0 <NEWLINE> for i in s : <NEWLINE> <INDENT> x , y , d = s . pop ( 0 ) <NEWLINE> a , b = ref [ x ] , ref [ y ] <NEWLINE> if a != b <NEWLINE> <INDENT> for j in ls : <NEWLINE> <INDENT> if ref [ j ] == a : ref [ j ] = b <NEWLINE> <DEDENT> ans += d / 100 - 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
<COMMENT> <NL> <NL> class vertex : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . is_in_V = False <NEWLINE> <NL> <DEDENT> <DEDENT> def is_single_in_V ( v , p ) : <NEWLINE> <INDENT> a = v [ p [ 0 ] ] . is_in_V <NEWLINE> b = v [ p [ 1 ] ] . is_in_V <NEWLINE> return ( a and not b ) or ( not a and b ) <NEWLINE> <NL> <DEDENT> def all_in_V ( v ) : <NEWLINE> <INDENT> for e in v : <NEWLINE> <INDENT> if not e . is_in_V : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def add_in_V ( v , d ) : <NEWLINE> <INDENT> v [ d [ 0 ] ] . is_in_V = True <NEWLINE> v [ d [ 1 ] ] . is_in_V = True <NEWLINE> <NL> <DEDENT> def remove_all_in_V_pass ( v , d ) : <NEWLINE> <INDENT> for i in xrange ( len ( d ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if v [ d [ i ] [ 0 ] ] . is_in_V and v [ d [ i ] [ 1 ] ] . is_in_V : <NEWLINE> <INDENT> d . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( nu , mu , du ) : <NEWLINE> <INDENT> E = [ ] <NEWLINE> vertexes = [ vertex ( ) for i in xrange ( nu ) ] <NEWLINE> vertexes [ 0 ] . is_in_V = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if all_in_V ( vertexes ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> min_dist , ind = float ( <STRING> ) , float ( <STRING> ) <NEWLINE> for i in xrange ( len ( du ) ) : <NEWLINE> <INDENT> if is_single_in_V ( vertexes , du [ i ] [ 0 : 2 ] ) : <NEWLINE> <INDENT> if min_dist > du [ i ] [ 2 ] : <NEWLINE> <INDENT> min_dist = du [ i ] [ 2 ] <NEWLINE> ind = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> E . append ( min_dist ) <NEWLINE> add_in_V ( vertexes , du [ ind ] ) <NEWLINE> du . pop ( ind ) <NEWLINE> remove_all_in_V_pass ( vertexes , du ) <NEWLINE> <DEDENT> print sum ( E ) / 100 - len ( E ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> m = input ( ) <NEWLINE> data = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> data . append ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> solve ( n , m , data ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n = input ( ) <NEWLINE> N = range ( n ) <NEWLINE> m = input ( ) <NEWLINE> A = [ sys . maxint ] * n <NEWLINE> B = [ A [ : ] for i in N ] <NEWLINE> A = [ 0 ] * n <NEWLINE> C = [ A [ : ] for i in N ] <NEWLINE> while 1 : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> a , b , w = map ( int , s . split ( <STRING> ) ) <NEWLINE> B [ a ] [ b ] , B [ b ] [ a ] = w , w <NEWLINE> <NL> <DEDENT> s = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> x = min ( B [ i ] ) <NEWLINE> y = B [ i ] . index ( x ) <NEWLINE> if C [ i ] [ y ] == 0 : <NEWLINE> <INDENT> C [ i ] [ y ] , C [ y ] [ i ] = 1 , 1 <NEWLINE> s += x / 100 - 1 <NEWLINE> <DEDENT> <DEDENT> print s <NEWLINE>
while 1 : <NEWLINE> <INDENT> x , h = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> if x : print ( x * x + ( ( x / 2 ) ** 2 + h ** 2 ) ** .5 * x * 2 ) <NEWLINE> <DEDENT>
def doc_string ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> h = int ( raw_input ) * 3600 <NEWLINE> m = int ( raw_input ) * 60 <NEWLINE> s = int ( raw_input ) <NEWLINE> time = 120 * 60 - ( h + m + s ) <NEWLINE> if h == - 1 and m == - 1 and s == - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> h = str ( time / 3600 ) <NEWLINE> m = str ( time % 3600 / 60 ) <NEWLINE> s = str ( time % 3600 % 60 ) <NEWLINE> if len ( h ) == 1 : <NEWLINE> <INDENT> h = <STRING> + h <NEWLINE> <DEDENT> if len ( m ) == 1 : <NEWLINE> <INDENT> m = <STRING> + m <NEWLINE> <DEDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> s = <STRING> + s <NEWLINE> <DEDENT> print h + <STRING> + m + <STRING> + s <NEWLINE> <NL> h = str ( time * 3 / 3600 ) <NEWLINE> m = str ( time * 3 % 3600 / 60 ) <NEWLINE> s = str ( time * 3 % 3600 % 60 ) <NEWLINE> if len ( h ) == 1 : <NEWLINE> <INDENT> h = <STRING> + h <NEWLINE> <DEDENT> if len ( m ) == 1 : <NEWLINE> <INDENT> m = <STRING> + m <NEWLINE> <DEDENT> if len ( s ) == 1 : <NEWLINE> <INDENT> s = <STRING> + s <NEWLINE> <DEDENT> print h + <STRING> + m + <STRING> + s <NEWLINE> <DEDENT>
p = lambda x : print ( <STRING> ) <NEWLINE> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> h , m , s = map ( int , e . split ( ) ) <NEWLINE> d = 7200 - h * 3600 - m * 60 - s <NEWLINE> p ( d ) ; p ( d * 3 ) <NEWLINE> <DEDENT>
def f ( t ) : <NEWLINE> <INDENT> c , t = t % N , t / N <NEWLINE> print <STRING> % ( t / N , t % N , c ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> h , m , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if [ h , m , s ] == [ - 1 , - 1 , - 1 ] : break <NEWLINE> t = 7200 - ( h * N + m ) * N - s <NEWLINE> f ( t ) <NEWLINE> f ( t * 3 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> s , w , h = map ( float , line . strip ( ) . split ( <STRING> ) ) <NEWLINE> print ( s if w / ( h ** 2 ) >= 25 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> s1 = s . split ( <STRING> ) <NEWLINE> n = int ( s1 [ 0 ] ) <NEWLINE> h , w = map ( float ( s [ 1 : ] ) ) <NEWLINE> bmi = w / h ^ 2 <NEWLINE> if bmi >= 25 : print n <NEWLINE> <DEDENT>
import sys <NEWLINE> l = [ list ( map ( float , i . split ( <STRING> ) ) ) for i in sys . stdin ] <NEWLINE> bmi = lambda i : i [ 1 ] / ( i [ 2 ] ** 2 ) <NEWLINE> [ print ( int ( i [ 0 ] ) ) for i in l bmi ( i ) >= 25 ] <NEWLINE>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r , theta = math . sqrt ( 2.0 ) , pi / 4.0 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> r = math . sqrt ( r ** 2 + 1.0 ) <NEWLINE> theta += math . asin ( 1.0 / r ) <NEWLINE> <DEDENT> print r * math . cos ( theta ) <NEWLINE> print r * math . sin ( theta ) <NEWLINE> <DEDENT>
A = [ ] <NEWLINE> x = 1.0 <NEWLINE> y = 0.0 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> A . append ( [ x , y ] ) <NEWLINE> tmp = ( x ** 2 + y ** 2 ) ** .5 <NEWLINE> dx , dy = - y / tmp , x / tmp <NEWLINE> x += dx <NEWLINE> y += dy <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == - 1 : break <NEWLINE> a , b = A [ n - 1 ] <NEWLINE> print <STRING> % ( a , b ) <NEWLINE> <DEDENT>
text = [ ] <NEWLINE> ptext = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <NL> <NL> <INDENT> text = list ( map ( str , raw_input ( ) ) ) <NEWLINE> <COMMENT> <NL> f = 0 <NEWLINE> ptext = [ ] <NEWLINE> <NL> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> if text [ i ] == <STRING> : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> for k in range ( int ( text [ i + 1 ] ) - 1 ) : <NEWLINE> <INDENT> ptext . append ( text [ i + 2 ] ) <NEWLINE> <NL> <DEDENT> f = 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> if f == 0 : <NEWLINE> <INDENT> ptext . append ( text [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> for inp sys . stdin : <NEWLINE> <INDENT> msg = <STRING> <NEWLINE> for i in range ( len ( inp ) ) : <NEWLINE> <INDENT> if inp [ i ] == <STRING> : msg += inp [ i + 2 ] * int ( inp [ i + 1 ] ) <NEWLINE> else : msg += inp [ i ] <NEWLINE> <DEDENT> print msg <NEWLINE> <DEDENT>
import re , sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> l = re . split ( <STRING> , s ) <NEWLINE> for s in l : <NEWLINE> <INDENT> if <STRING> in s : <NEWLINE> <INDENT> s = s [ 2 ] * int ( s [ 1 ] ) <NEWLINE> <DEDENT> print s , <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> array = map ( str , raw_input ( ) ) <NEWLINE> display = [ ] <NEWLINE> for i in range ( len ( array ) ) : <NEWLINE> <INDENT> if array [ i ] != <STRING> : <NEWLINE> <INDENT> display . append ( array [ i ] ) <NEWLINE> <DEDENT> elif array [ i ] == <STRING> : <NEWLINE> <INDENT> insert = int ( array [ i + 1 ] ) * array [ i + 2 ] <NEWLINE> display . append ( insert ) <NEWLINE> array [ i + 1 ] , array [ i + 2 ] = <STRING> , <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( display ) - 1 ) : <NEWLINE> <INDENT> display [ i + 1 ] = display [ i ] + display [ i + 1 ] <NEWLINE> <NL> <DEDENT> print display [ - 1 ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> board = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> xp = n / 2 <NEWLINE> yp = n / 2 + 1 <NEWLINE> for i in range ( n ** 2 ) : <NEWLINE> <INDENT> if board [ yp ] [ xp ] == 0 : <NEWLINE> <INDENT> board [ yp ] [ xp ] = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xp -= 1 <NEWLINE> yp += 1 <NEWLINE> if xp == - 1 : xp = n - 1 <NEWLINE> if yp == n : yp = 0 <NEWLINE> board [ yp ] [ xp ] = i + 1 <NEWLINE> <DEDENT> yp += 1 <NEWLINE> xp += 1 <NEWLINE> if xp == n : xp = 0 <NEWLINE> if yp == n : yp = 0 <NEWLINE> <DEDENT> for b in board : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , b ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> magic = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] <NEWLINE> x , y = n / 2 , n / 2 <NEWLINE> magic [ y ] [ x ] = 1 <NEWLINE> count = 2 <NEWLINE> while count <= n ** 2 : <NEWLINE> <INDENT> x , y = ( x + 1 ) % n , ( y + 1 ) % n <NEWLINE> if magic [ y ] [ x ] == 0 : <NEWLINE> <INDENT> magic [ y ] [ x ] = count <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x , y = ( x - 1 ) % n , ( y + 1 ) % n <NEWLINE> magic [ y ] [ x ] = count <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( lambda s : str ( s ) . rjust ( 4 ) , board [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> magic = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> i = n / 2 <NEWLINE> j = n / 2 + 1 <NEWLINE> for number in range ( 1 , n * n + 1 ) : <NEWLINE> <INDENT> magic [ j ] [ i ] = number <NEWLINE> if number == n * n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if magic [ ( j + 1 ) % n ] [ ( i + 1 ) % n ] == 0 : <NEWLINE> <INDENT> i , j = ( i + 1 ) % n , ( j + 1 ) % n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i , j = ( i + 1 ) % n , ( j + 1 ) % n <NEWLINE> while magic [ j ] [ i ] != 0 : <NEWLINE> <INDENT> i , j = ( i - 1 ) % n , ( j + 1 ) % n <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> print str ( magic [ i ] [ j ] ) . rjust ( 3 ) , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 1 <NEWLINE> N = n * n <NEWLINE> circle = [ 0 ] * N <NEWLINE> p = ( N + 1 ) / 2 - 1 <NEWLINE> while c <= N : <NEWLINE> <INDENT> if p == N : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> elif p % n == 0 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> elif p + n > N : <NEWLINE> <INDENT> p -= ( N - n - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += n + 1 <NEWLINE> <NL> <DEDENT> if circle [ p - 1 ] != 0 : <NEWLINE> <INDENT> while circle [ p - 1 ] != 0 : <NEWLINE> <INDENT> if p == N - n + 1 : <NEWLINE> <INDENT> p = n <NEWLINE> <DEDENT> elif p - 1 % n == 0 : <NEWLINE> <INDENT> p += ( n * 2 - 1 ) <NEWLINE> <DEDENT> elif p + n > N : <NEWLINE> <INDENT> p -= N - n + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p += n - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> circle [ p - 1 ] = c <NEWLINE> c += 1 <NEWLINE> <DEDENT> p = 0 <NEWLINE> temp = <STRING> <NEWLINE> while p * n != N : <NEWLINE> <INDENT> temp += <STRING> . join ( map ( lambda x : str ( x ) . rjust ( 4 ) , circle [ n * p : n * ( p + 1 ) ] ) ) <NEWLINE> temp += <STRING> <NEWLINE> p += 1 <NEWLINE> <DEDENT> ans . append ( temp ) <NEWLINE> <DEDENT> for i in ans : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> board = [ [ 0 ] * n for unused in xrange ( n ) ] <NEWLINE> y , x = n / 2 + 1 , n / 2 <NEWLINE> board [ y ] [ x ] = 1 <NEWLINE> for i in xrange ( 2 , n * n + 1 ) : <NEWLINE> <INDENT> ny , nx = ( y + 1 ) % n , ( x + 1 ) % n <NEWLINE> while True : <NEWLINE> <INDENT> if board [ ny ] [ nx ] == 0 : <NEWLINE> <INDENT> y , x = ny , nx <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ny , nx = ( ny + 1 ) % n , ( nx + n - 1 ) % n <NEWLINE> <DEDENT> <DEDENT> board [ y ] [ x ] = i <NEWLINE> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( n ) : <NEWLINE> <INDENT> print str ( board [ i ] [ j ] ) . rjust ( 4 ) , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
def chekend ( mc ) : <NEWLINE> <INDENT> for m in mc : <NEWLINE> <INDENT> if not all ( m ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> mc = [ [ 0 for j in xrange ( n ) ] for i in xrange ( n ) ] <NEWLINE> px = n / 2 <NEWLINE> py = n / 2 + 1 <NEWLINE> cnt = 1 <NEWLINE> mc [ py ] [ px ] = cnt <NEWLINE> px += 1 <NEWLINE> py += 1 <NEWLINE> cnt += 1 <NEWLINE> while True : <NEWLINE> <INDENT> if chekend ( mc ) : break <NEWLINE> if px >= n : px = 0 ; continue <NEWLINE> if px < 0 : px = n - 1 ; continue <NEWLINE> if py >= n : py = 0 ; continue <NEWLINE> if mc [ py ] [ px ] : px -= 1 ; py += 1 ; continue <NEWLINE> mc [ py ] [ px ] = cnt <NEWLINE> cnt += 1 <NEWLINE> px += 1 <NEWLINE> py += 1 <NEWLINE> <NL> <DEDENT> for m in mc : <NEWLINE> <INDENT> for l in m : <NEWLINE> <INDENT> print <STRING> % ( l ) , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> solve ( n ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = 0 <NEWLINE> p = [ list ( map ( float , e . split ( <STRING> ) ) ) for e in sys . stdin ] <NEWLINE> x , y = p [ 0 ] <NEWLINE> print ( abs ( sum ( ( p [ i ] [ 0 ] - x ) * ( p [ i + 1 ] [ 1 ] - y ) - ( p [ i ] [ 1 ] - y ) * ( p [ i + 1 ] [ 0 ] - x ) ) for i in range ( 1 , len ( p ) - 1 ) ) ) / 2 ) <NEWLINE>
import math <NEWLINE> def op ( u , v ) : <NEWLINE> <INDENT> return ( conjugate ( u ) * v ) . imag <NEWLINE> <NL> <DEDENT> f = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> st = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> x , y = list ( map ( float , st ) ) <NEWLINE> f . append ( x + y * 1j ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> s = 0.0 <NEWLINE> fo = f [ 0 ] <NEWLINE> for j in range ( 2 , len ( f ) ) : <NEWLINE> <INDENT> i = j - 1 <NEWLINE> s += op ( i - fo , j - fo ) / 2.0 <NEWLINE> <DEDENT> print ( <STRING> % abs ( ss ) ) <NEWLINE>
def cross ( x , y ) : <NEWLINE> <INDENT> return ( x . conjugate ( ) * y ) . imag <NEWLINE> <NL> <DEDENT> def area_polygon ( points ) : <NEWLINE> <INDENT> area = 0 <NEWLINE> n = len ( points ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> area += cross ( points [ i ] , points [ ( i + 1 ) % n ] ) <NEWLINE> <DEDENT> return area / 2 <NEWLINE> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> p = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p . append ( list ( map ( float , line . split ( <STRING> ) ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( area_polygon ( p ) ) ) <NEWLINE>
import sys <NEWLINE> s = 0 <NEWLINE> p = [ list ( map ( float , e . split ( <STRING> ) ) ) for e in sys . stdin ] <NEWLINE> n = len ( p ) <NEWLINE> for i in range ( n ) : a , b = p [ i ] ; c , d = p [ - ~ i % n ] ; s += a * d - b * c <NEWLINE> print ( s / 2 ) <NEWLINE> <NL> // abs abs <NEWLINE>
def cross ( x , y ) : <NEWLINE> <INDENT> return ( x . conjugate ( ) * y ) . imag <NEWLINE> <NL> <DEDENT> def area_polygon ( points ) : <NEWLINE> <INDENT> area = 0 <NEWLINE> n = len ( points ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> area += cross ( points [ i ] , points [ ( i + 1 ) % n ] ) <NEWLINE> <DEDENT> return area / 2 <NEWLINE> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> p = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> x , y = map ( float , line . split ( <STRING> ) ) <NEWLINE> p . append ( x + y * j ) ) <NEWLINE> <NL> <DEDENT> print ( abs ( area_polygon ( p ) ) ) <NEWLINE>
def third_root ( q ) : <NEWLINE> <INDENT> x = q / 2.0 <NEWLINE> while abs ( x ** 3 - q ) >= q * 10 ** ( - 5 ) : <NEWLINE> <INDENT> x = x - ( x ** 3 - q ) / ( 3 * x ** 2 ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> if q == - 1 : break <NEWLINE> ans = third_root ( q ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> q = float ( e ) <NEWLINE> x = q / 2 <NEWLINE> while abs ( x ** 3 - q ) - q * 1e-5 : x -= ( x ** 3 - q ) / ( 3 * x * x ) <NEWLINE> print ( x ) <NEWLINE> <DEDENT>
<NL> <NL> def third ( n , q ) : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> q = float ( q ) <NEWLINE> if n == 1 : return q / 2 <NEWLINE> else : return third ( n - 1 , q ) - ( third ( n - 1 , q ) ** 3 - q ) / ( 3 * third ( n - 1 , q ) ** 2 ) <NEWLINE> <NL> <DEDENT> kai = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> if q == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 1 <NEWLINE> q = float ( q ) <NEWLINE> while ( abs ( q - third ( n , q ) ** 3 ) >= 0.00001 * q ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> print <STRING> . format ( third ( n , q ) ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def third_root ( q ) : <NEWLINE> <INDENT> x = q / 2 <NEWLINE> while abs ( x ** 3 - q ) >= q * 10 ** ( - 5 ) : <NEWLINE> <INDENT> x = x - ( x ** 3 - q ) / ( 3 * x ** 2 ) <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> q = input ( ) <NEWLINE> if q == - 1 : break <NEWLINE> ans = third_root ( q ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 , xq , yq = map ( float , line . strip ( ) . split ( <STRING> ) ) <NEWLINE> if x1 == x2 : <NEWLINE> <INDENT> x , y = - xq + 2 * x1 , yq <NEWLINE> <DEDENT> elif y1 == y2 : <NEWLINE> <INDENT> x , y = xq , - yq + 2 * y1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = ( y1 - y2 ) / ( x1 - x2 ) <NEWLINE> n = - m * x1 + y1 <NEWLINE> x , y = ( 2 * yq * m - 2 * m * n + xq - m * m * xq ) / ( m * m + 1 ) , ( xq - x ) / m + yq ; <NEWLINE> <DEDENT> print <STRING> . format ( x + 0 , y + 0 ) <NEWLINE> <DEDENT>
v = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> p = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> min = [ ] <NEWLINE> min_value = 0 <NEWLINE> <NL> for i in range ( 8 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for j in range ( 8 ) : <NEWLINE> <INDENT> if p [ ( j ) % 8 ] - v [ ( j + i ) % 8 ] >= 0 : <NEWLINE> <INDENT> count += p [ ( j ) % 8 ] - v [ ( j + i ) % 8 ] <NEWLINE> <DEDENT> <DEDENT> if len ( min ) == 0 : <NEWLINE> <INDENT> min_value = count <NEWLINE> min . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count < min_value : <NEWLINE> <INDENT> min_value = count <NEWLINE> min = [ ] <NEWLINE> min . append ( i ) <NEWLINE> <DEDENT> elif count == min_value : <NEWLINE> <INDENT> min . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> min1_value = 41412122 <NEWLINE> for i in range ( len ( min ) ) : <NEWLINE> <INDENT> value = <STRING> <NEWLINE> for j in range ( 8 ) : <NEWLINE> <INDENT> value += str ( v [ ( j + min [ i ] ) % 8 ] ) <NEWLINE> <DEDENT> if min1_value > int ( value ) : <NEWLINE> <INDENT> min1_value = int ( value ) <NEWLINE> min1 = min [ i ] <NEWLINE> <DEDENT> <DEDENT> solve = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> solve . append ( str ( v [ ( i + min1 ) % 8 ] ) ) <NEWLINE> <DEDENT> print <STRING> . join ( solve ) <NEWLINE> <DEDENT>
merry = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> gst = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = 10000 <NEWLINE> ans = set ( ) <NEWLINE> for i in range ( len ( merry ) ) : <NEWLINE> <INDENT> temp = merry [ i : ] + merry [ : i ] <NEWLINE> s = sum ( [ max ( gst [ i ] - temp [ i ] , 0 ) for i in range ( len ( merry ) ) ] ) <NEWLINE> if s == m : <NEWLINE> <INDENT> ans . add ( <STRING> . join ( map ( str , temp ) ) ) <NEWLINE> <DEDENT> elif s < m : <NEWLINE> <INDENT> m = s <NEWLINE> ans . clear ( ) <NEWLINE> ans . add ( <STRING> . join ( map ( str , temp ) ) ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( min ( ans ) ) <NEWLINE> <DEDENT>
cart = [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> que = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mx , mxcart = 0 , <STRING> <NEWLINE> for sp in range ( 8 ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> for num in range ( 8 ) : <NEWLINE> <INDENT> if cart [ ( sp + num ) % 8 ] <= que [ num ] : <NEWLINE> <INDENT> sm += cart [ ( sp + num ) % 8 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sm += que [ num ] <NEWLINE> <DEDENT> <DEDENT> if sm = mx : <NEWLINE> <INDENT> mx = sm <NEWLINE> mxcart = <STRING> . join ( map ( str , cart [ sp : ] + cart [ : sp ] ) ) <NEWLINE> <DEDENT> elif sm == mx : <NEWLINE> <INDENT> acart = <STRING> . join ( map ( str , cart [ sp : ] + cart [ : sp ] ) ) <NEWLINE> if int ( mxcart ) > int ( acart ) : <NEWLINE> <INDENT> mxcart = acart <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , mxcart ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> patterns = [ [ 1 , 2 , 1 , 2 , 1 , 4 , 1 , 4 ] , <NEWLINE> <INDENT> [ 1 , 2 , 1 , 4 , 1 , 4 , 1 , 2 ] , <NEWLINE> [ 1 , 4 , 1 , 4 , 1 , 2 , 1 , 2 ] , <NEWLINE> [ 2 , 1 , 2 , 1 , 4 , 1 , 4 , 1 ] , <NEWLINE> [ 2 , 1 , 4 , 1 , 4 , 1 , 2 , 1 ] , <NEWLINE> [ 4 , 1 , 2 , 1 , 2 , 1 , 4 , 1 ] , <NEWLINE> [ 4 , 1 , 4 , 1 , 2 , 1 , 2 , 1 ] , <NEWLINE> <DEDENT> ] <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> if not line : continue <NEWLINE> p = [ int ( x ) for x in line . split ( ) ] <NEWLINE> m = sum ( p ) <NEWLINE> pt = None <NEWLINE> for ptn in patterns : <NEWLINE> <INDENT> rem = sum ( max ( 0 , v - x ) for v , x in zip ( ptn , p ) ) <NEWLINE> if rem < m : <NEWLINE> <INDENT> m = rem <NEWLINE> pt = ptn <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( [ str ( x ) for x in pt ] ) <NEWLINE> <DEDENT>
from datetime import datetime <NEWLINE> def era ( f ) : <NEWLINE> <INDENT> meiji_st = datetime ( 1868 , 9 , 8 ) <NEWLINE> taisho_st = datetime ( 1912 , 7 , 30 ) <NEWLINE> showa_st = datetime ( 1926 , 12 , 25 ) <NEWLINE> heisei_st = datetime ( 1989 , 1 , 8 ) <NEWLINE> <NL> y , m , d = f <NEWLINE> dt = datetime ( y , m , d ) <NEWLINE> if dt > heisei_st : <NEWLINE> <INDENT> ret = <STRING> % ( dt . year - heisei_st . year + 1 , dt . month , dt . day ) <NEWLINE> <DEDENT> elif dt > showa_st : <NEWLINE> <INDENT> ret = <STRING> % ( dt . year - showa_st . year + 1 , dt . month , dt . day ) <NEWLINE> <DEDENT> elif dt > taisho_st : <NEWLINE> <INDENT> ret = <STRING> % ( dt . year - taisho_st . year + 1 , dt . month , dt . day ) <NEWLINE> <DEDENT> elif dt > meiji_st : <NEWLINE> <INDENT> ret = <STRING> % ( dt . year - meiji_st . year + 1 , dt . month , dt . day ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> <NL> <DEDENT> return ( ret ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> f = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> print ( era ( f ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> line = raw_input ( ) <NEWLINE> word_list = line . translate ( None , <STRING> ) . split ( ) <NEWLINE> for i , word in enumerate ( word_list ) : <NEWLINE> <INDENT> if len ( word ) >= 3 and len ( word ) <= 6 : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( word ) <NEWLINE> <DEDENT> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE>
code = str ( raw_input ( ) ) <NEWLINE> <NL> code = code . replace ( <STRING> , <STRING> ) <NEWLINE> code = code . replace ( <STRING> , <STRING> ) <NEWLINE> code = code . split ( ) <NEWLINE> <NL> list = [ ] <NEWLINE> <NL> for var in code : <NEWLINE> <INDENT> if len ( var ) >= 3 and len ( var ) <= 6 : <NEWLINE> <INDENT> list . append ( var ) <NEWLINE> <NL> <DEDENT> <DEDENT> for var in list : <NEWLINE> <INDENT> print var , <NEWLINE> <NL> <DEDENT> print <STRING> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> str = raw_input ( ) <NEWLINE> str = str . replace ( <STRING> , <STRING> ) <NEWLINE> str = str . replace ( <STRING> , <STRING> ) <NEWLINE> strs = str . split ( ) <NEWLINE> ans = <STRING> <NEWLINE> for out in strs : <NEWLINE> <INDENT> if ( len ( out ) > 2 and len ( out ) < 7 ) : <NEWLINE> <INDENT> ans += out + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
import re <NEWLINE> print ( * [ x for x in re . split ( <STRING> , input ( ) ) if 2 < len ( s ) < 7 ] ) <NEWLINE>
msg = map ( str , raw_input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> ans = <STRING> <NEWLINE> for word in msg : <NEWLINE> <INDENT> if 2 < len ( word ) < 7 : <NEWLINE> <INDENT> ans += word + <STRING> <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
msg = map ( str , raw_input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> for w in msg : <NEWLINE> <INDENT> print w , if 2 < len ( w ) < 7 else <STRING> <NEWLINE> <DEDENT>
s = raw_input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . split ( ) <NEWLINE> s = <STRING> . join ( map ( lambda 2 < len ( w ) < 7 s ) ) <NEWLINE> print s <NEWLINE>
while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ 1 for i in range ( n ) ] <NEWLINE> pn = n ; count = 0 ; flag = 1 <NEWLINE> while flag = 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == m : <NEWLINE> <INDENT> p [ i ] = 0 <NEWLINE> count = 0 <NEWLINE> pn -= 1 <NEWLINE> if pn == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print p . index ( 1 ) + 1 <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ 1 for i in range ( n ) ] <NEWLINE> pn = n ; count = 0 <NEWLINE> while pn > 1 : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> if count == m : <NEWLINE> <INDENT> p [ i ] = 0 <NEWLINE> pn -= 1 <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print p . index ( 1 ) + 1 <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 and m == 0 : break <NEWLINE> l = range ( 1 , 1 + n ) <NEWLINE> st = m - 1 <NEWLINE> while len ( l ) != 1 : <NEWLINE> <INDENT> del l [ st ] <NEWLINE> st += ( m - 1 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if st >= len ( l ) : <NEWLINE> <INDENT> st = st - len ( l ) <NEWLINE> <DEDENT> if st < len ( l ) : break <NEWLINE> <DEDENT> <DEDENT> print ( l [ 0 ] ) <NEWLINE> <NL> <DEDENT>
def act ( t , m , l ) : <NEWLINE> <INDENT> t = ( t + m ) % len ( l ) ; <NEWLINE> del l [ t - 1 ] <NEWLINE> return ( t - 1 ) % ( len ( l ) + 1 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> i = raw_input ( ) . split ( ) <NEWLINE> <NL> n = int ( i [ 0 ] ) <NEWLINE> m = int ( i [ 1 ] ) <NEWLINE> <NL> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = range ( 1 , n + 1 ) <NEWLINE> t = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tt = act ( t , m , l ) ; <NEWLINE> t = tt ; <NEWLINE> <DEDENT> print l [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
def f ( n , k ) : <NEWLINE> <INDENT> return 0 if n == 0 else ( f ( n - 1 , k ) + k ) % n <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> n , k = map ( int , raw_input ( ) . strip ( ) . split ( ) ) <NEWLINE> if ( n , k ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print f ( n , k ) + 1 <NEWLINE> <DEDENT>
<COMMENT> <NL> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <COMMENT> <NL> <INDENT> key = [ 0 ] * 101 <NEWLINE> <COMMENT> <NL> while 1 : <NEWLINE> <INDENT> input = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( input [ 0 ] == 0 and input [ 1 ] == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> key [ input [ 0 ] ] += 1 <NEWLINE> key [ input [ 1 ] ] += 1 <NEWLINE> <NL> <DEDENT> if ( key [ 1 ] % 2 == 1 and key [ 2 ] % 2 == 1 and len ( filter ( lambda x : x % 2 = 1 , key [ 3 : ] ) ) == 0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> <NL> input = stdin . readline <NEWLINE> <NL> <NL> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> routes = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> routes . append ( [ a , b ] ) <NEWLINE> <DEDENT> if len ( routes ) < 1 : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <NL> <DEDENT> degree = [ 0 ] * 101 <NEWLINE> for a , b in routes : <NEWLINE> <INDENT> degree [ a ] += 1 <NEWLINE> degree [ b ] += 1 <NEWLINE> <DEDENT> odds = [ x for x in degree if x % 2 == 1 ] <NEWLINE> evens = [ x for x in degree if x % 2 == 0 ] <NEWLINE> <NL> if len ( odds ) == 0 or len ( odds ) == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> def dfs ( v ) : <NEWLINE> <INDENT> global ret <NEWLINE> if ret : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if v == 2 : <NEWLINE> <INDENT> if len ( used ) == cnt : <NEWLINE> <INDENT> ret = True <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> for idx , u in enumerate ( edges [ v ] ) : <NEWLINE> <INDENT> tmp = tuple ( sorted ( ( u , v ) ) + [ idx ] ) <NEWLINE> if tmp in used : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used . add ( tmp ) <NEWLINE> dfs ( u ) <NEWLINE> used . discard ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> edges = defaultdict ( list ) <NEWLINE> cnt = 0 <NEWLINE> try : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> edges [ a ] . append ( b ) <NEWLINE> edges [ b ] . append ( a ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> stack = [ ] <NEWLINE> ret = False <NEWLINE> used = set ( ) <NEWLINE> dfs ( 1 ) <NEWLINE> if ret : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> foo = map ( str , line . strip ( ) . split ( ) ) <NEWLINE> stack = [ ] <NEWLINE> while ( foo != [ ] ) : <NEWLINE> <INDENT> if foo [ 0 ] == <STRING> : <NEWLINE> <INDENT> del foo [ 0 ] <NEWLINE> stack . append ( int ( stack . pop ( ) ) + int ( stack . pop ( ) ) ) <NEWLINE> <DEDENT> elif foo [ 0 ] == <STRING> : <NEWLINE> <INDENT> del foo [ 0 ] <NEWLINE> stack . append ( int ( stack . pop ( ) ) * int ( stack . pop ( ) ) ) <NEWLINE> <DEDENT> elif foo [ 0 ] == <STRING> : <NEWLINE> <INDENT> del foo [ 0 ] <NEWLINE> stack . append ( - int ( stack . pop ( ) ) + int ( stack . pop ( ) ) ) <NEWLINE> <DEDENT> elif foo [ 0 ] == <STRING> : <NEWLINE> <INDENT> del foo [ 0 ] <NEWLINE> stack . append ( 1.0 / int ( stack . pop ( ) ) * int ( stack . pop ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( foo . pop ( 0 ) ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . format ( stack [ 0 ] + 0 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> inp = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> stuck = [ ] <NEWLINE> for i in inp : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> stuck . append ( int ( stuck . pop ( len ( stuck ) - 2 ) ) + int ( stuck . pop ( len ( stuck ) - 1 ) ) ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> stuck . append ( int ( stuck . pop ( len ( stuck ) - 2 ) ) - int ( stuck . pop ( len ( stuck ) - 1 ) ) ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> stuck . append ( int ( stuck . pop ( len ( stuck ) - 2 ) ) * int ( stuck . pop ( len ( stuck ) - 1 ) ) ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> stuck . append ( int ( stuck . pop ( len ( stuck ) - 2 ) ) / float ( stuck . pop ( len ( stuck ) - 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stuck . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print stuck <NEWLINE> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> from collections import deque <NEWLINE> import operator <NEWLINE> <NL> func = { <STRING> : operator . add , <STRING> : operator . sub , <STRING> : operator . mul , <STRING> : operator . div } <NEWLINE> <NL> for line in f : <NEWLINE> <INDENT> stack = deque ( ) <NEWLINE> for element in line . strip ( ) . split ( ) : <NEWLINE> <INDENT> if element . isdigit ( ) : <NEWLINE> <INDENT> stack . append ( float ( element ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = stack . pop ( ) <NEWLINE> a = stack . pop ( ) <NEWLINE> stack . append ( func [ element ] ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( stack [ 0 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for s in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> st = [ ] <NEWLINE> for c in s . strip ( ) . split ( ) : <NEWLINE> <INDENT> if c . isdigit ( ) : <NEWLINE> <INDENT> st . append ( float ( c ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = st . pop ( ) ; a = st . pop ( ) ; <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> st . append ( a + b ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> st . append ( a - b ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> st . append ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . append ( a / b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print st . pop ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def line ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> ops = { <STRING> : lambda a , b : b + a , <NEWLINE> <INDENT> <STRING> : lambda a , b : b - a , <NEWLINE> <STRING> : lambda a , b : b * a , <NEWLINE> <STRING> : lambda a , b : b / a } <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> for s in line ( ) . split ( ) : <NEWLINE> <INDENT> if s in ops : <NEWLINE> <INDENT> stack . append ( ops [ s ] ( stack . pop ( ) , stack . pop ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( int ( s ) ) <NEWLINE> <DEDENT> <DEDENT> print ( stack [ 0 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import ( division , absolute_import , print_function , <NEWLINE> <INDENT> unicode_literals ) <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> <NL> for line in stdin : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> for s in line . split ( ) : <NEWLINE> <INDENT> if s . isdigit ( ) : <NEWLINE> <INDENT> stack . append ( float ( s ) ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> n = stack . pop ( ) <NEWLINE> stack [ - 1 ] += n <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> n = stack . pop ( ) <NEWLINE> stack [ - 1 ] -= n <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> n = stack . pop ( ) <NEWLINE> stack [ - 1 ] *= n <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> n = stack . pop ( ) <NEWLINE> stack [ - 1 ] /= n <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( stack [ - 1 ] ) ) <NEWLINE> <DEDENT>
def calc_inverse_polish_notation_string ( s ) : <NEWLINE> <INDENT> tokens = [ token for token in s . split ( <STRING> ) if token != <STRING> ] <NEWLINE> stack = [ ] <NEWLINE> for token in tokens : <NEWLINE> <INDENT> if token in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> val2 = stack . pop ( ) <NEWLINE> val1 = stack . pop ( ) <NEWLINE> result = eval ( <STRING> % ( val1 , token , val2 ) ) <NEWLINE> stack . append ( result ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( token ) <NEWLINE> <NL> <DEDENT> <DEDENT> return stack [ 0 ] <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> print ( calc_inverse_polish_notation_string ( line ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
s = list ( ) ; [ [ [ s . append ( eval ( <STRING> . format ( s . pop ( ) , i , s . pop ( ) ) ) if ( i in <STRING> ) else i ) for i in input ( ) . split ( <STRING> ) ] and print ( s . pop ( ) ) ] for x in __import__ ( <STRING> ) . count ( ) ] <NEWLINE>
while True : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> for s in raw_input ( ) . split ( ) : <NEWLINE> <INDENT> if s in ( <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> stack . append ( eval ( <STRING> . format ( stack . pop ( ) , s , stack . pop ( ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( float ( s ) ) <NEWLINE> <DEDENT> print <STRING> % stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for s in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> L = [ ] <NEWLINE> for d in s : <NEWLINE> <INDENT> if d == <STRING> : <NEWLINE> <INDENT> L . append ( - ( L . pop ( ) - L . pop ( ) ) ) <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> L . append ( L . pop ( ) + L . pop ( ) ) <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> L . append ( L . pop ( ) * L . pop ( ) ) <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> L . append ( 1 / L . pop ( ) * L . pop ( ) ) <NEWLINE> <DEDENT> L . append ( float ( d ) ) <NEWLINE> <DEDENT> print L [ 0 ] <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> st = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> for s in st : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( - 2 ) + stack . pop ( ) ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( - 2 ) - stack . pop ( ) ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( - 2 ) * stack . pop ( ) ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( - 2 ) / stack . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( float ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print stack [ 0 ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
encode = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> decode = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> string = raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> e , ans = <STRING> , <STRING> <NEWLINE> for s in string : <NEWLINE> <INDENT> e += encode [ s ] <NEWLINE> <DEDENT> tmp = [ ] <NEWLINE> while len ( e ) > 4 : <NEWLINE> <INDENT> tmp . append ( e [ 0 : 5 ] ) <NEWLINE> e = e [ 5 : ] <NEWLINE> <DEDENT> if len ( e ) != 0 : <NEWLINE> <INDENT> e += <STRING> * ( 5 - len ( e ) ) <NEWLINE> tmp . append ( e ) <NEWLINE> <DEDENT> print tmp <NEWLINE> <NL> <COMMENT> <NL> for s in tmp : <NEWLINE> <INDENT> ans += decode [ s ] <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
import sys <NEWLINE> A = <STRING> <NEWLINE> B = <STRING> <STRING> <STRING> <STRING> . split ( ) <NEWLINE> C = <STRING> <NEWLINE> d1 = { } <NEWLINE> for i in range ( 26 ) : d1 [ A [ i ] ] = B [ i ] <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> x = <STRING> <NEWLINE> for c in s [ : - 1 ] : x += d1 [ c ] <NEWLINE> x += <STRING> * ( - len ( x ) % 5 ) <NEWLINE> s = <STRING> <NEWLINE> for i in range ( 0 , len ( x ) , 5 ) : s += C [ int ( x [ i : i + 5 ] , 2 ) ] <NEWLINE> print s <NEWLINE> <DEDENT>
d1 = { <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> d2 = { <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> while 1 : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> s1 , ans = <STRING> , <STRING> <NEWLINE> for w in s : <NEWLINE> <INDENT> s1 += d1 [ w ] <NEWLINE> <DEDENT> s1 += <STRING> * ( 5 - len ( s1 ) % 5 ) <NEWLINE> for i in range ( len ( s1 ) / 5 ) : <NEWLINE> <INDENT> ans += d2 [ s1 [ : 5 ] ] <NEWLINE> s1 = s1 [ 5 : ] <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
def mx ( p , w , h , l ) : <NEWLINE> <INDENT> if h <= c / 2 : <NEWLINE> <INDENT> if w == 0 : p [ h ] [ w ] += p [ h - 1 ] [ w ] <NEWLINE> elif w == l - 1 : p [ h ] [ w ] += p [ h - 1 ] [ w - 1 ] <NEWLINE> else : p [ h ] [ w ] += max ( p [ h - 1 ] [ w ] , p [ h - 1 ] [ w - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ h ] [ w ] += max ( p [ h - 1 ] [ w ] , p [ h - 1 ] [ w + 1 ] ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> p = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p . append ( map ( int , raw_put ( ) . split ( <STRING> ) ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for h in range ( 1 , c ) : <NEWLINE> <INDENT> l = len ( p [ h ] ) <NEWLINE> for w in range ( l ) : <NEWLINE> <INDENT> p = mx ( p , w , h , l ) <NEWLINE> <DEDENT> <DEDENT> print p [ c - 1 ] [ 0 ] <NEWLINE>
import sys <NEWLINE> def index ( x , n ) : <NEWLINE> <INDENT> if x < 0 : return 0 <NEWLINE> if n < x : return n <NEWLINE> return x <NEWLINE> <NL> <DEDENT> las = map ( int , raw_input ( ) ) <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> now = map ( int , s . split ( <STRING> ) ) <NEWLINE> nin , lin = len ( now ) - 1 , len ( las ) - 1 <NEWLINE> if nin > lin : d = - 1 <NEWLINE> if nin < lin : d = 1 <NEWLINE> for i in xrange ( nin + 1 ) : <NEWLINE> <INDENT> now [ i ] += max ( las [ index ( i + d , lin ) ] , las [ index ( i , lin ) ] ) <NEWLINE> <DEDENT> if not nin : print now [ 0 ] <NEWLINE> las = now <NEWLINE> <DEDENT>
def path ( w , h , sm ) : <NEWLINE> <INDENT> if w < 0 or len ( inp [ h ] ) - 1 < w : return 0 <NEWLINE> sm += inp [ h ] [ w ] <NEWLINE> if h == c - 1 : return sm <NEWLINE> if h < c / 2 : return max ( path ( w , h + 1 , sm ) , path ( w + 1 , h + 1 , sm ) ) <NEWLINE> else : return max ( path ( w , h + 1 , sm ) , path ( w - 1 , h + 1 , sm ) ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> inp = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> inp . append ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print path ( 0 , 0 , 0 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
e = 1e-6 <NEWLINE> def f ( m ) : <NEWLINE> <INDENT> c = 1j * math . acos ( a / 2 ) <NEWLINE> p1 = cmath . exp ( b + c ) + p <NEWLINE> p2 = cmath . exp ( b - c ) + p <NEWLINE> s1 , s2 = 2 , 2 <NEWLINE> for k in N : <NEWLINE> <INDENT> if k in [ i , i1 ] : continue <NEWLINE> if abs ( X [ k ] - p1 ) < 1 + e : s1 += 1 <NEWLINE> if abs ( X [ k ] - p2 ) < 1 + e : s2 += 1 <NEWLINE> <DEDENT> return max ( m , s1 , s2 ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> N = range ( n ) <NEWLINE> X = [ ] <NEWLINE> for i in N : <NEWLINE> <INDENT> x , y = input ( ) <NEWLINE> X += [ x + 1j * y ] <NEWLINE> <DEDENT> m = 1 <NEWLINE> for i in N : <NEWLINE> <INDENT> p = X [ i ] <NEWLINE> for i1 in range ( i + 1 , n ) : <NEWLINE> <INDENT> a , b = cmath . polar ( X [ i1 ] - p ) <NEWLINE> b *= 1j <NEWLINE> if a <= 2 : m = f ( m ) <NEWLINE> <DEDENT> <DEDENT> print m <NEWLINE> <DEDENT>
from __future__ import division <NEWLINE> import math <NEWLINE> <NL> def cross ( p1 , p2 ) : <NEWLINE> <INDENT> a , b , c , d = p1 [ 0 ] , p1 [ 1 ] , p2 [ 0 ] , p2 [ 1 ] <NEWLINE> t = pow ( a , 2 ) + pow ( c , 2 ) + pow ( d , 2 ) - pow ( b , 2 ) - 2 * a * c <NEWLINE> alpha = 4 * ( pow ( b - d , 2 ) + pow ( c - a , 2 ) ) <NEWLINE> beta = 4 * ( t * ( b - d ) - 2 * b * pow ( c - a , 2 ) ) <NEWLINE> gamma = pow ( t , 2 ) + 4 * pow ( b , 2 ) * pow ( c - a , 2 ) - 4 * pow ( c - a , 2 ) <NEWLINE> judge = pow ( beta , 2 ) - 4 * alpha * gamma <NEWLINE> EPS = 1e-5 <NEWLINE> if c == a : <NEWLINE> <INDENT> y = ( pow ( a , 2 ) + pow ( b , 2 ) - pow ( c , 2 ) - pow ( d , 2 ) ) / ( 2 * ( b - d ) ) <NEWLINE> bd = pow ( b - d , 2 ) <NEWLINE> a1 = 4 * bd <NEWLINE> b1 = - 8 * a * bd <NEWLINE> c1 = 4 * a * a * bd + pow ( a * a - b * b - c * c - d * d + 2 * b * d , 2 ) - 4 * bd <NEWLINE> inroot = pow ( b1 , 2 ) - 4 * a1 * c1 <NEWLINE> x1 = ( - b1 + math . sqrt ( inroot ) ) / ( 2 * a1 ) <NEWLINE> x2 = ( - b1 - math . sqrt ( inroot ) ) / ( 2 * a1 ) <NEWLINE> return ( ( x1 , y ) , ( x2 , y ) ) <NEWLINE> <NL> <DEDENT> if judge > EPS : <NEWLINE> <INDENT> y1 = ( - beta + math . sqrt ( judge ) ) / ( 2 * alpha ) <NEWLINE> y2 = ( - beta - math . sqrt ( judge ) ) / ( 2 * alpha ) <NEWLINE> x1 = ( 2 * ( b - d ) * y1 + pow ( c , 2 ) + pow ( d , 2 ) - pow ( a , 2 ) - pow ( b , 2 ) ) / ( 2 * ( c - a ) ) <NEWLINE> x2 = ( 2 * ( b - d ) * y2 + pow ( c , 2 ) + pow ( d , 2 ) - pow ( a , 2 ) - pow ( b , 2 ) ) / ( 2 * ( c - a ) ) <NEWLINE> return ( ( x1 , y1 ) , ( x2 , y2 ) ) <NEWLINE> <DEDENT> elif - EPS <= judge <= EPS : <NEWLINE> <INDENT> y = - beta / ( 2 * alpha ) <NEWLINE> x = ( 2 * ( b - d ) * y + pow ( c , 2 ) + pow ( d , 2 ) - pow ( a , 2 ) - pow ( b , 2 ) ) / ( 2 * ( c - a ) ) <NEWLINE> return ( ( x , y ) , ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def maxNum ( P , L ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> for x , y in P : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for px , py in L : <NEWLINE> <INDENT> d = math . sqrt ( pow ( px - x , 2 ) + pow ( py - y , 2 ) ) <NEWLINE> if d <= 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> L = [ map ( float , raw_input ( ) . split ( <STRING> ) ) for i in range ( n ) ] <NEWLINE> P = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> points = cross ( L [ i ] , L [ j ] ) <NEWLINE> if points : <NEWLINE> <INDENT> P . extend ( points ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print maxNum ( P , L ) <NEWLINE> <DEDENT>
def isOver ( a , b ) : <NEWLINE> <INDENT> return True if ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 <= 4.0 else False <NEWLINE> <NL> <DEDENT> def largestGroup ( mtrx , num ) : <NEWLINE> <INDENT> mx = 1 <NEWLINE> ls = [ num ] <NEWLINE> for i in mtrx [ num ] : <NEWLINE> <INDENT> m = youKnow ( mtrx , ls , i ) <NEWLINE> mx = max ( mx , m ) <NEWLINE> <DEDENT> return mx <NEWLINE> <NL> <DEDENT> def youKnow ( mtrx , ls , num ) : <NEWLINE> <INDENT> mx = len ( ls ) <NEWLINE> if set ( ls ) <= set ( mtrx [ num ] ) : <NEWLINE> <INDENT> ls . append ( num ) <NEWLINE> for i in list ( set ( mtrx [ num ] ) - set ( ls ) ) : <NEWLINE> <INDENT> m = youKnow ( mtrx , ls , i ) <NEWLINE> mx = max ( mx , m ) <NEWLINE> <DEDENT> <DEDENT> return mx <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> max_over = 0 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> seals = [ map ( float , raw_input ( ) . split ( <STRING> ) ) for i in range ( n ) ] <NEWLINE> <NL> overs = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> over = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if isOver ( seals [ i ] , seals [ j ] ) and i != j : <NEWLINE> <INDENT> over . append ( j ) <NEWLINE> <DEDENT> <DEDENT> overs . append ( over ) <NEWLINE> <NL> <DEDENT> ref = [ i for i in range ( n ) ] <NEWLINE> for i in ref : <NEWLINE> if len ( overs [ i ] ) > 0 : <NEWLINE> <INDENT> num_over = largestGroup ( overs , i ) <NEWLINE> for j in overs [ i ] : <NEWLINE> <INDENT> if j in ref : ref . remove ( j ) <NEWLINE> if num_over > max_over : <NEWLINE> max_over = num_over <NEWLINE> <DEDENT> <DEDENT> print max_over <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> EPS = 10 ** ( - 8 ) <NEWLINE> N = 100 <NEWLINE> def intersection ( p , q , s , t ) : <NEWLINE> <INDENT> a = 2 * ( p - s ) <NEWLINE> b = 2 * ( q - t ) <NEWLINE> c = ( p ** 2 + q ** 2 ) - ( s ** 2 + t ** 2 ) <NEWLINE> A = a ** 2 + b ** 2 <NEWLINE> x0 , y0 , x1 , y1 = [ 0.0 ] * 4 <NEWLINE> if A < EPS : <NEWLINE> <INDENT> return p , q , s , t <NEWLINE> <DEDENT> Bx = p * b ** 2 + a * ( c - q * b ) <NEWLINE> Cx = ( p ** 2 + q ** 2 - 1 ) * b ** 2 - 2 * b * c * q + c ** 2 <NEWLINE> Dx = Bx ** 2 - A * Cx <NEWLINE> By = q * a ** 2 + b * ( c - p * a ) <NEWLINE> Cy = ( p ** 2 + q ** 2 - 1 ) * a ** 2 - 2 * a * c * p + c ** 2 <NEWLINE> Dy = By ** 2 - A * Cy <NEWLINE> if b > EPS : <NEWLINE> <INDENT> x0 = ( - sqrt ( Dx ) + Bx ) / A ; y0 = ( - x0 * a + c ) / b ; <NEWLINE> x1 = ( sqrt ( Dx ) + Bx ) / A ; y1 = ( - x1 * a + c ) / b ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x0 = ( - y0 * b + c ) / a ; y0 = ( - sqrt ( Dy ) + By ) / A ; <NEWLINE> x1 = ( - y1 * b + c ) / a ; y1 = ( sqrt ( Dy ) + By ) / A ; <NEWLINE> <DEDENT> return x0 , y0 , x1 , y1 <NEWLINE> <DEDENT> def dist ( p , q , s , t ) : <NEWLINE> <INDENT> return ( p - s ) ** 2 + ( q - t ) ** 2 <NEWLINE> <DEDENT> x , y = [ 0.0 ] * N , [ 0.0 ] * N <NEWLINE> xi = [ 0.0 ] * 2 ; yi = [ 0.0 ] * 2 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> x [ i ] , y [ i ] = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , n ) : <NEWLINE> <INDENT> rr = dist ( x [ i ] , y [ i ] , x [ j ] , y [ j ] ) <NEWLINE> if rr < 4.00 + EPS : <NEWLINE> <INDENT> if rr < EPS : <NEWLINE> <INDENT> cnt = 2 <NEWLINE> for k in xrange ( n ) : <NEWLINE> <INDENT> if k == i or k == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist ( x [ i ] , y [ i ] , x [ k ] , y [ k ] ) < 1.00 + EPS : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xi [ 0 ] , yi [ 0 ] , xi [ 1 ] , yi [ 1 ] = intersection ( x [ i ] , y [ i ] , x [ j ] , y [ j ] ) <NEWLINE> for t in xrange ( 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> cnt = 2 <NEWLINE> for k in xrange ( n ) : <NEWLINE> <INDENT> if k == i or k == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rri = dist ( xi [ t ] , yi [ t ] , x [ k ] , y [ k ] ) <NEWLINE> if rri < 1.00 + EPS : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
import math , cmath <NEWLINE> def f ( m ) : <NEWLINE> <INDENT> b *= 1j <NEWLINE> c = math . acos ( a / 2 ) <NEWLINE> p1 = cmath . exp ( b + c ) + p0 <NEWLINE> p2 = cmath . exp ( b - c ) + p0 <NEWLINE> s1 , s2 = 0 , 0 <NEWLINE> for k in N : <NEWLINE> <INDENT> if k == i or k == j : continue <NEWLINE> if abs ( p1 - X [ k ] ) <= 1 : s1 += 1 <NEWLINE> if abs ( p2 - X [ k ] ) <= 1 : s2 += 1 <NEWLINE> <DEDENT> if s1 > m : m = s1 <NEWLINE> if s2 > m : m = s2 <NEWLINE> return m <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> N = range ( n ) <NEWLINE> X = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( float , input ( ) ) <NEWLINE> X += [ complex ( x , y ) ] <NEWLINE> <DEDENT> m = 0 <NEWLINE> for i in N : <NEWLINE> <INDENT> p0 = X [ i ] <NEWLINE> for j in N : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> a , b = cmath . polar ( p0 - X [ j ] ) <NEWLINE> if a <= 2 : m = f ( m ) <NEWLINE> <DEDENT> <DEDENT> print m + 2 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def read_data ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> x = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> x . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> return n , x <NEWLINE> <NL> <DEDENT> def is_area3 ( x , y ) : <NEWLINE> <INDENT> if x > 7 or y > 5 : return False <NEWLINE> for dx in [ 0 , 1 , 2 , 1 , 0 ] : <NEWLINE> <INDENT> A = P [ y ] [ x - dx : x + dx + 1 ] <NEWLINE> if A . count ( 0 ) > 0 : return False <NEWLINE> y += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_area2 ( x , y ) : <NEWLINE> <INDENT> if x > 7 or y > 7 : return False <NEWLINE> for dy in [ 0 , 1 , 2 ] : <NEWLINE> <INDENT> A = P [ y + dy ] [ x : x + 3 ] <NEWLINE> if A . count ( 0 ) > 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_area1 ( x , y ) : <NEWLINE> <INDENT> if x > 8 or y > 7 : return False <NEWLINE> for dx in [ 0 , 1 , 0 ] : <NEWLINE> <INDENT> A = P [ y ] [ x - dx : x + dx + 1 ] <NEWLINE> if A . count ( 0 ) > 0 : return False <NEWLINE> y += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def ink ( x , y , s , m ) : <NEWLINE> <INDENT> global P <NEWLINE> dx = [ 0 , 1 , - 1 , 0 , 0 , 1 , 1 , - 1 , - 1 , 2 , - 2 , 0 , 0 ] <NEWLINE> dy = [ 0 , 0 , - 0 , 1 , - 1 , 1 , - 1 , 1 , - 1 , 0 , 0 , 2 , - 2 ] <NEWLINE> for i in range ( [ 5 , 9 , 13 ] [ s - 1 ] ) : <NEWLINE> <INDENT> P [ y + dy [ i ] ] [ x + dx [ i ] ] += m <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> drops , P = read_data ( ) <NEWLINE> A = [ ] <NEWLINE> i = - 1 <NEWLINE> m = 3 <NEWLINE> while i < 99 : <NEWLINE> <INDENT> i += 1 <NEWLINE> y = i / 10 <NEWLINE> x = i % 10 <NEWLINE> if P [ y ] [ x ] == 0 : continue <NEWLINE> <NL> if m == 3 : <NEWLINE> <INDENT> while is_area3 ( x , y ) : <NEWLINE> <INDENT> A . append ( [ x , y , 3 ] ) <NEWLINE> ink ( x , y + 2 , 3 , - 1 ) <NEWLINE> <DEDENT> if P [ y ] [ x ] == 0 : <NEWLINE> <INDENT> m = 3 <NEWLINE> continue <NEWLINE> <DEDENT> else : m = 2 <NEWLINE> <NL> <DEDENT> if m == 2 : <NEWLINE> <INDENT> while is_area2 ( x , y ) : <NEWLINE> <INDENT> A . append ( [ x , y , 2 ] ) <NEWLINE> ink ( x + 1 , y + 1 , 2 , - 1 ) <NEWLINE> <DEDENT> if P [ y ] [ x ] == 0 : <NEWLINE> <INDENT> m = 3 <NEWLINE> continue <NEWLINE> <DEDENT> else : m = 1 <NEWLINE> <NL> <DEDENT> if m == 1 : <NEWLINE> <INDENT> while is_area1 ( x , y ) : <NEWLINE> <INDENT> A . append ( [ x , y , 1 ] ) <NEWLINE> ink ( x , y + 1 , 1 , - 1 ) <NEWLINE> <DEDENT> if P [ y ] [ x ] == 0 : <NEWLINE> <INDENT> m = 3 <NEWLINE> continue <NEWLINE> <DEDENT> else : m = 0 <NEWLINE> <NL> <DEDENT> dx = [ 0 , 1 , 0 ] <NEWLINE> dy = [ 1 , 1 , 2 ] <NEWLINE> if m == 0 and len ( A ) > 0 : <NEWLINE> <INDENT> x , y , m = A . pop ( ) <NEWLINE> m -= 1 <NEWLINE> ink ( x + dx [ m ] , y + dy [ m ] , m + 1 , 1 ) <NEWLINE> i = y * 10 + x - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if drops <= 12 and len ( A ) == drops : <NEWLINE> <INDENT> for x , y , s in A : print x + dx [ s - 1 ] , y + dy [ s - 1 ] , s <NEWLINE> <DEDENT>
import itertools <NEWLINE> ref = { 5 : 1 , 9 : 2 , 13 : 3 } <NEWLINE> dx = [ 0 , 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , - 1 , 2 , 0 , - 2 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 , 0 , - 1 , 1 , 1 , - 1 , 0 , 2 , 0 , - 2 ] <NEWLINE> <NL> def isOn ( x , y ) : <NEWLINE> <INDENT> return 0 <= x < 10 and 0 <= y < 10 <NEWLINE> <NL> <DEDENT> def minus ( C , x , y , size ) : <NEWLINE> <INDENT> for i in range ( size ) : <NEWLINE> <INDENT> C [ y + dy [ i ] ] [ x + dx [ i ] ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def plus ( C , x , y , size ) : <NEWLINE> <INDENT> for i in range ( size ) : <NEWLINE> <INDENT> C [ y + dy [ i ] ] [ x + dx [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def canMinus ( C , x , y , size ) : <NEWLINE> <INDENT> return all ( [ isOn ( x + dx [ i ] , y + dy [ i ] ) and C [ y + dy [ i ] ] [ x + dx [ i ] ] > 0 for i in range ( size ) ] ) <NEWLINE> <NL> <DEDENT> def findAns ( C , drops , k , sp ) : <NEWLINE> <INDENT> if k == len ( drops ) : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> for i in range ( sp , 100 ) : <NEWLINE> <INDENT> if C [ i / 10 ] [ i % 10 ] > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sp += 1 <NEWLINE> <DEDENT> for drop in drops : <NEWLINE> <INDENT> size = drop [ 0 ] <NEWLINE> if drop [ 1 ] != 0 : <NEWLINE> <INDENT> for i in range ( size ) : <NEWLINE> <INDENT> sx , sy = sp % 10 + dx [ i ] , sp / 10 + dy [ i ] <NEWLINE> if isOn ( sx , sy ) and C [ sy ] [ sx ] > 0 : <NEWLINE> <INDENT> if canMinus ( C , sx , sy , size ) : <NEWLINE> <INDENT> minus ( C , sx , sy , size ) <NEWLINE> drops [ k ] [ 1 ] -= 1 <NEWLINE> pk = 1 if drops [ k ] [ 1 ] == 0 else 0 <NEWLINE> ans = findAns ( C , drops , k + pk , sp ) <NEWLINE> if ans != False : <NEWLINE> <INDENT> ans . append ( [ sx , sy , size ] ) <NEWLINE> return ans <NEWLINE> <DEDENT> drops [ k ] [ 1 ] += 1 <NEWLINE> plus ( C , sx , sy , size ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> C = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( 10 ) ] <NEWLINE> sm = sum ( [ sum ( C [ i ] ) for i in range ( 10 ) ] ) <NEWLINE> dropList = [ ] <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> m4 = 13 * n - sm - 8 * s <NEWLINE> if m4 < 0 : break <NEWLINE> if m4 % 4 == 0 : <NEWLINE> <INDENT> m = m4 / 4 <NEWLINE> if n - s - m >= 0 : <NEWLINE> <INDENT> dropList . append ( [ [ 13 , n - s - m ] , [ 9 , m ] , [ 5 , s ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for drops in dropList : <NEWLINE> <INDENT> for i in range ( 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> if drops [ i ] [ 1 ] == 0 : <NEWLINE> <INDENT> drops . pop ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = findAns ( C , drops , 0 , 0 ) <NEWLINE> if ans != False : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print a [ 0 ] , a [ 1 ] , ref [ a [ 2 ] ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import time <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> import math , sys , time <NEWLINE> <NL> def read_data ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = input ( ) <NEWLINE> x = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( 10 ) : <NEWLINE> <INDENT> x . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> return n , x <NEWLINE> <NL> <DEDENT> def is_area3 ( x , y ) : <NEWLINE> <INDENT> if x > 7 or y > 6 : return False <NEWLINE> for dx in [ 0 , 1 , 2 , 1 , 0 ] : <NEWLINE> <INDENT> A = P [ y ] [ x - dx : x + dx + 1 ] <NEWLINE> if A . count ( 0 ) > 0 : return False <NEWLINE> y += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_area2 ( x , y ) : <NEWLINE> <INDENT> if x > 7 or y > 7 : return False <NEWLINE> for dy in [ 0 , 1 , 2 ] : <NEWLINE> <INDENT> A = P [ y + dy ] [ x : x + 3 ] <NEWLINE> if A . count ( 0 ) > 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_area1 ( x , y ) : <NEWLINE> <INDENT> if x > 8 or y > 8 : return False <NEWLINE> for dx in [ 0 , 1 , 0 ] : <NEWLINE> <INDENT> A = P [ y ] [ x - dx : x + dx + 1 ] <NEWLINE> if A . count ( 0 ) > 0 : return False <NEWLINE> y += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def ink ( x , y , s , m ) : <NEWLINE> <INDENT> global P <NEWLINE> for dy , dx in [ [ 0 , 0 ] , [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] : <NEWLINE> <INDENT> P [ y + dy ] [ x + dx ] += m <NEWLINE> <DEDENT> if s == 1 : return <NEWLINE> for dy , dx in [ [ 1 , 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] , [ - 1 , - 1 ] ] : <NEWLINE> <INDENT> P [ y + dy ] [ x + dx ] += m <NEWLINE> <DEDENT> if s == 2 : return <NEWLINE> for dy , dx in [ [ 2 , 0 ] , [ - 2 , 0 ] , [ 0 , 2 ] , [ 0 , - 2 ] ] : <NEWLINE> <INDENT> P [ y + dy ] [ x + dx ] += m <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> drops , P = read_data ( ) <NEWLINE> M = [ ] <NEWLINE> i = - 1 <NEWLINE> step = 3 <NEWLINE> while i < 99 : <NEWLINE> <INDENT> i += 1 <NEWLINE> y = i / 10 <NEWLINE> x = i % 10 <NEWLINE> if P [ y ] [ x ] == 0 : continue <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> if step == 3 : <NEWLINE> <COMMENT> <NL> <INDENT> while is_area3 ( x , y ) : <NEWLINE> <INDENT> M . append ( [ x , y , 3 ] ) <NEWLINE> ink ( x , y + 2 , 3 , - 1 ) <NEWLINE> <DEDENT> if P [ y ] [ x ] == 0 : <NEWLINE> <INDENT> step = 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> continue <NEWLINE> <DEDENT> else : step = 2 <NEWLINE> <NL> <DEDENT> if step == 2 : <NEWLINE> <COMMENT> <NL> <INDENT> while is_area2 ( x , y ) : <NEWLINE> <INDENT> M . append ( [ x , y , 2 ] ) <NEWLINE> ink ( x + 1 , y + 1 , 2 , - 1 ) <NEWLINE> <DEDENT> if P [ y ] [ x ] == 0 : <NEWLINE> <INDENT> step = 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> continue <NEWLINE> <DEDENT> else : step = 1 <NEWLINE> <NL> <DEDENT> if step == 1 : <NEWLINE> <COMMENT> <NL> <INDENT> while is_area1 ( x , y ) : <NEWLINE> <INDENT> M . append ( [ x , y , 1 ] ) <NEWLINE> ink ( x , y + 1 , 1 , - 1 ) <NEWLINE> <DEDENT> if P [ y ] [ x ] == 0 : <NEWLINE> <INDENT> step = 3 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> continue <NEWLINE> <DEDENT> else : step = 0 <NEWLINE> <NL> <DEDENT> dx = 0 <NEWLINE> dy = 1 <NEWLINE> if step == 0 and len ( M ) > 0 : <NEWLINE> <INDENT> x , y , tmp = M . pop ( ) <NEWLINE> if tmp == 3 : dy = 2 <NEWLINE> elif tmp == 2 : dx = 1 <NEWLINE> ink ( x + dx , y + dy , tmp , 1 ) <NEWLINE> i = y * 10 + x - 1 <NEWLINE> step = tmp - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if drops <= 12 and len ( M ) == drops : <NEWLINE> <INDENT> for x , y , s in M : <NEWLINE> <INDENT> dx = 0 <NEWLINE> dy = 1 <NEWLINE> if s == 3 : dy = 2 <NEWLINE> elif s == 2 : dx = 1 <NEWLINE> print x + dx , y + dy , s <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> field = [ raw_input ( ) for i in range ( n ) ] <NEWLINE> flag = 0 <NEWLINE> for len in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> for row in range ( n - len + 1 ) : <NEWLINE> <INDENT> for sp in range ( n - len + 1 ) : <NEWLINE> <INDENT> if field [ row ] [ sp : sp + len ] == <STRING> * len : <NEWLINE> <INDENT> for i in range ( 1 , len ) : <NEWLINE> <INDENT> if field [ row + i ] [ sp : sp + len ] != <STRING> * len : <NEWLINE> <INDENT> if len == 1 : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print len <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag : break <NEWLINE> <DEDENT> if flag : break <NEWLINE> <DEDENT> if flag : break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> A = [ raw_input ( ) for i in range ( n ) ] <NEWLINE> B = [ ] <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if c == 0 and <STRING> in A [ i ] : c = 1 <NEWLINE> B . append ( int ( A [ i ] . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) , 2 ) ) <NEWLINE> <DEDENT> C = B [ : ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( n - i ) : <NEWLINE> <INDENT> B [ j ] &= B [ j + 1 ] <NEWLINE> if <STRING> * ( i + 1 ) in format ( B [ j ] , <STRING> ) : c = i + 1 <NEWLINE> <DEDENT> if c != i + 1 : break <NEWLINE> <DEDENT> print c <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> r = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j , ch in enumerate ( raw_input ( ) ) : <NEWLINE> <INDENT> if ch == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dp [ i ] [ j ] = 1 <NEWLINE> if i >= 1 or j >= 1 : <NEWLINE> <INDENT> for k in range ( 1 , dp [ i - 1 ] [ j - 1 ] + 1 ) : <NEWLINE> <INDENT> if dp [ i - k ] [ j ] == 0 or dp [ i ] [ j - k ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i ] [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> r = max ( r , dp [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print r <NEWLINE> <DEDENT>
def check ( sum , i , j , size ) : <NEWLINE> <INDENT> s = sum [ i ] [ j ] - sum [ i - size ] [ j ] - sum [ i ] [ j - size ] + sum [ i - size ] [ j - size ] <NEWLINE> return s == 0 <NEWLINE> <NL> <DEDENT> def mm ( sum , n , size ) : <NEWLINE> <INDENT> for i in xrange ( size , n + 1 ) : <NEWLINE> <INDENT> for j in xrange ( size , n + 1 ) : <NEWLINE> <INDENT> if check ( sum , i , j , size ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def m ( sum , n ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> left , mid , right = 0 , 0 , n <NEWLINE> while left <= right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if mm ( sum , n , mid ) : <NEWLINE> <INDENT> r = max ( r , mid ) <NEWLINE> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if left == right : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = [ map ( int , raw_input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) for i in xrange ( n ) ] <NEWLINE> sum = [ [ 0 ] * ( n + 1 ) for i in xrange ( n + 1 ) ] <NEWLINE> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> sum [ i ] [ j ] += s [ i - 1 ] [ j - 1 ] <NEWLINE> sum [ i ] [ j ] += ( sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print m ( sum , n ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> n = input ( ) + 1 <NEWLINE> if n == 1 : break <NEWLINE> A = [ <STRING> * n ] + [ <STRING> + raw_input ( ) for i in range ( 1 , n ) ] <NEWLINE> M = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> M [ i ] [ j ] = min ( M [ i - 1 ] [ j - 1 ] , M [ i - 1 ] [ j ] , M [ i ] [ j - 1 ] ) + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print max ( map ( max , M ) ) <NEWLINE> <INDENT> a = min ( M [ i - 1 ] [ j - 1 ] , M [ i - 1 ] [ j ] , a ) + 1 <NEWLINE> M [ i ] [ j ] = a <NEWLINE> <DEDENT> print max ( map ( max , M ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> def find_square0 ( data ) : <NEWLINE> <INDENT> max_size = 0 <NEWLINE> dp = [ ] <COMMENT> <NEWLINE> <COMMENT> <NL> for row in data : <NEWLINE> <INDENT> temp = [ ] <NEWLINE> for c in row : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> temp . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp . append ( 0 ) <NEWLINE> <DEDENT> <DEDENT> dp . append ( temp ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for y in range ( 1 , len ( dp ) ) : <NEWLINE> <INDENT> for x in range ( 1 , len ( dp [ 0 ] ) ) : <NEWLINE> <INDENT> if dp [ y ] [ x ] == 1 : <NEWLINE> <INDENT> dp [ y ] [ x ] = min ( dp [ y - 1 ] [ x - 1 ] , dp [ y - 1 ] [ x ] , dp [ y ] [ x - 1 ] ) + 1 <NEWLINE> if dp [ y ] [ x ] > max_size : <NEWLINE> <INDENT> max_size = dp [ y ] [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def find_square2 ( data ) : <NEWLINE> <INDENT> max_size = 0 <NEWLINE> dp = [ [ 0 ] * len ( data [ 0 ] ) for _ in range ( len ( data ) ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> for y , row in enumerate ( data ) : <NEWLINE> <INDENT> for x , c in enumerate ( row ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> dp [ y ] [ x ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> prev_row = dp [ 0 ] <NEWLINE> for curr_row in dp [ 1 : ] : <NEWLINE> <INDENT> for x , t in enumerate ( curr_row [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> curr_row [ x ] = min ( prev_row [ x - 1 ] , prev_row [ x ] , curr_row [ x - 1 ] ) + 1 <NEWLINE> if curr_row [ x ] > max_size : <NEWLINE> <INDENT> max_size = curr_row [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prev_row = curr_row <NEWLINE> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def find_square3 ( data ) : <NEWLINE> <INDENT> from array import array <NEWLINE> max_size = 0 <NEWLINE> dp = [ array ( <STRING> , [ 0 ] * len ( data [ 0 ] ) ) for _ in range ( len ( data ) ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> for y , row in enumerate ( data ) : <NEWLINE> <INDENT> for x , c in enumerate ( row ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> dp [ y ] [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> prev_row = dp [ 0 ] <NEWLINE> for curr_row in dp [ 1 : ] : <NEWLINE> <INDENT> for x , t in enumerate ( curr_row [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> if t == 1 : <NEWLINE> <INDENT> curr_row [ x ] = min ( prev_row [ x - 1 ] , prev_row [ x ] , curr_row [ x - 1 ] ) + 1 <NEWLINE> if curr_row [ x ] > max_size : <NEWLINE> <INDENT> max_size = curr_row [ x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prev_row = curr_row <NEWLINE> <DEDENT> return max_size <NEWLINE> <NL> <NL> <DEDENT> def find_square4 ( data ) : <NEWLINE> <INDENT> max_size = 0 <NEWLINE> dp = [ [ 0 ] * 1024 * 1024 ] <NEWLINE> <COMMENT> <NL> for y , row in enumerate ( data ) : <NEWLINE> <INDENT> for x , c in enumerate ( row ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> dp [ y * 1024 + x ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for y in range ( 1 , len ( dp ) ) : <NEWLINE> <INDENT> for x in range ( 1 , len ( dp [ 0 ] ) ) : <NEWLINE> <INDENT> if dp [ y * 1024 + x ] == 1 : <NEWLINE> <INDENT> dp [ y * 1024 + x ] = min ( dp [ ( y - 1 ) * 1024 + x - 1 ] , dp [ ( y - 1 ) * 1024 + x ] , dp [ y * 1024 + x - 1 ] ) + 1 <NEWLINE> if dp [ y * 1024 + x ] > max_size : <NEWLINE> <INDENT> max_size = dp [ y * 1024 + x ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return max_size <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ input ( ) for _ in range ( n ) ] <NEWLINE> result = find_square4 ( data ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> flag0 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> for c in raw_input ( ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> dp [ i ] [ j ] = 1 <NEWLINE> flag0 = 1 <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> <DEDENT> if flag0 == 0 : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solve = 1 <NEWLINE> while True : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for y in xrange ( n - 1 ) : <NEWLINE> <INDENT> for x in xrange ( n - 1 ) : <NEWLINE> <INDENT> if dp [ y ] [ x ] != 0 : <NEWLINE> <INDENT> old = dp [ y ] [ x ] <NEWLINE> dp [ y ] [ x ] = min ( dp [ y + 1 ] [ x ] , dp [ y ] [ x + 1 ] , dp [ y + 1 ] [ x + 1 ] ) + 1 <NEWLINE> if dp [ y ] [ x ] - old == 1 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> solve += 1 <NEWLINE> <DEDENT> print solve <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> uruu = [ ] <NEWLINE> for i in [ year for year in range ( b + 1 ) if year >= a ] : <NEWLINE> <INDENT> if i % 4 == 0 and i % 100 != 0 or i % 400 == 0 : <NEWLINE> <INDENT> uruu . append ( str ( i ) ) <NEWLINE> <DEDENT> <DEDENT> if len ( uruu ) != 0 : <NEWLINE> <INDENT> print <STRING> . join ( uruu ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
p = print <NEWLINE> b = 0 <NEWLINE> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> if b : p ( ) <NEWLINE> b = f = 1 ; s , t = map ( int , e . split ( ) ) <NEWLINE> for y in range ( s , t + 1 ) : <NEWLINE> <INDENT> if ( y % 4 == 0 ) * ( y % 100 ) or y % 400 == 0 : p ( y ) ; f = 0 <NEWLINE> <DEDENT> if u : p ( <STRING> ) <NEWLINE> <DEDENT>
b = 0 <NEWLINE> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> if b : print ( ) <NEWLINE> b = u = 1 <NEWLINE> s , t = map ( int , e . split ( ) ) <NEWLINE> for y in range ( s , t + 1 ) if y % 4 == 0 and y % 100 != 0 or y % 400 == 0 : print ( y ) ; u = 0 <NEWLINE> if u : print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for s in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , s . split ( ) ) <NEWLINE> if a == b == 0 : break <NEWLINE> x = [ ] <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> if i % 100 == 0 : <NEWLINE> <INDENT> if i % 400 == 0 : f = 1 <NEWLINE> else : f = 0 <NEWLINE> <DEDENT> else : f = 1 <NEWLINE> <DEDENT> else : f = 0 <NEWLINE> if f == 1 : x . append ( i ) <NEWLINE> <DEDENT> if x == [ ] : print <STRING> <NEWLINE> else : <NEWLINE> <INDENT> for e in x : print e <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
flag = False <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( a , b ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = [ y for y in xrange ( a , b + 1 ) if ( y % 4 == 0 and not y % 100 == 0 ) or y % 400 == 0 ] <NEWLINE> if not ans : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , ans ) ) <NEWLINE> <DEDENT> if not flag : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> <DEDENT>
line = False <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if line : print <STRING> <NEWLINE> line = True <NEWLINE> count = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( i % 4 == 0 and i % 100 != 0 ) or i % 400 == 0 : <NEWLINE> <INDENT> print i <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> if count == 0 : print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , line . rstrip ( ) . split ( ) ) <NEWLINE> if a != 0 and b != 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> for y in range ( a , b + 1 ) : <NEWLINE> <INDENT> if ( y % 4 == 0 and y % 400 == 0 ) or ( y % 4 == 0 and y % 100 != 0 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> print y <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not flag : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> flag = False <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a + b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flag = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % 4 == 0 and ( i % 100 != 0 or i % 400 == 0 ) : <NEWLINE> <INDENT> print i <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a + b == 0 : break <NEWLINE> tmp = [ ] <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % 4 == 0 : <NEWLINE> <INDENT> if i % 400 == 0 : <NEWLINE> <INDENT> tmp . append ( i ) <NEWLINE> <DEDENT> elif i % 100 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . append ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( tmp ) == 0 : tmp . append ( <STRING> ) <NEWLINE> ans . append ( tmp ) <NEWLINE> <DEDENT> for a in ans : <NEWLINE> <INDENT> for t in a : <NEWLINE> <INDENT> print t <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> f = 0 <NEWLINE> for i in range ( a , b + 1 ) : <NEWLINE> <INDENT> if i % 400 == 0 or ( i % 4 == 0 and i % 100 != 0 ) : <NEWLINE> <INDENT> f = 1 <NEWLINE> print i <NEWLINE> <DEDENT> <DEDENT> if f == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
n = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if n > 0 : print <STRING> <NEWLINE> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( a , b ) == ( 0 , 0 ) : break <NEWLINE> <NL> ls = [ i for i in range ( a , b + 1 ) ] <NEWLINE> ans = [ ] <NEWLINE> for j in ls : <NEWLINE> <INDENT> if j % 4 == 0 and j % 100 != 0 : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <DEDENT> elif j % 400 == 0 : <NEWLINE> <INDENT> ans . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == [ ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for y in ans : <NEWLINE> <INDENT> print y <NEWLINE> <DEDENT> <DEDENT> n += 1 <NEWLINE> <DEDENT>
def isUruu ( t ) : <NEWLINE> <INDENT> if t % 4 == 0 : <NEWLINE> <INDENT> if t % 100 == 0 : <NEWLINE> <INDENT> if t % 400 == 0 : return True <NEWLINE> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == b == 0 : break <NEWLINE> cnt = 0 <NEWLINE> for i in xrange ( a , b + 1 ) : <NEWLINE> <INDENT> if isUruu ( i ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a * b / 3.305785 ) <NEWLINE>
<NL> if __name__ == <STRING> : <NEWLINE> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> b = int ( raw_input ( ) ) <NEWLINE> a = a * b <NEWLINE> print a / 3.305785 <NEWLINE> <NL> <DEDENT>
sA = raw_input ( ) <NEWLINE> idx = sA . index ( <STRING> ) <NEWLINE> a = int ( sA [ : idx ] ) <NEWLINE> b = int ( sA [ idx + 1 : ] <NEWLINE> S = a * b <NEWLINE> print S / 3.305785 <NEWLINE>
a , b = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> print ( ( a * b ) / 3.305785 ) <NEWLINE>
print eval ( raw_input ( ) . replace ( <STRING> , <STRING> ) / 3.30578 <NEWLINE>
from operator import itemgetter <NEWLINE> n = int ( input ( ) ) <NEWLINE> rs = [ list ( map ( int ( ) , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> rs = sorted ( rs , key = itemgetter ( 0 ) ) <NEWLINE> print ( <STRING> . join ( map ( str , sorted ( rs , key = itemgetter ( 1 ) , reverse = True ) [ 0 ] ) ) ) <NEWLINE>
L = [ ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> L . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print <STRING> % sorted ( L , key = lambda a : ( - a [ 1 ] , a [ 0 ] ) ) [ 0 ] <NEWLINE>
<COMMENT> <NL> <NL> n = input ( ) <NEWLINE> A = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> A . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> Max = - 1 <NEWLINE> Maxidx = - 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if Max < A [ i ] [ 1 ] : <NEWLINE> <INDENT> Max = A [ i ] [ 1 ] <NEWLINE> Maxidx = i <NEWLINE> <DEDENT> elif Max = A [ i ] [ 1 ] and A [ Maxidx ] [ 0 ] > A [ i ] [ 0 ] : <NEWLINE> <INDENT> Maxidx = i <NEWLINE> <NL> <DEDENT> <DEDENT> print A [ Maxidx ] [ 0 ] , A [ Maxidx ] [ 1 ] <NEWLINE>
d = { } <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> d [ a ] = v <NEWLINE> <DEDENT> m = max ( d . items ( ) , key = lambda x : x [ 1 ] ) [ 0 ] <NEWLINE> print ( m , min ( d [ m ] ) ) <NEWLINE>
n = input ( ) <NEWLINE> a0 , v0 = n , 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if v > v0 : a0 , v0 = a , v <NEWLINE> elif v = v0 : a0 = min ( a0 , a ) <NEWLINE> <DEDENT> print a , v <NEWLINE>
T = 1000 <NEWLINE> memo = [ [ 0 ] * ( 2 * T + 1 ) for _ in range ( 3 ) ] <NEWLINE> <COMMENT> <NL> memo [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 1 , 3 ) : <NEWLINE> <INDENT> for j in range ( i * T + 1 ) : <NEWLINE> <INDENT> memo [ i ] [ j ] = sum ( [ memo [ i - 1 ] [ k ] for k in range ( max ( 0 , j - T ) , j + 1 ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 0 <NEWLINE> for a in range ( T + 1 ) : <NEWLINE> <INDENT> for b in range ( T + 1 ) : <NEWLINE> <INDENT> cnt += memo [ 2 ] [ n - ( a + b ) ] if 0 <= n - ( a + b ) <= 2 * T else 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print cnt <NEWLINE> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
data_map = [ 0 ] * 4001 <NEWLINE> <NL> for i1 in range ( 1001 ) : <NEWLINE> <INDENT> for i2 in range ( 1001 ) : <NEWLINE> <INDENT> for i3 in range ( 1001 ) : <NEWLINE> <INDENT> for i4 in range ( 1001 ) : <NEWLINE> <INDENT> data_map [ i1 + i2 + i3 + i4 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print data_map [ line ] [ 3 ] <NEWLINE> <DEDENT>
while True : <NEWLINE>
def get_input ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> yield <STRING> . join ( input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ans1 = [ 1 for i in range ( 4001 ) ] <NEWLINE> ans2 = [ 0 for i in range ( 4001 ) ] <NEWLINE> ans3 = [ 0 for i in range ( 4001 ) ] <NEWLINE> ans4 = [ 0 for i in range ( 4001 ) ] <NEWLINE> <NL> for i in range ( 1001 ) : <NEWLINE> <INDENT> ans1 [ i ] = 1 <NEWLINE> <DEDENT> for i in range ( 1001 , 4001 ) : <NEWLINE> <INDENT> ans1 [ i ] = 0 <NEWLINE> <NL> <DEDENT> for i in range ( 4001 ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> ans2 [ i ] += ans1 [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 4001 ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> ans3 [ i ] += ans2 [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 4001 ) : <NEWLINE> <INDENT> for j in range ( i + 1 ) : <NEWLINE> <INDENT> ans4 [ i ] += ans3 [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> N = list ( get_input ( ) ) <NEWLINE> for l in range ( len ( N ) ) : <NEWLINE> <INDENT> print ( ans4 [ int ( N [ l ] ) ] ) <NEWLINE> <NL> <DEDENT>
n = 1001 <NEWLINE> a = range ( 1 , n ) <NEWLINE> a += [ n ] + a [ : : - 1 ] <NEWLINE> for n in map ( int , sys . stdin ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for i in range ( max ( 0 , n - 2000 ) , min ( n , 2000 ) + 1 ) : <NEWLINE> <INDENT> x += a [ i ] * a [ n - i ] <NEWLINE> <DEDENT> print x <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = 1001 <NEWLINE> a = range ( 1 , n ) <NEWLINE> a += [ n ] + a [ : : - 1 ] <NEWLINE> <NL> for n in map ( int , sys . stdin ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> for i in range ( max ( 0 , n - 2000 ) , n + 1 ) : <NEWLINE> <INDENT> x += a [ i ] * a [ n - i ] <NEWLINE> <DEDENT> print x <NEWLINE> <DEDENT>
import sys <NEWLINE> def N ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 6 <NEWLINE> <DEDENT> for n in sys . stdin : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n > 2000 : <NEWLINE> <INDENT> n = 4000 - n <NEWLINE> <DEDENT> if n < 1001 : <NEWLINE> <INDENT> print N ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = n - 1000 <NEWLINE> print N ( n ) - ( N ( 2 * m ) - m - 1 ) / 2 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , exit <NEWLINE> <NL> <NL> def calc_combination ( n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for a in xrange ( ( n if n < 1000 else 1000 ) + 1 ) : <NEWLINE> <INDENT> e1 = n - a - 1001 if n - a - 1001 >= 0 else - 1 <NEWLINE> for nab in xrange ( n - a , e1 , - 1 ) : <NEWLINE> <INDENT> ran = ( ( nab if nab < 1000 else 1000 ) - <NEWLINE> <INDENT> ( ( nab - 1001 ) if nab > 1000 else - 1 ) ) <NEWLINE> <DEDENT> if ran >= 0 : <NEWLINE> <INDENT> count += ran <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> ans = [ 0 ] * 4001 <NEWLINE> for line in stdin : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> <NL> if not ans [ n ] : <NEWLINE> <INDENT> count = calc_combination ( n ) <NEWLINE> ans [ n ] = count <NEWLINE> ans [ 4000 - n ] = count <NEWLINE> <DEDENT> print ( ans [ n ] ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dp = [ [ 0 ] * 1001 for i in range ( 11 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in range ( 9 , - 1 , - 1 ) : <NEWLINE> <INDENT> for k in range ( 0 , 1001 - i ) : <NEWLINE> <INDENT> dp [ j + 1 ] [ k + i ] += dp [ j ] [ k ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print dp [ n ] [ s ] <NEWLINE> <DEDENT>
def dfs ( p , c , s ) : <NEWLINE> <INDENT> if c == n : <NEWLINE> <INDENT> return not s <NEWLINE> <DEDENT> if p == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if memo [ s ] [ p ] [ c ] != - 1 : <NEWLINE> <INDENT> return memo [ s ] [ p ] [ c ] <NEWLINE> <DEDENT> ret = 0 <NEWLINE> for i in xrange ( min ( p , s ) , - 1 , - 1 ) : <NEWLINE> <INDENT> ret += dfs ( i - 1 , c + 1 , s - i ) <NEWLINE> <DEDENT> memo [ s ] [ p ] [ c ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> memo = [ [ [ - 1 ] * ( n + 1 ) for i in xrange ( 101 ) ] for j in xrange ( s + 1 ) ] <NEWLINE> print dfs ( min ( s , 100 ) , 0 , s ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> while True : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == s == 0 : break <NEWLINE> cnt = 0 <NEWLINE> for i in itertools . combinations ( range ( 101 ) , n ) : <NEWLINE> <INDENT> if sum ( i ) == s : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if i [ 0 ] >= s : break <NEWLINE> <DEDENT> print cnt <NEWLINE> <DEDENT>
m = 1001 <NEWLINE> while 1 : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == s == 0 : break <NEWLINE> A = range ( n ) <NEWLINE> d = [ [ 0 ] * m for i in A ] <NEWLINE> for i in range ( 101 ) : <NEWLINE> <INDENT> for j in A [ : : - 1 ] : <NEWLINE> <INDENT> if j == 0 : d [ j ] [ i ] = 1 <NEWLINE> else : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> if k + i < m : d [ j ] [ k + i ] += d [ j - 1 ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print d [ n - 1 ] [ s ] <NEWLINE> <DEDENT>
ls = [ i for i in range ( 101 ) ] <NEWLINE> def comb ( n , s , sp ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 if s == 0 else 0 <NEWLINE> <DEDENT> if sp + n > 100 : return 0 <NEWLINE> mn , mx = sum ( ls [ sp : sp + n ] ) , sum ( ls [ : : - 1 ] [ : n ] ) <NEWLINE> if s < mn or mx < s : return 0 <NEWLINE> elif mn == s or mx == s : return 1 <NEWLINE> <NL> sm = 0 <NEWLINE> for i in range ( sp , 101 ) : <NEWLINE> <INDENT> if ls [ i ] > s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sm += comb ( n - 1 , s - ls [ i ] , i + 1 ) <NEWLINE> <DEDENT> return sm <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print comb ( n , s , 0 ) <NEWLINE> <DEDENT>
from itertools import combinations_with_replacement <NEWLINE> n = input ( ) <NEWLINE> sq = [ map ( int , raw_input ( ) . split ( ) ) for u in xrange ( n ) ] <NEWLINE> s_sq = [ [ 0 ] * ( n + 1 ) for u in xrange ( n + 1 ) ] <NEWLINE> ma = sq [ 0 ] [ 0 ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> for ii in xrange ( n ) : <NEWLINE> <INDENT> s_sq [ i ] [ ii ] = sq [ i ] [ ii ] + s_sq [ i ] [ ii - 1 ] + s_sq [ i - 1 ] [ ii ] - s_sq [ i - 1 ] [ ii - 1 ] <NEWLINE> <DEDENT> <DEDENT> for tx , bx in combinations_with_replacement ( range ( n ) , 2 ) : <NEWLINE> <INDENT> for ty , by in combinations_with_replacement ( range ( n ) , 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> ma = max ( [ ma , s_sq [ by ] [ bx ] - s_sq [ ty - 1 ] [ bx ] - s_sq [ by ] [ tx - 1 ] + s_sq [ ty - 1 ] [ tx - 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT> print ma <NEWLINE>
def f ( mtrx ) : <NEWLINE> <INDENT> maxSum = - 10000000 <NEWLINE> for colStart in range ( n ) : <NEWLINE> <INDENT> partSum = [ 0 ] * n <NEWLINE> for colEnd in range ( colStart , n ) : <NEWLINE> <INDENT> for row in range ( n ) : <NEWLINE> <INDENT> partSum [ row ] += mtrx [ row ] [ colEnd ] <NEWLINE> <DEDENT> calcSum = maxPart ( partSum ) <NEWLINE> maxSum = max ( calcSum , maxSum ) <NEWLINE> <DEDENT> <DEDENT> return maxSum <NEWLINE> <NL> <DEDENT> def maxPart ( mtrx ) : <NEWLINE> <INDENT> maxSum = - 10000000 <NEWLINE> for startP in range ( n ) : <NEWLINE> <INDENT> for endP in range ( startP , n ) : <NEWLINE> <INDENT> calcSum = sum ( mtrx [ startP : endP + 1 ] ) <NEWLINE> maxSum = max ( calcSum , maxSum ) <NEWLINE> <DEDENT> <DEDENT> return maxSum <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> mtrx = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> print f ( mtrx ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> a = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> aa = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a [ i + 1 ] [ j + 1 ] = a [ i ] [ j + 1 ] + a [ i + 1 ] [ j ] - a [ i ] [ j ] + aa [ j ] <NEWLINE> <DEDENT> <DEDENT> m = - 10000 * 100 * 100 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( n ) : <NEWLINE> <INDENT> for k in xrange ( i + 1 , n + 1 ) : <NEWLINE> <INDENT> for l in xrange ( j + 1 , n + 1 ) : <NEWLINE> <INDENT> r = a [ k ] [ l ] - a [ k ] [ j ] - a [ i ] [ l ] + a [ i ] [ j ] <NEWLINE> m = max ( m , r ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print m <NEWLINE>
def g ( j , i ) : <NEWLINE> <INDENT> a = B [ j - 1 ] [ i - 1 ] <NEWLINE> b1 = B [ j - 1 ] <NEWLINE> m = [ ] <NEWLINE> for y in range ( j , n + 1 ) : <NEWLINE> <INDENT> b = B [ y ] <NEWLINE> m . append ( max ( [ b [ x ] + a - b [ i - 1 ] - b1 [ x ] for x in range ( i , n + 1 ) ] ) ) <NEWLINE> <DEDENT> return max ( m ) <NEWLINE> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> N = range ( n ) <NEWLINE> B = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for j in N : <NEWLINE> <INDENT> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = 0 <NEWLINE> b = B [ j ] <NEWLINE> for i in N : <NEWLINE> <INDENT> s += A [ i ] <NEWLINE> B [ j + 1 ] [ i + 1 ] = b [ i + 1 ] + s <NEWLINE> <DEDENT> <DEDENT> N = N [ 1 : ] + [ n ] <NEWLINE> m = [ max ( [ g ( j , i ) for i in N ] ) for j in N ] <NEWLINE> print max ( m ) <NEWLINE>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = { } <NEWLINE> t = - 1 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ans . has_key ( a ) : <NEWLINE> <INDENT> ans [ a ] += v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ a ] = v <NEWLINE> <DEDENT> if t == - 1 : <NEWLINE> <INDENT> t = a <NEWLINE> <DEDENT> elif ans [ a ] > ans [ t ] or ( ans [ a ] == ans [ t ] and a < t ) : <NEWLINE> <INDENT> t = a <NEWLINE> <NL> <DEDENT> if v < 0 : <NEWLINE> <INDENT> t = - 1 <NEWLINE> <DEDENT> if t == - 1 : <NEWLINE> <INDENT> for i in ans : <NEWLINE> <INDENT> if t == - 1 : <NEWLINE> <INDENT> t = i <NEWLINE> <DEDENT> elif ans [ t ] < ans [ i ] : <NEWLINE> <INDENT> t = i <NEWLINE> <DEDENT> elif ans [ t ] == ans [ i ] and t > i : <NEWLINE> <INDENT> t = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print t , ans [ t ] <NEWLINE> <DEDENT> exit ( ) <NEWLINE>
class SegmentTree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> n_ = 1 <NEWLINE> while n_ < n : n_ *= 2 <NEWLINE> self . n = n_ <NEWLINE> self . data = [ ( 0 , - n_ - 1 ) ] * ( 2 * n_ ) <NEWLINE> <NL> <DEDENT> def add ( self , k , a ) : <NEWLINE> <INDENT> idx = k + ( self . n - 1 ) <NEWLINE> data = self . data <NEWLINE> data [ idx ] = ( data [ idx ] [ 0 ] + a , - k ) <NEWLINE> while idx : <NEWLINE> <INDENT> idx = ( idx - 1 ) / 2 <NEWLINE> data [ idx ] = max ( data [ 2 * idx + 1 ] , data [ 2 * idx + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get ( self ) : <NEWLINE> <INDENT> return self . data [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> inputs = lambda : map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n , q = inputs ( ) <NEWLINE> st = SegmentTree ( n ) <NEWLINE> for t in xrange ( q ) : <NEWLINE> <INDENT> a , v = inputs ( ) <NEWLINE> st . add ( a , v ) <NEWLINE> <NL> p , q = st . get ( ) <NEWLINE> print - q , p <NEWLINE> <DEDENT>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> L = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> L [ a - 1 ] += v <NEWLINE> m = max ( L ) <NEWLINE> print L . index ( m ) + 1 , m <NEWLINE> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , exit <NEWLINE> <NL> <NL> def main ( readline = stdin . readline ) : <NEWLINE> <INDENT> n , q = ( int ( s ) for s in readline ( ) . split ( ) ) <NEWLINE> <NL> base = [ 0 ] * n <NEWLINE> midway = [ 0 ] * ( n // 1000 + 1 ) <NEWLINE> <NL> for _ in xrange ( q ) : <NEWLINE> <INDENT> a , v = ( int ( s ) for s in readline ( ) . split ( ) ) <NEWLINE> <NL> a -= 1 <NEWLINE> base [ a ] += v <NEWLINE> <NL> b = a - a % 1000 <NEWLINE> index = b <NEWLINE> value = base [ b ] <NEWLINE> end = b + 1000 if b + 1000 < n else n <NEWLINE> for i in xrange ( b , end ) : <NEWLINE> <INDENT> if value < base [ i ] : <NEWLINE> <INDENT> value = base [ i ] <NEWLINE> index = i <NEWLINE> <DEDENT> <DEDENT> midway [ b // 1000 ] = index <NEWLINE> <NL> index = midway [ 0 ] <NEWLINE> value = base [ index ] <NEWLINE> for i in midway : <NEWLINE> <INDENT> if value < base [ i ] : <NEWLINE> <INDENT> value = base [ i ] <NEWLINE> index = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( index + 1 , value ) <NEWLINE> <DEDENT> exit ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> fish = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> fish [ a - 1 ] = fish [ a - 1 ] + v <NEWLINE> ans1 = fish . index ( max ( fish ) ) + 1 <NEWLINE> ans2 = max ( fish ) <NEWLINE> print <STRING> . format ( ans1 , ans2 ) <NEWLINE> <DEDENT>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * n <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s [ a - 1 ] += v <NEWLINE> ss = sorted ( s , reverse = True ) <NEWLINE> print s . index ( ss [ 0 ] ) + 1 , ss [ 0 ] <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> s = [ 0 ] * - ~ n <NEWLINE> w = m = 0 <NEWLINE> for _ in [ 0 ] * q : <NEWLINE> <INDENT> a , v = map ( int , input ( ) . split ( ) ) <NEWLINE> s [ a ] += v <NEWLINE> if v < 0 and a == w : m = max ( s ) ; w = s . index ( m ) <NEWLINE> elif s [ a ] > maxv : w , m = a , s [ a ] <NEWLINE> elif s [ a ] == maxv : w = min ( w , a ) <NEWLINE> print ( w , m ) <NEWLINE> <DEDENT>
def f ( ) : return map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n , q = f ( ) <NEWLINE> A = [ [ 0 , - i ] for i in range ( n + 1 ) ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b = f ( ) <NEWLINE> A [ a ] [ 0 ] += b <NEWLINE> m0 , m1 = sorted ( A , key = lambda A : [ A [ 0 ] , A [ 1 ] ] ) [ - 1 ] <NEWLINE> print - m1 , m0 <NEWLINE> <DEDENT>
1001 2000 520 <NEWLINE> 1002 1800 450 <NEWLINE> 1003 1600 625 <NEWLINE> 1001 200 1220 <NEWLINE>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : break <NEWLINE> f = 1 <NEWLINE> L = { } <NEWLINE> for a , b , c in [ map ( int , input ( ) . split ( ) ) for i in range ( n ) ] : <NEWLINE> <INDENT> a = str ( a ) <NEWLINE> if a in L : <NEWLINE> <INDENT> d = b * c <NEWLINE> if L [ a ] >= 1e6 : continue <NEWLINE> L [ a ] += d <NEWLINE> <DEDENT> else : L [ a ] = d <NEWLINE> if L [ a ] >= 1e6 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> f = 0 <NEWLINE> <DEDENT> <DEDENT> if f : print ( <STRING> ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> D = { } <NEWLINE> A = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , c = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if a in D : D [ a ] += b * c <NEWLINE> else : <NEWLINE> <INDENT> D [ a ] = b * c <NEWLINE> A . append ( a ) <NEWLINE> <DEDENT> <DEDENT> B = [ i for i in A : if D [ i ] >= 1e6 ] <NEWLINE> if B = [ ] : B = [ <STRING> ] <NEWLINE> for e in B : print e <NEWLINE> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> ans , name1 , name2 = [ ] , [ ] , [ ] <NEWLINE> hogehoge = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> hoge = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if hoge [ 0 ] in name2 : <NEWLINE> <INDENT> ww = hoge [ 1 ] * hoge [ 2 ] <NEWLINE> r = name2 . index ( hoge [ 0 ] ) <NEWLINE> if len ( ans [ r ] + ww ) >= 7 : <NEWLINE> <INDENT> hogehoge += 1 <NEWLINE> name1 . append ( hoge [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ r ] += ww <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> qq = hoge [ 1 ] * hoge [ 2 ] <NEWLINE> if len ( str ( qq ) ) >= 7 : <NEWLINE> <INDENT> hogehoge += 1 <NEWLINE> name1 . append ( hoge [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> name2 . append ( hoge [ 0 ] ) <NEWLINE> ans . append ( qq ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if hogehoge == 0 : print <STRING> <NEWLINE> else : <NEWLINE> <INDENT> for i in range ( len ( name1 ) ) : <NEWLINE> <INDENT> print name1 [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> l = [ ] <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i , p , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a in d : <NEWLINE> <INDENT> d [ a ] += b * c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ a ] = b * c <NEWLINE> l . append ( a ) <NEWLINE> <DEDENT> <DEDENT> if max ( d . values ( ) ) < 1000000 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in l : <NEWLINE> <INDENT> if d [ k ] >= 1000000 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : break <NEWLINE> f = 1 <NEWLINE> L = { } <NEWLINE> for a , b , c in [ input ( ) . split ( ) for i in range ( n ) ] : <NEWLINE> <INDENT> if a in L : <NEWLINE> <INDENT> if L [ a ] >= 1e6 : continue <NEWLINE> L [ a ] += d <NEWLINE> <DEDENT> else : L [ a ] = d <NEWLINE> if L [ a ] >= 1e6 : <NEWLINE> <INDENT> print ( a ) <NEWLINE> f = 0 <NEWLINE> <DEDENT> <DEDENT> if f : print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> no = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> exit <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> datas = map ( int , input ( ) . split ( ) ) <NEWLINE> li = list ( datas ) <NEWLINE> e = li [ 0 ] <NEWLINE> p = li [ 1 ] <NEWLINE> q = li [ 2 ] <NEWLINE> <NL> s = p * q <NEWLINE> if ( 1000000 < s and ( e in no ) == False ) : <NEWLINE> <INDENT> print ( e ) <NEWLINE> no . append ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ( len ( no ) == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> num , p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> if num in d : <NEWLINE> <INDENT> d [ num ] [ 1 ] += ( p * q ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ num ] = [ n , p * q ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> fla = False <NEWLINE> for k , v in sorted ( d . items ( ) , key = lambda x [ 1 ] [ 0 ] ) : <NEWLINE> <INDENT> if v [ 1 ] >= 1000000 : <NEWLINE> <INDENT> print ( k ) <NEWLINE> fla = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not fla : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from Config import DB <NEWLINE> def add ( lis , check_list ) : <NEWLINE> <INDENT> for index in range ( len ( lis ) ) : <NEWLINE> <INDENT> if lis [ index ] [ 0 ] == check_list [ 0 ] : <NEWLINE> <INDENT> lis [ index ] [ 1 ] += int ( check_list [ 1 ] ) * int ( check_list [ 2 ] ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> lis . append ( [ check_list [ 0 ] , int ( check_list [ 1 ] ) * int ( check_list [ 2 ] ) ] ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> num = int ( raw_input ( ) ) <NEWLINE> if num == 0 : break <NEWLINE> lis = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> l = raw_input ( ) . split ( <STRING> ) <NEWLINE> add ( lis , l ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> for ele in lis : <NEWLINE> <INDENT> if ele [ 1 ] >= 1000000 : <NEWLINE> <INDENT> print ele [ 0 ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> if c == 0 : print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> rs = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr = input ( ) . split ( <STRING> ) <NEWLINE> s = arr [ 0 ] * arr [ 1 ] <NEWLINE> rs [ arr [ 0 ] ] = ( rs [ arr [ 0 ] ] or 0 ) + s <NEWLINE> <NL> <DEDENT> top = [ k for k , v in rs . items if v > 1000000 ] <NEWLINE> if len ( top ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in top : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> res = { } <NEWLINE> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d = [ int ( num ) for num in input ( ) . split ( <STRING> ) ] <NEWLINE> res [ d [ 0 ] - 1 ] += d [ 1 ] * d [ 2 ] <NEWLINE> if d [ 0 ] - 1 not in li : li . append ( d [ 0 ] - 1 ) <NEWLINE> <DEDENT> flag = False <NEWLINE> for i in li : <NEWLINE> <INDENT> if res [ i ] >= 1000000 : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> if flag == False : print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> for i in range ( num ) : print raw_input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( raw_input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
[ print ( input ( ) . replace ( <STRING> , <STRING> ) ) for _ in range ( int ( inpu ( ) ) ) ] <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inputs = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> ans = <STRING> <NEWLINE> for j in inputs : <NEWLINE> <INDENT> if j [ : 7 ] == <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans += j + <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> ans = ans [ : - 1 ] <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in [ raw_input ( ) . replace ( <STRING> , <STRING> ) for i in range ( n ) ] : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> doc = input ( ) . split ( ) <NEWLINE> ans = [ ] <NEWLINE> for s in doc : <NEWLINE> <INDENT> if <STRING> in s : <NEWLINE> <INDENT> while <STRING> in s : <NEWLINE> <INDENT> t = s . find ( <STRING> ) <NEWLINE> s = s [ : t ] + <STRING> + s [ s + 7 : ] <NEWLINE> <DEDENT> <DEDENT> ans . append ( s ) <NEWLINE> <DEDENT> print <STRING> . join ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> num = int ( raw_input ( ) ) <NEWLINE> if not num : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ raw_input ( ) for _ in range ( num ) ] <NEWLINE> for el in data : <NEWLINE> <INDENT> print ( el . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> print input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT>
import re <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print re . sub ( <STRING> , <STRING> , raw_input ( ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( raw_input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lis = raw_input ( ) . split ( ) <NEWLINE> ans = [ ] <NEWLINE> for st in lis : <NEWLINE> <INDENT> if <STRING> in st : <NEWLINE> <INDENT> while <STRING> in st : <NEWLINE> <INDENT> s = st . find ( <STRING> ) <NEWLINE> st = st [ : s ] + <STRING> + st [ s + 7 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( st ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( st ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> . join ( ans ) <NEWLINE> <DEDENT> <DEDENT>
def Aizu_PR ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> print ( input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> Aizu_PR ( ) <NEWLINE>
n = - 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> a = [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( n ) ] <NEWLINE> a = [ l + [ sum ( l ) ] for l in a ] <NEWLINE> a . append ( [ sum ( [ l [ i ] for l in a ] ) for i in xrange ( len ( a [ 0 ] ) ) ] ) <NEWLINE> print <STRING> . join ( [ <STRING> . join ( [ str ( i ) . rjust ( 5 ) for i in l ] ) for l in a ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <NL> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] . append ( sum ( a [ i ] ) ) <NEWLINE> <NL> <DEDENT> col_sum = [ ] <NEWLINE> for col in range ( len ( a [ 0 ] ) ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for row in range ( len ( a ) ) : <NEWLINE> <INDENT> s += a [ row ] [ col ] ; <NEWLINE> <DEDENT> col_sum . append ( s ) <NEWLINE> <DEDENT> a . append ( col_sum ) <NEWLINE> <NL> for row in range ( len ( a ) ) : <NEWLINE> <INDENT> for col in range ( len ( a [ 0 ] ) ) : <NEWLINE> <INDENT> print <STRING> % a [ row ] [ col ] , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n : <NEWLINE> <INDENT> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * n ] <NEWLINE> for r in a : <NEWLINE> <INDENT> for s in r : print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> for c in zip ( * a ) : print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> table = [ ] <NEWLINE> for m in range ( n ) : <NEWLINE> <INDENT> line = [ ] <NEWLINE> <NL> line = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> line_sum = sum ( line ) <NEWLINE> line . append ( line_sum ) <NEWLINE> table . append ( line ) <NEWLINE> <NL> <NL> <NL> <DEDENT> vert_sum_line = [ ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> vert_sum = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> vert_sum += table [ j ] [ k ] <NEWLINE> <DEDENT> vert_sum_line . append ( vert_sum ) <NEWLINE> <NL> <DEDENT> total = sum ( vert_sum_line ) <NEWLINE> vert_sum_line . append ( total ) <NEWLINE> <NL> <NL> for line in table : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , line ) ) . strip ( ) <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , vert_sum_line ) ) . strip ( ) <NEWLINE> <DEDENT> <DEDENT>
f = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) + 1 <NEWLINE> if n == 1 : break <NEWLINE> x = [ ] <NEWLINE> y = [ 0 ] * n <NEWLINE> N = range ( n ) <NEWLINE> for i in N [ : - 1 ] : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> a . append ( sum ( a ) ) <NEWLINE> x . append ( a ) <NEWLINE> for j in N : y [ j ] += a [ j ] <NEWLINE> <DEDENT> x . append ( y ) <NEWLINE> for i in N : <NEWLINE> <INDENT> if f : print <NEWLINE> for e in x [ i ] : print str ( e ) . rjust ( 5 ) , <NEWLINE> f = 1 <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break ; <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = [ list ( map ( int , input ( ) . split ( ) ) ) ] <NEWLINE> a [ i ] += [ sum ( a [ i ] ) ] <NEWLINE> for s in a [ i ] : print ( <STRING> % s , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> for c in zip ( * a ) : print ( <STRING> % sum ( c ) , end = <STRING> ) <NEWLINE> print ( ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> input_list = [ ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> input_list . append ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> last_list_row = [ ] <NEWLINE> for x in range ( n ) : <NEWLINE> <INDENT> input_list [ x ] . append ( sum ( input_list [ x ] ) ) <NEWLINE> print <STRING> . join ( map ( lambda n : <STRING> . format ( n ) , input_list ) ) <NEWLINE> last_list . append ( input_list [ x ] [ - 1 ] ) <NEWLINE> <NL> <DEDENT> input_len = len ( input_list [ 0 ] ) <NEWLINE> column_list = [ ] <NEWLINE> for x in range ( input_len ) : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for y in range ( n ) : <NEWLINE> <INDENT> tmp += input_list [ y ] [ x ] <NEWLINE> <DEDENT> column_list . append ( tmp ) <NEWLINE> <DEDENT> print <STRING> . join ( map ( lambda n : <STRING> . format ( n ) , column_list ) ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n ) ] <NEWLINE> ans = [ [ 0 ] * ( n + 1 ) for _ in xrange ( n + 1 ) ] <NEWLINE> for i in xrange ( n + 1 ) : <NEWLINE> <INDENT> for j in xrange ( n + 1 ) : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> if j == n : <NEWLINE> <INDENT> ans [ n ] [ n ] += sum ( ans [ n ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in xrange ( n ) : <NEWLINE> <INDENT> ans [ n ] [ j ] += a [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if j == n : <NEWLINE> <INDENT> for k in xrange ( n ) : <NEWLINE> <INDENT> ans [ i ] [ n ] += a [ i ] [ k ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans [ i ] [ j ] = a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in xrange ( n + 1 ) : <NEWLINE> <INDENT> for j in xrange ( n + 1 ) : <NEWLINE> <INDENT> if j == n : <NEWLINE> <INDENT> print <STRING> % str ( ans [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % str ( ans [ i ] [ j ] ) , <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> ans = [ ] <NEWLINE> if n == 0 : break <NEWLINE> tmp = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ans . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> ans [ i ] . append ( sum ( ans [ i ] ) ) <NEWLINE> for j in range ( len ( ans [ i ] ) ) : <NEWLINE> <INDENT> tmp [ j ] += ans [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> ans . append ( tmp ) <NEWLINE> for a in ans : <NEWLINE> <INDENT> print <STRING> . join ( map ( lambda x : str ( x ) . rjust ( 5 ) , a ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> total = None <NEWLINE> result = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lis = list ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> lis . append ( sum ( lis ) ) <NEWLINE> result . append ( lis ) <NEWLINE> if total == None : <NEWLINE> <INDENT> total = lis [ : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( len ( total ) ) : <NEWLINE> <INDENT> total [ i ] = total [ i ] + lis [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result . append ( total ) <NEWLINE> for line in result : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> for v in line : <NEWLINE> <INDENT> ans . append ( <STRING> % v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> . join ( ans ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> if num == 0 : break <NEWLINE> <NL> sht = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> sht . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> sht [ i ] . append ( sum ( sht [ i ] ) ) <NEWLINE> print <STRING> . join ( map ( str , sht [ i ] ) ) <NEWLINE> <NL> <DEDENT> row = [ ] <NEWLINE> for i in range ( num + 1 ) : <NEWLINE> <INDENT> sm = 0 <NEWLINE> for j in range ( num ) : <NEWLINE> <INDENT> sm += sht [ j ] [ i ] <NEWLINE> <DEDENT> row . append ( sm ) <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , row ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> x = [ ] <NEWLINE> y = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . append ( sum ( a ) ) <NEWLINE> x . append ( a ) <NEWLINE> for j in range ( n + 1 ) : <NEWLINE> <INDENT> y [ j ] += a [ j ] <NEWLINE> <DEDENT> <DEDENT> x . append ( y ) <NEWLINE> for a in x : <NEWLINE> <INDENT> print <STRING> . join ( [ str ( e ) . rjust ( 5 ) for e in a ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> while True : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> ans2 , tage = 0 , [ 0 ] * a <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> hoge = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sys . stdout . write ( <STRING> ) <NEWLINE> for j in range ( a ) : <NEWLINE> <INDENT> tage [ j ] += hoge [ j ] <NEWLINE> print <STRING> % ( hoge [ j ] ) , <NEWLINE> ans += hoge [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans2 += ans <NEWLINE> print <STRING> % ( ans ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> for x in range ( a ) : <NEWLINE> <INDENT> print <STRING> % ( tage [ x ] ) , <NEWLINE> <DEDENT> else : print <STRING> % ( ans2 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> curAns = [ ] <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> lst = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> lst . append ( sum ( lst ) ) <NEWLINE> curAns . append ( lst ) <NEWLINE> <DEDENT> lLst = [ ] <COMMENT> <NEWLINE> for i in xrange ( n + 1 ) : <COMMENT> <NEWLINE> <INDENT> verSum = 0 <NEWLINE> for j in xrange ( n ) : <COMMENT> <NEWLINE> <INDENT> verSum += curAns [ j ] [ i ] <NEWLINE> <DEDENT> lLst . append ( verSum ) <NEWLINE> <DEDENT> curAns . append ( lLst ) <NEWLINE> relAns = [ ] <NEWLINE> for i in curAns : <NEWLINE> <INDENT> tmpLst = map ( str , i ) <NEWLINE> nLst = [ ] <NEWLINE> for j in tmpLst : <NEWLINE> <INDENT> nLst . append ( j . rjust ( 4 ) ) <NEWLINE> <DEDENT> ansStr = <STRING> . join ( nLst ) <NEWLINE> relAns . append ( ansStr ) <NEWLINE> <DEDENT> ans . append ( relAns ) <NEWLINE> <NL> <DEDENT> for i in ans : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> print j <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> try : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> if ( temp == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N = temp <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( map ( int , raw_input ( ) . split ( ) ) + [ 0 ] ) <NEWLINE> <DEDENT> a . append ( [ 0 for i in range ( 0 , temp + 1 ) ] ) <NEWLINE> for i in range ( 0 , temp ) : <COMMENT> <NEWLINE> <INDENT> for j in range ( 0 , temp ) : <COMMENT> <NEWLINE> <INDENT> a [ i ] [ temp ] += a [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> for k in range ( 0 , temp + 1 ) : <COMMENT> <NEWLINE> <INDENT> for l in range ( 0 , temp ) : <COMMENT> <NEWLINE> <INDENT> a [ temp ] [ k ] += a [ l ] [ k ] <NEWLINE> <DEDENT> <DEDENT> for m in range ( 0 , temp + 1 ) : <NEWLINE> <INDENT> for n in range ( 0 , temp + 1 ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( a [ m ] [ n ] ) . rjust ( 5 ) ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except ( RuntimeError ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <COMMENT> <NL> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> inp = [ ] <NEWLINE> for x in range ( N ) : <NEWLINE> <INDENT> input_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> inp . append ( input_list ) <NEWLINE> <NL> <DEDENT> printAns ( inp ) <NEWLINE> <NL> <DEDENT> <DEDENT> def printAns ( num_list ) : <NEWLINE> <INDENT> add_list = [ ] <NEWLINE> for x in num_list : <NEWLINE> <INDENT> x . append ( sum ( x ) ) <NEWLINE> add_list . append ( x ) <NEWLINE> <NL> <DEDENT> total_list = [ sum ( x ) for x in zip ( * add_list ) ] <NEWLINE> add_list . append ( total_list ) <NEWLINE> print5digit ( add_list ) <NEWLINE> <NL> <DEDENT> def print5digit ( num_list ) : <NEWLINE> <INDENT> for x in num_list : <NEWLINE> <INDENT> for y in x : <NEWLINE> <INDENT> print ( <STRING> . format ( y ) ) , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> out_count = 0 <NEWLINE> score = 0 <NEWLINE> runners = [ 0 , 0 , 0 ] <NEWLINE> <NL> while n : <NEWLINE> <INDENT> event = input ( ) <NEWLINE> if event == <STRING> : <NEWLINE> <INDENT> if runners . pop ( ) : <NEWLINE> <INDENT> score += 1 <NEWLINE> <DEDENT> runners = [ 1 ] + runners <NEWLINE> <DEDENT> if event == <STRING> : <NEWLINE> <INDENT> score += 1 + sum ( runners ) <NEWLINE> runners = [ 0 , 0 , 0 ] <NEWLINE> <NL> <DEDENT> if event == <STRING> : <NEWLINE> <INDENT> out_count += 1 <NEWLINE> if out_count > 2 : <NEWLINE> <INDENT> print ( score ) <NEWLINE> score = 0 <NEWLINE> out_count = 0 <NEWLINE> runners = [ 0 , 0 , 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> p = 0 <NEWLINE> b = [ 0 , 0 , 0 ] <NEWLINE> o = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> e = raw_input ( ) <NEWLINE> if e == <STRING> : <NEWLINE> <INDENT> if b [ - 1 ] == 1 : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> b [ 0 ] , b [ 1 ] , b [ 2 ] = 1 , b [ 0 ] , b [ 1 ] <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> p += sum ( b ) + 1 <NEWLINE> b = [ 0 , 0 , 0 ] <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> o += 1 <NEWLINE> if o == 3 : <NEWLINE> <INDENT> print p <NEWLINE> p = 0 <NEWLINE> b = [ 0 , 0 , 0 ] <NEWLINE> o = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> game = 0 <NEWLINE> while game < n : <NEWLINE> <INDENT> run = 0 <NEWLINE> score = 0 <NEWLINE> out = 0 <NEWLINE> while out < 3 : <NEWLINE> <INDENT> ev = raw_input ( ) <NEWLINE> if ev == <STRING> : <NEWLINE> <INDENT> out = out + 1 <NEWLINE> <DEDENT> elif ev == <STRING> : <NEWLINE> <INDENT> run = run + 1 <NEWLINE> if run > 3 : <NEWLINE> <INDENT> run = 3 <NEWLINE> score = score + 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> score = score + run + 1 <NEWLINE> run = 0 <NEWLINE> <DEDENT> <DEDENT> print score <NEWLINE> game = game + 1 <NEWLINE> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> point = 0 <NEWLINE> out = 0 <NEWLINE> runner = [ 0 , 0 , 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> event = input ( ) <NEWLINE> if event == <STRING> : <NEWLINE> <INDENT> if runner [ 2 ] == 1 : <NEWLINE> <INDENT> point += 1 <NEWLINE> <DEDENT> if runner [ 1 ] == 1 : <NEWLINE> <INDENT> runner [ 2 ] = 1 <NEWLINE> <DEDENT> if runner [ 0 ] == 1 : <NEWLINE> <INDENT> runner [ 1 ] = 1 <NEWLINE> <DEDENT> runner [ 0 ] = 1 <NEWLINE> <DEDENT> elif event == <STRING> : <NEWLINE> <INDENT> point += ( sum ( runner ) + 1 ) <NEWLINE> <DEDENT> elif event == <STRING> : <NEWLINE> <INDENT> out += 1 <NEWLINE> if out == 3 : <NEWLINE> <INDENT> print ( point ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def CurrentPos ( ls , h = 0 , w = 0 ) : <NEWLINE> <INDENT> if ls [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> elif ls [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> elif ls [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> elif ls [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> return [ h , w ] <NEWLINE> <NL> <DEDENT> def HasPosReached ( pos_list , h , w ) : <NEWLINE> <INDENT> for k , j in pos_list : <NEWLINE> <INDENT> if ( h , w ) == ( k , j ) : <NEWLINE> <INDENT> return True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if [ H , W ] == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ls = [ ] <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> ls . append ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> pos_list = [ ] <NEWLINE> h = 0 ; w = 0 <NEWLINE> while True : <NEWLINE> <INDENT> [ h , w ] = CurrentPos ( ls , h , w ) <NEWLINE> pos_list . append ( ( h , w ) ) <NEWLINE> if HasPosReached ( h , w ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , [ h , w ] ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tile = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> tile . append ( list ( raw_input ( ) ) ) <NEWLINE> <DEDENT> x = y = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = tile [ y ] [ x ] <NEWLINE> tile [ y ] [ x ] = 0 <NEWLINE> if w == <STRING> : <NEWLINE> <INDENT> print x , y ; break <NEWLINE> <DEDENT> elif w == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> elif w == <STRING> : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> elif w == <STRING> : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> elif w == <STRING> : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> ; break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> def decide_move ( x , y , tile , check ) : <NEWLINE> <INDENT> if tile == <STRING> : <NEWLINE> <INDENT> x -= 1 <NEWLINE> check [ x ] [ y ] += 1 <NEWLINE> return x , y , check <NEWLINE> <DEDENT> elif tile == <STRING> : <NEWLINE> <INDENT> x += 1 <NEWLINE> check [ x ] [ y ] += 1 <NEWLINE> return x , y , check <NEWLINE> <DEDENT> elif tile == <STRING> : <NEWLINE> <INDENT> y -= 1 <NEWLINE> check [ x ] [ y ] += 1 <NEWLINE> return x , y , check <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += 1 <NEWLINE> check [ x ] [ y ] += 1 <NEWLINE> return x , y , check <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tile_map = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> tile_map . append ( input ( ) ) <NEWLINE> <DEDENT> check = [ [ 0 for i in range ( w ) ] for j in range ( h ) ] <NEWLINE> check [ 0 ] [ 0 ] = 1 <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> status = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if tile_map [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> status = 1 <NEWLINE> print ( y , x ) <NEWLINE> break <NEWLINE> <DEDENT> x , y , check = decide_move ( x , y , tile_map [ x ] [ y ] , check ) <NEWLINE> if check [ x ] [ y ] > 1 : <NEWLINE> <INDENT> status = 1 <NEWLINE> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
S = [ [ <STRING> for i in range ( 10 ) ] for j in range ( 10 ) ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> check = [ [ False for i in range ( 10 ) ] for j in range ( 10 ) ] <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> LOOP = False <NEWLINE> <NL> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if ( H == 0 and W == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> S [ i ] = raw_input ( ) <NEWLINE> <NL> <DEDENT> while ( S [ y ] [ x ] != <STRING> ) : <NEWLINE> <INDENT> if ( check [ y ] [ x ] == True ) : <NEWLINE> <INDENT> LOOP = True <NEWLINE> print <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> check [ y ] [ x ] = True <NEWLINE> <NL> if ( S [ y ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> elif ( S [ y ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> elif ( S [ y ] [ x ] == <STRING> ) : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if ( LOOP == False ) : <NEWLINE> <INDENT> print x , y <NEWLINE> <DEDENT> <DEDENT>
DIR = { <STRING> : ( 0 , 1 ) , <STRING> : ( 0 , - 1 ) , <STRING> : ( - 1 , 0 ) , <STRING> : ( 1 , 0 ) } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> w , h = m ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> m = [ ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> m . append ( [ c for c in raw_input ( ) . strip ( ) ] ) <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> y = 0 <NEWLINE> while m [ x ] [ y ] != <STRING> : <NEWLINE> <INDENT> i = m [ x ] [ y ] <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m [ x ] [ y ] = <STRING> <NEWLINE> x += DIR [ i ] [ 0 ] <NEWLINE> y += DIR [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> if m [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( y , x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def moov ( x , y ) : <NEWLINE> <INDENT> if ( x , y ) in Loc : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Loc . append ( ( x , y ) ) <NEWLINE> if Room [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return str ( x ) + <STRING> + str ( y ) <NEWLINE> <DEDENT> elif Room [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return moov ( x + 1 , y ) <NEWLINE> <DEDENT> elif Room [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return moov ( x - 1 , y ) <NEWLINE> <DEDENT> elif Room [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return moov ( x , y - 1 ) <NEWLINE> <DEDENT> elif Room [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return moov ( x , y + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> Loc = [ ] <NEWLINE> Room = [ ] <NEWLINE> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> vec = input ( ) <NEWLINE> Room . append ( list ( vec ) ) <NEWLINE> <DEDENT> print ( moov ( 1 , 0 ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> H , W = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( input ( ) for i in range ( H ) ) <NEWLINE> visitedlist = [ ] <NEWLINE> h = 0 <NEWLINE> w = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if ( h , w ) not in visitedlist : <NEWLINE> <INDENT> visitedlist . append ( [ h , w ] ) <NEWLINE> if a [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> w += 1 <NEWLINE> <DEDENT> if a [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> w -= 1 <NEWLINE> <DEDENT> if a [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> h -= 1 <NEWLINE> <DEDENT> if a [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> if a [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> print ( w , h ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def f ( ) : <NEWLINE> <INDENT> A = [ raw_input ( ) for _ in range ( h ) ] <NEWLINE> x , y = 0 , 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> A [ y ] = A [ y ] [ 0 : x ] + <STRING> + A [ y ] [ x + 1 : ] <NEWLINE> if s == <STRING> : x += 1 <NEWLINE> elif s == <STRING> : x -= 1 <NEWLINE> elif s == <STRING> : y += 1 <NEWLINE> elif s == <STRING> 3 : y -= 1 <NEWLINE> elif s == <STRING> : return <STRING> . join ( map ( str , [ x , y ] ) ) <NEWLINE> else : return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> print f ( ) <NEWLINE> <DEDENT>
for a in iter ( input , <STRING> ) : <NEWLINE> <INDENT> m = [ input ( ) for _ in [ 0 ] * int ( a . split ( ) [ 0 ] ) ] <NEWLINE> y = x = 0 ; s = { ( 0 , 0 ) } <NEWLINE> while <STRING> != m [ y ] [ x ] : <NEWLINE> <INDENT> u , v = x , y <NEWLINE> c = m [ y ] [ x ] <NEWLINE> if c == <STRING> : x += 1 ; <NEWLINE> if c == <STRING> : y += 1 ; <NEWLINE> if c == <STRING> : x -= 1 ; <NEWLINE> if c == <STRING> : y -= 1 ; <NEWLINE> if c == <STRING> : print ( x , y ) ; break <NEWLINE> else : s |= { ( x , y ) } <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tile = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> tile . append ( list ( raw_input ( ) ) ) <NEWLINE> <DEDENT> print tile <NEWLINE> x = y = 0 <NEWLINE> while True : <NEWLINE> <INDENT> a = tile [ y ] [ x ] <NEWLINE> tile [ y ] [ x ] = 0 <NEWLINE> if a == <STRING> : x += 1 <NEWLINE> elif a == <STRING> : x -= 1 <NEWLINE> elif a == <STRING> : y -= 1 <NEWLINE> elif a == <STRING> : y += 1 <NEWLINE> elif a == <STRING> : print x , y ; break <NEWLINE> else : print <STRING> ; break <NEWLINE> <DEDENT> <DEDENT>
DIR = { <STRING> : ( 0 , 1 ) , <STRING> : ( 0 , - 1 ) , <STRING> : ( - 1 , 0 ) , <STRING> : ( 1 , 0 ) } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> m = [ [ ] in i for range ( w ) ] <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> m [ i ] = [ c for c in raw_input ( ) . strip ( ) ] <NEWLINE> <NL> <DEDENT> x = 0 <NEWLINE> y = 0 <NEWLINE> while m [ x ] [ y ] != <STRING> : <NEWLINE> <INDENT> i = m [ x ] [ y ] <NEWLINE> if i == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m [ x ] [ y ] = <STRING> <NEWLINE> x += DIR [ i ] [ 0 ] <NEWLINE> y += DIR [ i ] [ 1 ] <NEWLINE> <NL> <DEDENT> if m [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( y , x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h + w == 0 : break <NEWLINE> b = [ list ( raw_input ( ) ) for i in range ( h ) ] <NEWLINE> direction = { <STRING> : [ 1 , 0 ] , <STRING> : [ 0 , 1 ] , <STRING> : [ - 1 , 0 ] , <STRING> : [ 0 , - 1 ] } <NEWLINE> f = False <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if b [ j ] [ i ] != <STRING> : <NEWLINE> <INDENT> p = [ i , j ] <NEWLINE> f = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : break <NEWLINE> <DEDENT> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> tmp = direction [ b [ p [ 1 ] ] [ p [ 0 ] ] ] <NEWLINE> p [ 0 ] += tmp [ 0 ] <NEWLINE> p [ 1 ] += tmp [ 1 ] <NEWLINE> c += 1 <NEWLINE> if c == h * w : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif b [ p [ 1 ] ] [ p [ 0 ] ] == <STRING> : <NEWLINE> <INDENT> print <STRING> . format ( p [ 0 ] , p [ 1 ] ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
posX , posY = 0 , 0 <NEWLINE> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> while not ( H == W == 0 ) : <NEWLINE> <INDENT> tile = [ [ False for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> tileinfo = [ [ <STRING> for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> tileinfo [ i ] = input ( ) . rstrip ( ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if tileinfo [ posX ] [ posY ] == <STRING> : <NEWLINE> <INDENT> posX += 1 <NEWLINE> <DEDENT> elif tileinfo [ posX ] [ posY ] == <STRING> : <NEWLINE> <INDENT> posX -= 1 <NEWLINE> <DEDENT> elif tileinfo [ posX ] [ posY ] == <STRING> : <NEWLINE> <INDENT> posY += 1 <NEWLINE> <DEDENT> elif tileinfo [ posX ] [ posY ] == <STRING> : <NEWLINE> <INDENT> posY -= 1 <NEWLINE> <DEDENT> elif tileinfo [ posX ] [ posY ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . format ( posX , posY ) ) <NEWLINE> break <NEWLINE> <DEDENT> if tile [ posX ] [ posY ] == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tile [ posX ] [ posY ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
book_index = { } <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> word , page = input ( ) . split ( <STRING> ) <NEWLINE> page = int ( page ) <NEWLINE> page_list = book_index . get ( word ) <NEWLINE> if page_list : <NEWLINE> <INDENT> page_list . append ( page ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> book_index [ word ] = [ page ] <NEWLINE> <DEDENT> <DEDENT> except Exception : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for k in sorted ( book_index . keys ( ) ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> print ( <STRING> . join ( map ( str , ( sorted ( book_index . get ( k ) ) ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
dic = { } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> word , pgn = input ( ) . split ( ) <NEWLINE> <NL> <DEDENT> if word in dic . keys ( ) : <NEWLINE> <INDENT> dic [ word ] . append ( int ( pgn ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ word ] = [ int ( pgn ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for k , v in dic . items ( ) : <NEWLINE> <INDENT> print ( k ) <NEWLINE> print ( <STRING> . join ( map ( str , sorted ( v ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a = { } <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> b , c = i . split ( ) <NEWLINE> a . setdefault ( b , [ ] ) . append ( c ) <NEWLINE> if c == <STRING> : break <NEWLINE> <DEDENT> for a , b in sorted ( a . items ( ) , key = lambda x : x [ 0 ] ) : <NEWLINE> <INDENT> print ( a ) <NEWLINE> print ( * b . sort ( ) ) <NEWLINE> <DEDENT>
d = { } <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> w , p = s . split ( ) <NEWLINE> if w in d : d [ w ] . append ( int ( p ) ) <NEWLINE> else : d [ w ] = int ( p ) <NEWLINE> <NL> <DEDENT> for w in sorted ( d . keys ( ) ) : <NEWLINE> <INDENT> print w , <STRING> <NEWLINE> print <STRING> . join ( map ( str , sorted ( d [ w ] ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> dic = { } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( str , input ( ) , split ( ) ) <NEWLINE> page = int ( b ) <NEWLINE> <NL> if a not in dic : <NEWLINE> <INDENT> dic [ a ] = [ page ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ a ] . append ( page ) <NEWLINE> <NL> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> sorted ( dic . keys ( ) ) <NEWLINE> names = list ( dic . keys ( ) ) <NEWLINE> for i in range ( len ( names ) ) : <NEWLINE> <INDENT> print ( names [ i ] ) <NEWLINE> for j in range ( len ( dic [ i ] ) ) : <NEWLINE> <INDENT> if j == len ( dic [ i ] ) - 1 : <NEWLINE> <INDENT> print ( dic [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( dic [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT>
dict = { } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if a in dict : <NEWLINE> <INDENT> dict [ a ] . append ( int ( b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dict [ a ] = [ int ( b ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> for var in dict : <NEWLINE> <INDENT> dict [ var ] . sort ( ) <NEWLINE> <NL> <DEDENT> dic = list ( dict . keys ( ) ) <NEWLINE> dic . sort ( ) <NEWLINE> <NL> for var in dic : <NEWLINE> <INDENT> print var <NEWLINE> for i in xrange ( len ( dict [ var ] ) ) : <NEWLINE> <INDENT> print dict [ var ] [ i ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
index = { } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> w , p = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> index . setdefault ( w , [ ] ) . append ( int ( p ) ) <NEWLINE> <DEDENT> <DEDENT> index . sort ( ) <NEWLINE> for i in index : <NEWLINE> <INDENT> index [ i ] . sort ( ) <NEWLINE> print i <NEWLINE> print <STRING> . join ( map ( int , index [ i ] ) ) <NEWLINE> <DEDENT>
def solve2 ( amount ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> packages = [ ( 0 , 0 ) , ( 2 , 380 ) , ( 3 , 550 ) , ( 5 , 850 ) , ( 10 , 1520 ) , ( 12 , 1870 ) , ( 15 , 2244 ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> cart = [ [ 99999999 ] * ( amount // 100 + 1 ) for _ in range ( len ( packages ) ) ] <NEWLINE> for i in range ( len ( packages ) ) : <NEWLINE> <INDENT> cart [ i ] [ 0 ] = 0 <COMMENT> <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( packages ) ) : <NEWLINE> <INDENT> for j in range ( 1 , len ( cart [ 0 ] ) ) : <NEWLINE> <INDENT> w = packages [ i ] [ 0 ] <COMMENT> <NEWLINE> p = packages [ i ] [ 1 ] <COMMENT> <NEWLINE> <COMMENT> <NL> cart [ i ] [ j ] = min ( cart [ i - 1 ] [ j ] , cart [ i - 1 ] [ max ( 0 , j - w ) ] + p , cart [ i ] [ max ( 0 , j - w ) ] + p ) <NEWLINE> <DEDENT> <DEDENT> return cart [ - 1 ] [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> amount = int ( input ( ) ) <NEWLINE> if amount == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result = solve2 ( amount ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
def hantei ( A , B , C , R = 0 ) : <NEWLINE> <INDENT> h , t = sorted ( [ A , B , C ] ) [ : 2 ] <NEWLINE> if h ** 2 + t ** 2 < 4 * R ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> A , B , C = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for k in range ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> hantei ( A , B , C , int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( a , b , c ) == ( 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> d , w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dmin = min ( d ** 2 + w ** 2 , w ** 2 + h ** 2 , h ** 2 + d ** 2 ) <NEWLINE> if dmin == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r = input ( ) <NEWLINE> if dmin < 2 * r ** 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> from math import sqrt <NEWLINE> <NL> nyu = sys . stdin . read ( ) <NEWLINE> nyu = nyu . split ( <STRING> ) <NEWLINE> cheese = map ( float , nyu [ 0 ] . split ( ) ) <NEWLINE> cheese . sort ( ) <NEWLINE> supk = sqrt ( ( cheese [ 0 ] / 2 ) ** 2 + ( cheese [ 1 ] / 2 ) ** 2 ) <NEWLINE> nyu = map ( int , nyu [ 2 : - 1 ] ) <NEWLINE> try : <NEWLINE> <INDENT> for k in nyu : <NEWLINE> <INDENT> if k < supk : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> i , size = 0 , 0 <NEWLINE> rs = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> for r in rs : <NEWLINE> <INDENT> if size <= r : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i == 1 : <NEWLINE> <INDENT> t = [ int ( n ) for n in line . split ( ) ] <NEWLINE> t . sort ( ) <NEWLINE> size = int ( math . ceil ( math . sqrt ( t [ 0 ] * t [ 0 ] + t [ 1 ] * t [ 1 ] ) ) ) <NEWLINE> <DEDENT> if i > 2 : <NEWLINE> <INDENT> rs . append ( int ( line ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> a = sys . stdin <NEWLINE> while 1 : <NEWLINE> <INDENT> if <STRING> == a . readline ( ) : break <NEWLINE> s = list ( map ( int , a . readline ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> t = s ; s = [ t . count ( e ) for e in t ] <NEWLINE> if t == s : break <NEWLINE> c += 1 <NEWLINE> <DEDENT> print ( c ) ; print ( * s ) <NEWLINE> <DEDENT>
import sys <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = list ( int ( input ( ) . split ( ) ) ) <NEWLINE> cont = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp [ i ] = [ s . count ( s [ i ] ) ] <NEWLINE> <DEDENT> if s == temp : <NEWLINE> <INDENT> print ( cont ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cont += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> sys . stdout ( <STRING> . format ( s [ i ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( s [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> t = s ; s = [ t . count ( e ) for e in t ] <NEWLINE> if t == s : break <NEWLINE> c += 1 <NEWLINE> <DEDENT> print ( c ) ; print ( * s ) <NEWLINE> <DEDENT> <DEDENT>
def FOA ( a , count ) : <NEWLINE> <INDENT> b = a <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> b [ i ] = a . count ( a [ i ] ) <NEWLINE> <DEDENT> if b == a : <NEWLINE> <INDENT> print ( count ) <NEWLINE> print ( <STRING> . join ( map ( str , b ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return FOA ( b , count + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = map ( int , input ( ) . split ( ) ) <NEWLINE> FOA ( a , 0 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = [ ] <NEWLINE> u = 0 <NEWLINE> v = 0 <NEWLINE> s = list ( input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == s [ j ] : <NEWLINE> <INDENT> u += 1 <NEWLINE> <DEDENT> <DEDENT> t . append ( u ) <NEWLINE> t_str = list ( map ( str , t ) ) <NEWLINE> u = 0 <NEWLINE> <DEDENT> if s == t_str : <NEWLINE> <INDENT> print ( str ( v ) ) <NEWLINE> print ( <STRING> . join ( t_str ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = t <NEWLINE> v += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def up_to_you ( formula ) : <NEWLINE> <INDENT> l_p = None <NEWLINE> r_p = None <NEWLINE> for i , c in enumerate ( formula ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> l_p = i <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> r_p = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print fx ( formula ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> r = fx ( formula [ l_p + 1 : r_p ] ) <NEWLINE> n_formula = formula [ : l_p ] + r + formula [ r_p + 1 : ] <NEWLINE> return up_to_you ( n_formula ) <NEWLINE> <NL> <DEDENT> def fx ( gemstone ) : <NEWLINE> <INDENT> n = <STRING> <NEWLINE> lis = [ ] <NEWLINE> add = <STRING> <NEWLINE> if gemstone [ 0 ] == <STRING> : <NEWLINE> <INDENT> gemstone = gemstone [ 1 : ] <NEWLINE> add = <STRING> <NEWLINE> <DEDENT> for c in gemstone : <NEWLINE> <INDENT> if c . isdigit ( ) : <NEWLINE> <INDENT> n += c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( add + n ) <NEWLINE> lis . append ( c ) <NEWLINE> n = <STRING> <NEWLINE> add = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( add + n ) <NEWLINE> <DEDENT> return isolation ( lis ) <NEWLINE> <NL> <DEDENT> def isolation ( lis ) : <NEWLINE> <INDENT> if len ( lis ) == 1 : <NEWLINE> <INDENT> return str ( lis [ 0 ] ) <NEWLINE> <DEDENT> o1 = None <NEWLINE> o = None <NEWLINE> o2 = None <NEWLINE> o_i = None <NEWLINE> n_lis = None <NEWLINE> if <STRING> in lis or <STRING> in lis : <NEWLINE> <INDENT> for i , v in enumerate ( lis ) : <NEWLINE> <INDENT> if o1 == None : <NEWLINE> <INDENT> o1 = v <NEWLINE> <DEDENT> elif v == <STRING> or v == <STRING> : <NEWLINE> <INDENT> o = v <NEWLINE> o_i = i <NEWLINE> <DEDENT> elif v == <STRING> or v == <STRING> : <NEWLINE> <INDENT> o1 = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> o2 = v <NEWLINE> r = discomfort ( int ( o1 ) , o , int ( o2 ) ) <NEWLINE> n_lis = lis [ : ( o_i - 1 ) ] + [ r ] + lis [ ( o_i + 2 ) : ] <NEWLINE> return isolation ( n_lis ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> o1 = lis [ 0 ] <NEWLINE> o = lis [ 1 ] <NEWLINE> o2 = lis [ 2 ] <NEWLINE> o_i = 1 <NEWLINE> r = discomfort ( int ( o1 ) , o , int ( o2 ) ) <NEWLINE> n_lis = lis [ : ( o_i - 1 ) ] + [ r ] + lis [ ( o_i + 2 ) : ] <NEWLINE> return isolation ( n_lis ) <NEWLINE> <NL> <DEDENT> <DEDENT> def discomfort ( o1 , o , o2 ) : <NEWLINE> <INDENT> r = None <NEWLINE> if o == <STRING> : <NEWLINE> <INDENT> r = o1 * o2 <NEWLINE> <DEDENT> elif o == <STRING> : <NEWLINE> <INDENT> r = o1 / o2 <NEWLINE> if o1 < 0 : r += 1 <NEWLINE> <DEDENT> elif o == <STRING> : <NEWLINE> <INDENT> r = o1 + o2 <NEWLINE> <DEDENT> elif o == <STRING> : <NEWLINE> <INDENT> r = o1 - o2 <NEWLINE> <DEDENT> return str ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> formula = raw_input ( ) . rstrip ( <STRING> ) <NEWLINE> up_to_you ( formula ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import re <NEWLINE> class Num : <NEWLINE> <INDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return str ( self . x ) <NEWLINE> <DEDENT> def __init__ ( self , value ) : <NEWLINE> <INDENT> self . x = value <NEWLINE> <DEDENT> def __add__ ( self , value ) : <NEWLINE> <INDENT> return o ( self . x + value . x ) <NEWLINE> <DEDENT> def __sub__ ( self , value ) : <NEWLINE> <INDENT> return o ( self . x - value . x ) <NEWLINE> <DEDENT> def __mul__ ( self , value ) : <NEWLINE> <INDENT> return o ( self . x * value . x ) <NEWLINE> <DEDENT> def __truediv__ ( self , value ) : <NEWLINE> <INDENT> return o ( int ( self . x / value . x ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = input ( ) [ : - 1 ] <NEWLINE> s = re . sub ( <STRING> , <STRING> , s ) <NEWLINE> print ( eval ( s ) ) <NEWLINE> <DEDENT>
def divide ( x , y ) : <NEWLINE> <INDENT> s = 1 <NEWLINE> if ( x < 0 ) : s *= - 1 <NEWLINE> if ( y < 0 ) : s *= - 1 <NEWLINE> return abs ( x ) / abs ( y ) * s <NEWLINE> <NL> <DEDENT> def _split ( _src ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> l = len ( _src ) <NEWLINE> if l == 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> while c < l and ord ( <STRING> ) <= ord ( _src [ c ] ) <= ord ( <STRING> ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> if c == 0 : <NEWLINE> <INDENT> tmp = _split ( _src [ 1 : ] ) <NEWLINE> if tmp != [ ] and tmp [ 0 ] == <STRING> : <NEWLINE> <INDENT> tmp = [ <STRING> , 0 , <STRING> , 1 , <STRING> , <STRING> ] + tmp [ 1 : ] <NEWLINE> <DEDENT> return [ _src [ 0 ] ] + tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ int ( _src [ : c ] ) ] + _split ( _src [ c : ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def evaluate ( src ) : <NEWLINE> <INDENT> if len ( src ) == 1 : <NEWLINE> <INDENT> return src [ 0 ] <NEWLINE> <NL> <DEDENT> if <STRING> in src : <NEWLINE> <INDENT> l = src . index ( <STRING> ) <NEWLINE> r = l <NEWLINE> st = 1 <NEWLINE> while st : <NEWLINE> <INDENT> r += 1 <NEWLINE> if src [ r ] == <STRING> : st += 1 <NEWLINE> if src [ r ] == <STRING> : st -= 1 <NEWLINE> <NL> <NL> <DEDENT> mid = evaluate ( src [ l + 1 : r ] ) <NEWLINE> return evaluate ( src [ : l ] + [ mid ] + src [ r + 1 : ] ) <NEWLINE> <NL> <DEDENT> operators = [ ( <STRING> , lambda x , y : x + y ) , <NEWLINE> <INDENT> ( <STRING> , lambda x , y : x - y ) , <NEWLINE> ( <STRING> , lambda x , y : x * y ) , <NEWLINE> ( <STRING> , divide ) <NEWLINE> ] <NEWLINE> <NL> <DEDENT> for ( op , func ) in operators : <NEWLINE> <INDENT> if op in src : <NEWLINE> <INDENT> p = src . index ( op ) <NEWLINE> l = evaluate ( src [ : p ] ) <NEWLINE> r = evaluate ( src [ p + 1 : ] ) <NEWLINE> return func ( l , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for t in xrange ( input ( ) ) : <NEWLINE> <INDENT> _src = <STRING> + raw_input ( ) . strip ( <STRING> ) <NEWLINE> src = _split ( _src ) <NEWLINE> print evaluate ( src ) <NEWLINE> <DEDENT>
import re <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> def solve ( ) : <NEWLINE> <INDENT> for _ in range ( int ( sys . stdin . readline ( ) ) ) : <NEWLINE> <INDENT> expr = sys . stdin . readline ( ) [ : - 1 ] . strip ( <STRING> ) <NEWLINE> expr = re . sub ( <STRING> , <STRING> , expr ) <NEWLINE> print ( eval ( expr . replace ( <STRING> , <STRING> ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
R = { <STRING> : 2 , <STRING> : 2 , <STRING> : 1 , <STRING> : 1 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> L = [ ] ; t = <STRING> <NEWLINE> for e in input ( ) [ : - 1 ] : <NEWLINE> <INDENT> if e . isdigit ( ) : t += e <NEWLINE> else : <NEWLINE> <INDENT> if t : L += [ t ] ; t = <STRING> <NEWLINE> L += e <NEWLINE> <DEDENT> <DEDENT> if t : L += [ t ] <NEWLINE> P , S = [ ] , [ ] <NEWLINE> for i in L : <NEWLINE> <INDENT> if <STRING> == i : S += i <NEWLINE> elif <STRING> == i : <NEWLINE> <INDENT> while <STRING> != S [ - 1 ] : P += S . pop ( ) <NEWLINE> S . pop ( ) <NEWLINE> <DEDENT> elif i in R : <NEWLINE> <INDENT> while S and R [ S [ - 1 ] ] >= R [ i ] : P += S . pop ( ) <NEWLINE> S += i <NEWLINE> <DEDENT> else : P += [ i ] <NEWLINE> <DEDENT> while S : P += S . pop ( ) <NEWLINE> for x in P : <NEWLINE> <INDENT> S += [ str ( eval ( S . pop ( - 2 ) + p + S . pop ( ) ) ) if x in <STRING> else x ] <NEWLINE> <DEDENT> print ( * S ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> def String2List ( s ) : <NEWLINE> <INDENT> L = [ ] ; tmp = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> if i . isdigit ( ) : <NEWLINE> <INDENT> tmp += i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if tmp != <STRING> : <NEWLINE> <INDENT> L . append ( tmp ) <NEWLINE> tmp = <STRING> <NEWLINE> <DEDENT> L . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if tmp != <STRING> : <NEWLINE> <INDENT> L . append ( tmp ) <NEWLINE> <NL> <DEDENT> return L <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def Generate_RPN ( L ) : <NEWLINE> <INDENT> S , L2 = [ ] , [ ] <NEWLINE> table = { <STRING> : 1 , <STRING> : 1 , <STRING> : 0 , <STRING> : 0 , <STRING> : - 1 , <STRING> : - 1 } <NEWLINE> for i in L : <NEWLINE> <INDENT> if i . isdigit ( ) : <NEWLINE> <INDENT> L2 . append ( i ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> S . append ( i ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> while S [ - 1 ] != <STRING> : <NEWLINE> <INDENT> L2 . append ( S . pop ( ) ) <NEWLINE> <DEDENT> S . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while len ( S ) != 0 and ( table [ S [ - 1 ] ] >= table [ i ] ) : <NEWLINE> <INDENT> L2 . append ( S . pop ( ) ) <NEWLINE> <DEDENT> S . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> while len ( S ) != 0 : <NEWLINE> <INDENT> L2 . append ( S . pop ( ) ) <NEWLINE> <NL> <DEDENT> return L2 <NEWLINE> <NL> <DEDENT> def Calculate_RPN ( L ) : <NEWLINE> <INDENT> St = [ ] <NEWLINE> <NL> for i in L : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> St . append ( int ( St . pop ( ) ) + int ( St . pop ( ) ) ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> St . append ( - int ( St . pop ( ) ) + int ( St . pop ( ) ) ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> St . append ( int ( St . pop ( ) ) * int ( St . pop ( ) ) ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> a = int ( St . pop ( ) ) <NEWLINE> b = float ( St . pop ( ) ) <NEWLINE> St . append ( b / a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> St . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> return St [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> print Calculate_RPN ( Generate_RPN ( String2List ( s ) ) ) <NEWLINE> <DEDENT>
def f ( s ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> b = s . find ( <STRING> ) <NEWLINE> if b < 0 : return g ( s ) <NEWLINE> a = s [ : b ] . rfind ( <STRING> ) <NEWLINE> s1 = s [ a : b + 1 ] <NEWLINE> s = s . replace ( s1 , f ( s1 [ 1 : - 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def g ( s ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> f = 1 <NEWLINE> x = [ ] <NEWLINE> def F ( a , b ) : <NEWLINE> <INDENT> x . append ( a ) <NEWLINE> x . append ( b ) <NEWLINE> return 1 , <STRING> <NEWLINE> <DEDENT> for c in s : <NEWLINE> <INDENT> if c == <STRING> : continue <NEWLINE> elif c in <STRING> : f , a = F ( a , c ) <NEWLINE> elif c in <STRING> : <NEWLINE> <INDENT> if f == 1 : f , a = 0 , c <NEWLINE> else : f , a = F ( a , c ) <NEWLINE> <DEDENT> else : f , a = 0 , a + c <NEWLINE> <DEDENT> x . append ( a ) <NEWLINE> <NL> s = x [ : ] <NEWLINE> x = [ ] <NEWLINE> f = <STRING> <NEWLINE> for e in s : <NEWLINE> <INDENT> if e in <STRING> : x . append ( e ) <NEWLINE> elif e in <STRING> : f = e <NEWLINE> else : <NEWLINE> <INDENT> a = int ( e ) <NEWLINE> if f == <STRING> : a *= x . pop ( ) <NEWLINE> elif f == <STRING> : a = x . pop ( ) / a <NEWLINE> x . append ( a ) <NEWLINE> f == <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> s = x [ : ] <NEWLINE> x = [ ] <NEWLINE> f = <STRING> <NEWLINE> for e in s : <NEWLINE> <INDENT> if e == <STRING> or e == <STRING> : f = e <NEWLINE> else : <NEWLINE> <INDENT> a = int ( e ) <NEWLINE> if f == <STRING> : a += x . pop ( ) <NEWLINE> elif f == <STRING> : a = x . pop ( ) - a <NEWLINE> x . append ( a ) <NEWLINE> f == <STRING> <NEWLINE> <DEDENT> <DEDENT> return str ( x [ 0 ] ) <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for _ in [ 0 ] * n : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> print f ( s ) <NEWLINE> <DEDENT>
anb2 = lambda a , b : - ( abs ( int ( 1.0 * a / b ) ) ) <NEWLINE> <NL> def number ( begin ) : <NEWLINE> <INDENT> global i <NEWLINE> <NL> if begin [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> res = expression ( begin ) <NEWLINE> i += 1 <NEWLINE> return res <NEWLINE> <NL> <DEDENT> res = 0 <NEWLINE> <NL> while begin [ i ] . isdigit ( ) : <NEWLINE> <INDENT> res *= 10 <NEWLINE> res += int ( begin [ i ] ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def term ( begin ) : <COMMENT> <NEWLINE> <NL> <INDENT> global i <NEWLINE> res = number ( begin ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if begin [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> res *= number ( begin ) <NEWLINE> <DEDENT> elif begin [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> num = number ( begin ) <NEWLINE> if res < 0 or num < 0 : <NEWLINE> <INDENT> res = abs2 ( res , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res /= num <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def expression ( begin ) : <NEWLINE> <NL> <INDENT> global i <NEWLINE> res = term ( begin ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if begin [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> res += term ( begin ) <NEWLINE> <NL> <DEDENT> elif begin [ i ] == <STRING> : <NEWLINE> <INDENT> i += 1 <NEWLINE> res -= term ( begin ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global i <NEWLINE> for j in range ( input ( ) ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> ex = raw_input ( ) + <STRING> <NEWLINE> ans = expression ( ex ) <NEWLINE> <NL> print ans <NEWLINE> <DEDENT> <DEDENT> main ( ) <NEWLINE>
X = <STRING> <NEWLINE> N = <STRING> <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> i = s . find ( <STRING> ) <NEWLINE> j = s . find ( <STRING> ) <NEWLINE> k = s [ 0 ] == X or s [ i + 1 ] == X or s [ j + 1 ] == X <NEWLINE> f = 0 <NEWLINE> for c in N [ k : ] : <NEWLINE> <INDENT> a = s . replace ( X , c ) <NEWLINE> if eval ( a [ : i ] ) == eval ( a [ i + 1 : ] ) : f = 1 ; break <NEWLINE> <DEDENT> print [ <STRING> , c ] [ f ] <NEWLINE> <DEDENT>
import sys <NEWLINE> t = <STRING> <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> for i in <STRING> [ ( e [ 0 ] == t ) * ( e [ 1 ] != <STRING> ) or ( <STRING> in e ) * ( <STRING> not in e ) or ( e [ - 2 : ] == <STRING> ) : ] : <NEWLINE> <INDENT> if eval ( e . replace ( t , i ) . replace ( <STRING> , <STRING> ) ) : print ( i ) ; break <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
for line in open ( <STRING> ) . readlines ( ) : <NEWLINE> <INDENT> n = <STRING> <NEWLINE> lis = [ ] <NEWLINE> for c in line . rstrip ( ) : <NEWLINE> <INDENT> if c . isdigit ( ) or c == <STRING> : <NEWLINE> <INDENT> n += c <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> lis . append ( n ) <NEWLINE> n = <STRING> <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> lis . append ( n ) <NEWLINE> n = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lis . append ( n ) <NEWLINE> <NL> <DEDENT> c_lis = lis [ : ] <NEWLINE> for n in range ( 10 ) : <NEWLINE> <INDENT> for i , v in enumerate ( lis ) : <NEWLINE> <INDENT> if <STRING> in v : <NEWLINE> <INDENT> c_lis [ i ] = c_lis [ i ] . replace ( <STRING> , str ( n ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> if n == 0 : <NEWLINE> <INDENT> for v in c_lis : <NEWLINE> <INDENT> if len ( v ) >= 2 and v [ 0 ] == <STRING> : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> if int ( c_lis [ 0 ] ) + int ( c_lis [ 1 ] ) == int ( c_lis [ 2 ] ) : <NEWLINE> <INDENT> print n <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> c_lis = lis [ : ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> t = <STRING> <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> for i in <STRING> [ ( e [ 0 ] == t ) * ( e [ 1 ] != <STRING> ) or ( <STRING> in e ) * ( <STRING> not in e ) or ( <STRING> in e ) * ( e [ - 1 ] == t ) : ] : <NEWLINE> <INDENT> if eval ( e . replace ( t , i ) . replace ( <STRING> , <STRING> ) ) : print ( i ) ; break <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import re <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> s = any ( [ len ( x ) > 1 and x [ 0 ] == <STRING> for x in re . split ( <STRING> , e ) ] ) <NEWLINE> for i in <STRING> [ s : ] : <NEWLINE> <INDENT> if eval ( e . replace ( <STRING> , i ) . replace ( <STRING> , <STRING> ) ) : print ( i ) ; break <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import re <NEWLINE> def line ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> e = re . findall ( <STRING> , line ( ) ) <NEWLINE> <NL> ans = - 1 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> a , b , c = [ int ( _ . replace ( <STRING> , str ( i ) ) ) for _ in e ] <NEWLINE> if a + b == c : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
import re , sys <NEWLINE> def chk ( t ) : <NEWLINE> <INDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> if eval ( re . sub ( <STRING> , str ( i ) , t ) ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return 10 <NEWLINE> <NL> <DEDENT> l = [ chk ( i . replace ( <STRING> , <STRING> ) ) for i in sys . stdin ] <NEWLINE> [ print ( i ) if i != 10 else print ( <STRING> ) for i in l ] <NEWLINE> <NL>
def form_check ( t ) : <NEWLINE> <INDENT> plus = t . index ( <STRING> ) <NEWLINE> equal = t . index ( <STRING> ) <NEWLINE> if len ( t [ : plus ] ) > 1 or len ( t [ plus + 1 : equal ] ) > 1 or len ( t [ equal + 1 : ] > 1 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def check ( t ) : <NEWLINE> <INDENT> equal = t . index ( <STRING> ) <NEWLINE> if eval ( t [ : equal ] ) == eval ( t [ equal + 1 : ] ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if form_check ( line ) : <NEWLINE> <INDENT> nums = range ( 0 , 10 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nums = range ( 1 , 10 ) <NEWLINE> <DEDENT> a = - 1 <NEWLINE> for num in nums : <NEWLINE> <INDENT> if check ( line . replace ( <STRING> , str ( num ) ) ) : <NEWLINE> <INDENT> a = num <NEWLINE> <DEDENT> <DEDENT> if a >= 0 : <NEWLINE> <INDENT> print a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dataset = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flag = True <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> sequence = dataset . replace ( <STRING> , <STRING> ) . split ( <STRING> ) <NEWLINE> if i == 0 and any ( [ True if seq [ 0 ] == <STRING> and len ( seq ) >= 2 else False for seq in sequence ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a , b , c = map ( int , [ seq . replace ( <STRING> , str ( i ) ) for seq in sequence [ : 2 ] ] ) , sequence [ 2 ] . replace ( <STRING> , str ( i ) ) <NEWLINE> if a + b == c : <NEWLINE> <INDENT> print ( i ) <NEWLINE> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> <NL> def f ( s ) : <NEWLINE> <INDENT> for i in range ( 0 , 10 ) : <NEWLINE> <INDENT> t = s . replace ( <STRING> , str ( i ) ) <NEWLINE> a , b , c = map ( int , re . split ( <STRING> , t ) ) <NEWLINE> if a + b == c and str ( a ) + <STRING> + str ( b ) + <STRING> + str ( c ) == t : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> print f ( raw_input ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> for i in <STRING> [ ( e [ 0 ] == t ) * ( e [ 1 ] != <STRING> ) or ( <STRING> in e ) * ( <STRING> not in e ) or ( <STRING> in e ) : ] : <NEWLINE> <INDENT> l , r = e . replace ( <STRING> , i ) . split ( <STRING> ) <NEWLINE> if sum ( map ( int , l . split ( <STRING> ) ) ) == int ( r ) : print ( i ) ; break <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> import sys <NEWLINE> <NL> <NL> def solv ( s ) : <NEWLINE> <INDENT> left , right = s . split ( <STRING> ) <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> i = str ( i ) <NEWLINE> l = left . replace ( <STRING> , i ) <NEWLINE> r = right . replace ( <STRING> , i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if eval ( l ) == int ( r ) : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> print solv ( line . rstrip ( <STRING> ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> t = <STRING> <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> for i in <STRING> [ ( e [ 0 ] == t ) * ( e [ 1 ] != <STRING> ) or ( <STRING> in e ) * not ( <STRING> in e ) or ( <STRING> in e ) * ( e [ - 2 ] != <STRING> ) : ] : <NEWLINE> <INDENT> if eval ( e . replace ( t , i ) . replace ( <STRING> , <STRING> ) ) : print ( i ) ; break <NEWLINE> <DEDENT> else : print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> exp , ans = line . strip ( ) . replace ( <STRING> , str ( i ) ) . split ( <STRING> ) <NEWLINE> if eval ( exp ) == int ( ans ) : <NEWLINE> <INDENT> a = i <NEWLINE> <DEDENT> <DEDENT> print a <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import re <NEWLINE> import random <NEWLINE> <NL> input_text_path = __file__ . replace ( <STRING> , <STRING> ) <NEWLINE> fd = os . open ( input_text_path , os . O_RDONLY ) <NEWLINE> os . dup2 ( fd , sys . stdin . fileno ( ) ) <NEWLINE> <NL> tableA = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <NL> <DEDENT> tableB = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <NL> <DEDENT> def my_solve ( s ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> lst . append ( tableA [ c ] ) <NEWLINE> <DEDENT> s = <STRING> . join ( lst ) <NEWLINE> <NL> tmp , ans = <STRING> , <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> tmp += c <NEWLINE> if tmp in tableB : <NEWLINE> <INDENT> ans += tableB [ tmp ] <NEWLINE> tmp = <STRING> <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print ( my_solve ( s ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def f1 ( s ) : return <STRING> . join ( [ d0 [ c ] for c in s ] ) <NEWLINE> <NL> d0 = { <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> a = <STRING> ; <NEWLINE> for i in range ( 4 ) : d0 [ a [ i ] ] = format ( i , <STRING> ) <NEWLINE> a = <STRING> <NEWLINE> for i in range ( 8 ) : d0 [ a [ i ] ] = format ( i , <STRING> ) <NEWLINE> L0 = <STRING> <NEWLINE> L1 = <STRING> <NEWLINE> L2 = <STRING> <NEWLINE> <NL> d = { } <NEWLINE> a = <STRING> <STRING> . split ( <STRING> ) <NEWLINE> for i , e in enumerate ( a ) : d [ f1 ( e ) ] = ( L1 + L0 ) [ i ] <NEWLINE> for s0 in sys . stdin : <NEWLINE> <INDENT> s1 = <STRING> . join ( [ format ( ( L0 + L2 ) . index ( c ) , <STRING> ) for c in s0 . strip ( ) ] ) <NEWLINE> s = <STRING> <NEWLINE> x = <STRING> <NEWLINE> for c in s1 : <NEWLINE> <INDENT> try : x += d [ s ] ; s = <STRING> <NEWLINE> except : pass <NEWLINE> s += c <NEWLINE> <DEDENT> if s1 = <STRING> : print <NEWLINE> else : print x <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import os <NEWLINE> import math <NEWLINE> import re <NEWLINE> <NL> tableA = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <NL> <DEDENT> tableB = { <NEWLINE> <INDENT> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> <NL> <DEDENT> for s in sys . stdin : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> lst . append ( tableA [ c ] ) <NEWLINE> <DEDENT> s = <STRING> . join ( lst ) <NEWLINE> <COMMENT> <NL> <NL> tmp , ans = <STRING> , <STRING> <NEWLINE> for c in s : <NEWLINE> <INDENT> tmp += c <NEWLINE> if tmp in tableB : <NEWLINE> <INDENT> ans += tableB [ tmp ] <NEWLINE> tmp = <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> q = sorted ( [ input ( ) afor i in range ( n ) ] ) <NEWLINE> t = [ 0 ] * n <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t [ i + 1 ] = t [ i ] + q [ i ] <NEWLINE> <DEDENT> print sum ( t ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> x = sorted ( [ input ( ) for _ in [ 0 ] * n ] ) <NEWLINE> b = sum ( map ( sum , [ x [ : i ] for i in range ( n ) ] ) ) <NEWLINE> print b <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> mem = { } <NEWLINE> p , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a , b , c = <STRING> , p % q , 0 <NEWLINE> while True : <NEWLINE> <INDENT> b = ( b % q ) * 10 <NEWLINE> if b in mem or not b : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mem [ b ] = len ( a ) <NEWLINE> a += str ( b // q ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> if b != 0 : <NEWLINE> <INDENT> print ( <STRING> * mem [ b ] + <STRING> * ( len ( a ) - mem [ b ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 2 ** 16 ) <NEWLINE> <NL> <NL> def getfly ( x , a , m , i ) : <NEWLINE> <INDENT> if x == 1 and i != 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return getfly ( ( a * x ) % m , a , m , i + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getgcd ( a , b ) : <NEWLINE> <COMMENT> <NL> <INDENT> ( a , b ) = max ( a , b ) , min ( a , b ) <NEWLINE> if a % b == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return getgcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> indata = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if indata [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = indata [ 0 : : 2 ] <NEWLINE> m = indata [ 1 : : 2 ] <NEWLINE> A = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> A . append ( getfly ( 1 , a [ i ] , m [ i ] , 0 ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> gab = getgcd ( A [ 0 ] , A [ 1 ] ) <NEWLINE> lab = A [ 0 ] * A [ 1 ] / gab <NEWLINE> gac = getgcd ( A [ 2 ] , lab ) <NEWLINE> ans = A [ 2 ] * lab / gac <NEWLINE> print ans <NEWLINE> <DEDENT> <DEDENT>
def solve ( A , b ) : <NEWLINE> <INDENT> for i in xrange ( 3 ) : <NEWLINE> <INDENT> if A [ i ] [ i ] == 0.0 : <NEWLINE> <INDENT> for j in xrange ( i + 1 , 3 ) : <NEWLINE> <INDENT> if A [ j ] [ i ] != 0.0 : <NEWLINE> <INDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> b [ i ] , b [ j ] = b [ j ] , b [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for j in xrange ( 3 ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a = A [ j ] [ i ] / A [ i ] [ i ] <NEWLINE> for k in xrange ( 3 ) : <NEWLINE> <INDENT> A [ j ] [ k ] -= a * A [ i ] [ k ] <NEWLINE> <DEDENT> b [ j ] -= a * b [ i ] <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( 3 ) : <NEWLINE> <INDENT> b [ i ] /= A [ i ] [ i ] <NEWLINE> A [ i ] [ i ] /= A [ i ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> u = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> e = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> o = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> p = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> q = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> A = [ [ p [ i ] - o [ i ] , q [ i ] - o [ i ] , e [ i ] - u [ i ] ] for i in xrange ( 3 ) ] <NEWLINE> b = [ e [ i ] - o [ i ] for i in xrange ( 3 ) ] <NEWLINE> solve ( A , b ) <NEWLINE> s , t , x = b <NEWLINE> j = lambda x : - 0.0000001 < x < 1.0000001 <NEWLINE> if j ( s ) and j ( t ) and j ( s + t ) and j ( x ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
def cut ( squares ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for s in squares : <NEWLINE> <INDENT> for i , r in enumerate ( ret ) : <NEWLINE> <INDENT> if s [ 0 ] >= r [ 0 ] and s [ 1 ] >= r [ 1 ] : <COMMENT> <NEWLINE> <INDENT> ret [ i ] = s <NEWLINE> break <NEWLINE> <DEDENT> if s [ 0 ] <= r [ 0 ] and s [ 1 ] <= r [ 1 ] : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ret . append ( s ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def merge ( left , buttom ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for b in buttom : <NEWLINE> <INDENT> for l in left : <NEWLINE> <INDENT> w = min ( b [ 0 ] , l [ 0 ] + 1 ) <NEWLINE> h = min ( b [ 1 ] + 1 , l [ 1 ] ) <NEWLINE> ret += [ ( w , h ) , ( 1 , b [ 1 ] + 1 ) , ( l [ 0 ] + 1 , 1 ) ] <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( H , W ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ raw_input ( ) for _ in xrange ( H ) ] <NEWLINE> DP = [ [ [ ( 0 , 0 ) ] for _ in xrange ( W + 1 ) ] for _ in xrange ( H + 1 ) ] <NEWLINE> for x in xrange ( W - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> for y in ( y for y in xrange ( H - 1 , - 1 , - 1 ) if field [ y ] [ x ] != <STRING> ) : <NEWLINE> <INDENT> DP [ y ] [ x ] = cut ( merge ( DP [ y ] [ x + 1 ] , DP [ y + 1 ] [ x ] ) ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for x in xrange ( W ) : <NEWLINE> <INDENT> for y in xrange ( H ) : <NEWLINE> <INDENT> if DP [ y ] [ x ] : <NEWLINE> <INDENT> ans = max ( ans , max ( w * h for w , h in DP [ y ] [ x ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> H = range ( h ) <NEWLINE> A = [ 0 ] * h <NEWLINE> for i in H : <NEWLINE> <INDENT> x = raw_input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> A [ i ] = map ( int , list ( x ) ) <NEWLINE> <DEDENT> B = A [ : ] <NEWLINE> C = [ 0 ] * h <NEWLINE> for j in H [ 1 : ] : <NEWLINE> <INDENT> M = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in H [ j : ] : <NEWLINE> <INDENT> x = [ e1 * e2 for e1 , e2 in zip ( B [ i - j ] , A [ i ] ) ] <NEWLINE> B [ i - j ] = x [ : ] <NEWLINE> x = sorted ( <STRING> . join ( map ( str , x ) ) . split ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> C [ j ] = len ( sorted ( M ) [ - 1 ] ) * ( j + 1 ) <NEWLINE> <DEDENT> print max ( C ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 : break <NEWLINE> A = [ raw_input ( ) for i in range ( H ) ] <NEWLINE> S = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> L = ans = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if A [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> L += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = 0 <NEWLINE> <DEDENT> S [ h ] [ w ] = L <NEWLINE> if L > 0 : <NEWLINE> <INDENT> a = L <NEWLINE> for hi in range ( h - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if S [ hi ] [ w ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = min ( a , S [ hi ] [ w ] ) <NEWLINE> ans = max ( ans , a * ( h - hi + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
def f ( k , j ) : return max ( M [ k ] , j - C [ k ] ) <NEWLINE> while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : break <NEWLINE> H = range ( h ) <NEWLINE> C = [ 0 ] * ( h + 1 ) <NEWLINE> M = C [ : ] <NEWLINE> a = [ 0 ] * w <NEWLINE> for i in H : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> b = [ 0 ] * w <NEWLINE> sp = - 1 <NEWLINE> C = [ - 1 ] * ( h + 1 ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> if x [ j ] == <STRING> : <NEWLINE> <INDENT> c = 0 <NEWLINE> <DEDENT> elif x [ j ] == <STRING> : <NEWLINE> <INDENT> c = a [ j ] + 1 <NEWLINE> <DEDENT> b [ j ] = c <NEWLINE> if c > sp : <NEWLINE> <INDENT> C [ sp + 1 : c + 1 ] = [ j ] * ( c - sp ) <NEWLINE> <DEDENT> elif c < sp : <NEWLINE> <INDENT> for k in range ( c + 1 , sp + 1 ) : <NEWLINE> <INDENT> M [ k ] = f ( k , j ) <NEWLINE> C [ k ] = - 1 <NEWLINE> <DEDENT> <DEDENT> sp = c <NEWLINE> <DEDENT> for k in range ( 1 , sp + 1 ) : <NEWLINE> <INDENT> if C [ k ] >= 0 : <NEWLINE> <INDENT> M [ k ] = f ( k , w ) <NEWLINE> <DEDENT> <DEDENT> a = b <NEWLINE> <DEDENT> s = max ( [ a * b for a , b in zip ( M , H + [ h ] ) ] ) <NEWLINE> print s <NEWLINE> <DEDENT>
def get_rectangle_area ( table , w ) : <NEWLINE> <INDENT> maxv = 0 <NEWLINE> stack = [ ] <NEWLINE> table . append ( 0 ) <NEWLINE> for i , rect in enumerate ( table ) : <NEWLINE> <INDENT> if stack == [ ] : <NEWLINE> <INDENT> stack . append ( ( rect , i ) ) <NEWLINE> <DEDENT> elif stack [ - 1 ] [ 0 ] < rect : <NEWLINE> <INDENT> stack . append ( ( rect , i ) ) <NEWLINE> <DEDENT> elif stack [ - 1 ] [ 0 ] == rect : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif stack [ - 1 ] [ 0 ] > rect : <NEWLINE> <INDENT> while stack != [ ] and stack [ - 1 ] [ 0 ] >= rect : <NEWLINE> <INDENT> high , pos = stack . pop ( ) <NEWLINE> maxv = max ( maxv , high * ( i - pos ) ) <NEWLINE> <DEDENT> stack . append ( ( rect , pos ) ) <NEWLINE> <DEDENT> <DEDENT> return maxv <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> mass = [ raw_input ( ) for i in range ( h ) ] <NEWLINE> table = histgram ( mass , h , w ) <NEWLINE> ans = 0 <NEWLINE> for tab in table : <NEWLINE> <INDENT> ans = max ( ans , get_rectangle_area ( tab , w ) ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> def discomfort ( dic , n ) : <NEWLINE> <INDENT> global expenses <NEWLINE> if expenses != None and sum ( p_res ) >= expenses : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if n == s_n and g_n in load : <NEWLINE> <INDENT> expenses = sum ( p_res ) <NEWLINE> Pirates . append ( r - ( sum ( p_res ) + p ) ) <NEWLINE> return <NEWLINE> <DEDENT> for v in dic [ n ] : <NEWLINE> <INDENT> p_res . append ( p_dic [ ( n , v ) ] ) <NEWLINE> c_l_dic = copy . deepcopy ( dic ) <NEWLINE> c_l_dic [ n ] . remove ( v ) <NEWLINE> c_l_dic [ v ] . remove ( n ) <NEWLINE> load . append ( v ) <NEWLINE> discomfort ( c_l_dic , v ) <NEWLINE> del p_res [ - 1 ] <NEWLINE> del load [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l_dic = { } <NEWLINE> p_dic = { } <NEWLINE> for line in open ( <STRING> ) . readlines ( ) : <NEWLINE> <INDENT> n1 , n2 , p1 , p2 = map ( int , line . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> if not n1 in l_dic : <NEWLINE> <INDENT> l_dic [ n1 ] = [ n2 ] <NEWLINE> if not n2 in l_dic : <NEWLINE> <INDENT> l_dic [ n2 ] = [ n1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_dic [ n2 ] . append ( n1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> l_dic [ n1 ] . append ( n2 ) <NEWLINE> if not n2 in l_dic : <NEWLINE> <INDENT> l_dic [ n2 ] = [ n1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l_dic [ n2 ] . append ( n1 ) <NEWLINE> <DEDENT> <DEDENT> p_dic [ ( n1 , n2 ) ] = p1 <NEWLINE> p_dic [ ( n2 , n1 ) ] = p2 <NEWLINE> <NL> <DEDENT> s_n , g_n , r , p = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> p_res = [ ] <NEWLINE> load = [ 2 ] <NEWLINE> expenses = None <NEWLINE> Pirates = [ ] <NEWLINE> discomfort ( l_dic , s_n ) <NEWLINE> print sorted ( Pirates ) [ - 1 ] <NEWLINE> <DEDENT>
def wa ( h , w , f ) : <NEWLINE> <INDENT> if not ( 0 <= h < H and 0 <= w < W ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif mapp [ h ] [ w ] != f : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> mapp [ h ] [ w ] = <STRING> <NEWLINE> wa ( h , w + 1 , f ) <NEWLINE> wa ( h - 1 , w , f ) <NEWLINE> wa ( h , w - 1 , f ) <NEWLINE> wa ( h + 1 , w , f ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> W , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : break <NEWLINE> mapp = [ list ( raw_input ( ) ) for i in range ( H ) ] <NEWLINE> count = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if mapp [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> wa ( h , w , <STRING> ) <NEWLINE> <DEDENT> elif mapp [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> wa ( h , w , <STRING> ) <NEWLINE> <DEDENT> elif mapp [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> count += 1 <NEWLINE> wa ( h , w , <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print count <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> def search ( values , hp , vp , item ) : <NEWLINE> <INDENT> if not ( 0 <= hp < len ( values ) ) : return <NEWLINE> if not ( 0 <= vp < len ( values [ hp ] ) ) : return <NEWLINE> if item != values [ hp ] [ vp ] : return <NEWLINE> values [ hp ] [ vp ] = True <NEWLINE> search ( values , hp - 1 , vp , item ) <NEWLINE> search ( values , hp + 1 , vp , item ) <NEWLINE> search ( values , hp , vp - 1 , item ) <NEWLINE> search ( values , hp , vp + 1 , item ) <NEWLINE> <NL> <DEDENT> def solve ( values ) : <NEWLINE> <INDENT> count , valid_items = 0 , set ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for i in range ( len ( values ) ) : <NEWLINE> <INDENT> for j in range ( len ( values [ i ] ) ) : <NEWLINE> <INDENT> if values [ i ] [ j ] in valid_items : <NEWLINE> <INDENT> search ( values , i , j , values [ i ] [ j ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> line , values = input ( ) . strip ( ) , list ( ) <NEWLINE> while line != <STRING> : <NEWLINE> <INDENT> H , W = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> value = list ( ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> value . append ( input ( ) . strip ( ) ) <NEWLINE> <DEDENT> values . append ( value ) <NEWLINE> line = input ( ) . strip ( ) <NEWLINE> <DEDENT> for value in values : <NEWLINE> <INDENT> print ( solve ( value ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dxy = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> field = [ ] <NEWLINE> H , W = 0 , 0 <NEWLINE> q = queue . Queue ( ) <NEWLINE> <NL> def solver ( x , y , symbol ) : <NEWLINE> <INDENT> global q , field , H , W <NEWLINE> while True : <NEWLINE> <INDENT> if x < 0 or y < 0 or x >= H or y >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for dx , dy in dxy : <NEWLINE> <INDENT> if x + dx < 0 or y + dy < 0 or x + dx >= H or y + dy >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ x + dx ] [ y + dy ] == symbol : <NEWLINE> <INDENT> field [ x + dx ] [ y + dy ] = <STRING> <NEWLINE> q . put ( [ x + dx , y + dy ] ) <NEWLINE> <DEDENT> <DEDENT> data = q . get ( ) <NEWLINE> if data is None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> x , y = data ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ list ( raw_input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for x in xrange ( H ) : <NEWLINE> <INDENT> for y in xrange ( W ) : <NEWLINE> <INDENT> if field [ x ] [ y ] != <STRING> : <NEWLINE> <INDENT> solver ( x , y , field [ x ] [ y ] ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
def setLine ( tempH , line ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( line ) ) : <NEWLINE> <INDENT> geo [ tempH ] [ i ] = line [ i : i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> person = 0 <NEWLINE> for i in range ( 0 , H ) : <NEWLINE> <INDENT> for j in range ( 0 , W ) : <NEWLINE> <INDENT> if geo [ i ] [ j ] is not <STRING> : <NEWLINE> <INDENT> search ( i , j ) <NEWLINE> person += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( person ) <NEWLINE> <NL> <DEDENT> def search ( i , j ) : <NEWLINE> <INDENT> temp = geo [ i ] [ j ] <NEWLINE> geo [ i ] [ j ] = <STRING> <NEWLINE> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> for a in range ( 0 , 4 ) : <NEWLINE> <INDENT> idx = i + dx [ a ] <NEWLINE> jdy = j + dy [ a ] <NEWLINE> if ( isOnMap ( idx , jdy ) ) : <NEWLINE> <INDENT> if ( isNeededToSolve ( temp , idx , jdy ) ) : <NEWLINE> <INDENT> search ( idx , jdy ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def isOnMap ( i , j ) : <NEWLINE> <INDENT> return ( 0 <= i and 0 <= j and i < H and j < W ) <NEWLINE> <NL> <DEDENT> def isNeededToSolve ( temp , i , j ) : <NEWLINE> <INDENT> target = geo [ i ] [ j ] <NEWLINE> return ( target is not <STRING> and temp is target ) <NEWLINE> <NL> <DEDENT> limit = 10 ** 10 <NEWLINE> sys . getrecursionlimit ( limit ) <NEWLINE> <NL> H = - 1 <NEWLINE> W = - 1 <NEWLINE> tempH = 0 <NEWLINE> geo = [ [ 0 for i in range ( 1 ) ] for j in range ( 1 ) ] <NEWLINE> repeat = True <NEWLINE> while repeat : <NEWLINE> <INDENT> line = input ( ) <NEWLINE> if H is - 1 and W is - 1 : <NEWLINE> <INDENT> H = int ( line . split ( <STRING> ) [ 0 ] ) <NEWLINE> W = int ( line . split ( <STRING> ) [ 1 ] ) <NEWLINE> geo = [ [ 0 for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> setLine ( tempH , line ) <NEWLINE> tempH += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if H is 0 and W is 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if tempH is H : <NEWLINE> <INDENT> solve ( ) <NEWLINE> H = - 1 <NEWLINE> W = - 1 <NEWLINE> tempH = 0 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> def check ( x , y , flag ) : <NEWLINE> <INDENT> farm [ x ] [ y ] = <STRING> <NEWLINE> if farm [ x + 1 ] [ y ] == flag : check ( x + 1 , y , flag ) <NEWLINE> if farm [ x - 1 ] [ y ] == flag : check ( x - 1 , y , flag ) <NEWLINE> if farm [ x ] [ y + 1 ] == flag : check ( x , y + 1 , flag ) <NEWLINE> if farm [ x ] [ y - 1 ] == flag : check ( x , y - 1 , flag ) <NEWLINE> return 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> <NL> farm = [ ] <NEWLINE> farm . append ( list ( <STRING> * ( w + 2 ) ) ) <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> farm . append ( list ( <STRING> + raw_input ( ) + <STRING> ) ) <NEWLINE> <DEDENT> farm . append ( list ( <STRING> * ( w + 2 ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 0 , h ) : <NEWLINE> <INDENT> for j in range ( 0 , w ) : <NEWLINE> <INDENT> if farm [ i + 1 ] [ j + 1 ] != <STRING> : <NEWLINE> <INDENT> count += check ( i + 1 , j + 1 , farm [ i + 1 ] [ j + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> <NL> <NL> <NL> def solve ( data ) : <NEWLINE> <INDENT> size = len ( data [ 0 ] ) <NEWLINE> data . insert ( 0 , [ <STRING> for _ in range ( size ) ] ) <NEWLINE> data . insert ( len ( data ) , [ <STRING> for _ in range ( size ) ] ) <NEWLINE> <NL> processing_area = [ ] <NEWLINE> area_id = 0 <NEWLINE> for y in range ( 1 , len ( data ) - 1 ) : <NEWLINE> <INDENT> for x in range ( 1 , len ( data [ 0 ] ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> mark = data [ y ] [ x ] <NEWLINE> data [ y ] [ x ] = <STRING> <NEWLINE> if mark != <STRING> : <NEWLINE> <INDENT> area_id += 1 <NEWLINE> processing_area . append ( ( y , x ) ) <NEWLINE> <NL> while processing_area : <NEWLINE> <INDENT> yy , xx = processing_area . pop ( ) <NEWLINE> if data [ yy - 1 ] [ xx ] == mark : <COMMENT> <NEWLINE> <INDENT> data [ yy - 1 ] [ xx ] = <STRING> <NEWLINE> processing_area . append ( ( yy - 1 l , xx ) ) <NEWLINE> <DEDENT> if data [ yy + 1 ] [ xx ] == mark : <COMMENT> <NEWLINE> <INDENT> data [ yy + 1 ] [ xx ] = <STRING> <NEWLINE> processing_area . append ( ( yy + 1 , xx ) ) <NEWLINE> <DEDENT> if data [ yy ] [ xx - 1 ] == mark : <COMMENT> <NEWLINE> <INDENT> data [ yy ] [ xx - 1 ] = <STRING> <NEWLINE> processing_area . append ( ( yy , xx - 1 ) ) <NEWLINE> <DEDENT> if data [ yy ] [ xx + 1 ] == mark : <COMMENT> <NEWLINE> <INDENT> data [ yy ] [ xx + 1 ] = <STRING> <NEWLINE> processing_area . append ( ( yy , xx + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> mark = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return area_id <NEWLINE> <NL> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> while True : <NEWLINE> <INDENT> h , w = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> temp = list ( input ( ) ) <NEWLINE> temp . insert ( 0 , <STRING> ) <NEWLINE> temp . append ( <STRING> ) <NEWLINE> data . append ( temp ) <NEWLINE> <NL> <DEDENT> result = solve ( data ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
def dfs ( X , Y , ch ) : <NEWLINE> <INDENT> field [ X ] [ Y ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = X + moveY [ i ] <NEWLINE> ny = Y + moveX [ i ] <NEWLINE> if ( nx >= 0 and ny >= 0 ) and ( nx < H and ny < W ) and field [ nx ] [ ny ] == ch : <NEWLINE> <INDENT> if field [ nx ] [ ny ] == <STRING> or field [ nx ] [ ny ] == <STRING> or field [ nx ] [ ny ] == <STRING> : <NEWLINE> <INDENT> dfs ( nx , ny , field [ nx ] [ ny ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> moveY = [ - 1 , 0 , 1 , 0 ] <NEWLINE> moveX = [ 0 , 1 , 0 , - 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ list ( raw_input ( ) ) for i in range ( H ) ] <NEWLINE> print field <NEWLINE> correct = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == <STRING> or field [ i ] [ j ] == <STRING> or field [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> dfs ( i , j , field [ i ] [ j ] ) <NEWLINE> correct += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print correct <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def search ( values , hp , vp , item ) : <NEWLINE> <INDENT> if not ( 0 <= hp < len ( values ) ) : return <NEWLINE> if not ( 0 <= vp < len ( values [ hp ] ) ) : return <NEWLINE> if item != values [ hp ] [ vp ] : return <NEWLINE> values [ hp ] [ vp ] = True <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> search ( values , hp - 1 , vp , item ) <NEWLINE> search ( values , hp + 1 , vp , item ) <NEWLINE> search ( values , hp , vp - 1 , item ) <NEWLINE> search ( values , hp , vp + 1 , item ) <NEWLINE> <NL> <DEDENT> def solve ( values ) : <NEWLINE> <INDENT> count , valid_items = 0 , set ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for i in range ( len ( values ) ) : <NEWLINE> <INDENT> for j in range ( len ( values [ i ] ) ) : <NEWLINE> <INDENT> if values [ i ] [ j ] in valid_items : <NEWLINE> <INDENT> search ( values , i , j , values [ i ] [ j ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> line = input ( ) . strip ( ) <NEWLINE> while line != <STRING> : <NEWLINE> <INDENT> H , W = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> values . append ( list ( list ( input ( ) . strip ( ) ) for _ in range ( H ) ) ) <NEWLINE> line = input ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def f ( y , x , c0 ) : <NEWLINE> <INDENT> global A <NEWLINE> c = A [ y ] [ x ] <NEWLINE> if c == <STRING> or c != c0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ y ] [ x ] = <STRING> <NEWLINE> for i , j in [ [ 0 , - 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 1 , 0 ] ] : <NEWLINE> <INDENT> f ( y + i , x + j , c0 ) <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> A = [ [ <STRING> for _ in range ( W + 2 ) ] for _ in range ( H + 2 ) ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> A [ i + 1 ] [ 1 : W + 1 ] = list ( raw_input ( ) ) <NEWLINE> <DEDENT> c = 0 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> c += f ( i , j , A [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> <NL> def search ( values , hp , vp , item ) : <NEWLINE> <INDENT> if not ( 0 <= hp < len ( values ) ) : return <NEWLINE> if not ( 0 <= vp < len ( values [ hp ] ) ) : return <NEWLINE> if item != values [ hp ] [ vp ] : return <NEWLINE> values [ hp ] [ vp ] = True <NEWLINE> for dh , dv in list ( [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ) : <NEWLINE> <INDENT> search ( values , hp + dh , vp + dv , item ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def solve ( values ) : <NEWLINE> <INDENT> count , valid_items = 0 , set ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for i in range ( len ( values ) ) : <NEWLINE> <INDENT> for j in range ( len ( values [ i ] ) ) : <NEWLINE> <INDENT> if values [ i ] [ j ] in valid_items : <NEWLINE> <INDENT> search ( values , i , j , values [ i ] [ j ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> line = input ( ) . strip ( ) <NEWLINE> while line != <STRING> : <NEWLINE> <INDENT> H , W = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> values = list ( ) <NEWLINE> for _ in range ( H ) : <NEWLINE> <INDENT> values . append ( list ( input ( ) . strip ( ) ) ) <NEWLINE> <DEDENT> print ( solve ( values ) ) <NEWLINE> line = input ( ) . strip ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( c , h , w ) : <NEWLINE> <INDENT> if A [ h ] [ w ] == c : <NEWLINE> <INDENT> A [ h ] [ w ] = <STRING> <NEWLINE> for dx , dy in zip ( ( 1 , - 1 , 0 , 0 ) , ( 0 , 0 , 1 , - 1 ) ) : <NEWLINE> <INDENT> if 0 <= h + dh < H and 0 <= w + dw < W : <NEWLINE> <INDENT> solve ( c , h + dh , w + dw ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == W == 0 : break <NEWLINE> count = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if A [ h ] [ w ] != <STRING> : <NEWLINE> <INDENT> solve ( A [ h ] [ w ] , h , w ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
dxy = [ [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] ] <NEWLINE> field = [ ] <NEWLINE> H , W = 0 , 0 <NEWLINE> <NL> def solver ( x , y , symbol ) : <NEWLINE> <INDENT> global field , H , W <NEWLINE> if x < 0 or y < 0 or x >= H or y >= W : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for dx , dy in dxy : <NEWLINE> <INDENT> if x + dx < 0 or y + dy < 0 or x + dx >= H or y + dy >= W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ x + dx ] [ y + dy ] == symbol : <NEWLINE> <INDENT> field [ x + dx ] [ y + dy ] = <STRING> <NEWLINE> solver ( x + dx , y + dy , symbol ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if H == 0 and W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ list ( raw_input ( ) ) for i in range ( H ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for x in xrange ( H ) : <NEWLINE> <INDENT> for y in xrange ( W ) : <NEWLINE> <INDENT> if field [ x ] [ y ] != <STRING> : <NEWLINE> <INDENT> solver ( x , y , field [ x ] [ y ] ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> <NL> def process ( ) : <NEWLINE> <INDENT> for data in get_dataset ( ) : <NEWLINE> <INDENT> H = int ( data ) <NEWLINE> W = int ( data [ 0 ] ) <NEWLINE> field = create_field ( H , W ) <NEWLINE> print search ( H , W , data , field ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def search ( H , W , data , field ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in xrange ( H ) : <NEWLINE> <INDENT> for j in xrange ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> _search ( i , j , H , W , data [ i ] [ j ] , data , field ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> def _search ( i , j , H , W , cell , data , field ) : <NEWLINE> <INDENT> field [ i ] [ j ] = 0 <NEWLINE> for a in xrange ( i - 1 , i + 2 ) : <NEWLINE> <INDENT> if - 1 < a < H : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for b in xrange ( j - 1 , j + 2 ) : <NEWLINE> <INDENT> if - 1 < b < W : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if a != i and b != j : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if field [ a ] [ b ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cell == data [ a ] [ b ] : <NEWLINE> <INDENT> _search ( a , b , H , W , cell , data , field ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def create_field ( H , W ) : <NEWLINE> <INDENT> field = [ ] <NEWLINE> for i in xrange ( H ) : <NEWLINE> <INDENT> raw = [ ] <NEWLINE> for j in xrange ( W ) : <NEWLINE> <INDENT> raw . append ( 1 ) <NEWLINE> <DEDENT> field . append ( raw ) <NEWLINE> <DEDENT> return field <NEWLINE> <NL> <NL> <DEDENT> def get_dataset ( ) : <NEWLINE> <INDENT> dataset = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> data = get_data ( ) <NEWLINE> if data : <NEWLINE> <INDENT> dataset . append ( data ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return dataset <NEWLINE> <NL> <NL> <DEDENT> def get_data ( ) : <NEWLINE> <INDENT> line = raw_input ( ) . rstrip ( ) . split ( ) <NEWLINE> H = int ( line [ 0 ] ) <NEWLINE> data = [ ] <NEWLINE> for i in xrange ( H ) : <NEWLINE> <INDENT> data . append ( raw_input ( ) . rstrip ( ) ) <NEWLINE> <DEDENT> zero = raw_input ( ) <NEWLINE> return data <NEWLINE> <NL> <DEDENT> process ( ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> <NL> def process ( ) : <NEWLINE> <INDENT> for data in get_dataset ( ) : <NEWLINE> <INDENT> H = len ( data ) <NEWLINE> W = len ( data [ 0 ] ) <NEWLINE> field = create_field ( H , W ) <NEWLINE> print search ( H , W , data , field ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def search ( H , W , data , field ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in xrange ( H ) : <NEWLINE> <INDENT> for j in xrange ( W ) : <NEWLINE> <INDENT> if field [ i ] [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> _search ( i , j , H , W , data [ i ] [ j ] , data , field ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> def _search ( i , j , H , W , cell , data , field ) : <NEWLINE> <INDENT> field [ i ] [ j ] = 0 <NEWLINE> for a in xrange ( i - 1 , i + 2 ) : <NEWLINE> <INDENT> if - 1 < a < H : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for b in xrange ( j - 1 , j + 2 ) : <NEWLINE> <INDENT> if - 1 < b < W : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if a != i and b != j : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if field [ a ] [ b ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cell == data [ a ] [ b ] : <NEWLINE> <INDENT> _search ( a , b , H , W , cell , data , field ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def create_field ( H , W ) : <NEWLINE> <INDENT> field = [ ] <NEWLINE> for i in xrange ( H ) : <NEWLINE> <INDENT> raw = [ ] <NEWLINE> for j in xrange ( W ) : <NEWLINE> <INDENT> raw . append ( 1 ) <NEWLINE> <DEDENT> field . append ( raw ) <NEWLINE> <DEDENT> return field <NEWLINE> <NL> <NL> <DEDENT> def get_dataset ( ) : <NEWLINE> <INDENT> dataset = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) . rstrip ( ) . split ( ) <NEWLINE> H = int ( line [ 0 ] ) <NEWLINE> if H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> data = [ ] <NEWLINE> for i in xrange ( H ) : <NEWLINE> <INDENT> data . append ( raw_input ( ) . rstrip ( ) ) <NEWLINE> <DEDENT> dataset . append ( data ) <NEWLINE> <DEDENT> return dataset <NEWLINE> <NL> <DEDENT> process ( ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> matrix = [ ] <NEWLINE> vec = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> visited = [ ] <NEWLINE> h = 0 <NEWLINE> w = 0 <NEWLINE> <NL> def dfs ( x , y , fruit ) : <NEWLINE> <INDENT> global visited <NEWLINE> visited . append ( ( x , y ) ) <NEWLINE> for v in vec : <NEWLINE> <INDENT> nx = x + v [ 0 ] <NEWLINE> ny = y + v [ 1 ] <NEWLINE> if ( not ( nx , ny ) in visited ) and nx in xrange ( w ) and ny in xrange ( h ) : <NEWLINE> <INDENT> if matrix [ ny ] [ nx ] == fruit : <NEWLINE> <INDENT> dfs ( nx , ny , fruit ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> matrix = [ ] <NEWLINE> visited = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> s = raw_input ( ) . rstrip ( ) <NEWLINE> matrix . append ( list ( s ) ) <NEWLINE> <DEDENT> for i in xrange ( h ) : <NEWLINE> <INDENT> for j in xrange ( w ) : <NEWLINE> <INDENT> if not ( j , i ) in visited : <NEWLINE> <INDENT> dfs ( j , i , matrix [ i ] [ j ] ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> matrix = [ ] <NEWLINE> vec = [ [ 1 , 0 ] , [ - 1 , 0 ] , [ 0 , 1 ] , [ 0 , - 1 ] ] <NEWLINE> visited = [ ] <NEWLINE> h = 0 <NEWLINE> w = 0 <NEWLINE> <NL> def dfs ( x , y , fruit ) : <NEWLINE> <COMMENT> <NL> <INDENT> visited [ y ] [ x ] = 1 <NEWLINE> for v in vec : <NEWLINE> <INDENT> nx = x + v [ 0 ] <NEWLINE> ny = y + v [ 1 ] <NEWLINE> if nx in xrange ( w ) and ny in xrange ( h ) : <NEWLINE> <INDENT> if visited [ ny ] [ nx ] == 0 and matrix [ ny ] [ nx ] == fruit : <NEWLINE> <INDENT> dfs ( nx , ny , fruit ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <DEDENT> matrix = [ ] <NEWLINE> visited = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> s = raw_input ( ) . rstrip ( ) <NEWLINE> matrix . append ( list ( s ) ) <NEWLINE> visited . append ( [ 0 ] * w ) <NEWLINE> <DEDENT> for i in xrange ( h ) : <NEWLINE> <INDENT> for j in xrange ( w ) : <NEWLINE> <COMMENT> <NL> <INDENT> if visited [ i ] [ j ] == 0 : <NEWLINE> <INDENT> dfs ( j , i , matrix [ i ] [ j ] ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
def solve ( a , M ) : <NEWLINE> <INDENT> for x , y in xy : <NEWLINE> <INDENT> if x in a and ( y not in a or a . index ( x ) > a . index ( y ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( a ) == m : return a <NEWLINE> return max ( [ solve ( [ M [ i ] ] + a , M [ : i ] + M [ i + 1 : ] ) for i in range ( len ( M ) ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> m = input ( ) <NEWLINE> xy = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( input ( ) ) ] <NEWLINE> M = range ( m ) <NEWLINE> ans = solve ( [ ] , range ( 1 , m + 1 ) ) <NEWLINE> for i in ans : print i <NEWLINE>
import math <NEWLINE> while True : <NEWLINE> <INDENT> l = 0 ; r = [ ] <NEWLINE> try : <NEWLINE> <INDENT> inp = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l = inp [ 0 ] <NEWLINE> r = inp [ 1 : ] <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = len ( r ) <NEWLINE> if 2 * sum ( r ) <= l : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r . sort ( ) <NEWLINE> s = [ ] <NEWLINE> for i in xrange ( n / 2 ) : <NEWLINE> <INDENT> s = [ r [ i ] ] + s [ : : - 1 ] + [ r [ - i - 1 ] ] <NEWLINE> <DEDENT> if n & 1 : <NEWLINE> <INDENT> if abs ( s [ 0 ] - r [ n / 2 ] ) < abs ( s [ - 1 ] - r [ n / 2 ] ) : <NEWLINE> <INDENT> s . append ( r [ n / 2 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = [ r [ n / 2 ] ] + s <NEWLINE> <DEDENT> <DEDENT> ans = s [ 0 ] + s [ - 1 ] <NEWLINE> for i in xrange ( n - 1 ) : <NEWLINE> <INDENT> ans += 2 * math . sqrt ( s [ i ] * s [ i + 1 ] ) <NEWLINE> <DEDENT> print <STRING> if ans < 0.000000001 + l else <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys , itertools <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> a = map ( int , s . split ( <STRING> ) ) <NEWLINE> w = a [ 0 ] <NEWLINE> n = len ( a ) - 1 <NEWLINE> A = itertools . permutations ( a [ 1 : ] , n ) <NEWLINE> s0 = 1e9 <NEWLINE> for e in A : <NEWLINE> <INDENT> s = e [ 0 ] + e [ - 1 ] <NEWLINE> for i in range ( n - 1 ) : s += 2 * ( e [ i ] * e [ i + 1 ] ) ** .5 <NEWLINE> if s < s0 : s0 = s <NEWLINE> if s0 <= w : break <NEWLINE> <DEDENT> print [ <STRING> , <STRING> ] [ s0 > w ] <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import copy <NEWLINE> <NL> swap = [ [ 1 , 4 ] , [ 0 , 2 , 5 ] , [ 1 , 3 , 6 ] , [ 2 , 7 ] , [ 0 , 5 ] , [ 1 , 4 , 6 ] , [ 2 , 5 , 7 ] , [ 3 , 6 ] ] <NEWLINE> <NL> <NL> def bfs ( ) : <NEWLINE> <INDENT> ia = list ( range ( 8 ) ) <NEWLINE> count = { str ( ia ) : 0 } <NEWLINE> que = deque ( ) <NEWLINE> que . append ( ( ia , 0 ) ) <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> state , cnt = que . popleft ( ) <NEWLINE> <COMMENT> <NL> pos = state . index ( 0 ) <NEWLINE> swap_target = swap [ pos ] <NEWLINE> for i in swap_target : <NEWLINE> <INDENT> tmp_state = copy . copy ( state ) <NEWLINE> tmp_state [ i ] , tmp_state [ pos ] = tmp_state [ pos ] , tmp_state [ i ] <NEWLINE> if str ( tmp_state ) not in count : <NEWLINE> <INDENT> count [ str ( tmp_state ) ] = cnt + 1 <NEWLINE> que . append ( ( tmp_state , cnt + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> count = bfs ( ) <NEWLINE> while True : <NEWLINE> <INDENT> prob = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( count [ str ( prob ) ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> memo = { } <NEWLINE> sys . setrecursionlimit ( 40320 ) <NEWLINE> def swap ( state , a , b ) : <NEWLINE> <INDENT> state [ a ] , state [ b ] = state [ b ] , state [ a ] <NEWLINE> <DEDENT> def dfs ( state , pos , c ) : <NEWLINE> <INDENT> key = <STRING> . join ( map ( str , state ) ) <NEWLINE> if memo . has_key ( key ) : <NEWLINE> <INDENT> return memo [ key ] <NEWLINE> <DEDENT> memo [ key ] = c <NEWLINE> if pos != 0 and pos != 4 : <NEWLINE> <INDENT> swap ( state , pos - 1 , pos ) <NEWLINE> dfs ( state , pos - 1 , c + 1 ) <NEWLINE> swap ( state , pos - 1 , pos ) <NEWLINE> <DEDENT> if pos != 3 and pos != 7 : <NEWLINE> <INDENT> swap ( state , pos + 1 , pos ) <NEWLINE> dfs ( state , pos + 1 , c + 1 ) <NEWLINE> swap ( state , pos + 1 , pos ) <NEWLINE> <DEDENT> if pos < 4 : <NEWLINE> <INDENT> swap ( state , pos + 4 , pos ) <NEWLINE> dfs ( state , pos + 4 , c + 1 ) <NEWLINE> swap ( state , pos + 4 , pos ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> swap ( state , pos - 4 , pos ) <NEWLINE> dfs ( state , pos - 4 , c + 1 ) <NEWLINE> swap ( state , pos - 4 , pos ) <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> dfs ( range ( 8 ) , 0 , 0 ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> state = raw_input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> print memo [ state ] <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> except IOError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def fun ( f , i , sw ) : <NEWLINE> <INDENT> ret = [ ] <NEWLINE> for s in sw : <NEWLINE> <INDENT> ii , ss = min ( i , s ) , max ( i , s ) <NEWLINE> ret . append ( f [ : ii ] + f [ ss ] + f [ ii + 1 : ss ] + f [ ii ] + f [ ss + 1 : ] ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> swaplist = [ [ 1 , 4 ] , [ 0 , 2 , 5 ] , [ 1 , 3 , 6 ] , [ 2 , 7 ] , [ 0 , 5 ] , [ 4 , 6 , 1 ] , [ 5 , 7 , 2 ] , [ 6 , 3 ] ] <NEWLINE> A = { } <NEWLINE> A [ 1234567 ] = 0 <NEWLINE> ks = [ 1234567 ] <NEWLINE> F = [ <STRING> ] <NEWLINE> n = 0 <NEWLINE> while len ( F ) != 0 : <NEWLINE> <INDENT> NF = [ ] <NEWLINE> n += 1 <NEWLINE> for f in F : <NEWLINE> <INDENT> i = f . index ( <STRING> ) <NEWLINE> sw = swaplist [ i ] <NEWLINE> for g in fun ( f , i , sw ) : <NEWLINE> <INDENT> if int ( g ) not in ks : <NEWLINE> <INDENT> A [ int ( g ) ] = n <NEWLINE> ks . append ( int ( g ) ) <NEWLINE> NF . append ( g ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> F = NF [ : ] <NEWLINE> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print A [ int ( <STRING> . join ( raw_input ( ) . split ( ) ) ) ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
class Puzzle : <NEWLINE> <INDENT> def __init__ ( self , panel , space , cnt ) : <NEWLINE> <INDENT> self . panel = panel <NEWLINE> self . space = space <NEWLINE> self . cnt = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> d = ( 1 , - 1 , 4 , - 4 ) <NEWLINE> model = map ( str , range ( 8 ) ) <NEWLINE> def check ( s ) : <NEWLINE> <INDENT> if s == model : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def bfs ( s ) : <NEWLINE> <INDENT> m = set ( ) <NEWLINE> que = [ s ] <NEWLINE> m . add ( tuple ( s . panel ) ) <NEWLINE> while que != [ ] : <NEWLINE> <INDENT> now = que [ 0 ] <NEWLINE> del que [ 0 ] <NEWLINE> if check ( now . panel ) : <NEWLINE> <INDENT> return now . cnt <NEWLINE> <DEDENT> idx1 = now . space <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> idx2 = idx1 + d [ i ] <NEWLINE> if idx2 < 0 or idx2 > 7 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if ( idx1 == 3 and d [ i ] == 1 ) or ( idx1 == 4 and d [ i ] == - 1 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_panel = now . panel [ : ] <NEWLINE> next_panel [ idx2 ] , next_panel [ idx1 ] = now . panel [ idx1 ] , now . panel [ idx2 ] <NEWLINE> next = Puzzle ( next_panel , idx2 , now . cnt + 1 ) <NEWLINE> if tuple ( next . panel ) not in m : <NEWLINE> <INDENT> m . add ( tuple ( next . panel ) ) <NEWLINE> que . append ( next ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> panel = raw_input ( ) . split ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> space = panel . index ( <STRING> ) <NEWLINE> s = Puzzle ( panel , space , 0 ) <NEWLINE> ans = bfs ( s ) <NEWLINE> print ans <NEWLINE> <DEDENT>
from __future__ import division <NEWLINE> import sys <NEWLINE> if sys . version_info [ 0 ] >= 3 : raw_input = input <NEWLINE> <NL> X = 4 <NEWLINE> Y = 2 <NEWLINE> i = 0 <NEWLINE> m = { } <NEWLINE> prev = { } <NEWLINE> v = [ ] <NEWLINE> for i in range ( X * Y ) : v . append ( str ( i ) ) <NEWLINE> m [ <STRING> . join ( v ) ] = [ 0 , 0 ] <NEWLINE> prev [ <STRING> . join ( v ) ] = [ <STRING> . join ( v ) , None ] <NEWLINE> q = [ v ] <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> v = raw_input ( ) . split ( ) <NEWLINE> print ( m [ <STRING> . join ( v ) ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> MOVE = [ [ 1 , 4 ] , [ 0 , 2 , 5 ] , [ 1 , 3 , 6 ] , [ 2 , 7 ] , [ 0 , 5 ] , [ 1 , 4 , 6 ] , [ 2 , 5 , 7 ] , [ 3 , 6 ] ] <NEWLINE> GOAL = <STRING> <NEWLINE> def h ( field ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for p , n in enumerate ( map ( int , field ) ) : <NEWLINE> <INDENT> ret += dist ( p , n ) <NEWLINE> <DEDENT> return ret <NEWLINE> <DEDENT> def dist ( num , place ) : <NEWLINE> <INDENT> return abs ( num % 4 - place % 4 ) + ( num / 5 + place / 5 ) % 2 <COMMENT> <NEWLINE> <DEDENT> def swap ( field , a , b ) : <NEWLINE> <INDENT> tmp = [ f for f in field ] <NEWLINE> tmp [ a ] , tmp [ b ] = tmp [ b ] , tmp [ a ] <NEWLINE> return <STRING> . join ( tmp ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> field = raw_input ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> hq = [ ] <NEWLINE> visited = { field : True } <NEWLINE> heappush ( hq , [ 0 , 0 , field ] ) <NEWLINE> while len ( hq ) != 0 : <NEWLINE> <INDENT> f , g , field = heappop ( hq ) <NEWLINE> if field == GOAL : <NEWLINE> <INDENT> print g <NEWLINE> break <NEWLINE> <DEDENT> a = field . find ( <STRING> ) <NEWLINE> for b in MOVE [ a ] : <NEWLINE> <INDENT> tmp = swap ( field , a , b ) <NEWLINE> if tmp not in visited : <NEWLINE> <INDENT> visited [ tmp ] = True <NEWLINE> heappush ( hq , [ h ( field ) + g , g + 1 , tmp ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> v = raw_input ( ) . split ( ) <NEWLINE> print ( m [ <STRING> . join ( v ) ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <STRING> <NEWLINE>
def phyonkichi ( p , n ) : <NEWLINE> <INDENT> yoko = 0 <NEWLINE> tate = 1 <NEWLINE> if n [ - 1 ] == <STRING> : <NEWLINE> <INDENT> n = 10 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( n [ - 1 ] ) <NEWLINE> <DEDENT> s = dic [ n ] <NEWLINE> p_lis = [ ( p [ yoko ] + a [ yoko ] , p [ tate ] + a [ tate ] ) for a in jump ] <NEWLINE> s_lis = [ ( s [ yoko ] + a [ yoko ] , s [ tate ] + a [ tate ] ) for a in sprinkler ] <NEWLINE> c_lis = [ ] <NEWLINE> for v in list ( set ( p_lis ) & set ( s_lis ) ) : <NEWLINE> <INDENT> if 0 <= v [ yoko ] <= 9 and 0 <= v [ tate ] <= 9 : <NEWLINE> <INDENT> c_lis . append ( v ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not c_lis : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> for v in c_lis : <NEWLINE> <INDENT> if not v in res : <NEWLINE> <INDENT> res . append ( v ) <NEWLINE> if phyonkichi ( v , str ( n + 1 ) ) : return True <NEWLINE> del res [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print v , res <NEWLINE> print <STRING> <NEWLINE> return True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> jump = [ ( 2 , - 1 ) , ( 2 , 0 ) , ( 2 , 1 ) , <NEWLINE> <INDENT> ( - 1 , - 2 ) , ( 0 , - 2 ) , ( 1 , - 2 ) , <NEWLINE> ( - 2 , 1 ) , ( - 2 , 0 ) , ( - 2 , - 1 ) , <NEWLINE> ( - 1 , 2 ) , ( 0 , 2 ) , ( 1 , 2 ) ] <NEWLINE> <NL> <DEDENT> sprinkler = [ ( 0 , 0 ) , ( 1 , 0 ) , ( 1 , - 1 ) , <NEWLINE> <INDENT> ( 0 , - 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , <NEWLINE> ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if w == 0 and h == 0 : break <NEWLINE> N = int ( raw_input ( ) ) <NEWLINE> lis = raw_input ( ) . split ( <STRING> ) <NEWLINE> c_lis = [ lis [ i : i + 2 ] for i in range ( 0 , 20 , 2 ) ] <NEWLINE> dic = { } <NEWLINE> res = [ ] <NEWLINE> for i , c in enumerate ( c_lis ) : <NEWLINE> <INDENT> dic [ i + 1 ] = ( int ( c [ 0 ] ) , int ( c [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not phyonkichi ( ( w , h ) , <STRING> ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> def check ( here , count ) : <NEWLINE> <INDENT> return ( ( abs ( here [ 0 ] - s [ count ] [ 0 ] ) ) ** 2 + ( abs ( here [ 1 ] - s [ count ] [ 1 ] ) ) ** 2 <= 2 ) <NEWLINE> <NL> <DEDENT> def dfs ( here , count ) : <NEWLINE> <INDENT> if count == 10 : <NEWLINE> <INDENT> result = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = False <NEWLINE> for dx , dy in delta : <NEWLINE> <INDENT> next = ( here [ 0 ] + dx , here [ 1 ] + dy ) <NEWLINE> if lb [ 0 ] <= next [ 0 ] <= ub [ 0 ] and lb [ 1 ] <= next [ 1 ] <= ub [ 1 ] and check ( next , count ) : <NEWLINE> <INDENT> result |= dfs ( next , count + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <DEDENT> delta = ( ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , - 1 ) , ( 0 , 2 ) , ( 1 , 2 ) , ( - 1 , 2 ) , <NEWLINE> <INDENT> ( - 2 , 0 ) , ( - 2 , 1 ) , ( - 2 , - 1 ) , ( 0 , - 2 ) , ( 1 , - 2 ) , ( - 1 , - 2 ) ) <NEWLINE> <NL> <DEDENT> sys . setrecursionlimit = 1000000 <NEWLINE> lb = ( 0 , 0 ) <NEWLINE> ub = ( 9 , 9 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> here = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if here == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> s = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> s = [ ( s [ i * 2 ] , s [ i * 2 + 1 ] ) for i in range ( n ) ] <NEWLINE> if dfs ( here , 0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
mv = ( ( 2 , 0 ) , ( 2 , 1 ) , ( 2 , - 1 ) , ( - 2 , 0 ) , ( - 2 , 1 ) , ( - 2 , - 1 ) , <NEWLINE> <INDENT> ( 0 , 2 ) , ( 1 , 2 ) , ( - 1 , 2 ) , ( 0 , - 2 ) , ( 1 , - 2 ) , ( - 1 , - 2 ) ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == y == 0 : break <NEWLINE> n = input ( ) <NEWLINE> pos = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> pos = [ ( pos [ 2 * i ] , pos [ 2 * i + 1 ] ) for i in range ( n ) ] <NEWLINE> <NL> que = [ ( x , y , 0 ) ] <NEWLINE> while que != [ ] : <NEWLINE> <INDENT> X , Y , p = que [ 0 ] [ 0 ] , que [ 0 ] [ 1 ] , que [ 0 ] [ 2 ] <NEWLINE> del que [ 0 ] <NEWLINE> S = set ( ) <NEWLINE> if p >= 10 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> for k in range ( - 1 , 2 ) : <NEWLINE> <INDENT> for l in range ( - 1 , 2 ) : <NEWLINE> <INDENT> S . add ( ( pos [ p ] [ 0 ] + k , pos [ p ] [ 1 ] + l , p + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> for dx , dy in mv : <NEWLINE> <INDENT> mx = X + dx <NEWLINE> my = Y + dy <NEWLINE> if 0 <= mx < 10 and 0 <= my < 10 and ( mx , my , p + 1 ) in S : <NEWLINE> <INDENT> que . append ( ( mx , my , p + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
b = False <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> d = dict ( ) <NEWLINE> if b : print ( ) <NEWLINE> b = True <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> tmp = int ( line [ 1 ] ) * 3 + int ( line [ 3 ] * 1 ) <NEWLINE> if tmp in d : <NEWLINE> <INDENT> d [ tmp ] . append ( line [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ tmp ] = [ ] <NEWLINE> d [ tmp ] . append ( line [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> for k , vs in sorted ( d . items ( ) , key = lambda x : x [ 0 ] ) [ : : - 1 ] : <NEWLINE> <INDENT> for v in vs : <NEWLINE> <INDENT> print ( <STRING> % ( k , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> m = [ raw_input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> p = { } <NEWLINE> for t in m : <NEWLINE> <INDENT> p [ t [ 0 ] ] = 3 * int ( t [ 1 ] ) + 1 * int ( t [ 3 ] ) <NEWLINE> <DEDENT> for k , v in sorted ( p . items ( ) , key = lambda x : x [ 1 ] ) [ : : - 1 ] : <NEWLINE> <INDENT> print <STRING> % ( k , v ) <NEWLINE> <DEDENT> c += 1 <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> print <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> dic = { } <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lis = raw_input ( ) . split ( ) <NEWLINE> dic [ lis [ 0 ] ] = [ 3 * int ( lis [ 1 ] ) + int ( lis [ 3 ] ) , N - i ] <NEWLINE> <NL> <DEDENT> for k , v in sorted ( dic . items ( ) , key = lambda x : ( x [ 0 ] [ 0 ] , x [ 0 ] [ 1 ] ) , reverse = True ) : <NEWLINE> <INDENT> print <STRING> % ( k , v [ 0 ] ) <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> if N == 0 : break <NEWLINE> print <STRING> <NEWLINE> <DEDENT>
M = [ 0 , 1 , - 1 , 0 , 0 , 1 , 1 , 2 , 3 , 3 , 4 , 4 ] <NEWLINE> def L ( y , m ) : <NEWLINE> <INDENT> if m <= 2 : y -= 1 <NEWLINE> return y / 4 - y / 100 + y / 400 + M [ m ] <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> a , b , c , d , e , f = x = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if any ( [ i < 0 for i in x ] ) : break <NEWLINE> ans = ( d - a ) * 365 + ( e - b ) * 30 + f - c + L ( d , e ) - L ( a , b ) <NEWLINE> print ans <NEWLINE> <DEDENT>
def f ( A ) : return A . count ( a ) > 1 <NEWLINE> R = [ 0 , 3 , 6 ] <NEWLINE> N = range ( 9 ) <NEWLINE> Z = [ 0 ] * 9 <NEWLINE> <NL> n = input ( ) <NEWLINE> while n : <NEWLINE> <INDENT> F = [ [ <STRING> for _ in Z ] for _ in Z ] <NEWLINE> M = [ map ( int , raw_input ( ) . split ( ) ) for _ in Z ] <NEWLINE> M1 = [ [ M [ y ] [ x ] for y in N ] for x in N ] <NEWLINE> M2 = [ M [ y ] [ x : x + 3 ] + M [ y + 1 ] [ x : x + 3 ] + M [ y + 2 ] [ x : x + 3 ] for y in R for x in R ] <NEWLINE> for y in N : <NEWLINE> <INDENT> p0 = y / 3 * 3 <NEWLINE> for x in N : <NEWLINE> <INDENT> a = M [ y ] [ x ] <NEWLINE> if any ( map ( f , [ M [ y ] , M1 [ x ] , M2 [ p0 + x / 3 ] ] ) ) : F [ y ] [ x ] = <STRING> <NEWLINE> <DEDENT> print <STRING> . join ( [ a + b for a , b in zip ( F [ y ] , map ( str , A ) ) ] ) <NEWLINE> <DEDENT> if n > 1 : print <NEWLINE> n -= 1 <NEWLINE> <DEDENT>
import itertools <NEWLINE> dic = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> cnt = ord ( <STRING> ) <NEWLINE> for i in itertools . product ( range ( 1 , 6 ) , repeat = 2 ) : <NEWLINE> <INDENT> dic [ <STRING> . join ( map ( str , i ) ) ] = chr ( cnt ) <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( s ) % 2 != 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> . join ( dic [ s [ i : i + 2 ] ] for i in range ( 0 , len ( s ) , 2 ) ) <NEWLINE> <DEDENT> <DEDENT>
from sys import stdout <NEWLINE> <NL> cs = { <NEWLINE> <INDENT> 1 : [ None ] + list ( <STRING> ) , <NEWLINE> 2 : [ None ] + list ( <STRING> ) , <NEWLINE> 3 : [ None ] + list ( <STRING> ) , <NEWLINE> 4 : [ None ] + list ( <STRING> ) , <NEWLINE> 5 : [ None ] + list ( <STRING> ) , <NEWLINE> 6 : [ None ] + list ( <STRING> ) , <NEWLINE> <DEDENT> } <NEWLINE> <NL> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> it = iter ( raw_input ( ) . strip ( ) ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> r = c = None <NEWLINE> s = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> r = int ( it . next ( ) ) <NEWLINE> c = int ( it . next ( ) ) <NEWLINE> s += [ cs [ r ] [ c ] ] <NEWLINE> r = c = None <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> except StopIteration : <NEWLINE> <INDENT> if not r and not c : <NEWLINE> <INDENT> stdout . write ( <STRING> . join ( s ) + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stdout . write ( <STRING> ) <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> <DEDENT>
decode = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if len ( line ) % 2 == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> print <STRING> . join ( decode [ j - 1 ] [ i - 1 ] <NEWLINE> <INDENT> for i , j in zip ( map ( int , line [ : : 2 ] ) , map ( int , line [ 1 : : 2 ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> except KeyError : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
s = <STRING> <NEWLINE> d = { } <NEWLINE> for y in range ( 1 , 7 ) : <NEWLINE> <INDENT> for t in range ( 1 , 6 ) : <NEWLINE> <INDENT> d [ ( str ( y ) , str ( t ) ) ] = s [ 0 ] <NEWLINE> s = s [ 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if len ( line ) == 0 or len ( line ) % 2 != 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> for i in range ( 0 , len ( line ) , 2 ) : <NEWLINE> <INDENT> if d [ ( line [ i ] , line [ i + 1 ] ) ] : <NEWLINE> <INDENT> ans += d [ ( line [ i ] , line [ i + 1 ] ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ans <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = raw_input ( ) . zfill ( 5 ) <NEWLINE> for i in xrange ( 2 ) : <NEWLINE> <INDENT> print <STRING> . join ( [ <STRING> if int ( n [ j ] ) - 5 * i in range ( 5 ) else <STRING> for j in xrange ( 5 ) ] ) <NEWLINE> <DEDENT> print <STRING> * 5 <NEWLINE> for i in xrange ( 5 ) : <NEWLINE> <INDENT> print <STRING> . join ( [ <STRING> if ( int ( n [ j ] ) % 5 ) == i else <STRING> for j in xrange ( 5 ) ] ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from sys import stdout <NEWLINE> <NL> <NL> def upper ( n ) : <NEWLINE> <INDENT> if n < 5 : <NEWLINE> <INDENT> return [ <STRING> , <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return [ <STRING> , <STRING> ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def lower ( n ) : <NEWLINE> <INDENT> m = n % 5 <NEWLINE> return [ <STRING> ] * m + [ <STRING> ] + [ <STRING> ] * ( 4 - m ) <NEWLINE> <NL> <NL> <DEDENT> def abacus ( n ) : <NEWLINE> <INDENT> return upper ( n ) + [ <STRING> ] + lower ( n ) <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ns = map ( int , ( <STRING> + raw_input ( ) . strip ( ) ) [ - 5 : ] ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ab = [ ] <NEWLINE> for n in ns : <NEWLINE> <INDENT> ab . append ( abacus ( n ) ) <NEWLINE> <NL> <DEDENT> res = [ ] <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> for j in range ( 5 ) : <NEWLINE> <INDENT> res . append ( ab [ j ] [ i ] ) <NEWLINE> <DEDENT> res . append ( <STRING> ) <NEWLINE> <DEDENT> res . append ( <STRING> ) <NEWLINE> <NL> stdout . write ( <STRING> . join ( res [ : - 1 ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> d = { } <NEWLINE> B1 = [ <STRING> , <STRING> ] <NEWLINE> B2 = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> f = 0 <NEWLINE> for i in range ( 9 ) : d [ str ( i ) ] = B1 [ i / 5 ] + B2 [ i % 5 ] <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> A = [ d [ e ] for e in ( <STRING> * 5 + s [ : - 1 ] ) [ - 5 : ] ] <NEWLINE> if f : print <NEWLINE> for y in range ( 8 ) : print <STRING> . join ( [ A [ x ] [ y ] for x in range ( len ( A ) ) ] ) <NEWLINE> f = 1 <NEWLINE> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> d = [ [ <STRING> for i in range ( 8 ) ] for j in range ( 5 ) ] <NEWLINE> try : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> while len ( n ) < 5 : <NEWLINE> <INDENT> n = <STRING> + n <NEWLINE> <DEDENT> for i in range ( len ( n ) ) : <NEWLINE> <INDENT> if ( int ( n [ i ] ) <= 4 ) : <NEWLINE> <INDENT> d [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> if ( int ( n [ i ] ) >= 5 ) : <NEWLINE> <INDENT> d [ i ] [ 1 ] = <STRING> <NEWLINE> <DEDENT> d [ i ] [ 2 ] = <STRING> <NEWLINE> if ( int ( n [ i ] ) != 0 and int ( n [ i ] ) != 5 ) : <NEWLINE> <INDENT> d [ i ] [ 3 ] = <STRING> <NEWLINE> <DEDENT> if ( int ( n [ i ] ) != 1 and int ( n [ i ] ) != 6 ) : <NEWLINE> <INDENT> d [ i ] [ 4 ] = <STRING> <NEWLINE> <DEDENT> if ( int ( n [ i ] ) != 2 and int ( n [ i ] ) != 7 ) : <NEWLINE> <INDENT> d [ i ] [ 5 ] = <STRING> <NEWLINE> <DEDENT> if ( int ( n [ i ] ) != 3 and int ( n [ i ] ) != 8 ) : <NEWLINE> <INDENT> d [ i ] [ 6 ] = <STRING> <NEWLINE> <DEDENT> if ( int ( n [ i ] ) != 4 and int ( n [ i ] ) != 9 ) : <NEWLINE> <INDENT> d [ i ] [ 7 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for i in range ( 8 ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for j in range ( 5 ) : <NEWLINE> <INDENT> s += d [ j ] [ i ] <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
d = { <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> } <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = <STRING> * ( 5 - len ( s ) ) + s <NEWLINE> for i in range ( 8 ) : <NEWLINE> <INDENT> print <STRING> . join ( d [ c ] [ i ] for c in s ) <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def f ( ) : <NEWLINE> <INDENT> x = 0 ; y = 1 ; r = 2 <NEWLINE> for w in L_w : <NEWLINE> <INDENT> A = ( tx - w [ x ] ) ** 2 + ( ty - w [ y ] ) ** 2 - w [ r ] ** 2 <NEWLINE> B = ( sx - w [ x ] ) ** 2 + ( sy - w [ y ] ) ** 2 - w [ r ] ** 2 <NEWLINE> if 0 < A and 0 < B and ( tx - w [ w ] ) * ( sx - w [ x ] ) < 0 : <NEWLINE> <INDENT> P = abs ( ( sy - ty ) * w [ x ] - ( sx - tx ) * w [ y ] - ( sy - ty ) * tx + ty ) <NEWLINE> Q = math . sqrt ( ( sy - ty ) ** 2 + ( sx - tx ) ** 2 ) <NEWLINE> print ( float ( P ) / Q ) <NEWLINE> if ( float ( P ) / Q ) <= w [ r ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif A * B < 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> if N == 0 : break <NEWLINE> L_w = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> tx , ty , sx , sy = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> f ( ) <NEWLINE> <DEDENT> <DEDENT>
import math as M <NEWLINE> def R ( A ) : return ( A [ 0 ] ** 2 + A [ 1 ] ** 2 ) ** .5 <NEWLINE> def I ( i ) : return [ map ( int , raw_input ( ) . split ( ) ) for _ in [ 0 ] * i ] <NEWLINE> def C ( a , b ) : return a > b or abs ( a - b ) < 1e-6 <NEWLINE> def f ( e1 ) : <NEWLINE> <INDENT> tx , ty , sx , sy = e1 <NEWLINE> x = [ ] <NEWLINE> for e2 in WP : <NEWLINE> <INDENT> wx , wy , r = e2 <NEWLINE> wt = [ tx - wx , ty - wy ] ; rwt = R ( wt ) <NEWLINE> sw = [ wx - sx , wy - sy ] ; rsw = R ( sw ) <NEWLINE> st = [ tx - sx , ty - sy ] ; rst = R ( st ) <NEWLINE> F = [ rwt < r , rsw < r ] <NEWLINE> if rst == 0 : c = 1 <NEWLINE> elif F == [ 1 , 1 ] : c = 1 <NEWLINE> elif F == [ 1 , 0 ] or F == [ 0 , 1 ] : c = 0 <NEWLINE> elif F == [ 0 , 0 ] : <NEWLINE> <INDENT> c = 0 <NEWLINE> a = M . pi / 2 - M . acos ( r / rsw ) <NEWLINE> b = M . acos ( ( sw [ 0 ] * st [ 0 ] + sw [ 1 ] * st [ 1 ] ) / rsw / rst ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> x . append ( c ) <NEWLINE> <DEDENT> return all ( x ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> WP = I ( n ) <NEWLINE> P = I ( input ( ) ) <NEWLINE> for e in P : print [ <STRING> , <STRING> ] [ f ( e ) ] <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> train = <STRING> <NEWLINE> seq = input ( ) <NEWLINE> for i in range ( 0 , len ( seq ) , 3 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> train += seq [ i ] <NEWLINE> <DEDENT> if seq [ i - 2 ] == <STRING> and train [ - 1 ] == seq [ i - 3 ] : <NEWLINE> <INDENT> train = train + seq [ i ] <NEWLINE> <DEDENT> if seq [ i - 2 ] == <STRING> and train [ 0 ] == seq [ i - 3 ] : <NEWLINE> <INDENT> train = seq [ i ] + train <NEWLINE> <DEDENT> <DEDENT> print ( train ) <NEWLINE> <NL> <DEDENT>
import math as M <NEWLINE> def R ( A ) : return ( A [ 0 ] ** 2 + A [ 1 ] ** 2 ) ** .5 <NEWLINE> def I ( i ) : return [ map ( int , raw_input ( ) . split ( ) ) for _ in [ 0 ] * i ] <NEWLINE> def f ( e1 ) : <NEWLINE> <INDENT> tx , ty , sx , sy = e1 <NEWLINE> x = [ ] <NEWLINE> st = [ tx - sx , ty - sy ] ; rst = R ( st ) <NEWLINE> for e2 in WP : <NEWLINE> <INDENT> wx , wy , r = e2 <NEWLINE> wt = [ tx - wx , ty - wy ] ; rwt = R ( wt ) <NEWLINE> sw = [ wx - sx , wy - sy ] ; rsw = R ( sw ) <NEWLINE> F = [ rwt < r , rsw < r ] <NEWLINE> if F == [ 1 , 0 ] or F == [ 0 , 1 ] : return 0 <NEWLINE> elif F == [ 0 , 0 ] : <NEWLINE> <INDENT> a = M . pi / 2 - M . acos ( r / rsw ) <NEWLINE> b = M . acos ( round ( ( sw [ 0 ] * st [ 0 ] + sw [ 1 ] * st [ 1 ] ) / rsw / rst , 4 ) ) <NEWLINE> if a + 1e-6 > b and rst ** 2 + 1e-6 > rsw ** 2 - r ** 2 : return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> WP = I ( n ) <NEWLINE> P = I ( input ( ) ) <NEWLINE> for e in P : print [ <STRING> , <STRING> ] [ f ( e ) ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from math import sqrt , acos , cos , sin , radians , degrees <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def solve ( time ) : <NEWLINE> <COMMENT> <NL> <INDENT> short_hand_angle = time [ 1 ] * - 6 + 90 <NEWLINE> x_s = cos ( radians ( short_hand_angle ) ) <NEWLINE> y_s = sin ( radians ( short_hand_angle ) ) <NEWLINE> <NL> long_hand_angle = ( time [ 0 ] * 60 + time [ 1 ] ) / ( 12 * 60 ) * - 360 + 90 <NEWLINE> x_l = cos ( radians ( long_hand_angle ) ) <NEWLINE> y_l = sin ( radians ( long_hand_angle ) ) <NEWLINE> c = ( x_s * x_l + y_s * y_l ) / ( sqrt ( x_s ** 2 + y_s ** 2 ) * sqrt ( x_l ** 2 + y_l ** 2 ) ) <NEWLINE> ans = degrees ( acos ( c ) ) <NEWLINE> <NL> if ans < 30 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif ans >= 90 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( args ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = 1 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> time = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> result = solve ( time ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
<NL> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h , m = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> sangle = 1.0 * 360 * ( h * 60 + m ) / 720 <NEWLINE> langle = 1.0 * 360 * m / 60 <NEWLINE> angle = abs ( sangle - langle ) <NEWLINE> if angle > 180 : <NEWLINE> <INDENT> angle = 360 - d <NEWLINE> <DEDENT> if ( 0 <= angle < 30 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ( 90 <= angle <= 180 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> hh , mm = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> angleh = ( 60 * hh + mm ) * 0.5 <NEWLINE> anglem = 6 * mm <NEWLINE> diff = math . abs ( angleh - anglem ) <NEWLINE> if 0 <= diff < 30 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif 90 <= diff <= 180 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> print sum ( [ int ( raw_input ( ) ) for i in range ( N ) ] ) / N <NEWLINE>
histo = [ <STRING> for i in range ( 6 ) ] <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h = float ( raw_input ( ) ) <NEWLINE> if h < 165.0 : <NEWLINE> <INDENT> histo [ 0 ] += <STRING> <NEWLINE> <DEDENT> elif h < 170.0 : <NEWLINE> <INDENT> histo [ 1 ] += <STRING> <NEWLINE> <DEDENT> elif h < 175.0 : <NEWLINE> <INDENT> histo [ 2 ] += <STRING> <NEWLINE> <DEDENT> elif h < 180.0 : <NEWLINE> <INDENT> histo [ 3 ] += <STRING> <NEWLINE> <DEDENT> elif h < 185.0 : <NEWLINE> <INDENT> histo [ 4 ] += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> histo [ 5 ] += <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 6 ) : <NEWLINE> <INDENT> print <STRING> % ( i , a [ i ] ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = int ( raw_input ( ) ) <NEWLINE> print <STRING> % ( i + 1 ) <NEWLINE> for j in range ( 10 ) : <NEWLINE> <INDENT> s = int ( str ( s ** 2 ) [ - 6 : - 2 ] ) <NEWLINE> print s <NEWLINE> <DEDENT> <DEDENT>
<NL> def main ( ) : <NEWLINE> <INDENT> n = int ( iuput ( ) ) <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> a = [ ] <COMMENT> <NEWLINE> for _ in range ( 10 ) : <NEWLINE> <INDENT> s = <STRING> . format ( s ** 2 ) <NEWLINE> s = list ( s ) <NEWLINE> hoge = <STRING> <NEWLINE> for y in range ( 2 , 6 ) : <NEWLINE> <INDENT> hoge += s [ y ] <NEWLINE> <DEDENT> s = int ( hoge ) <NEWLINE> a . append ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , x , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> for y in a : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
l = [ [ ] , [ ] , [ ] ] <NEWLINE> ans = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for j in range ( 8 ) : <NEWLINE> <INDENT> s = raw_input ( ) . split ( ) <NEWLINE> l [ i ] . append ( float ( s [ 1 ] ) , int ( s [ 0 ] ) ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> l [ i ] . sort ( ) <NEWLINE> l [ i ] . reverse ( ) <NEWLINE> ans . append ( l [ i ] . pop ( 0 ) ) <NEWLINE> ans . append ( l [ i ] . pop ( 0 ) ) <NEWLINE> <DEDENT> l = l [ 0 ] + l [ 1 ] + [ 2 ] <NEWLINE> l . sort ( ) <NEWLINE> l . reverse ( ) <NEWLINE> ans . append ( l . pop ( 0 ) ) <NEWLINE> ans . append ( l . pop ( 0 ) ) <NEWLINE> for n in ans : <NEWLINE> <INDENT> print str ( n [ 1 ] ) + <STRING> + str ( n [ 0 ] ) <NEWLINE> <DEDENT>
bus = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 5 , 4 , 3 , 2 , 1 , 0 ] <NEWLINE> for i in xrange ( input ( ) ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if s > 5 : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , bus [ s : bus . index ( t , s ) + 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s < t : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , range ( s , t + 1 ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , xrange ( s , t - 1 , - 1 ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
stop = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 5 , 4 , 3 , 2 , 1 , 0 ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> sp , ep = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if sp < ep : <NEWLINE> <INDENT> print stop [ stop . index ( sp ) : stop . index ( ep ) + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print stop [ stop . rindex ( sp ) : stop . rindex ( ep ) + 1 ] <NEWLINE> <DEDENT> <DEDENT>
for _ in [ 0 ] * input ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> A = [ list ( <STRING> * n ) for _ in [ 0 ] * n ] <NEWLINE> for i in range ( ( n + 3 ) / 4 ) : <NEWLINE> <INDENT> i2 = i * 2 <NEWLINE> if i2 > 0 : A [ n - i2 ] [ i2 ] = <STRING> <NEWLINE> for j in range ( i2 , n - i2 ) : <NEWLINE> <INDENT> A [ j ] [ i2 ] = <STRING> <NEWLINE> A [ i2 ] [ j ] = <STRING> <NEWLINE> if j < n - i2 - 1 : A [ j ] [ n - i2 - 1 ] = <STRING> <NEWLINE> if j > i2 + 1 : A [ n - i2 - 1 ] [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for e in A : print <STRING> . join ( e ) <NEWLINE> print <NEWLINE> <DEDENT>
def f ( n ) : <NEWLINE> <INDENT> spiral = [ list ( <STRING> for i in range ( n ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> spiral [ i ] [ 0 ] = <STRING> <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> spiral [ 0 ] [ i ] = <STRING> <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> spiral [ i ] [ - 1 ] = <STRING> <NEWLINE> <NL> <DEDENT> return spiral <NEWLINE> <NL> <DEDENT> def draw ( n , m ) : <NEWLINE> <COMMENT> <NL> <INDENT> for w in range ( m , n ) : <NEWLINE> <INDENT> spiral [ n - 1 ] [ w ] = <STRING> <NEWLINE> <DEDENT> if n - m == 2 : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> for h in range ( m , n ) : <NEWLINE> <INDENT> spiral [ h ] [ m ] = <STRING> <NEWLINE> <DEDENT> if n - m == 3 : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> for w in range ( m , n - 2 ) : <NEWLINE> <INDENT> spiral [ m ] [ w ] = <STRING> <NEWLINE> <DEDENT> if n - m == 4 : <NEWLINE> <INDENT> return <NEWLINE> <COMMENT> <NL> <DEDENT> for h in range ( m , n - 2 ) : <NEWLINE> <INDENT> spiral [ h ] [ n - 3 ] = <STRING> <NEWLINE> <DEDENT> if n - m == 5 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> draw ( n - 2 , m + 2 ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> if c != 0 : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> spiral = [ [ <STRING> ] ] <NEWLINE> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> spiral = [ [ <STRING> ] , [ <STRING> ] ] <NEWLINE> <DEDENT> elif 3 <= n : <NEWLINE> <INDENT> spiral = f ( n ) <NEWLINE> <DEDENT> if 4 <= n : <NEWLINE> <INDENT> draw ( n , 2 ) <NEWLINE> <DEDENT> for line in spiral : <NEWLINE> <INDENT> print <STRING> . join ( line ) <NEWLINE> <DEDENT> c = 1 <NEWLINE> <DEDENT>
d = input ( ) <NEWLINE> for r in range ( d ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n < 3 : <NEWLINE> <INDENT> for i in range ( n ) : print <STRING> * ( n - i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = [ [ <STRING> ] * n for i in range ( n ) ] <NEWLINE> x , y , dx , dy = 0 , n - 1 , 0 , - 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> S [ y ] [ x ] = <STRING> <NEWLINE> y += dy ; x += dx <NEWLINE> try : <NEWLINE> <INDENT> if S [ y + dy ] [ x + dx ] == <STRING> : <NEWLINE> <INDENT> if y + dy != - 1 : <NEWLINE> <INDENT> y -= dy ; x -= dx <NEWLINE> <DEDENT> raise <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> S [ y ] [ x ] = <STRING> <NEWLINE> dx , dy = - dy , dx <NEWLINE> y += dy ; x += dx <NEWLINE> <DEDENT> if S [ y + dy ] [ x + dx ] == <STRING> or S [ y + dx ] [ x - dy ] == <STRING> : break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print <STRING> . join ( S [ i ] ) <NEWLINE> <DEDENT> <DEDENT> if r != d - 1 : print <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D = list ( { x ** 2 % n for x in xrange ( 1 , n ) } ) <NEWLINE> C = [ 0 ] * ( ( n - 1 ) / 2 ) <NEWLINE> for i in xrange ( len ( D ) ) : <NEWLINE> <INDENT> p = D [ i ] <NEWLINE> for j in xrange ( i ) : <NEWLINE> <INDENT> q = D [ j ] <NEWLINE> g = ( p - q ) % n <NEWLINE> C [ min ( g , n - g ) - 1 ] += 2 <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , C ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> r = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n ) ] <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> pa = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( m ) ] <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> d = [ 1 ] * n <NEWLINE> q = deque ( [ pa [ i ] [ 0 ] ] ) <NEWLINE> used = [ False ] * n <NEWLINE> used [ pa [ i ] [ 0 ] - 1 ] = True <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> f = 0 <NEWLINE> p = q . popleft ( ) <NEWLINE> p -= 1 <NEWLINE> if d [ p ] == pa [ i ] [ 2 ] : break <NEWLINE> for j in r [ p ] [ 2 : ] : <NEWLINE> <INDENT> j -= 1 <NEWLINE> if pa [ i ] [ 1 ] - 1 == j : <NEWLINE> <INDENT> f = 1 <NEWLINE> d [ j ] += d [ p ] <NEWLINE> break <NEWLINE> <DEDENT> if used [ r [ j ] [ 0 ] - 1 ] : continue <NEWLINE> q . append ( j + 1 ) <NEWLINE> d [ j ] = d [ p ] + 1 <NEWLINE> used [ j ] = True <NEWLINE> <DEDENT> if f == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if f == 1 : <NEWLINE> <INDENT> print ( d [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> C = [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( n ) ] <NEWLINE> memo = { ( i , i ) : 0 for i in xrange ( n ) } <NEWLINE> def calc ( i , j ) : <NEWLINE> <INDENT> if ( i , j ) in memo : <NEWLINE> <INDENT> return memo [ i , j ] <NEWLINE> <DEDENT> return min ( calc ( i , k ) + calc ( k + 1 , j ) + C [ i ] [ 0 ] * C [ k ] [ 1 ] * C [ k + 1 ] [ 0 ] * C [ j ] [ 1 ] for k in xrange ( i , j ) ) <NEWLINE> <DEDENT> print calc ( 0 , n - 1 ) <NEWLINE>
def solve ( Card ) : <NEWLINE> <INDENT> n = len ( Card ) <NEWLINE> if n == 2 : return 0 <NEWLINE> x = [ ] <NEWLINE> for i in range ( 0 , n - 2 , 2 ) : <NEWLINE> <INDENT> tmp = Card [ : ] <NEWLINE> T = tuple ( Card [ i : i + 4 ] ) <NEWLINE> if T not in d : d [ T ] = reduce ( lambda a , b : a * b , T ) <NEWLINE> tmp [ i + 1 : i + 3 ] = [ ] <NEWLINE> x . append ( d [ T ] + solve ( tmp ) ) <NEWLINE> <DEDENT> return min ( x ) <NEWLINE> <NL> <DEDENT> d = { } <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> Card = [ ] <NEWLINE> for _ in [ 0 ] * n : Card += map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print solve ( Card ) <NEWLINE>
def dfs ( l , r ) : <NEWLINE> <INDENT> if ( l , r ) in cache : <NEWLINE> <INDENT> return cache [ ( l , r ) ] <NEWLINE> <DEDENT> if l == r : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return min ( dfs ( l , m ) + dfs ( m + 1 , r ) + L [ l ] [ 1 ] * L [ m ] [ 0 ] * L [ m + 1 ] [ 1 ] * L [ m + 1 ] [ 0 ] for m in xrange ( l , r ) ) <NEWLINE> <NL> <DEDENT> cache = { } <NEWLINE> L = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( input ( ) ) ] <NEWLINE> print dfs ( 0 , len ( L ) - 1 ) <NEWLINE>
<COMMENT> <NL> def f ( a , b , visited ) : <NEWLINE> <INDENT> w = W [ visited ] * 20 <NEWLINE> return abs ( lengths [ a ] - lengths [ b ] ) * ( 70 + w ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> cache = dict ( [ ( ( i , 0 ) , ( 0 , [ i ] ) ) for i in xrange ( n ) ] ) <NEWLINE> def dfs ( top , visited ) : <NEWLINE> <INDENT> if ( top , visited ) in cache : <NEWLINE> <INDENT> return cache [ ( top , visited ) ] <NEWLINE> <DEDENT> ret = ( 1 << 30 , [ - 1 ] ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if ( visited >> i ) & 1 == 1 : <NEWLINE> <INDENT> tmp = dfs ( i , visited ^ ( 1 << i ) ) <NEWLINE> c = tmp [ 0 ] + f ( top , i , visited ) <NEWLINE> if c < ret [ 0 ] : <NEWLINE> <INDENT> ret = ( c , tmp [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cache [ ( top , visited ) ] = ( ret [ 0 ] , ret [ 1 ] + [ top ] ) <NEWLINE> return cache [ ( top , visited ) ] <NEWLINE> <DEDENT> mask = ( 1 << n ) - 1 <NEWLINE> ret = ( 1 << 30 , - 1 ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> ret = min ( ret , dfs ( i , mask ^ ( 1 << i ) ) ) <NEWLINE> <DEDENT> return ret [ 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> num , lengths , weights = zip ( * [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n ) ] ) <NEWLINE> cache = dict ( [ ( ( i , 0 ) , 0 ) for i in xrange ( n ) ] ) <NEWLINE> W = [ 0 ] + [ sum ( weights [ i ] for i in xrange ( n ) if ( b >> i ) & 1 == 1 ) <NEWLINE> <INDENT> for b in xrange ( 1 , 1 << n ) ] <NEWLINE> <DEDENT> print <STRING> . join ( map ( lambda i : str ( num [ i ] ) , solve ( ) ) ) <NEWLINE>
R = range ( 100 ) <NEWLINE> M = [ [ 2 , 5 , 2 , 2 , 2 ] [ i % 5 ] for i in R ] <NEWLINE> Out = [ - 1 ] * 100 <NEWLINE> P = [ - 1 ] * 100 <NEWLINE> S = [ - 1 ] * 17 <NEWLINE> Q = [ ] <NEWLINE> W = [ 0 ] * 100 <NEWLINE> <NL> def stand ( I , s ) : <NEWLINE> <INDENT> n = M [ I ] <NEWLINE> P [ I ] = - 1 <NEWLINE> S [ s : s + n ] = [ - 1 ] * n <NEWLINE> Out [ I ] = - 1 <NEWLINE> return 1 <NEWLINE> <NL> <DEDENT> def sit ( I , s ) : <NEWLINE> <INDENT> n = M [ I ] <NEWLINE> P [ I ] = s <NEWLINE> S [ s : s + n ] = [ I ] * n <NEWLINE> Out . [ I ] = t + 17 * ( I % 2 ) + 3 * ( I % 3 ) + 19 <NEWLINE> W [ I ] = t - I * 5 <NEWLINE> return <NEWLINE> <NL> <DEDENT> def check ( I ) : <NEWLINE> <INDENT> n = M [ I ] <NEWLINE> for s in range ( 17 - n ) : <NEWLINE> <INDENT> if S [ s : s + n ] == [ - 1 ] * n : return s <NEWLINE> <DEDENT> return - 1 <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> c = 0 <NEWLINE> while t < 100 : <NEWLINE> <INDENT> while t in Out : <NEWLINE> <INDENT> I = Out . index ( t ) <NEWLINE> c += stand ( I , P [ I ] ) <NEWLINE> <NL> <DEDENT> if t < 500 and t % 5 == 0 : Q . append ( t / 5 ) <NEWLINE> <NL> while len ( Q ) > 0 : <NEWLINE> <INDENT> s = check ( Q [ 0 ] ) <NEWLINE> if s == - 1 : break <NEWLINE> sit ( Q . pop ( 0 ) , s ) <NEWLINE> <DEDENT> t += 1 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> try : print W [ int ( raw_input ( ) ) ] <NEWLINE> except : break <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> print <STRING> . format ( n % 39 ) <NEWLINE> <DEDENT> <DEDENT>
ld , rd = [ 0 , 0 , 0 , 0 ] . [ 0 , 0 , 0 , 0 ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l , r = map ( float , input ( ) . split ( ) ) <NEWLINE> if l < 0.2 : <NEWLINE> <INDENT> ld [ 3 ] += 1 <NEWLINE> <DEDENT> elif l < 0.6 : <NEWLINE> <INDENT> ld [ 2 ] += 1 <NEWLINE> <DEDENT> elif l < 1.1 : <NEWLINE> <INDENT> ld [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ld [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> if r < 0.2 : <NEWLINE> <INDENT> rd [ 3 ] += 1 <NEWLINE> <DEDENT> elif r < 0.6 : <NEWLINE> <INDENT> rd [ 2 ] += 1 <NEWLINE> <DEDENT> elif r < 1.1 : <NEWLINE> <INDENT> rd [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rd [ 0 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for l , r in zip ( ld , rd ) : <NEWLINE> <INDENT> print ( l , r ) <NEWLINE> <DEDENT>
ref = [ 1.1 , 0.6 , 0.2 , 0.0 ] <NEWLINE> rank = [ [ 0 , 0 ] for i in range ( 4 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> eye = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if eye [ i ] >= ref [ j ] : rank [ j ] [ i ] += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print <STRING> . join ( map ( str , rank [ i ] ) ) for i in range ( 4 ) <NEWLINE> <DEDENT>
def hantei ( l ) : <NEWLINE> <INDENT> if l >= 1.1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 0.6 <= l < 1.1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 0.2 <= l < 0.6 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif 0.2 < l : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> ldic = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> rdic = { <STRING> : 0 , <STRING> : 0 , <STRING> : 0 , <STRING> : 0 } <NEWLINE> ls = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> l , r = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> ls . append ( ( l , r ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i , j in ls : <NEWLINE> <INDENT> ldic [ hantei ( i ) ] += 1 <NEWLINE> rdic [ hantei ( j ) ] += 1 <NEWLINE> <NL> <DEDENT> for L , R in zip ( sorted ( ldic ) , sorted ( rdic ) ) : <NEWLINE> <INDENT> print L , R <NEWLINE> <DEDENT>
def f ( ) : <NEWLINE> <INDENT> max_c = 0 <NEWLINE> c = 0 <NEWLINE> for h in range ( n ) : <NEWLINE> <INDENT> for w in range ( n ) : <NEWLINE> <INDENT> if grid [ h ] [ w ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for w in range ( n ) : <NEWLINE> <INDENT> for h in range ( n ) : <NEWLINE> <INDENT> if grid [ h ] [ w ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for p in range ( n ) : <NEWLINE> <INDENT> for a in range ( n - p ) : <NEWLINE> <INDENT> if grid [ p + a ] [ 0 + a ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for p in range ( 1 , n ) : <NEWLINE> <INDENT> for a in range ( n - p ) : <NEWLINE> <INDENT> if grid [ 0 + a ] [ p + a ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for p in range ( n ) : <NEWLINE> <INDENT> for a in range ( n - p ) : <NEWLINE> <INDENT> if grid [ p + a ] [ n - 1 - a ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for p in range ( n , - 1 , - 1 ) : <NEWLINE> <INDENT> for a in range ( p ) : <NEWLINE> <INDENT> if grid [ 0 + a ] [ p - a ] == 1 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if max_c < c : <NEWLINE> <INDENT> max_c = c <NEWLINE> <DEDENT> c = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print max_c <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> grid = [ map ( int , raw_input ( ) ) for i in range ( n ) ] <NEWLINE> f ( ) <NEWLINE> <DEDENT>
def score ( x ) : <NEWLINE> <INDENT> s = 0 ; t = 1 <NEWLINE> for _ in [ 0 ] * 10 : <NEWLINE> <INDENT> a = 2 ; b = 3 <NEWLINE> if x [ t ] == 10 : a = 1 <NEWLINE> elif x [ t ] + x [ t + 1 ] != 10 : b = 2 <NEWLINE> s += sum ( x [ t : t + b ] ) ; t += a <NEWLINE> <DEDENT> return x [ 0 ] , s <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> A = sorted ( [ score ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * n ] ) <NEWLINE> for a , b in sorted ( A , key = lambda x : - x [ 1 ] ) : print ( a , b ) <NEWLINE> <DEDENT>
def get_point ( info ) : <NEWLINE> <INDENT> info . reverse ( ) <NEWLINE> acc = 0 <NEWLINE> NORMAL , SPARE , STRIKE , DOUBLE = 0 , 1 , 2 , 3 <NEWLINE> flag = NORMAL <NEWLINE> game_num = 0 <NEWLINE> while info : <NEWLINE> <INDENT> if game_num != 9 : <NEWLINE> <INDENT> down_num1 = info . pop ( ) <NEWLINE> if down_num1 != 10 : <NEWLINE> <INDENT> down_num2 = info . pop ( ) <NEWLINE> if flag == SPARE : <NEWLINE> <INDENT> acc += down_num1 * 2 + down_num2 <NEWLINE> <DEDENT> elif flag == STRIKE : <NEWLINE> <INDENT> acc += down_num1 * 2 + down_num2 * 2 <NEWLINE> <DEDENT> elif flag == DOUBLE : <NEWLINE> <INDENT> acc += down_num1 * 3 + down_num2 * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> acc += down_num1 + down_num2 <NEWLINE> <NL> <DEDENT> if down_num1 + down_num2 == 10 : <NEWLINE> <INDENT> flag = SPARE <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = NORMAL <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if flag in ( SPARE , STRIKE ) : <NEWLINE> <INDENT> acc += down_num1 * 2 <NEWLINE> <DEDENT> elif flag == DOUBLE : <NEWLINE> <INDENT> acc += down_num1 * 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> acc += down_num1 <NEWLINE> <DEDENT> if flag in ( STRIKE , DOUBLE ) : <NEWLINE> <INDENT> flag = DOUBLE <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = STRIKE <NEWLINE> <DEDENT> <DEDENT> game_num += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> down_num1 , down_num2 = info . pop ( ) , info . pop ( ) <NEWLINE> if flag == SPARE : <NEWLINE> <INDENT> acc += down_num1 * 2 + down_num2 <NEWLINE> <DEDENT> elif flag == STRIKE : <NEWLINE> <INDENT> acc += down_num1 * 2 + down_num2 * 2 <NEWLINE> <DEDENT> elif flag == DOUBLE : <NEWLINE> <INDENT> acc += down_num1 * 3 + down_num2 * 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> acc += down_num1 + down_num2 <NEWLINE> <DEDENT> if info : <NEWLINE> <INDENT> acc += info . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return acc <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> score = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] <NEWLINE> score_mp = [ ( info [ 0 ] , get_point ( info [ 1 : ] ) ) for info in score ] <NEWLINE> score . mpsort ( ) <NEWLINE> score_mp . sort ( key = lambda x : - x [ 1 ] ) <NEWLINE> for pair in score_mp : <NEWLINE> <INDENT> print ( * pair ) <NEWLINE> <DEDENT> <DEDENT>
def In ( ) : return map ( int , raw_input ( ) . split ( ) ) <NEWLINE> def D ( a , b ) : return ( ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 ) ** .5 <NEWLINE> def side ( a , b , c ) : <NEWLINE> <INDENT> f = ( c [ 1 ] - a [ 1 ] ) * ( b [ 0 ] - a [ 0 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - a [ 0 ] ) <NEWLINE> if f > 0 : return 1 <NEWLINE> elif f < 0 : return - 1 <NEWLINE> else return 0 <NEWLINE> <DEDENT> def isIn ( x , p0 , p1 , p2 ) : <NEWLINE> <INDENT> f1 = side ( p0 , p1 , x ) <NEWLINE> f2 = side ( p1 , p2 , x ) <NEWLINE> f3 = side ( p2 , p0 , x ) <NEWLINE> return ( f1 >= 0 and f2 >= 0 and f3 >= 0 ) or ( f1 <= 0 and f2 <= 0 and f3 <= 0 ) <NEWLINE> <DEDENT> def S ( a , b , c ) : return abs ( a [ 0 ] * ( b [ 1 ] - c [ 1 ] ) + b [ 0 ] * ( c [ 1 ] - a [ 1 ] ) + c [ 0 ] * ( a [ 1 ] - b [ 1 ] ) ) / 2.0 <NEWLINE> def H ( P1 , P2 , P3 ) : return 2 * S ( P1 , P2 , P3 ) / D ( P2 , P3 ) <NEWLINE> def check ( P4 , r , P1 , P2 , P3 ) : <NEWLINE> <INDENT> if all ( [ D ( P4 , P1 ) <= r , D ( P4 , P2 ) <= r , D ( P4 , P3 ) <= r ] ) : return 2 <NEWLINE> h1 = H ( P4 , P1 , P2 ) <NEWLINE> h2 = H ( P4 , P2 , P3 ) <NEWLINE> h3 = H ( P4 , P3 , P1 ) <NEWLINE> if isIn ( P4 , P1 , P2 , P3 ) : <NEWLINE> <INDENT> if all ( [ h1 >= r , h2 >= r , h3 >= r ] ) : return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if all ( [ h1 > r , h2 > r , h3 > r ] ) : return 0 <NEWLINE> <DEDENT> return 3 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> P1 = In ( ) <NEWLINE> if P1 [ 0 ] == P1 [ 1 ] == 0 : break <NEWLINE> P2 = In ( ) <NEWLINE> P3 = In ( ) <NEWLINE> P4 = In ( ) <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> print <STRING> [ check ( P4 , r , P1 , P2 , P3 ) ] <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def routing ( s , g , route ) : <NEWLINE> <INDENT> ans = [ ] <NEWLINE> i = g <NEWLINE> while i != - 1 : <NEWLINE> <INDENT> ans . append ( i + 1 ) <NEWLINE> i = route [ i ] <NEWLINE> <DEDENT> return ans [ : : - 1 ] <NEWLINE> <NL> <DEDENT> inf = 100000 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> L = [ [ inf ] * n for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L [ i ] [ i ] = 0 <NEWLINE> <DEDENT> B = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> ba , xa , ya = B [ i ] <NEWLINE> bb , xb , yb = B [ j ] <NEWLINE> ba , bb = ba - 1 , bb - 1 <NEWLINE> d = math . sqrt ( pow ( xa - xb , 2 ) + pow ( ya - yb , 2 ) ) <NEWLINE> if d <= 50 : <NEWLINE> <INDENT> L [ ba ] [ bb ] = L [ bb ] [ ba ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> m = input ( ) <NEWLINE> for p in range ( m ) : <NEWLINE> <INDENT> s , g = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s , g = s - 1 , g - 1 <NEWLINE> n = len ( L ) <NEWLINE> done = [ s ] <NEWLINE> dist = [ inf ] * n <NEWLINE> dist [ s ] = 0 <NEWLINE> route = [ - 1 ] * n <NEWLINE> i = s <NEWLINE> while len ( done ) < n : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if j in done : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if dist [ j ] > dist [ i ] + L [ i ] [ j ] : <NEWLINE> <INDENT> dist [ j ] = dist [ i ] + L [ i ] [ j ] <NEWLINE> route [ j ] = i <NEWLINE> <DEDENT> <DEDENT> min_node_size = inf <NEWLINE> for v , w in enumerate ( dist ) : <NEWLINE> <INDENT> if v not in done and w < min_node_size : <NEWLINE> <INDENT> min_node_size = w <NEWLINE> min_node_num = v <NEWLINE> <DEDENT> <DEDENT> i = min_node_num <NEWLINE> done . append ( min_node_num ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from collections import deque <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def bfs ( field , sx , sy , d = None , q = [ ] ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> dy = [ - 1 , 1 , 0 , 0 ] <NEWLINE> dx = [ 0 , 0 , - 1 , 1 ] <NEWLINE> <COMMENT> <NL> Y = len ( field ) <NEWLINE> X = len ( field [ 0 ] ) <NEWLINE> if d == None : <NEWLINE> <INDENT> d = [ [ float ( <STRING> ) ] * X for _ in range ( Y ) ] <COMMENT> <NEWLINE> <DEDENT> moats = set ( ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> Q = deque ( ) <NEWLINE> if q == [ ] : <NEWLINE> <INDENT> Q . append ( ( sx , sy ) ) <NEWLINE> d [ sy ] [ sx ] = 0 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q . extend ( q ) <NEWLINE> <DEDENT> while Q : <NEWLINE> <INDENT> cx , cy = Q . popleft ( ) <COMMENT> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = cx + dx [ i ] <NEWLINE> ny = cy + dy [ i ] <NEWLINE> <COMMENT> <NL> if ( not 0 <= nx < X ) or ( not 0 <= ny < Y ) : <NEWLINE> <INDENT> return True , moats , d <NEWLINE> <DEDENT> elif d [ ny ] [ nx ] == float ( <STRING> ) : <NEWLINE> <INDENT> if field [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> moats . add ( ( nx , ny ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Q . append ( ( nx , ny ) ) <NEWLINE> d [ ny ] [ nx ] = d [ cy ] [ cx ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return False , moats , d <NEWLINE> <NL> <NL> <DEDENT> def fill_moat ( field , moats ) : <NEWLINE> <COMMENT> <NL> <INDENT> dy = [ - 1 , 1 , 0 , 0 ] <NEWLINE> dx = [ 0 , 0 , - 1 , 1 ] <NEWLINE> <COMMENT> <NL> Y = len ( field ) <NEWLINE> X = len ( field [ 0 ] ) <NEWLINE> <NL> while moats : <NEWLINE> <INDENT> cx , cy = moats . pop ( ) <COMMENT> <NEWLINE> field [ cy ] [ cx ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> nx = cx + dx [ i ] <NEWLINE> ny = cy + dy [ i ] <NEWLINE> if ( 0 <= nx < X ) and ( 0 <= ny < Y ) : <NEWLINE> <INDENT> if field [ ny ] [ nx ] == <STRING> : <NEWLINE> <INDENT> moats . add ( ( nx , ny ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def solve ( field ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = ( 0 , 0 ) <NEWLINE> for y , row in enumerate ( field ) : <NEWLINE> <INDENT> if <STRING> in row : <NEWLINE> <INDENT> start = ( row . index ( <STRING> ) , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> sx , sy = start <NEWLINE> climb = 0 <COMMENT> <NEWLINE> d = None <NEWLINE> q = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> res , moats , d = bfs ( field , sx , sy , d , q ) <COMMENT> <NEWLINE> q = list ( moats ) <NEWLINE> if res is False : <NEWLINE> <INDENT> climb += 1 <NEWLINE> fill_moat ( field , moats ) <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return climb <NEWLINE> <NL> <NL> <DEDENT> def main ( args ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> data = [ input ( ) . strip ( <STRING> ) for _ in range ( m ) ] <NEWLINE> field = [ list ( x ) for x in data ] <COMMENT> <NEWLINE> result = solve ( field ) <NEWLINE> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
d = { } <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> c = 0 <NEWLINE> while n != 1 <NEWLINE> <INDENT> if n % 2 == 0 : n /= 2 <NEWLINE> else : n = n * 3 + 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> print c <NEWLINE> <DEDENT>
M = 10 ** 6 ; dp = [ - 1 ] * M ; dp [ 0 ] , dp [ 1 ] = 0 , 0 ; <NEWLINE> def collatz ( n ) : <NEWLINE> <INDENT> if dp [ n ] != - 1 : return dp [ n ] <NEWLINE> dp [ n ] = 1 + collatz ( n / 2 if n % 2 == 0 else 3 * n + 1 ) <NEWLINE> return dp [ n ] <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> print collatz ( n ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> team = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> i , * T = map ( int , input ( ) . split ( ) ) <NEWLINE> t = 0 <NEWLINE> for m , s in zip ( T [ : : 2 ] , T [ 1 : : 2 ] ) : <NEWLINE> <INDENT> t += m * 60 + s <NEWLINE> <DEDENT> team . append ( ( t , i ) ) <NEWLINE> <DEDENT> team . sort ( ) <NEWLINE> print ( team [ 0 ] [ 1 ] ) <NEWLINE> print ( team [ 1 ] [ 1 ] ) <NEWLINE> print ( team [ - 2 ] [ 1 ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in xrange ( n , m + 1 ) : <NEWLINE> <INDENT> p = i <NEWLINE> while p > 1 : <NEWLINE> <INDENT> if p % 2 == 0 : <NEWLINE> <INDENT> p /= 2 <NEWLINE> <DEDENT> elif p % 3 == 0 : <NEWLINE> <INDENT> p /= 3 <NEWLINE> <DEDENT> elif p % 5 == 0 : <NEWLINE> <INDENT> p /= 5 <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> if p == 1 : ans += 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> N = 1000000 <NEWLINE> prime = [ 1 ] * ( N + 1 ) <NEWLINE> prime [ 0 ] = 0 <NEWLINE> prime [ 1 ] = 0 <NEWLINE> for i in range ( 2 , int ( math . sqrt ( N ) ) ) : <NEWLINE> <INDENT> if prime [ i ] == 1 : <NEWLINE> <INDENT> j = i <NEWLINE> while i * j <= N : <NEWLINE> <INDENT> prime [ i * j ] = 0 <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prime = [ i for i in range ( N + 1 ) if prime [ i ] == 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( len ( prime ) ) : <NEWLINE> <INDENT> if p - m <= prime [ j ] <= p + m : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if p + m <= prime [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print cnt - n <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def inputData ( j ) : <NEWLINE> <INDENT> A = [ ] <NEWLINE> t = 0 <NEWLINE> for i in range ( j - 1 ) : <NEWLINE> <INDENT> v = input ( ) <NEWLINE> x = math . cos ( math . pi * ( v + t ) / 180 ) <NEWLINE> y = math . sin ( math . pi * ( v + t ) / 180 ) <NEWLINE> t += v <NEWLINE> A . append ( ( x , y ) ) <NEWLINE> <DEDENT> A . append ( A [ 0 ] ) <NEWLINE> return A <NEWLINE> <NL> <DEDENT> def calcArea ( A ) : <NEWLINE> <INDENT> return sum ( ( A [ i ] [ 0 ] - A [ i + 1 ] [ 0 ] ) * ( A [ i ] [ 1 ] + A [ i + 1 ] [ 1 ] ) for i in range ( m - 1 ) ) / 2 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m = input ( ) <NEWLINE> if m == 0 : break <NEWLINE> A = inputData ( m ) <NEWLINE> n = input ( ) <NEWLINE> B = inputData ( n ) <NEWLINE> S1 , S2 = calcArea ( A ) , calcArea ( B ) <NEWLINE> if S1 > S2 : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT> elif S1 < S2 : <NEWLINE> <INDENT> print 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> <DEDENT>
def bubble_sort ( A , N ) : <NEWLINE> <INDENT> flag = True <NEWLINE> c = 0 <NEWLINE> i = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> c += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> return c <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <NL> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> <NL> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> A = [ map ( int , raw_input ( ) ) _ for i in range ( N ) ] <NEWLINE> <NL> print bubble_sort ( A , N ) <NEWLINE> <DEDENT>
<COMMENT> <NL> a = [ 1 , 2 , 4 ] <NEWLINE> MAX_N = 30 <NEWLINE> for i in xrange ( 3 , MAX_N + 1 ) : <NEWLINE> <INDENT> a . append ( a [ i - 3 ] + a [ i - 2 ] + a [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a [ n - 1 ] / 3650 + 1 <NEWLINE> <DEDENT> <DEDENT>
import functools <NEWLINE> <NL> <NL> <COMMENT> <NL> def rec ( i ) : <NEWLINE> <INDENT> if i <= 0 : <NEWLINE> <INDENT> return i == 0 <NEWLINE> <DEDENT> return rec ( i - 1 ) + rec ( i - 2 ) + rec ( i - 3 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if not N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( ( ( rec ( N ) - 1 ) // 10 ) // 365 + 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> try : <NEWLINE> <INDENT> input = raw_input <NEWLINE> <DEDENT> except NameError : <NEWLINE> <INDENT> pass <NEWLINE> <COMMENT> <NL> <DEDENT> memo = [ 0 ] * 31 <NEWLINE> def solve ( x ) : <NEWLINE> <INDENT> if memo [ x ] == 0 : <NEWLINE> <INDENT> if x > 1 : <NEWLINE> <INDENT> memo [ x ] = solve ( x - 1 ) + solve ( x - 2 ) + solve ( x - 3 ) <NEWLINE> return memo [ x ] <NEWLINE> <DEDENT> elif x == 0 : <NEWLINE> <INDENT> memo [ x ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return memo [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> if inp == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( solve ( inp ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> step = [ 1 , 1 , 2 , 4 ] + [ 0 ] * 27 <NEWLINE> for i in range ( 4 , 31 ) : <NEWLINE> <INDENT> step [ i ] = step [ i - 1 ] + step [ i - 2 ] + step [ i - 3 ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( s ) <NEWLINE> if n == 0 : break <NEWLINE> print int ( math . ceil ( step [ n ] / 3650.0 ) ) <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> a [ : 4 ] = [ 0 , 1 , 2 , 3 ] <NEWLINE> inList = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> inList . append ( n ) <NEWLINE> <DEDENT> n = max ( inList ) <NEWLINE> for i in range ( 4 , n + 1 ) : <NEWLINE> <INDENT> a [ i ] = a [ i - 1 ] + a [ i - 2 ] + a [ i - 3 ] <NEWLINE> <DEDENT> for i in inList : <NEWLINE> <INDENT> print ( ( a [ i ] // 3650 ) + ( a [ i ] % 3650 != 0 ) ) <NEWLINE> <DEDENT>
def up ( n ) : <NEWLINE> <INDENT> if n == 0 : return 1 <NEWLINE> if n < 0 : return 0 <NEWLINE> return up ( n - 1 ) + up ( n - 2 ) + up ( n - 3 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( up ( n ) // 10 + 1 ) // 365 + 1 <NEWLINE> <DEDENT>
import itertools <NEWLINE> from copy import deepcopy <NEWLINE> <NL> def stuck ( Array , Order ) : <NEWLINE> <INDENT> remain = len ( Array ) <NEWLINE> if remain == 0 : return G ( Order ) , Order <NEWLINE> minG , minOrder = 9999999 , [ ] <NEWLINE> w = sum ( [ int ( Array [ i ] [ 1 ] ) for i in range ( remain ) ] ) <NEWLINE> for i in range ( remain ) : <NEWLINE> <INDENT> if int ( Array [ i ] [ 2 ] ) >= w - int ( Array [ i ] [ 1 ] ) : <NEWLINE> <INDENT> array = deepcopy ( Array ) <NEWLINE> order = deepcopy ( Order ) <NEWLINE> order [ n - remain ] = array . pop ( i ) <NEWLINE> curG , curOrder = stuck ( array , order ) <NEWLINE> if curG < minG : <NEWLINE> <INDENT> minG = curG <NEWLINE> minOrder = curOrder <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return minG , minOrder <NEWLINE> <NL> <DEDENT> def G ( array ) : <NEWLINE> <INDENT> nume = sum ( [ ( i + 1 ) * int ( array [ i ] [ 1 ] ) for i in range ( n ) ] ) * 1.0 <NEWLINE> denomi = sum ( [ int ( array [ i ] [ 1 ] ) for i in range ( n ) ] ) <NEWLINE> return nume / denomi <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> lunch = [ raw_input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> minG , ans = stuck ( lunch , [ 0 ] * n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ans [ i ] [ 0 ] <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , c = [ 10000 ] , [ 10000 ] , [ 10000 ] <NEWLINE> a , b , c = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> b , c = a [ 1 ] , a [ 2 ] <NEWLINE> print <STRING> % ( a , b + c , 200 * b + 300 + c ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
for i in range ( 9 ) : <NEWLINE> <INDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a , b + c , 200 * b + 300 * c <NEWLINE> <DEDENT>
<INDENT> def f ( n ) : <NEWLINE> <INDENT> a = <STRING> <NEWLINE> while n > 0 : <NEWLINE> <INDENT> a += str ( n % 4 ) <NEWLINE> n //= 4 <NEWLINE> <DEDENT> return a [ : : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == - 1 : break <NEWLINE> print f ( n ) if n > 0 else 0 <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> hmax = 10000 <NEWLINE> block = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> field = [ [ 0 ] * 5 for i in range ( hmax ) ] <NEWLINE> h = 0 <NEWLINE> for d , p , q in block : <NEWLINE> <INDENT> if d == 1 : <NEWLINE> <INDENT> for li in range ( h + 1 , - 2 , - 1 ) : <NEWLINE> <INDENT> if field [ li ] [ q - 1 : q + p - 1 ] != [ 0 ] * p or li == - 1 : <NEWLINE> <INDENT> field [ li + 1 ] [ q - 1 : q + p - 1 ] = [ 1 ] * p <NEWLINE> h = max ( h , li + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for li in range ( h + 1 , - 2 , - 1 ) : <NEWLINE> <INDENT> if field [ li ] [ q - 1 ] != 0 or li == - 1 : <NEWLINE> <INDENT> for i in range ( p ) : <NEWLINE> <INDENT> field [ li + i + 1 ] [ q - 1 ] = 1 <NEWLINE> <DEDENT> h = max ( h , li + 1 + q ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if field [ i ] == [ 1 ] * 5 : <NEWLINE> <INDENT> del field [ i ] <NEWLINE> h -= 1 <NEWLINE> <DEDENT> elif field [ i ] == [ 0 ] * 5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print sum ( [ sum ( field [ li ] ) for li in range ( hmax ) ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> hmax = 5000 <NEWLINE> block = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> field = [ [ 0 ] * 5 for i in range ( hmax ) ] <NEWLINE> h = 0 <NEWLINE> for d , p , q in block : <NEWLINE> <INDENT> if d == 1 : <NEWLINE> <INDENT> for li in range ( h , - 2 , - 1 ) : <NEWLINE> <INDENT> if field [ li ] [ q - 1 : q + p - 1 ] != [ 0 ] * p or li == - 1 : <NEWLINE> <INDENT> field [ li + 1 ] [ q - 1 : q + p - 1 ] = [ 1 ] * p <NEWLINE> h = max ( h , li + 2 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for li in range ( h , - 2 , - 1 ) : <NEWLINE> <INDENT> if field [ li ] [ q - 1 ] != 0 or li == - 1 : <NEWLINE> <INDENT> for i in range ( p ) : <NEWLINE> <INDENT> field [ li + i + 1 ] [ q - 1 ] = 1 <NEWLINE> <DEDENT> h = max ( h , li + 1 + p ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if field [ i ] == [ 1 ] * 5 : <NEWLINE> <INDENT> del field [ i ] <NEWLINE> h -= 1 <NEWLINE> <DEDENT> elif field [ i ] == [ 0 ] * 5 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print sum ( [ sum ( field [ li ] ) for li in range ( h ) ] ) <NEWLINE> <DEDENT>
def yoko ( ) : <NEWLINE> <INDENT> for h , line in enumerate ( L ) : <NEWLINE> <INDENT> if line [ q - 1 : q - 1 + p ] != [ <STRING> ] * p : <NEWLINE> <INDENT> h = h - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( q - 1 , q - 1 + p ) : <NEWLINE> <INDENT> L [ h ] [ i ] = <STRING> <NEWLINE> <DEDENT> check ( h , 1 ) <NEWLINE> <NL> <DEDENT> def tate ( ) : <NEWLINE> <INDENT> for h , line in enumerate ( L ) : <NEWLINE> <INDENT> if line [ q - 1 ] != <STRING> : <NEWLINE> <INDENT> h = h - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( h - p + 1 , h - p + 1 + p ) : <NEWLINE> <INDENT> L [ i ] [ q - 1 ] = <STRING> <NEWLINE> <DEDENT> check ( h - p + 1 , p ) <NEWLINE> <NL> <DEDENT> def check ( h , c ) : <NEWLINE> <INDENT> while 0 < c : <NEWLINE> <INDENT> if L [ h ] == [ <STRING> ] * 5 : <NEWLINE> <INDENT> del L [ h ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> c -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def add ( ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for line in L : <NEWLINE> <INDENT> if line == [ <STRING> ] * 5 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( 5 - c ) : <NEWLINE> <INDENT> L . insert ( 0 , [ <STRING> ] * 5 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def result ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for line in L : <NEWLINE> <INDENT> for v in line : <NEWLINE> <INDENT> if v == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ans <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> L = [ [ <STRING> ] * 5 for i in range ( 5 ) ] <NEWLINE> for line in L : <NEWLINE> <INDENT> print line <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> d , p , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if d == 1 : <NEWLINE> <INDENT> yoko ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tate ( ) <NEWLINE> <DEDENT> add ( ) <NEWLINE> for line in L : <NEWLINE> <INDENT> print line <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> result ( ) <NEWLINE> <DEDENT> <DEDENT>
MAXN = 5000 <NEWLINE> def deleteBlocks ( ) : <NEWLINE> <INDENT> i = MAXN - 1 <NEWLINE> while i >= 0 and set ( L [ i ] ) != set ( [ False ] ) : <NEWLINE> <INDENT> if set ( L [ i ] ) == set ( [ True ] ) : <NEWLINE> <INDENT> del L [ i ] <NEWLINE> L . insert ( 0 , [ False ] * 5 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def setBlocks ( d , lng , pos ) : <NEWLINE> <INDENT> if d == 1 : <NEWLINE> <INDENT> for i in range ( MAXN ) : <NEWLINE> <INDENT> if set ( L [ i ] [ pos : pos + lng ] ) != set ( [ False ] ) : <NEWLINE> <INDENT> L [ i - 1 ] [ pos : pos + lng ] = [ True ] * lng <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> L [ i ] [ pos : pos + lng ] = [ True ] * lng <NEWLINE> <DEDENT> <DEDENT> elif d == 2 : <NEWLINE> <INDENT> for i in range ( MAXN ) : <NEWLINE> <INDENT> if L [ i ] [ pos ] : <NEWLINE> <INDENT> for j in range ( i - lng , i ) : <NEWLINE> <INDENT> L [ j ] [ pos ] = True <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i - lng + 1 , i + 1 ) : <NEWLINE> <INDENT> L [ j ] [ pos ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> deleteBlocks ( ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> L = [ [ False ] * 5 for i in range ( MAXN ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d , p , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> setBlocks ( d , p , q - 1 ) <NEWLINE> <DEDENT> cnt , i = 0 , MAXN - 1 <NEWLINE> while i >= 0 and set ( L [ i ] ) != set ( [ False ] ) : <NEWLINE> <INDENT> cnt += sum ( L [ i ] ) <NEWLINE> i -= 1 <NEWLINE> <DEDENT> print cnt <NEWLINE> <DEDENT>
def f ( n , ans ) : <NEWLINE> <INDENT> for k , c in dic . items ( ) : <NEWLINE> <INDENT> a , b = k <NEWLINE> if a == n : <NEWLINE> <INDENT> if not b in cost or c < cost [ b ] : <NEWLINE> <INDENT> cost [ b ] = c <NEWLINE> <DEDENT> <DEDENT> elif b == n : <NEWLINE> <INDENT> if not a in cost or c < cost [ a ] : <NEWLINE> <INDENT> cost [ a ] = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k , c in sorted ( cost . items ( ) , key = lambda x : x [ 1 ] ) : <NEWLINE> <INDENT> if not k in res : <NEWLINE> <INDENT> res . append ( k ) <NEWLINE> ans += c <NEWLINE> del dic [ k ] <NEWLINE> return f ( k , ans ) <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == m == 0 : break <NEWLINE> dic = { } <NEWLINE> s , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dic [ ( s , b ) ] = c <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dic [ ( a , b ) ] = c <NEWLINE> <DEDENT> cost = { } <NEWLINE> res = [ s ] <NEWLINE> print f ( s , 0 ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> def f ( s , cost , route , ans , data ) : <NEWLINE> <INDENT> route . append ( s ) <NEWLINE> ans += cost [ s ] <NEWLINE> del cost [ s ] <NEWLINE> _data = copy . deepcopy ( data ) <NEWLINE> for k , c in _data . items ( ) : <NEWLINE> <INDENT> if s in k : <NEWLINE> <INDENT> a , b = k <NEWLINE> a , b = a , b if s == a else b , a <NEWLINE> if not b in route : <NEWLINE> <INDENT> if not b in cost or c < cost [ b ] : <NEWLINE> <INDENT> cost [ b ] = c <NEWLINE> del data [ ( a , b ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cost : <NEWLINE> <INDENT> s = sorted ( cost . items ( ) , key = lambda x : x [ 1 ] ) [ 0 ] [ 0 ] <NEWLINE> return f ( s , cost , route , ans , data ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == m == 0 : break <NEWLINE> data = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> data [ ( a , b ) ] = c <NEWLINE> <DEDENT> print f ( 0 , { 0 : 0 } , [ ] , 0 , data ) <NEWLINE> <DEDENT>
def f ( s , cost , route , ans ) : <NEWLINE> <INDENT> route . append ( s ) <NEWLINE> ans += cost [ s ] <NEWLINE> del cost [ s ] <NEWLINE> for k , c in data . items ( ) : <NEWLINE> <INDENT> if s in k : <NEWLINE> <INDENT> a , b = k <NEWLINE> b = b if s == a else a <NEWLINE> <DEDENT> if not b in route : <NEWLINE> <INDENT> if not b in cost or c < cost [ b ] : <NEWLINE> <INDENT> cost [ b ] = c <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cost : <NEWLINE> <INDENT> s = sorted ( cost . items ( ) , key = lambda x : x [ 1 ] ) [ 0 ] [ 0 ] <NEWLINE> return f ( s , cost , route , ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ans <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == m == 0 : break <NEWLINE> data = { } <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> data [ ( a , b ) ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print f ( 0 , { 0 : 0 } , [ ] , 0 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> class Solve : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . M , self . N = map ( int , input ( ) . split ( ) ) <NEWLINE> self . bs = [ int ( input ( ) ) for i in range ( self . N ) ] <NEWLINE> <NL> self . S = min ( sum ( self . bs ) , 1500000 ) <NEWLINE> self . l , self . r = 0 , self . S <NEWLINE> <NL> <DEDENT> def check ( self , W ) : <NEWLINE> <INDENT> w = W <NEWLINE> i = 1 <NEWLINE> for b in self . bs : <NEWLINE> <INDENT> if ( w >= b ) : <NEWLINE> <INDENT> w -= b <NEWLINE> <DEDENT> elif ( W >= b ) : <NEWLINE> <INDENT> if ( i >= self . M ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 1 <NEWLINE> w = W - b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> while self . r - self . l > 1 : <NEWLINE> <INDENT> m = ( self . l + self . r ) // 2 <NEWLINE> if self . check ( m ) : <NEWLINE> <INDENT> self . r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . l = m <NEWLINE> <DEDENT> <DEDENT> return self . r <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> print ( Solve ( ) . solve ( ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> book = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> unit = min ( book ) <NEWLINE> max_shelf = max ( sum ( book ) / m , max ( book ) ) <NEWLINE> while 1 : <NEWLINE> <INDENT> i = 0 <NEWLINE> cur_shelf , num = 0 , 1 <NEWLINE> while i < n : <NEWLINE> <INDENT> if num > m : break <NEWLINE> if cur_shelf + book [ i ] > max_shelf : <NEWLINE> <INDENT> num += 1 <NEWLINE> cur_shelf = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur_shelf += book [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> max_shelf += unit <NEWLINE> <DEDENT> print max_shelf <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> s += <STRING> . join ( [ raw_input ( ) for i in range ( 2 ) ] ) <NEWLINE> L = [ ( i , i + 1 , i + 2 ) for i in range ( 0 , 9 , 3 ) ] + <NEWLINE> [ ( i , i + 3 , i + 6 ) for i in range ( 3 ) ] + <NEWLINE> [ ( 0 , 4 , 8 ) , ( 2 , 4 , 6 ) ] <NEWLINE> for i , j , k in L : <NEWLINE> <INDENT> if s [ i ] == s [ j ] == s [ k ] : <NEWLINE> <INDENT> print <STRING> if s [ i ] == <STRING> else <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ 0 for i in range ( 7 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if 0 <= a < 10 : <NEWLINE> <INDENT> x [ 0 ] += 1 <NEWLINE> <DEDENT> elif 10 <= a < 20 : <NEWLINE> <INDENT> x [ 1 ] += 1 <NEWLINE> <DEDENT> elif 20 <= a < 30 : <NEWLINE> <INDENT> x [ 2 ] += 1 <NEWLINE> <DEDENT> elif 30 <= a < 40 : <NEWLINE> <INDENT> x [ 3 ] += 1 <NEWLINE> <DEDENT> elif 40 <= a < 50 : <NEWLINE> <INDENT> x [ 4 ] += 1 <NEWLINE> <DEDENT> elif 50 <= a < 60 : <NEWLINE> <INDENT> x [ 5 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x [ 6 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 7 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> s = [ 0 for i in xrange ( 7 ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> age = input ( ) <NEWLINE> s [ min ( 6 , age / 10 ) ] += 1 <NEWLINE> <DEDENT> for i in xrange ( 7 ) : <NEWLINE> <INDENT> print s [ i ] <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> h = [ 0 for i in range ( 7 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> h [ min ( 6 , input ( ) / 10 ) ] += 1 <NEWLINE> <DEDENT> for i in h : print i <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> s = [ 0 for i in xrange ( 7 ) ] <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> age = input ( ) <NEWLINE> s [ min ( 6 , age / 10 ) ] += 1 <NEWLINE> <DEDENT> for i in xrange ( 7 ) : <NEWLINE> <INDENT> print s [ i ] <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> ans = [ 0 for _ in range ( 7 ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> age = int ( input ( ) ) <NEWLINE> if age < 10 : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> elif age < 20 : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> elif age < 30 : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <DEDENT> elif age < 40 : <NEWLINE> <INDENT> ans [ 3 ] += 1 <NEWLINE> <DEDENT> elif age < 50 : <NEWLINE> <INDENT> ans [ 4 ] += 1 <NEWLINE> <DEDENT> elif age < 60 : <NEWLINE> <INDENT> ans [ 5 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 6 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for a in ans : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> ans = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> age = input ( ) <NEWLINE> if age <= 9 : <NEWLINE> <INDENT> ans [ 0 ] += 1 <NEWLINE> <DEDENT> elif age <= 19 : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> elif age <= 29 : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <DEDENT> elif age <= 39 : <NEWLINE> <INDENT> ans [ 3 ] += 1 <NEWLINE> <DEDENT> elif age <= 49 : <NEWLINE> <INDENT> ans [ 4 ] += 1 <NEWLINE> <DEDENT> elif age <= 59 : <NEWLINE> <INDENT> ans [ 5 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 6 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for c in ans : <NEWLINE> <INDENT> print c <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = [ 0 ] * 7 <NEWLINE> for _ in xrange ( n ) : <NEWLINE> <INDENT> A [ min ( input ( ) / 10 , 6 ) ] += 1 <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , A ) ) <NEWLINE> <DEDENT>
MN = 100000 <NEWLINE> prime = [ ] <NEWLINE> mem = [ False ] * 2 + [ True ] * MN <NEWLINE> for i in range ( 2 , MN ) : <NEWLINE> <INDENT> if not mem [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prime . append ( i ) <NEWLINE> for j in range ( i + i , MN , i ) : <NEWLINE> <INDENT> mem [ j ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N , ans = input ( ) , 0 <NEWLINE> if not N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for p in prime : <NEWLINE> <INDENT> if p > N / 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if mem [ N - p ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> inp = raw_input ( ) <NEWLINE> if inp == <STRING> : break <NEWLINE> q1 , b , c1 , c2 , q2 = map ( int , inp . split ( ) ) <NEWLINE> buy1 = min ( b / c1 , q2 ) <NEWLINE> buy2 = ( b - buy1 * c1 ) / c2 <NEWLINE> while buy1 * c1 + buy2 * c2 > b or buy1 + buy2 < q1 : <NEWLINE> <INDENT> buy1 -= 1 <NEWLINE> buy2 = ( b - buy1 * c1 ) / c2 <NEWLINE> <DEDENT> if buy1 > 0 : <NEWLINE> <INDENT> print buy1 , buy2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> inp = raw_input ( ) <NEWLINE> if inp == <STRING> : break <NEWLINE> q1 , b , c1 , c2 , q2 = map ( int , inp . split ( ) ) <NEWLINE> buy1 = min ( b / c1 , q2 ) <NEWLINE> buy2 = ( b - buy1 * c1 ) / c2 <NEWLINE> while buy1 * c1 + buy2 * c2 > b or buy1 + buy2 < q1 : <NEWLINE> <INDENT> buy1 -= 1 <NEWLINE> buy2 = ( b - buy1 * c1 ) / c2 <NEWLINE> if buy1 == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print buy1 , buy2 <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> N = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> s = input ( ) <NEWLINE> i = n / 2 <NEWLINE> c = 1 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> if N [ i ] == s : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif N [ i ] < s : <NEWLINE> <INDENT> i /= 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = min ( n - 1 , i + i / 2 ) <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> l , r = 0 , int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( r ) ] <NEWLINE> r -= 1 ; c = 0 <NEWLINE> k = int ( input ( ) ) <NEWLINE> while l <= r : <NEWLINE> <INDENT> c += 1 <NEWLINE> m = ( l + r ) // 2 <NEWLINE> if a [ m ] == k : break <NEWLINE> if a [ m ] < k : l = m + 1 <NEWLINE> else : r = m - 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
road = int ( input ( ) ) <NEWLINE> while road > 0 : <NEWLINE> <INDENT> answer = [ [ float ( <STRING> ) if n != m else 0 for n in range ( 10 ) ] for m in range ( 10 ) ] <NEWLINE> city = 0 <NEWLINE> for _ in range ( road ) : <NEWLINE> <INDENT> c1 , c2 , w = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> answer [ c1 ] [ c2 ] = w <NEWLINE> answer [ c2 ] [ c1 ] = w <NEWLINE> city = max ( city , c1 , c2 ) <NEWLINE> <DEDENT> city = max ( connect . keys ( ) ) + 1 <NEWLINE> for i in range ( city ) : <NEWLINE> <INDENT> for j in range ( city ) : <NEWLINE> <INDENT> for k in range ( city ) : <NEWLINE> <INDENT> answer [ j ] [ k ] = min ( answer [ j ] [ k ] , answer [ j ] [ i ] + answer [ i ] [ k ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sum_ans = [ - 1 , float ( <STRING> ) ] <NEWLINE> for i in range ( city ) : <NEWLINE> <INDENT> if sum ( answer [ i ] [ : city ] ) < sum_ans [ 1 ] : <NEWLINE> <INDENT> sum_ans = [ i , sum ( answer [ i ] [ : city ] ) ] <NEWLINE> <DEDENT> <DEDENT> print ( * sum_ans ) <NEWLINE> road = int ( input ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def generate_next_hexes ( x , y ) : <NEWLINE> <INDENT> hexes = [ ( x , y - 1 ) , ( x , y + 1 ) , ( x - 1 , y ) , ( x + 1 , y ) ] <NEWLINE> if y % 2 : <NEWLINE> <INDENT> hexes += [ ( x - 1 , y - 1 ) , ( x - 1 , y + 1 ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> hexes += [ ( x + 1 , y - 1 ) , ( x + 1 , y + 1 ) ] <NEWLINE> <DEDENT> hexes = [ ( a , b ) for ( a , b ) in hexes if 1 <= b <= m and 1 <= b <= n ] <NEWLINE> return hexes <NEWLINE> <NL> <DEDENT> def update_map ( hex_map , hexes ) : <NEWLINE> <INDENT> num_updated_hexes = 0 <NEWLINE> distance = 0 <NEWLINE> while hexes : <NEWLINE> <INDENT> next_hexes = [ ] <NEWLINE> for pos in hexes : <NEWLINE> <INDENT> if pos not in hex_map or distance < hex_map [ pos ] ) : <NEWLINE> <INDENT> hex_map [ pos ] = distance <NEWLINE> num_updated_hexes += 1 <NEWLINE> next_hexes += generate_next_hexes ( pos [ 0 ] , pos [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> distance += 1 <NEWLINE> hexes = next_hexes <NEWLINE> <DEDENT> return num_updated_hexes <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> ( m , n ) = [ int ( i ) for i in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> if m == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s = int ( sys . stdin . readline ( ) ) <NEWLINE> stores = [ ] <NEWLINE> for i in range ( s ) : <NEWLINE> <INDENT> pos = [ int ( j ) for j in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> stores . append ( tuple ( pos ) ) <NEWLINE> <DEDENT> hex_map = { } <NEWLINE> update_map ( hex_map , stores ) <NEWLINE> <NL> t = int ( sys . stdin . readline ( ) ) <NEWLINE> candidates = [ ] <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> pos = [ int ( j ) for j in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> candidates . append ( tuple ( pos ) ) <NEWLINE> <NL> <DEDENT> max_num_blocks = 0 <NEWLINE> for candidate in candidates : <NEWLINE> <INDENT> new_hex_map = hex_map . copy ( ) <NEWLINE> num_blocks = update_map ( new_hex_map , [ candidate ] ) <NEWLINE> max_num_blocks = max ( max_num_blocks , num_blocks ) <NEWLINE> <NL> <DEDENT> print ( max_num_blocks ) <NEWLINE> <DEDENT>
<COMMENT> <NL> D = ( ( ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , 0 ) ) , <NEWLINE> <INDENT> ( ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 0 ) ) ) <NEWLINE> <DEDENT> def func ( y , x ) : <NEWLINE> <INDENT> q = [ ( y , x , 0 ) ] <NEWLINE> cover = [ [ - 1 ] * m for _ in xrange ( n ) ] <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> y , x , step = q . pop ( 0 ) <NEWLINE> if cover [ y ] [ x ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cover [ y ] [ x ] = step <NEWLINE> for dx , dy in D [ y % 2 ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < n and 0 <= nx < m : <NEWLINE> <INDENT> q . append ( ( ny , nx , step + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cover <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> scover = [ func ( pos [ 1 ] - 1 , pos [ 0 ] - 1 ) for pos in spos ] <NEWLINE> min_cover = [ [ min ( sc [ y ] [ x ] for sc in scover ) for x in xrange ( m ) ] for y in xrange ( n ) ] <NEWLINE> def count ( cover ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> for y in xrange ( n ) : <NEWLINE> <INDENT> for x in xrange ( m ) : <NEWLINE> <INDENT> if cover [ y ] [ x ] < min_cover [ y ] [ x ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <DEDENT> return max ( count ( func ( pos [ 1 ] - 1 , pos [ 0 ] - 1 ) ) for pos in tpos ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> data = raw_input ( ) . sprit ( ) <NEWLINE> m , n = map ( int , data . split ( ) ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = input ( ) <NEWLINE> spos = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( s ) ] <NEWLINE> t = input ( ) <NEWLINE> tpos = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( t ) ] <NEWLINE> print solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> D = ( ( ( - 1 , - 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 1 ) , ( - 1 , 0 ) ) , <NEWLINE> <INDENT> ( ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , 0 ) ) ) <NEWLINE> <DEDENT> def func ( y , x ) : <NEWLINE> <INDENT> q = [ ( y , x , 0 ) ] <NEWLINE> cover = [ [ - 1 ] * m for _ in xrange ( n ) ] <NEWLINE> return cover <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> y , x , step = q . pop ( 0 ) <NEWLINE> if cover [ y ] [ x ] >= 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cover [ y ] [ x ] = step <NEWLINE> for dx , dy in D [ y % 2 ] : <NEWLINE> <INDENT> ny , nx = y + dy , x + dx <NEWLINE> if 0 <= ny < n and 0 <= nx < m : <NEWLINE> <INDENT> q . append ( ( ny , nx , step + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cover <NEWLINE> <NL> <DEDENT> def count ( cover , min_cover ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> return ret <NEWLINE> for y in xrange ( n ) : <NEWLINE> <INDENT> for x in xrange ( m ) : <NEWLINE> <INDENT> if cover [ y ] [ x ] < min_cover [ y ] [ x ] : <NEWLINE> <INDENT> ret += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> scover = [ func ( pos [ 1 ] - 1 , pos [ 0 ] - 1 ) for pos in spos ] <NEWLINE> min_cover = [ [ min ( sc [ y ] [ x ] for sc in scover ) for x in xrange ( m ) ] for y in xrange ( n ) ] <NEWLINE> return max ( count ( func ( pos [ 1 ] - 1 , pos [ 0 ] - 1 ) , min_cover ) for pos in tpos ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> data = raw_input ( ) <NEWLINE> if data == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m , n = map ( int , data . split ( ) ) <NEWLINE> s = input ( ) <NEWLINE> spos = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( s ) ] <NEWLINE> t = input ( ) <NEWLINE> tpos = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( t ) ] <NEWLINE> print solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from heapq import heappop , heappush <NEWLINE> from string import ascii_lowercase as al <NEWLINE> dic = dict ( [ ( c , i ) for i , c in enumerate ( al ) ] ) <NEWLINE> f = lambda ( h , v ) : ( dic [ h ] , int ( v ) - 1 ) <NEWLINE> g = lambda s : f ( s . split ( <STRING> ) ) <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> hq = [ ( 0 , start [ 0 ] , start [ 1 ] ) ] <NEWLINE> while len ( hq ) != 0 : <NEWLINE> <INDENT> cost , cy , cx = heappop ( hq ) <NEWLINE> <COMMENT> <NL> if ( cy , cx ) == goal : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> for dy , dx in ( ( 0 , 1 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( - 1 , 0 ) ) : <NEWLINE> <INDENT> ny , nx = cy + dy , cx + dx <NEWLINE> if 0 <= ny < M and 0 <= nx < N : <NEWLINE> <COMMENT> <NL> <INDENT> nc = condition [ ny ] [ nx ] [ cy ] [ cx ] + D + cost <NEWLINE> if field [ ny ] [ nx ] == 0 : <NEWLINE> <INDENT> heappush ( hq , ( nc , ny , nx ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dy == 0 : <NEWLINE> <INDENT> if ( nc / field [ ny ] [ nx ] ) % 2 == 1 : <NEWLINE> <INDENT> heappush ( hq , ( nc , ny , nx ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( nc / field [ ny ] [ nx ] ) % 2 == 0 : <NEWLINE> <INDENT> heappush ( hq , ( nc , ny , nx ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> M , N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if M | N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> D = input ( ) <NEWLINE> field = [ [ 0 ] * N for _ in xrange ( M ) ] <NEWLINE> condition = [ [ [ [ 0 ] * N for _ in xrange ( M ) ] for _ in xrange ( N ) ] for _ in xrange ( M ) ] <NEWLINE> for _ in xrange ( input ( ) ) : <NEWLINE> <INDENT> p , k = raw_input ( ) . split ( ) <NEWLINE> h , v = g ( p ) <NEWLINE> field [ h ] [ v ] = int ( k ) <NEWLINE> <NL> <DEDENT> for _ in xrange ( input ( ) ) : <NEWLINE> <INDENT> ( h1 , v1 ) , ( h2 , v2 ) = map ( g , raw_input ( ) . split ( ) ) <NEWLINE> condition [ h1 ] [ v1 ] [ h2 ] [ v2 ] = condition [ h2 ] [ v2 ] [ h1 ] [ v1 ] = 1 << 30 <NEWLINE> <NL> <DEDENT> for _ in xrange ( input ( ) ) : <NEWLINE> <INDENT> p1 , p2 , d = raw_input ( ) . split ( ) <NEWLINE> h1 , v1 = g ( p1 ) <NEWLINE> h2 , v2 = g ( p2 ) <NEWLINE> condition [ h1 ] [ v1 ] [ h2 ] [ v2 ] = condition [ h2 ] [ v2 ] [ h1 ] [ v1 ] = int ( d ) <NEWLINE> <NL> <DEDENT> start , goal = map ( g , raw_input ( ) . split ( ) ) <NEWLINE> print solve ( ) <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> cnt += 1 <NEWLINE> if n == k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l . append ( n + k ) <NEWLINE> if cnt % 5 == 0 : <NEWLINE> <INDENT> print chr ( l . index ( max ( l ) ) + 65 ) , max ( l ) <NEWLINE> l = [ ] <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( f . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> teams = [ f . readline ( ) . split ( ) for i in range ( n ) ] <NEWLINE> <NL> teams = [ ( t [ 0 ] , - t . count ( <STRING> ) , t . count ( <STRING> ) , i ) for i , t in enumerate ( teams ) ] <NEWLINE> <NL> teams . sort ( key = operator . itemgetter ( 1 , 2 , 3 ) ) <NEWLINE> <NL> print ( <STRING> . join ( [ t [ 0 ] for t in teams ] ) ) <NEWLINE> <DEDENT>
def downA ( chair ) : <NEWLINE> <INDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if chair [ i ] == <STRING> : <NEWLINE> <INDENT> chair [ i ] = <STRING> <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def downB ( chair ) : <NEWLINE> <INDENT> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> if chair [ i ] == <STRING> and chair [ i - 1 ] != <STRING> and chair [ i + 1 ] != <STRING> : <NEWLINE> <INDENT> chair [ i ] = <STRING> <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> chair [ chair . index ( <STRING> ) ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def downC ( chair ) : <NEWLINE> <INDENT> if set ( chair [ 1 : - 1 ] ) == set ( [ <STRING> ] ) : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> chair [ n / 2 + 2 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> chair [ ( n + 1 ) / 2 + 1 ] = <STRING> <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if chair [ i ] != <STRING> : <NEWLINE> <INDENT> if chair [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> chair [ i + 1 ] = <STRING> <NEWLINE> return <NEWLINE> <DEDENT> elif i - 1 >= 1 and chair [ i - 1 ] == <STRING> : <NEWLINE> <INDENT> chair [ i - 1 ] = <STRING> <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def downD ( chair ) : <NEWLINE> <INDENT> if set ( chair [ 1 : - 1 ] ) == set ( [ <STRING> ] ) : <NEWLINE> <INDENT> chair [ 1 ] = <STRING> <NEWLINE> return <NEWLINE> <DEDENT> t = [ 0 ] * n <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if chair [ i ] != <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t [ i ] = cnt <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> if chair [ i ] != <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> t [ i ] = min ( cnt , t [ i ] ) <NEWLINE> <DEDENT> <DEDENT> maxInt = max ( t ) <NEWLINE> chair [ t . index ( maxInt ) ] = <STRING> <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == m == 0 : break <NEWLINE> chair = [ <STRING> ] + [ <STRING> ] * n + [ <STRING> ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> p = raw_input ( ) <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> downA ( chair ) <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> downB ( chair ) <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> downC ( chair ) <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> downD ( chair ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( chair [ 1 : - 1 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def dijkstra ( m , start , goal , matrix ) : <NEWLINE> <INDENT> defnode = [ False ] * ( m + 1 ) <NEWLINE> cost = [ sys . maxint ] * ( m + 1 ) <NEWLINE> cost [ start ] = 0 <NEWLINE> node = start <NEWLINE> while True : <NEWLINE> <INDENT> defnode [ node ] = True <NEWLINE> minnode = sys . maxint <NEWLINE> mincost = sys . maxint <NEWLINE> for i in xrange ( 1 , m + 1 ) : <NEWLINE> <INDENT> if defnode [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if matrix [ node ] [ i ] == sys . maxint : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost [ i ] = min ( cost [ i ] , cost [ node ] + matrix [ node ] [ i ] ) <NEWLINE> if cost [ i ] < mincost : <NEWLINE> <INDENT> minnode = i <NEWLINE> mincost = cost [ i ] <NEWLINE> <DEDENT> <DEDENT> if minnode == goal : <NEWLINE> <INDENT> print cost [ goal ] <NEWLINE> return <NEWLINE> <DEDENT> node = minnode <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cost = [ [ sys . maxint ] * ( m + 1 ) for j in xrange ( m + 1 ) ] <NEWLINE> time = [ [ sys . maxint ] * ( m + 1 ) for j in xrange ( m + 1 ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> a , b , c , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> cost [ a ] [ b ] = c <NEWLINE> cost [ b ] [ a ] = c <NEWLINE> time [ a ] [ b ] = t <NEWLINE> time [ b ] [ a ] = t <NEWLINE> <DEDENT> k = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( k ) : <NEWLINE> <INDENT> p , q , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r == 0 : <NEWLINE> <INDENT> dijkstra ( m , p , q , cost ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dijkstra ( m , p , q , time ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> [ n , m ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C = [ [ 9999 for x in range ( m + 1 ) ] for y in range ( m + 1 ) ] <NEWLINE> T = [ [ 9999 for x in range ( m + 1 ) ] for y in range ( m + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> [ a , b , c , t ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> C [ a ] [ b ] = c <NEWLINE> C [ b ] [ a ] = c <NEWLINE> T [ a ] [ b ] = t <NEWLINE> T [ b ] [ a ] = t <NEWLINE> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> C [ i ] [ i ] = 0 <NEWLINE> T [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for k in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if C [ i ] [ j ] > C [ i ] [ k ] + C [ k ] [ j ] : <NEWLINE> <INDENT> C [ i ] [ j ] = C [ i ] [ k ] + C [ k ] [ j ] <NEWLINE> <DEDENT> if T [ i ] [ j ] > T [ i ] [ k ] + T [ k ] [ j ] : <NEWLINE> <INDENT> T [ i ] [ j ] = T [ i ] [ k ] + T [ k ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> Q = int ( raw_input ( ) ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> [ p , q , r ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if r : <NEWLINE> <INDENT> print T [ p ] [ q ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print C [ p ] [ q ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
inf = 0x10101010 <NEWLINE> def solve ( A , strt ) : <NEWLINE> <INDENT> cost = [ inf ] * m <NEWLINE> visited = [ False ] * m <NEWLINE> cost [ strt ] = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> min = inf <NEWLINE> next = - 1 <NEWLINE> visited [ strt ] = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if visited [ i ] : continue <NEWLINE> if A [ strt ] [ i ] : <NEWLINE> <INDENT> d = cost [ strt ] + A [ strt ] [ i ] <NEWLINE> if d < cost [ i ] : <NEWLINE> <INDENT> cost [ i ] = d <NEWLINE> <DEDENT> <DEDENT> if cost [ i ] < min : <NEWLINE> <INDENT> min = cost [ i ] <NEWLINE> next = i <NEWLINE> <DEDENT> <DEDENT> strt = next <NEWLINE> if next == - 1 : break <NEWLINE> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> T = [ [ 0 ] * m for i in range ( m ) ] <NEWLINE> C = [ [ 0 ] * m for i in range ( m ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> T [ a - 1 ] [ b - 1 ] = T [ b - 1 ] [ a - 1 ] = t <NEWLINE> C [ a - 1 ] [ b - 1 ] = C [ b - 1 ] [ a - 1 ] = c <NEWLINE> <DEDENT> TS = [ solve ( T , i ) for i in range ( m ) ] <NEWLINE> CS = [ solve ( C , i ) for i in range ( m ) ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> a , b , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if q == 0 : <NEWLINE> <INDENT> print CS [ a - 1 ] [ b - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print TS [ a - 1 ] [ b - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> inf = 0x10101010 <NEWLINE> <NL> def solve ( A , strt ) : <NEWLINE> <INDENT> cost = [ inf ] * m <NEWLINE> visited = [ False ] * m <NEWLINE> cost [ strt ] = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> min = inf <NEWLINE> next = - 1 <NEWLINE> visited [ strt ] = True <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if visited [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if A [ strt ] [ i ] : <NEWLINE> <INDENT> d = cost [ strt ] + A [ strt ] [ i ] <NEWLINE> if d < cost [ i ] : <NEWLINE> <INDENT> cost [ i ] = d <NEWLINE> <DEDENT> if cost [ i ] < min : <NEWLINE> <INDENT> min = cost [ i ] <NEWLINE> next = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> strt = next <NEWLINE> if next == - 1 : break <NEWLINE> <DEDENT> return cost <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> while 1 : <NEWLINE> <COMMENT> <NL> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> T = [ [ 0 ] * m for i in range ( m ) ] <NEWLINE> C = [ [ 0 ] * m for i in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c , t = map ( int , raw_input ( ) . split ( ) ) <COMMENT> <NEWLINE> T [ a - 1 ] [ b - 1 ] = T [ b - 1 ] [ a - 1 ] = t <NEWLINE> C [ a - 1 ] [ b - 1 ] = C [ b - 1 ] [ a - 1 ] = c <NEWLINE> <DEDENT> TS = [ solve ( T , i ) for i in range ( m ) ] <NEWLINE> CS = [ solve ( C , i ) for i in range ( m ) ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> a , b , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if q == 0 : <NEWLINE> <INDENT> print CS [ a - 1 ] [ b - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print TS [ a - 1 ] [ b - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dic = { } <NEWLINE> for _ in xrange ( n ) : <NEWLINE> <INDENT> name , cost = raw_input ( ) . split ( ) <NEWLINE> dic [ name ] = int ( cost ) <NEWLINE> <DEDENT> m = input ( ) <NEWLINE> recipe = [ ] <NEWLINE> for _ in xrange ( m ) : <NEWLINE> <INDENT> data = raw_input ( ) . split ( ) <NEWLINE> if data [ 1 ] <= 0 : <NEWLINE> <INDENT> m -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> recipe . append ( [ data [ 0 ] ] + data [ 2 : ] ) <NEWLINE> <DEDENT> for _ in xrange ( m ) : <NEWLINE> <INDENT> for i in xrange ( m ) : <NEWLINE> <INDENT> dic [ recipe [ i ] [ 0 ] ] = min ( recipe [ i ] [ 0 ] , <NEWLINE> <INDENT> sum ( map ( lambda x : dic [ x ] , recipe [ i ] [ 1 : ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print dic [ raw_input ( ) ] <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def cheaperprice ( item , checkloop , rawprices , menus ) : <NEWLINE> <INDENT> rawprice = rawprices [ item ] <NEWLINE> if item in checkloop : <NEWLINE> <INDENT> return rawprice <NEWLINE> <DEDENT> elif item not in menus : <NEWLINE> <INDENT> checkloop . append ( item ) <NEWLINE> return rawprice <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> checkloop . append ( item ) <NEWLINE> indegrients = menus [ item ] <NEWLINE> combinedprice = 0 <NEWLINE> for i in indegrients : <NEWLINE> <INDENT> combinedprice += cheaperprice ( i , checkloop , rawprices , menus ) <NEWLINE> <DEDENT> return min ( combinedprice , rawprice ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = 0 <COMMENT> <NEWLINE> flag = 0 <NEWLINE> rawprices = { } <NEWLINE> menus = { } <NEWLINE> checkloop = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> line = line . strip ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> if flag == 0 and line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif flag != 2 : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print cheaperprice ( line , checkloop , rawprices , menus ) <NEWLINE> rawprices = { } <NEWLINE> menus = { } <NEWLINE> checkloop = [ ] <NEWLINE> <DEDENT> flag = ( flag + 1 ) % 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> line = line . split ( <STRING> ) <NEWLINE> if flag == 1 : <COMMENT> <NEWLINE> <INDENT> rawprices [ line [ 0 ] ] = int ( line [ 1 ] ) <NEWLINE> <DEDENT> elif flag == 2 : <NEWLINE> <INDENT> menus [ line [ 0 ] ] = line [ 2 : ] <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <INDENT> things = { } <NEWLINE> count = input ( ) <NEWLINE> if count == 0 : break <NEWLINE> for i in range ( count ) : <NEWLINE> <INDENT> fuga = raw_input ( ) . split ( ) <NEWLINE> things [ fuga [ 0 ] ] = int ( fuga [ 1 ] ) <NEWLINE> <DEDENT> for i in range ( input ( ) ) : <NEWLINE> <INDENT> fuga = raw_input ( ) . split ( ) <NEWLINE> money = 0 <NEWLINE> for j in range ( int ( fuga [ 1 ] ) ) : <NEWLINE> <INDENT> money += things [ fuga [ j + 2 ] ] <NEWLINE> <DEDENT> things [ fuga [ 0 ] ] = things [ fuga [ 0 ] ] if money > things [ fuga [ 0 ] ] else money <NEWLINE> <DEDENT> ans = raw_input ( ) <NEWLINE> fin = things [ ans ] if ans in things else 0 <NEWLINE> print fin <NEWLINE> <DEDENT>
while True : <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> <INDENT> q = ts [ f [ 0 ] ] <NEWLINE> <DEDENT> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> item = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , cost = raw_input ( ) . split ( ) <NEWLINE> item [ name ] = int ( cost ) <NEWLINE> <DEDENT> m = input ( ) <NEWLINE> recipes = [ raw_input ( ) . split ( ) for i in range ( m ) ] <NEWLINE> for recipe in recipes : <NEWLINE> <INDENT> name = recipe [ 0 ] <NEWLINE> cost = 0 <NEWLINE> for need in recipe [ 2 : ] : <NEWLINE> <INDENT> cost += item [ need ] <NEWLINE> <DEDENT> item [ name ] = min ( cost , item [ name ] ) <NEWLINE> <DEDENT> print item [ raw_input ( ) ] <NEWLINE> <DEDENT>
q , w , e = range , input , raw_input <NEWLINE> while True : <NEWLINE> <INDENT> n = w ( ) <NEWLINE> if n == 0 : break <NEWLINE> d = { } <NEWLINE> for i in q ( n ) : <NEWLINE> <INDENT> o = e ( ) . split ( ) <NEWLINE> d [ o [ 0 ] ] = int ( o [ 1 ] ) <NEWLINE> <DEDENT> for j in q ( w ( ) ) : <NEWLINE> <INDENT> t = e ( ) . split ( ) <NEWLINE> a = sum ( [ d [ i ] for i in t [ 2 : ] ] ) <NEWLINE> d [ t [ 0 ] ] = a if a < d [ t [ 0 ] ] else d [ t [ 0 ] ] <NEWLINE> <DEDENT> print d [ e ( ) ] <NEWLINE> <DEDENT>
def check ( item ) : <NEWLINE> <INDENT> price = 0 <NEWLINE> for i in recipe [ item [ - 1 ] ] : <NEWLINE> <INDENT> if recipe . has_key ( i ) == False : <NEWLINE> <INDENT> price += pricelist [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> item . append ( i ) <NEWLINE> price += min ( check ( item ) , pricelist [ item [ - 1 ] ] ) <NEWLINE> item . pop ( ) <NEWLINE> <DEDENT> <DEDENT> return price <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> pricelist = { } <NEWLINE> recipe = { } <NEWLINE> <NL> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> item , price = raw_input ( ) . split ( ) <NEWLINE> pricelist [ item ] = int ( price ) <NEWLINE> <NL> <DEDENT> m = input ( ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> data = raw_input ( ) . split ( ) <NEWLINE> recipe [ data [ 0 ] ] = [ ] <NEWLINE> for j in range ( int ( data [ 1 ] ) ) : <NEWLINE> <INDENT> recipe [ data [ 0 ] ] . append ( data [ j + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> price = check ( [ raw_input ( ) ] ) <NEWLINE> print price <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> [ X , Y ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if X == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F = [ ] <NEWLINE> for i in range ( Y ) : <NEWLINE> <INDENT> F . append ( [ 0 ] + [ int ( x ) for x in raw_input ( ) . split ( ) ] + [ 0 ] ) <NEWLINE> <DEDENT> F . append ( [ 3 for x in range ( X + 2 ) ] ) <NEWLINE> S = [ [ 0 for x in range ( X + 2 ) ] for y in range ( Y + 1 ) ] <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> S [ 0 ] [ i ] = 1 - F [ 0 ] [ i ] <NEWLINE> <DEDENT> for j in range ( Y + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , X + 1 ) : <NEWLINE> <INDENT> if F [ j ] [ i ] == 2 : <NEWLINE> <INDENT> S [ j ] [ i ] = S [ j ] [ i ] + S [ j - 1 ] [ i ] <NEWLINE> S [ j + 2 ] [ i ] = S [ j + 2 ] [ i ] + S [ j ] [ i ] <NEWLINE> <DEDENT> elif F [ j ] [ i ] == 1 : <NEWLINE> <INDENT> S [ j ] [ i ] = 0 <NEWLINE> <DEDENT> elif F [ j ] [ i ] == 3 : <NEWLINE> <INDENT> S [ j ] [ i ] = S [ j ] [ i ] + S [ j - 1 ] [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ j ] [ i ] = S [ j ] [ i ] + ( 1 - F [ j - 1 ] [ i ] / 2 ) * S [ j - 1 ] [ i ] + ( 1 - F [ j - 1 ] [ i - 1 ] / 2 ) * S [ j - 1 ] [ i - 1 ] + ( 1 - F [ j - 1 ] [ i + 1 ] / 2 ) * S [ j - 1 ] [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print sum ( S [ Y ] ) <NEWLINE> <DEDENT> <DEDENT>
from math import sqrt <NEWLINE> <NL> class Ufo : <NEWLINE> <INDENT> def __init__ ( self , px , py , d , vd , ui ) : <NEWLINE> <INDENT> self . pd = sqrt ( px ** 2 + py ** 2 ) <NEWLINE> self . px = float ( px ) <NEWLINE> self . py = float ( py ) <NEWLINE> self . ex = self . px / self . pd <NEWLINE> self . ey = self . py / self . pd <NEWLINE> self . d = float ( d ) <NEWLINE> self . vd = float ( vd ) <NEWLINE> self . vx = - self . vd * self . ex <NEWLINE> self . vy = - self . vd * self . ey <NEWLINE> self . i = ui <NEWLINE> <DEDENT> def move ( self ) : <NEWLINE> <INDENT> self . pd -= self . vd <NEWLINE> self . px += self . vx <NEWLINE> self . py += self . vy <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> R , ul = tuple ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> if ( R == 0 and ul == 0 ) : break <NEWLINE> us = [ ] <NEWLINE> for ui in xrange ( ul ) : <NEWLINE> <INDENT> px , py , d , vd = tuple ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> u = Ufo ( px , py , d , vd , ui ) <NEWLINE> us . append ( u ) <NEWLINE> <NL> <DEDENT> re = 0 <NEWLINE> while len ( us ) != 0 : <NEWLINE> <INDENT> for u in us : u . move ( ) <NEWLINE> us . sort ( key = lambda u : u . pd ) <NEWLINE> <NL> for u in us [ : ] : <NEWLINE> <INDENT> if u . pd <= R : <NEWLINE> <INDENT> re += 1 <NEWLINE> us . remove ( u ) <NEWLINE> <COMMENT> <NL> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> neu = us . pop ( 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> laserex = neu . ex <NEWLINE> laserey = neu . ey <NEWLINE> <NL> for u in us [ : ] : <NEWLINE> <INDENT> d = u . pd * abs ( laserex * u . ey - laserey * u . ex ) <COMMENT> <NEWLINE> if d < u . d : <NEWLINE> <INDENT> if u . pd * abs ( laserex * u . ex + laserey * u . ey ) + sqrt ( u . d ** 2 - d ** 2 ) > R : <NEWLINE> <INDENT> us . remove ( u ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print re <NEWLINE> <DEDENT>
import math <NEWLINE> ans = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> ufo = [ ] <NEWLINE> n = raw_input ( ) . split ( ) <NEWLINE> if n == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> for an in ans : <NEWLINE> <INDENT> print an <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> R = int ( n [ 0 ] ) <NEWLINE> for i in range ( int ( n [ 1 ] ) ) : <NEWLINE> <INDENT> m = [ int ( f ) for f in raw_input ( ) . split ( ) ] <NEWLINE> l = math . sqrt ( m [ 0 ] ** 2 + m [ 1 ] ** 2 ) <NEWLINE> ufo . append ( [ l , l , ( m [ 0 ] , m [ 1 ] ) , m [ 2 ] , m [ 3 ] ] ) <NEWLINE> <DEDENT> a = 0 <NEWLINE> while len ( ufo ) > 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> for xs in ufo : xs [ 0 ] -= xs [ 4 ] <NEWLINE> ufo . sort ( ) <NEWLINE> for xs in ufo [ : ] : <NEWLINE> <INDENT> if xs [ 0 ] <= R : <NEWLINE> <INDENT> a += 1 <NEWLINE> ufo . remove ( xs ) <NEWLINE> continue <NEWLINE> <DEDENT> elif flag : <NEWLINE> <INDENT> r = xs [ 1 ] <NEWLINE> pos = xs [ 2 ] <NEWLINE> ufo . remove ( xs ) <NEWLINE> flag = False <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = xs [ 0 ] / xs [ 1 ] * abs ( pos [ 0 ] * xs [ 2 ] [ 1 ] - pos [ 1 ] * xs [ 2 ] [ 0 ] ) / r <NEWLINE> if d <= xs [ 3 ] : <NEWLINE> <INDENT> if xs [ 0 ] * math . cos ( math . atan2 ( xs [ 2 ] [ 1 ] , xs [ 2 ] [ 0 ] ) - math . atan2 ( pos [ 1 ] , pos [ 0 ] ) ) + math . sqrt ( xs [ 3 ] ** 2 - d ** 2 ) > R : <NEWLINE> <INDENT> ufo . remove ( xs ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> h1 = int ( input ( ) ) <NEWLINE> if h1 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> h2 , h3 , h4 , h5 = [ int ( input ( ) ) for _ in range ( 4 ) ] <NEWLINE> l = [ h1 , h2 , h3 , h4 , h5 ] <NEWLINE> if 1 and 2 and 3 in l : <NEWLINE> <INDENT> for _ in range ( 5 ) : print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> if l [ i ] == 1 : <NEWLINE> <INDENT> print ( <STRING> if 2 in l <STRING> ) <NEWLINE> <DEDENT> elif l [ i ] == 2 : <NEWLINE> <INDENT> print ( <STRING> if 3 in l <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if 1 in l <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> from io import StringIO <NEWLINE> readline = StringIO ( <STRING> ) . readline <NEWLINE> <NL> R , S , P = 1 , 2 , 3 <COMMENT> <NEWLINE> W , L , D = 1 , 2 , 3 <COMMENT> <NEWLINE> <NL> <NL> while True : <NEWLINE> <INDENT> hands = [ ] <NEWLINE> hands . append ( int ( readline ( ) ) ) <NEWLINE> if hands [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> hands . append ( int ( readline ( ) ) ) <NEWLINE> <NL> <DEDENT> hands_set = tuple ( sorted ( set ( hands ) ) ) <NEWLINE> for h in hands : <NEWLINE> <INDENT> print ( rps [ hands_set ] [ h ] ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> L = input ( ) <NEWLINE> if L = 0 : break <NEWLINE> flag = True <NEWLINE> for i in range ( 1 , 13 ) : <NEWLINE> <INDENT> M , N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> L -= ( M - N ) <NEWLINE> if L <= 0 and flag : <NEWLINE> <INDENT> print i <NEWLINE> flag = False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
global B <NEWLINE> def check ( B , x , y , c ) : <NEWLINE> <INDENT> if 0 < x < w + 2 and 0 < y < h + 2 and B [ y ] [ x ] == c : <NEWLINE> <INDENT> B [ y ] [ x ] = - 1 <NEWLINE> check ( B , x - 1 , y , c ) ; check ( B , x , y - 1 , c ) ; check ( B , x + 1 , y , c ) ; check ( B , x , y + 1 , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == 0 : break <NEWLINE> B = [ [ 0 ] * ( w + 2 ) for i in range ( h + 2 ) ] <NEWLINE> xs , ys = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> xg , yg = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> c , d , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if d == 0 : <NEWLINE> <INDENT> B [ y ] [ x : x + 4 ] = [ c ] * 4 <NEWLINE> B [ y + 1 ] [ x : x + 4 ] = [ c ] * 4 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> B [ y + j ] [ x : x + 2 ] = [ c ] * 2 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if B [ ys ] [ xs ] != B [ yg ] [ xg ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check ( B , xs , ys , B [ xs ] [ ys ] ) <NEWLINE> print <STRING> if B [ yg ] [ xg ] == - 1 else <STRING> <NEWLINE> <DEDENT> <DEDENT>
import Queue <NEWLINE> blockpos = [ [ [ 0 , 0 ] , [ 0 , 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] , [ [ 0 , 0 ] , [ 0 , 1 ] , [ 0 , 2 ] , [ 0 , 3 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 1 , 2 ] , [ 1 , 3 ] ] ] <NEWLINE> dxy = [ [ 0 , 1 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ - 1 , 0 ] ] <NEWLINE> q = Queue . Queue ( ) <NEWLINE> W , H = 0 , 0 <NEWLINE> <NL> def checker ( xs , ys , xg , yg , field , color ) : <NEWLINE> <INDENT> if color == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> global W , H <NEWLINE> x = xs <NEWLINE> y = ys <NEWLINE> while True : <NEWLINE> <INDENT> if x == xg and y == yg : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for dx , dy in dxy : <NEWLINE> <INDENT> if x + dx < 1 or y + dy < 1 or x + dx > H or y + dx > W : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ x + dx ] [ y + dy ] == color : <NEWLINE> <INDENT> field [ x + dx ] [ y + dy ] = 0 <NEWLINE> q . put ( [ x + dx , y + dy ] ) <NEWLINE> <DEDENT> <DEDENT> if q . empty ( ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> x , y = q . get ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <COMMENT> <NL> <INDENT> W , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ [ 0 for i in range ( W + 1 ) ] for j in range ( H + 1 ) ] <NEWLINE> xs , ys = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> xg , yg = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , d , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for dx , dy in blockpos [ d ] : <NEWLINE> <INDENT> field [ x + dx ] [ y + dy ] = c <NEWLINE> <DEDENT> <DEDENT> result = checker ( xs , ys , xg , yg , field , field [ xs ] [ ys ] ) <NEWLINE> if result : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while ( 1 ) : print ( oct ( n ) [ 2 : ] . translate ( str . maketrans ( <STRING> , <STRING> ) ) ) <NEWLINE>
newnum = [ ] <NEWLINE> j = 1 <NEWLINE> i = 0 <NEWLINE> while i < 1000000000 : <NEWLINE> <INDENT> num = str ( j ) <NEWLINE> nl = list ( num ) <NEWLINE> j += 1 <NEWLINE> if <STRING> in nl or <STRING> in nl : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> newnum . append ( nl ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <STRING> % <STRING> . join ( newnum [ n - 1 ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> <NL> index = 1 <NEWLINE> for n in range ( 1 , num ) : <NEWLINE> <INDENT> index += 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> str_index = str ( index ) <NEWLINE> if <STRING> in str_index or <STRING> in str_index : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( index ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = str ( cnt ) <NEWLINE> while <STRING> in tmp or <STRING> in tmp : <NEWLINE> <INDENT> if <STRING> in tmp and <STRING> in tmp : <NEWLINE> <INDENT> l = min ( tmp . find ( <STRING> ) , tmp . find ( <STRING> ) ) <NEWLINE> r = len ( tmp [ l + 1 : ] ) <NEWLINE> cnt += 1 * pow ( 10 , r ) <NEWLINE> <DEDENT> elif <STRING> in tmp : <NEWLINE> <INDENT> l = tmp . find ( <STRING> ) <NEWLINE> r = len ( tmp [ l + 1 : ] ) <NEWLINE> cnt += 1 * pow ( 10 , r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = tmp . find ( <STRING> ) <NEWLINE> r = len ( tmp [ l + 1 : ] ) <NEWLINE> cnt += 1 * pow ( 10 , r ) <NEWLINE> <DEDENT> tmp = str ( cnt ) <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> <DEDENT> print ( cnt - 1 ) <NEWLINE> <DEDENT>
inputlist = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> inputnum = int ( raw_input ( ) ) <NEWLINE> if ( inputnum == 0 ) : break <NEWLINE> inputlist . append ( inputnum ) <NEWLINE> <DEDENT> def octnpower ( num ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> maxi = 0 <NEWLINE> maxj = 0 <NEWLINE> if ( num < 8 ) : <NEWLINE> <INDENT> temp [ 0 ] = num <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> for j in range ( 1 , 8 ) : <NEWLINE> <INDENT> if ( num >= ( 8 ** i ) * j ) : <NEWLINE> <INDENT> flag = ( 8 ** i ) * j <NEWLINE> maxi = i <NEWLINE> maxj = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp [ maxi ] = maxj <NEWLINE> return octnpower ( num - flag ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> octdictionary = { 0 : 0 , 1 : 1 , 2 : 2 , 3 : 3 , 4 : 5 , 5 : 7 , 6 : 8 , 7 : 9 } <NEWLINE> for i in range ( len ( inputlist ) - 1 ) : <NEWLINE> <INDENT> temp = [ 0 ] * 10 <NEWLINE> octnpower ( inputlist [ i ] ) <NEWLINE> for i in range ( len ( temp ) ) : <NEWLINE> <INDENT> temp [ i ] = octdictionary [ temp [ i ] ] <NEWLINE> <DEDENT> temp . reverse ( ) <NEWLINE> for j in range ( len ( temp ) ) : <NEWLINE> <INDENT> index = j <NEWLINE> if ( temp [ j ] != 0 ) : break <NEWLINE> <DEDENT> temp = temp [ index : ] <NEWLINE> ansstr = <STRING> <NEWLINE> for j in range ( len ( temp ) ) : <NEWLINE> <INDENT> ansstr += str ( temp [ i ] ) <NEWLINE> <DEDENT> print ansstr <NEWLINE> <DEDENT>
def ge ( arr ) : <NEWLINE> <INDENT> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> tmp = int ( arr [ i ] ) <NEWLINE> if tmp >= 4 : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> if tmp >= 6 : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> arr [ i ] = str ( tmp ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( <STRING> . join ( ge ( list ( oct ( n ) ) [ 2 : ] ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c = 0 <NEWLINE> key = 0 <NEWLINE> while c < n : <NEWLINE> <INDENT> sc = list ( set ( str ( key + 1 ) ) ) <NEWLINE> if sc . count ( <STRING> ) or sc . count ( <STRING> ) : <NEWLINE> <INDENT> key += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> key += 1 <NEWLINE> <DEDENT> <DEDENT> print key <NEWLINE> <DEDENT>
def getxy ( pic ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for dy in range ( m ) : <NEWLINE> <INDENT> for dx in range ( m ) : <NEWLINE> <INDENT> if pic [ dy ] [ dx ] > - 1 : <NEWLINE> <INDENT> ans = str ( x + dx + 1 ) + <STRING> + str ( y + dy + 1 ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : break <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> scene = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> pic = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( m ) ] <NEWLINE> ans = <STRING> <NEWLINE> for rot in range ( 4 ) : <NEWLINE> <INDENT> if scene == pic : <NEWLINE> <INDENT> ans = getxy ( pic ) <NEWLINE> <DEDENT> for y in range ( n - m ) : <NEWLINE> <INDENT> for x in range ( n - m ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for dy in range ( m ) : <NEWLINE> <INDENT> for dx in range ( m ) : <NEWLINE> <INDENT> if pic [ dy ] [ dx ] > - 1 and scene [ y + dy ] [ x + dx ] - pic [ dy ] [ dx ] != 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : break <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> ans = getxy ( pic ) <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : break <NEWLINE> <DEDENT> if flag == 0 : break <NEWLINE> pic = [ [ pic [ j ] [ i ] for j in range ( m - 1 , - 1 , - 1 ) ] for i in range ( m ) ] <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
def hinan ( ) : <NEWLINE> <INDENT> ans , houi , vector = [ ] , [ [ 0 , 1 ] , [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ 1 , 0 ] ] , [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> while True : <NEWLINE> <INDENT> n = raw_input ( ) . split ( <STRING> ) <NEWLINE> if n == [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> for an in ans : <NEWLINE> <INDENT> print an <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xs = [ [ ] , [ ] , [ ] ] <NEWLINE> for i in range ( int ( n [ 1 ] ) ) : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> xs = [ xs [ l ] + [ [ [ i , j ] for j in range ( len ( n ) ) if n [ j ] != <STRING> ] , [ [ [ i , j ] , houi [ vector . index ( n [ j ] ) ] ] for j in range ( len ( n ) ) if n [ j ] in vector ] , [ [ i , j ] for j in range ( len ( n ) ) if n [ j ] == <STRING> ] ] [ l ] for l in range ( 3 ) ] <NEWLINE> <DEDENT> for time in range ( 181 ) : <NEWLINE> <INDENT> if len ( xs [ 1 ] ) == 0 : <NEWLINE> <INDENT> ans . append ( time ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in xs [ 1 ] : <NEWLINE> <INDENT> where = [ l [ 0 ] for l in xs [ 1 ] ] <NEWLINE> if len ( [ k for k in [ [ i [ 0 ] [ l ] + houi [ houi . index ( i [ 1 ] ) - 1 + j ] [ l ] for l in range ( 2 ) ] for j in range ( 4 ) ] if k in xs [ 0 ] and not k in where ] ) > 0 : <NEWLINE> <INDENT> i [ 1 ] = [ [ k for k in [ [ i [ 0 ] [ l ] + houi [ houi . index ( i [ 1 ] ) - 1 + j ] [ l ] for l in range ( 2 ) ] for j in range ( 4 ) ] if k in xs [ 0 ] and not k in where ] [ 0 ] [ s ] - i [ 0 ] [ s ] for s in range ( 2 ) ] <NEWLINE> <DEDENT> <DEDENT> go_point = [ [ i [ 0 ] [ l ] + i [ 1 ] [ l ] for l in range ( 2 ) ] for i in xs [ 1 ] ] <NEWLINE> for i in range ( len ( go_point ) ) : <NEWLINE> <INDENT> if go_point . count ( go_point [ i ] ) > 1 : <NEWLINE> <INDENT> if not go_point [ i ] in where : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if xs [ 1 ] [ i ] != [ [ go_point [ i ] [ l ] + houi [ j ] [ l ] for l in range ( 2 ) ] , houi [ j + 2 ] ] and [ [ go_point [ i ] [ l ] + houi [ j ] [ l ] for l in range ( 2 ) ] , houi [ j + 2 ] ] in xs [ 1 ] : <NEWLINE> <INDENT> go_point [ i ] = xs [ 1 ] [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> xs [ 1 ] = [ [ go_point [ i ] , xs [ 1 ] [ i ] [ 1 ] ] for i in range ( len ( xs [ 1 ] ) ) if not go_point [ i ] in xs [ 2 ] ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> hinan ( ) <NEWLINE>
import sys <NEWLINE> <NL> direction = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> step = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> vv = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> W , H = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> if W == 0 and H == 0 : break <NEWLINE> m = [ list ( sys . stdin . readline ( ) . strip ( ) ) for i in xrange ( H ) ] <NEWLINE> people = [ ( i , j , direction [ m [ i ] [ j ] ] ) for i in xrange ( H ) for j in range ( W ) <NEWLINE> <INDENT> if m [ i ] [ j ] in <STRING> ] <NEWLINE> <DEDENT> time = 0 <NEWLINE> while any ( people ) : <NEWLINE> <INDENT> time += 1 <NEWLINE> if time > 180 : <NEWLINE> <INDENT> time = - 1 <NEWLINE> break <NEWLINE> <DEDENT> sched = [ ] <NEWLINE> for n in xrange ( len ( people ) ) : <NEWLINE> <INDENT> if people [ n ] is None : continue <NEWLINE> x , y , d = people [ n ] <NEWLINE> for i in range ( 1 , - 3 , - 1 ) : <NEWLINE> <INDENT> dx , dy = step [ ( d + i ) % 4 ] <NEWLINE> if 0 <= x + dx < H and 0 <= y + dy < W and m [ x + dx ] [ y + dy ] in <STRING> : <NEWLINE> <INDENT> people [ n ] [ 2 ] = ( d + i ) % 4 <NEWLINE> beat = True <NEWLINE> for k in range ( len ( sched ) ) : <NEWLINE> <INDENT> xx , yy , dd = sched [ k ] [ 1 : ] <NEWLINE> if ( x + dx , y + dy ) == ( xx , yy ) : <NEWLINE> <INDENT> if dd < ( d + i ) % 4 : <NEWLINE> <INDENT> sched [ k ] = ( n , x + dx , y + dy , ( d + i ) % 4 ) <NEWLINE> beat = False <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> beat = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if beat : <NEWLINE> <INDENT> sched . append ( ( n , x + dx , y + dy , ( d + i ) % 4 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for ( k , x , y , d ) in sched : <NEWLINE> <INDENT> m [ people [ k ] [ 0 ] ] [ people [ k ] [ 1 ] ] = <STRING> <NEWLINE> if m [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> people [ k ] = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m [ x ] [ y ] = <STRING> <NEWLINE> people [ k ] = x , y , d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if time >= 0 : <NEWLINE> <INDENT> vv . append ( time ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vv . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for v in vv : <NEWLINE> <INDENT> print v <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> _data = copy . deepcopy ( data ) <NEWLINE> while 1 < len ( _data ) : <NEWLINE> <INDENT> d1 , v1 = _data [ 0 ] <NEWLINE> d2 , v2 = _data [ 1 ] <NEWLINE> l = f1 ( v1 , v2 ) <NEWLINE> v = l <NEWLINE> m1 , m2 = list ( f2 ( l , v1 , v2 ) ) <NEWLINE> d = f1 ( d1 * m1 , d2 * m2 ) <NEWLINE> for i in range ( 2 ) : del _data [ 0 ] <NEWLINE> _data . append ( [ d , v ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> f3 ( _data [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def f1 ( a , b ) : <NEWLINE> <INDENT> x , y = ( a , b ) if a >= b else ( b , a ) <NEWLINE> g = gcd ( x , y ) <NEWLINE> return lcm ( x , y , g ) <NEWLINE> <NL> <DEDENT> def f2 ( l , * s ) : <NEWLINE> <INDENT> for v in s : <NEWLINE> <INDENT> yield l / v <NEWLINE> <NL> <DEDENT> <DEDENT> def f3 ( _data ) : <NEWLINE> <INDENT> d1 , v1 = _data <NEWLINE> for d2 , v2 in data : <NEWLINE> <INDENT> ans = str ( ( float ( d1 ) / v1 ) / ( float ( d2 ) / v2 ) ) <NEWLINE> print int ( ans [ : - 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def gcd ( x , y ) : <NEWLINE> <INDENT> while y != 0 : <NEWLINE> <INDENT> x = x - ( x / y ) * y <NEWLINE> x , y = y , x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return x <NEWLINE> <NL> <DEDENT> <DEDENT> def lcm ( x , y , g ) : <NEWLINE> <INDENT> return ( x * y ) / g <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> data = [ map ( int , line . rstrip ( ) . split ( ) ) for line in open ( <STRING> ) ] <NEWLINE> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import heapq <NEWLINE> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> c , n , m , s , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if not ( c or n or m or s or d ) : break <NEWLINE> field = { } <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> a , b , f = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> field [ ( a , b ) ] = f ; <NEWLINE> field [ ( b , a ) ] = f ; <NEWLINE> <DEDENT> visited = { } <NEWLINE> q = [ ] <NEWLINE> heapq . heappush ( q , ( 0 , c , s ) ) <NEWLINE> while q : <NEWLINE> <INDENT> cost , rem , pos = heapq . heappop ( q ) <NEWLINE> if pos == d : <NEWLINE> <INDENT> print cost <NEWLINE> break <NEWLINE> <DEDENT> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> edge = ( pos , i ) <NEWLINE> if edge in field : <NEWLINE> <INDENT> next = ( rem , i ) <NEWLINE> ncost = cost + field [ edge ] <NEWLINE> if not next in visited or visited [ next ] < ncost : <NEWLINE> <INDENT> heapq . heappush ( q , ( ncost , rem , i ) ) <NEWLINE> visited [ next ] = ncost <NEWLINE> <DEDENT> if rem > 0 : <NEWLINE> <INDENT> next = ( rem - 1 , pos ) <NEWLINE> ncost = cost + field [ edge ] / 2 <NEWLINE> if not next in visited or visited [ next ] < ncost : <NEWLINE> <INDENT> heapq . heappush ( q , ( ncost , rem - 1 , i ) ) <NEWLINE> visited [ next ] = ncost <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def dijkstra ( nodes , start , matrix ) : <NEWLINE> <INDENT> defnode = [ False ] * ( nodes ) <NEWLINE> cost = [ sys . maxint ] * ( nodes ) <NEWLINE> cost [ start ] = 0 <NEWLINE> node = start <NEWLINE> counter = 0 <NEWLINE> while True : <NEWLINE> <INDENT> counter += 1 <NEWLINE> if counter == nodes : <NEWLINE> <INDENT> return cost <NEWLINE> <DEDENT> defnode [ node ] = True <NEWLINE> for i in xrange ( 1 , nodes ) : <NEWLINE> <INDENT> if defnode [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if matrix [ node ] [ i ] == sys . maxint : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost [ i ] = min ( cost [ i ] , cost [ node ] + matrix [ node ] [ i ] ) <NEWLINE> <DEDENT> minnode = sys . maxint <NEWLINE> mincost = sys . maxint <NEWLINE> for i in xrange ( 1 , nodes ) : <NEWLINE> <INDENT> if defnode [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if cost [ i ] < mincost : <NEWLINE> <INDENT> minnode = i <NEWLINE> mincost = cost [ i ] <NEWLINE> <DEDENT> <DEDENT> node = minnode <NEWLINE> <NL> <DEDENT> <DEDENT> def get_state ( a , c , k ) : <NEWLINE> <INDENT> return ( a - 1 ) * ( c + 1 ) + k <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> c , n , m , s , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> matrix = [ [ sys . maxint ] * n * ( c + 1 ) for i in xrange ( n * ( c + 1 ) ) ] <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> a , b , f = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> for i in xrange ( c + 1 ) : <NEWLINE> <INDENT> matrix [ get_state ( a , c , i ) ] [ get_state ( b , c , i ) ] = f <NEWLINE> matrix [ get_state ( b , c , i ) ] [ get_state ( a , c , i ) ] = f <NEWLINE> <COMMENT> <NL> <DEDENT> for i in xrange ( c ) : <NEWLINE> <INDENT> matrix [ get_state ( a , c , i ) ] [ get_state ( b , c , i + 1 ) ] = f / 2 <NEWLINE> matrix [ get_state ( b , c , i ) ] [ get_state ( a , c , i + 1 ) ] = f / 2 <NEWLINE> <DEDENT> <DEDENT> costs = dijkstra ( n * ( c + 1 ) , get_state ( s , c , 0 ) , matrix ) <NEWLINE> mincost = sys . maxint <NEWLINE> for i in xrange ( c + 1 ) : <NEWLINE> <INDENT> mincost = min ( mincost , costs [ get_state ( d , c , i ) ] ) <NEWLINE> <DEDENT> print mincost <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> m = 0 <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , d1 , d2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> t = d1 + d2 <NEWLINE> m = max ( m , t ) <NEWLINE> dic [ t ] = p <NEWLINE> <DEDENT> print dic [ m ] , m <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break ; <NEWLINE> solve ( n ) <NEWLINE> <DEDENT> <DEDENT> def solve ( n ) : <NEWLINE> <INDENT> a = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> a . append ( Pair ( tmp [ 0 ] , tmp [ 1 ] + tmp [ 2 ] ) ) <NEWLINE> <DEDENT> a . sort ( ) <NEWLINE> print a [ - 1 ] . x , a [ - 1 ] . y <NEWLINE> <DEDENT> class Pair : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <DEDENT> def __cmp__ ( self , a ) : <NEWLINE> <INDENT> return self . y - a . y <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : main ( ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> r = { } <NEWLINE> n = input ( ) <NEWLINE> l = m = 0 <NEWLINE> for i in [ 1 ] * n : <NEWLINE> <INDENT> p , d1 , d2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d = d1 + d2 <NEWLINE> if d > m : l , m = p , d <NEWLINE> <DEDENT> print l , m <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , d1 , d2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l . append ( [ p , d1 + d2 ] ) <NEWLINE> <DEDENT> l . sort ( reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> print l [ 0 ] [ 0 ] , l [ 0 ] [ 1 ] <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m , e , j = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = sum ( m , e , j ) <NEWLINE> if 100 in [ m , e , j ] or m + e >= 180 or a >= 240 : print <STRING> <NEWLINE> elif a >= 210 or ( a >= 150 and max ( m , e ) >= 80 ) : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> m , e , j = map ( int , input ( ) . split ( ) ) <NEWLINE> if m == 100 or e == 100 or j == 100 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif ( m + e ) / 2 >= 90 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif ( m + e + j ) / 3 >= 80 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif ( m + e + j ) / 3 >= 70 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif ( m + e + j ) / 3 >= 50 : <NEWLINE> <INDENT> if m >= 80 or e >= 80 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
for s in sys . stdin : <NEWLINE> <INDENT> s = map ( int , s . split ( ) ) <NEWLINE> if len ( s ) == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ( pm , pe , pj ) = tuple ( s ) <NEWLINE> if 100 in ( pm , pe , pj ) : c = <STRING> <NEWLINE> elif pm + pe >= 180 : c = <STRING> <NEWLINE> elif pm + pe + pj >= 240 : c = <STRING> <NEWLINE> elif pm + pe + pj >= 240 : c = <STRING> <NEWLINE> elif pm + pe + pj >= 150 and ( pm >= 80 or pe >= 80 ) : c = <STRING> <NEWLINE> else : c = <STRING> <NEWLINE> <DEDENT> print c <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == <STRING> : break <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = sum ( a ) <NEWLINE> if sum ( a [ : 2 ] ) / 2 >= 90 or c / 3 >= 80 or 100 in a : b = <STRING> <NEWLINE> elif c / 3 >= 70 or ( c / 3 >= 50 and ( a [ 0 ] >= 80 or a [ 1 ] >= 80 ) ) : b = <STRING> <NEWLINE> else : b = <STRING> <NEWLINE> print ( b ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> L = [ 0 ] * 10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> L [ input ( ) ] += 1 <NEWLINE> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> print <STRING> * L [ i ] if L [ i ] != 0 else <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> q = { } <NEWLINE> a = input ( ) <NEWLINE> if a == 0 : break <NEWLINE> for i in range ( 10 ) : q [ i ] = 0 <NEWLINE> for i in range ( a ) : q [ input ( ) ] += 1 <NEWLINE> for i in range ( 10 ) : print <STRING> * q [ i ] if q [ i ] != 0 else <STRING> <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = [ 0 ] * 10 <NEWLINE> <NL> for a in range ( n ) : <NEWLINE> <INDENT> t = int ( raw_input ( ) ) <NEWLINE> data [ t ] += 1 <NEWLINE> <NL> <DEDENT> for a in range ( 10 ) : <NEWLINE> <INDENT> if data [ a ] == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for t in range ( data [ a ] ) : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> x = [ 0 for i in range ( 10 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> x [ a ] += 1 <NEWLINE> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> if x [ i ] == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( x [ i ] * <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <COMMENT> <NL> <INDENT> a = input ( ) <NEWLINE> if a < 0 : break <NEWLINE> s , s2 = <STRING> , <STRING> <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> <NL> while b != 0 and cnt <= 4 : <NEWLINE> <INDENT> b *= 2 <NEWLINE> s2 += str ( b / 10 ) <NEWLINE> b %= 10 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> s2 = <STRING> * 4 <NEWLINE> <NL> if len ( s2 ) <= 4 : <NEWLINE> <INDENT> print <STRING> % ( int ( format ( int ( a ) , <STRING> ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> M , N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if M == N == 0 : break <NEWLINE> m = [ i for i in range ( 1 , M + 1 ) ] <NEWLINE> index = 0 <NEWLINE> num = 1 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if num % 15 == 0 : <NEWLINE> <INDENT> if line != <STRING> : <NEWLINE> <INDENT> del m [ index ] <NEWLINE> <DEDENT> <DEDENT> elif num % 3 == 0 : <NEWLINE> <INDENT> if line != <STRING> : <NEWLINE> <INDENT> del m [ index ] <NEWLINE> <DEDENT> <DEDENT> elif num % 5 == 0 : <NEWLINE> <INDENT> if line != <STRING> : <NEWLINE> <INDENT> del m [ index ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not line . isdigit ( ) : <NEWLINE> <INDENT> del m [ index ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( line ) != num : <NEWLINE> <INDENT> del m [ index ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( m ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif index + 1 >= len ( m ) : <NEWLINE> <INDENT> index = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> num += 1 <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , m ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n [ 0 ] == n [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m , o = [ 1 for x in range ( n [ 0 ] ) ] , 0 <NEWLINE> <NL> for x in range ( 1 , n [ 1 ] + 1 ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if sum ( m ) == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif x % 15 == 0 : <NEWLINE> <INDENT> if a != <STRING> : <NEWLINE> <INDENT> m [ o ] = 0 <NEWLINE> <DEDENT> <DEDENT> elif x % 3 == 0 : <NEWLINE> <INDENT> if a != <STRING> : <NEWLINE> <INDENT> m [ o ] = 0 <NEWLINE> <DEDENT> <DEDENT> elif x % 5 == 0 : <NEWLINE> <INDENT> if a != <STRING> : <NEWLINE> <INDENT> m [ o ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if a != str ( x ) : <NEWLINE> <INDENT> m [ o ] = 0 <NEWLINE> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> o += 1 <NEWLINE> if sum ( m ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif o == len ( m ) : <NEWLINE> <INDENT> o = - 1 <NEWLINE> <DEDENT> elif m [ o ] == 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( n [ 0 ] ) : <NEWLINE> <INDENT> if m [ x ] == 1 : <NEWLINE> <INDENT> print x + 1 , <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
def fizzbuzz ( n ) : <NEWLINE> <INDENT> if n % 15 == 0 : return <STRING> <NEWLINE> if n % 5 == 0 : return <STRING> <NEWLINE> if n % 3 == 0 : return <STRING> <NEWLINE> return str ( n ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> player = range ( 1 , m + 1 ) <NEWLINE> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if len ( player ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if fizzbuzz ( i + 1 ) != raw_input ( ) : <NEWLINE> <INDENT> del player [ p ] <NEWLINE> p %= len ( player ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = ( p + 1 ) % len ( player ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , player ) ) <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> [ m , n ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> truenum = 0 <NEWLINE> player = [ x for x in range ( 1 , m + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if len ( player ) > 1 : <NEWLINE> <INDENT> shout = raw_input ( ) <NEWLINE> pnow = player . pop ( 0 ) <NEWLINE> truenum = truenum + 1 <NEWLINE> if truenum % 15 == 0 : <NEWLINE> <INDENT> if shout == <STRING> : <NEWLINE> <INDENT> player . append ( pnow ) <NEWLINE> <DEDENT> <DEDENT> elif truenum % 5 == 0 : <NEWLINE> <INDENT> if shout == <STRING> : <NEWLINE> <INDENT> player . append ( pnow ) <NEWLINE> <DEDENT> <DEDENT> elif truenum % 3 == 0 : <NEWLINE> <INDENT> if shout == <STRING> : <NEWLINE> <INDENT> player . append ( pnow ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if shout == str ( truenum ) : <NEWLINE> <INDENT> player . append ( pnow ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( [ str ( x ) for x in sorted ( player ) ] ) <NEWLINE> <DEDENT> <DEDENT>
def Judge ( i ) : <NEWLINE> <INDENT> if i % 15 == 0 : return <STRING> <NEWLINE> if i % 5 == 0 : return <STRING> <NEWLINE> if i % 3 == 0 : return <STRING> <NEWLINE> return str ( i ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> L = range ( 1 , m + 1 ) <NEWLINE> j = 0 <NEWLINE> if m == n == 0 : break <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> c = raw_input ( ) <NEWLINE> if len ( L ) == 1 : break <NEWLINE> <INDENT> if Judge ( i ) != c : <NEWLINE> <INDENT> del L [ j ] <NEWLINE> j %= len ( L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = ( j + 1 ) % len ( L ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , L ) ) <NEWLINE> <DEDENT>
move = [ [ [ 10 , 10 ] , [ 4 , 4 ] ] , [ [ 8 , 2 ] , [ 4 , 2 ] ] ] <NEWLINE> <NL> MAX_N = 10000000 + 1 <NEWLINE> sos = [ 1 ] * ( MAX_N + 1 ) <NEWLINE> sos [ 0 ] = sos [ 1 ] = 0 <NEWLINE> for i in range ( 2 , int ( MAX_N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if sos [ i ] : <NEWLINE> <INDENT> for j in range ( i + i , MAX_N + 1 , i ) : <NEWLINE> <INDENT> sos [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> if not n : break <NEWLINE> n -= ( n % 2 == 0 ) <NEWLINE> while n >= 13 : <NEWLINE> <INDENT> if sos [ n ] and sos [ n - 2 ] and sos [ n - 6 ] and sos [ n - 8 ] : <NEWLINE> <INDENT> print ( n ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n -= move [ sos [ n - 8 ] ] [ sos [ n - 6 ] ] [ sos [ n - 2 ] ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
primes = [ 0 , 0 ] + [ 1 ] * 9999999 <NEWLINE> for i in range ( 2 , 3163 ) : <NEWLINE> <INDENT> for j in range ( i * i , 10000001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 5 , n + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> if primes [ i ] and primes [ i - 2 ] and primes [ i - 6 ] and primes [ i - 8 ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = 10000000 <NEWLINE> p = [ 1 ] * ( n + 1 ) <NEWLINE> p [ 0 ] , p [ 1 ] = 0 , 0 <NEWLINE> for i in range ( 2 , int ( n ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , n + 1 , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> for i in range ( n , 2 , - 1 ) : <NEWLINE> <INDENT> if ( p [ i ] , p [ i - 2 ] , p [ i - 6 ] , p [ i - 8 ] ) == ( 1 , 1 , 1 , 1 ) : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_quad ( n , p ) : <NEWLINE> <INDENT> for ni in range ( n , 0 , - 1 ) : <NEWLINE> <INDENT> if p [ ni ] and p [ ni - 2 ] and p [ ni - 6 ] and p [ ni - 8 ] : <NEWLINE> <INDENT> return ni <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def sieve ( ) : <NEWLINE> <INDENT> n = 10000001 <NEWLINE> p = [ 1 ] * n <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> <NL> for i in range ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , len ( p ) , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> prime = sieve ( ) <NEWLINE> while True : <NEWLINE> <INDENT> n = f . readline ( ) <NEWLINE> if not n . isnumeric ( ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n = int ( n ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( get_quad ( ni , prime ) ) <NEWLINE> <DEDENT>
r = 10000001 <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> for i in range ( int ( r ** 0.5 ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i : : i ] = [ 0 for j in range ( 2 * i , r , i ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> n -= 1 - n % 2 <NEWLINE> while any ( not p [ n - i ] for i in [ 0 , 2 , 6 , 8 ] ) : <NEWLINE> <INDENT> n -= 2 <NEWLINE> <DEDENT> print n <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
primes = [ 0 , 0 ] + [ 1 ] * 9999999 <NEWLINE> for i in range ( 2 , 3163 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 10000001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 5 , n + 1 ) [ : : - 1 ] : <NEWLINE> <INDENT> if primes [ i - 8 ] & primes [ i - 6 ] & primes [ i - 2 ] & primes [ i ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def get_quad ( n , p ) : <NEWLINE> <INDENT> if n < 19 : <NEWLINE> <INDENT> return 13 <NEWLINE> <DEDENT> n = ( n + 1 ) // 10 * 10 - 1 <NEWLINE> for ni in range ( n , 0 , - 10 ) : <NEWLINE> <INDENT> if p [ ni ] and p [ ni - 2 ] and p [ ni - 6 ] and p [ ni - 8 ] : <NEWLINE> <INDENT> return ni <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def sieve ( ) : <NEWLINE> <INDENT> n = 10000001 <NEWLINE> p = [ 1 ] * n <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> <NL> for i in range ( int ( n ** 0.5 ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( 2 * i , len ( p ) , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return p <NEWLINE> <NL> <DEDENT> prime = sieve ( ) <NEWLINE> while True : <NEWLINE> <INDENT> n = f . readline ( ) . strip ( ) <NEWLINE> if not n . isdigit ( ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> n = int ( n ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( get_quad ( n , prime ) ) <NEWLINE> <DEDENT>
primes = [ 0 , 0 ] + [ 1 ] * 9999999 <NEWLINE> for i in range ( 2 , 3163 ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , 10000001 , i ) : <NEWLINE> <INDENT> primes [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while not ( primes [ n ] & primes [ n - 2 ] & primes [ n - 6 ] & primes [ n - 8 ] ) : <NEWLINE> <INDENT> n -= 1 <NEWLINE> <DEDENT> print ( n ) <NEWLINE> <DEDENT>
from line_profiler import LineProfiler <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> W , H = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> if not W : break <NEWLINE> tx , ty = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> kx , ky = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> ma = [ [ False ] * ( W + 2 ) for _ in range ( H + 2 ) ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j , a in enumerate ( stdin . readline ( ) . split ( ) ) : <NEWLINE> <INDENT> ma [ i ] [ j + 1 ] = bool ( 1 - int ( a ) ) <NEWLINE> <DEDENT> <DEDENT> que = deque ( [ [ tx , ty , kx , ky , 0 ] ] ) <NEWLINE> pas = set ( ) <NEWLINE> ans = <STRING> <NEWLINE> while ( que ) : <NEWLINE> <INDENT> tx , ty , kx , ky , c = que . popleft ( ) <NEWLINE> if tx == kx and ty == ky : <NEWLINE> <INDENT> ans = c <NEWLINE> break <NEWLINE> <DEDENT> for dx , dy in [ [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> tdx , tdy = ( dx , dy ) if ma [ ty + dy ] [ tx + dx ] else ( 0 , 0 ) <NEWLINE> kdx , kdy = ( - dx , - dy ) if ma [ ky - dy ] [ kx - dx ] else ( 0 , 0 ) <NEWLINE> ttx , tty , kkx , kky = tx + tdx , ty + tdy , kx + kdx , ky + kdy <NEWLINE> if ( ttx , tty , kkx , kky ) in pas : continue <NEWLINE> if c + 1 > 100 : continue <NEWLINE> que . append ( [ ttx , tty , kkx , kky , c + 1 ] ) <NEWLINE> pas . add ( ( ttx , tty , kkx , kky ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> prf = LineProfiler ( ) <NEWLINE> prf . add_function ( main ) <NEWLINE> prf . runcall ( main ) <NEWLINE> prf . print_stats ( ) <NEWLINE> <COMMENT> <NL> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> W , H = map ( int , sys . stdin ( ) . split ( ) ) <NEWLINE> if not W : break <NEWLINE> tx , ty = map ( int , sys . stdin ( ) . split ( ) ) <NEWLINE> kx , ky = map ( int , sys . stdin ( ) . split ( ) ) <NEWLINE> ma = [ [ False ] * ( W + 2 ) for _ in range ( H + 2 ) ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j , a in enumerate ( sys . stdin ( ) . split ( ) ) : <NEWLINE> <INDENT> ma [ i ] [ j + 1 ] = bool ( 1 - int ( a ) ) <NEWLINE> <DEDENT> <DEDENT> que = deque ( [ [ tx , ty , kx , ky , 0 ] ] ) <NEWLINE> pas = set ( ) <NEWLINE> ans = <STRING> <NEWLINE> while ( que ) : <NEWLINE> <INDENT> tx , ty , kx , ky , c = que . popleft ( ) <NEWLINE> if c > 100 : break <NEWLINE> if tx == kx and ty == ky : <NEWLINE> <INDENT> ans = c <NEWLINE> break <NEWLINE> <DEDENT> for dx , dy in [ [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> tdx , tdy = [ dx , dy ] if ma [ ty + dy ] [ tx + dx ] else [ 0 , 0 ] <NEWLINE> kdx , kdy = [ - dx , - dy ] if ma [ ky - dy ] [ kx - dx ] else [ 0 , 0 ] <NEWLINE> if ( tx + tdx , ty + tdy , kx + kdx , ky + kdy ) in pas : continue <NEWLINE> que . append ( [ tx + tdx , ty + tdy , kx + kdx , ky + kdy , c + 1 ] ) <NEWLINE> pas . add ( ( tx + tdx , ty + tdy , kx + kdx , ky + kdy ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> main ( ) <NEWLINE> <DEDENT>
from line_profiler import LineProfiler <NEWLINE> from collections import deque <NEWLINE> from sys import stdin <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> W , H = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> if not W : break <NEWLINE> tx , ty = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> kx , ky = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> ma = [ [ False ] * ( W + 2 ) for _ in range ( H + 2 ) ] <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j , a in enumerate ( stdin . readline ( ) . split ( ) ) : <NEWLINE> <INDENT> ma [ i ] [ j + 1 ] = bool ( 1 - int ( a ) ) <NEWLINE> <DEDENT> <DEDENT> que = deque ( [ [ tx , ty , kx , ky , 0 ] ] ) <NEWLINE> pas = set ( ) <NEWLINE> ans = <STRING> <NEWLINE> while ( que ) : <NEWLINE> <INDENT> tx , ty , kx , ky , c = que . popleft ( ) <NEWLINE> if tx == kx and ty == ky : <NEWLINE> <INDENT> ans = c <NEWLINE> break <NEWLINE> <DEDENT> for dx , dy in [ [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> tdx , tdy = [ dx , dy ] if ma [ ty + dy ] [ tx + dx ] else [ 0 , 0 ] <NEWLINE> kdx , kdy = [ - dx , - dy ] if ma [ ky - dy ] [ kx - dx ] else [ 0 , 0 ] <NEWLINE> if ( tx + tdx , ty + tdy , kx + kdx , ky + kdy ) in pas : continue <NEWLINE> if c + 1 > 100 : continue <NEWLINE> que . append ( [ tx + tdx , ty + tdy , kx + kdx , ky + kdy , c + 1 ] ) <NEWLINE> pas . add ( ( tx + tdx , ty + tdy , kx + kdx , ky + kdy ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> prf = LineProfiler ( ) <NEWLINE> prf . add_function ( main ) <NEWLINE> prf . runcall ( main ) <NEWLINE> prf . print_stats ( ) <NEWLINE> <COMMENT> <NL> <DEDENT>
direc = ( ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> while 1 : <NEWLINE> <INDENT> X , Y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if X == 0 : break <NEWLINE> <NL> ftx , fty = list ( map ( lambda x : x - 1 , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> fkx , fky = list ( map ( lambda x : x - 1 , map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> m = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( Y ) ] <NEWLINE> <NL> d = { ( ftx , fty , fkx , fky ) : 0 } <NEWLINE> <NL> s = [ [ 0 , ( ftx , fty , fkx , fky ) ] ] <NEWLINE> res = <STRING> <NEWLINE> while len ( s ) > 0 : <NEWLINE> <INDENT> spm = s . pop ( 0 ) <NEWLINE> cnt = spm [ 0 ] + 1 <NEWLINE> if cnt > 100 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> def search_move ( ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> tx = spm [ 1 ] [ 0 ] + direc [ i ] [ 0 ] <NEWLINE> ty = spm [ 1 ] [ 1 ] + direc [ i ] [ 1 ] <NEWLINE> kx = spm [ 1 ] [ 2 ] - direc [ i ] [ 0 ] <NEWLINE> ky = spm [ 1 ] [ 3 ] - direc [ i ] [ 1 ] <NEWLINE> <NL> <NL> hm = 0 <NEWLINE> if tx < 0 or tx >= X or ty < 0 or ty >= Y or m [ ty ] [ tx ] == 1 : <NEWLINE> <INDENT> tx = ftx <NEWLINE> ty = fty <NEWLINE> hm += 1 <NEWLINE> <DEDENT> if kx < 0 or kx >= X or ky < 0 or ky >= Y or m [ ky ] [ kx ] == 1 : <NEWLINE> <INDENT> kx = fkx <NEWLINE> ky = fky <NEWLINE> hm += 1 <NEWLINE> <NL> <DEDENT> hm == 2 : continue <NEWLINE> tpl = ( tx , ty , kx , ky ) <NEWLINE> if tpl in d and d [ tpl ] <= cnt : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> if tx == kx and ty == ky : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( [ cnt , tpl ] ) <NEWLINE> d [ tpl ] = cnt <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> if search_move ( ) : <NEWLINE> <INDENT> res = str ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
import Queue <NEWLINE> INF = 1 << 29 <NEWLINE> class Edge : <NEWLINE> <INDENT> def __init__ ( self , _v , _cost ) : <NEWLINE> <INDENT> self . v = _v <NEWLINE> self . cost = _cost <NEWLINE> <DEDENT> <DEDENT> def parse ( s , m , n ) : <NEWLINE> <INDENT> if ( s [ 0 ] == <STRING> ) : return int ( s . translate ( None , <STRING> ) ) - 1 <NEWLINE> elif ( s [ 0 ] == <STRING> ) : return int ( s . translate ( None , <STRING> ) ) - 1 + m <NEWLINE> elif ( s [ 0 ] == <STRING> ) : return m + n <NEWLINE> else : return m + n + 1 <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> m , n , k , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m == 0 and n == 0 and k == 0 and d == 0 : break <NEWLINE> cake = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> G = [ [ ] for i in range ( m + n + 2 ) ] <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> dist = raw_input ( ) . split ( ) <NEWLINE> u = parse ( dist [ 0 ] , m , n ) <NEWLINE> v = parse ( dist [ 1 ] , m , n ) <NEWLINE> G [ v ] . append ( Edge ( u , int ( dist [ 2 ] ) ) ) <NEWLINE> G [ u ] . append ( Edge ( v , int ( dist [ 2 ] ) ) ) <NEWLINE> <DEDENT> D = [ [ 0 for col in range ( 1 << 6 ) ] for row in range ( 108 ) ] <NEWLINE> for i in range ( m + n + 2 ) : <NEWLINE> <INDENT> for j in range ( 1 << m ) : <NEWLINE> <INDENT> D [ i ] [ j ] = INF <NEWLINE> <DEDENT> <DEDENT> D [ m + n ] [ 0 ] = 0 <NEWLINE> ans = INF <NEWLINE> que = Queue . PriorityQueue ( ) <NEWLINE> que . put ( [ 0 , [ m + n , 0 ] ] ) <NEWLINE> while not que . empty ( ) : <NEWLINE> <INDENT> item = que . get ( ) <NEWLINE> d_now = - item [ 0 ] <NEWLINE> u = item [ 1 ] [ 0 ] <NEWLINE> s = item [ 1 ] [ 1 ] <NEWLINE> if D [ u ] [ s ] < d_now : continue <NEWLINE> if u == m + n + 1 : ans = min ( ans , d_now ) <NEWLINE> for i in range ( len ( G [ u ] ) ) : <NEWLINE> <INDENT> v = G [ u ] [ i ] . v <NEWLINE> if v < m : <NEWLINE> <INDENT> if s & 1 << v != 0 : continue <NEWLINE> s2 = s | 1 << v <NEWLINE> d2 = d_now + k * G [ u ] [ i ] . cost - cake [ v ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s2 = s <NEWLINE> d2 = d_now + k * G [ u ] [ i ] . cost <NEWLINE> <DEDENT> if d2 < D [ v ] [ s2 ] : <NEWLINE> <INDENT> D [ v ] [ s2 ] = d2 <NEWLINE> que . put ( [ - d2 , [ v , s2 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
alphabets = { } <NEWLINE> alphabets_num = { } <NEWLINE> vartexs = [ ] <NEWLINE> fail_check = { } <NEWLINE> <NL> class Vartex ( ) : <NEWLINE> <INDENT> def __init__ ( self , string ) : <NEWLINE> <INDENT> global alphabets <NEWLINE> self . ID = string <NEWLINE> self . link = [ ] <NEWLINE> self . arrival = 0 <NEWLINE> alphabets [ string [ 0 ] ] . append ( self ) <NEWLINE> alphabets_num [ string [ 0 ] ] += 1 <NEWLINE> return <NEWLINE> <NL> <DEDENT> def register ( self , new_vartex ) : <NEWLINE> <INDENT> self . link . append ( new_vartex ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> def check_all ( vartexs ) : <NEWLINE> <INDENT> for content in vartexs : <NEWLINE> <INDENT> if not content . arrival : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def dfs ( start_vartex ) : <NEWLINE> <INDENT> global vartexs <NEWLINE> start_vartex . arrival = 1 <NEWLINE> for link_vartex in start_vartex . link : <NEWLINE> <INDENT> if link_vartex . arrival : <NEWLINE> <INDENT> if check_all ( vartexs ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dfs ( link_vartex ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> <DEDENT> start_vartex . arrival = 0 <NEWLINE> return False <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> alphabets = { } <NEWLINE> alphabets_num = { } <NEWLINE> vartexs = [ ] <NEWLINE> fail_check = { } <NEWLINE> for al in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> alphabets [ chr ( al ) ] = [ ] <NEWLINE> alphabets_num [ chr ( al ) ] = 0 <NEWLINE> fail_check [ chr ( al ) ] = 0 <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> vartexs . append ( Vartex ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> for x in range ( n ) : <NEWLINE> <INDENT> vartex = vartexs [ x ] <NEWLINE> string = vartex . ID <NEWLINE> fail_check [ string [ - 1 ] ] += 1 <NEWLINE> for content in alphabets [ string [ - 1 ] ] : <NEWLINE> <INDENT> vartex . register ( content ) <NEWLINE> <NL> <DEDENT> <DEDENT> if alphabets_num != fail_check : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = vartexs [ 0 ] <NEWLINE> if dfs ( start ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> r , a = input ( ) . split ( ) <NEWLINE> if r == a == 0 : break <NEWLINE> print ( sum ( 1 for i , j in zip ( r , a ) if i == j ) , sum ( 1 for i in range ( len ( r ) ) for j in range ( len ( a ) ) if r [ i ] == a [ j ] and i != j ) ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <NL> <NL> <INDENT> while True : <NEWLINE> <NL> <INDENT> a , b = map ( str , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = list ( a ) <NEWLINE> b = list ( b ) <NEWLINE> <COMMENT> <NL> <NL> <NL> br = 0 <NEWLINE> hit = 0 <NEWLINE> for i , data in enumerate ( b ) : <NEWLINE> <NL> <INDENT> if data in a : <NEWLINE> <INDENT> if a [ i ] == data : <NEWLINE> <INDENT> hit += 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> br += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print hit , br <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> aw = [ ] <NEWLINE> ar = raw_input ( ) <NEWLINE> if ar [ 0 ] == 0 and ar [ 1 ] == 0 and ar [ 2 ] == 0 : break <NEWLINE> else : <NEWLINE> <INDENT> hit = 0 <NEWLINE> blo = 0 <NEWLINE> for t in range ( 5 , 9 ) : <NEWLINE> <INDENT> aw . append ( ar [ t ] ) <NEWLINE> <DEDENT> for t in range ( 0 , 4 ) : <NEWLINE> <INDENT> if ar [ t ] == aw [ t ] : hit += 1 <NEWLINE> <DEDENT> for t in range ( 0 , 4 ) : <NEWLINE> <INDENT> for y in range ( 0 , 4 ) : <NEWLINE> <INDENT> if ar [ t ] == aw [ y ] : <NEWLINE> <INDENT> if t == y : break <NEWLINE> else : blo += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print hit , blo <NEWLINE> <DEDENT> <DEDENT>
for q in range ( 12000 ) : <NEWLINE> <INDENT> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = input ( ) <NEWLINE> if a [ 0 ] == 0 and b [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> hit = 0 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] == int ( b [ i ] ) : <NEWLINE> <INDENT> hit = hit + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> blow = 0 <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if ( int ( b [ j ] ) == a [ i ] ) and ( a [ i ] != int ( b [ i ] ) ) and ( a [ j ] != int ( b [ j ] ) ) : <NEWLINE> <INDENT> blow = blow + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( hit , blow ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> r , a = raw_input ( ) . split ( ) <NEWLINE> if r == a == 0 : break <NEWLINE> h = 0 <NEWLINE> _r = [ ] <NEWLINE> _a = [ ] <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> if a [ i ] == r [ i ] : <NEWLINE> <INDENT> h += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _r . append ( r [ i ] ) <NEWLINE> _a . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print h , len ( set ( _r ) & set ( _a ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n , m = ( int ( x . strip ( ) ) for x in raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : break <NEWLINE> p = [ int ( x . strip ( ) ) for x in raw_input ( ) . split ( ) ] <NEWLINE> s = sum ( p ) <NEWLINE> p . sort ( reverse = True ) <NEWLINE> for x in p [ m - 1 : : m ] : <NEWLINE> <INDENT> s -= x <NEWLINE> <DEDENT> print s <NEWLINE> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> v = sorted ( map ( int , raw_input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> for i in range ( m - 1 , n , m ) : <NEWLINE> <INDENT> v [ i ] = 0 <NEWLINE> <DEDENT> print sum ( v ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> nm = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if nm == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> n = nm [ 0 ] <NEWLINE> m = nm [ 1 ] <NEWLINE> p = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p_sorted = sorted ( p ) <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % m != 0 : <NEWLINE> <INDENT> sum += p_sorted [ - 1 - i ] <NEWLINE> <DEDENT> <DEDENT> print sum <NEWLINE> <DEDENT>
ref = [ 63 , 6 , 91 , 79 , 102 , 109 , 125 , 39 , 127 , 111 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == - 1 : break <NEWLINE> e = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = ref [ int ( raw_input ( ) ) ] <NEWLINE> print <STRING> . format ( a ^ e ) <NEWLINE> e = a <NEWLINE> <DEDENT> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> datas = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> maxw = 0 <NEWLINE> for d1 in datas : <NEWLINE> <INDENT> w = sum ( [ d2 [ 0 ] for d2 in datas if d2 [ 1 ] <= d1 [ 1 ] < d2 [ 2 ] ] ) <NEWLINE> maxw = max ( w , mxw ) <NEWLINE> <DEDENT> print <STRING> if maxw <= 150 else <STRING> <NEWLINE> <DEDENT>
def solve ( X , Y , Z , V , E , A ) : <NEWLINE> <INDENT> dp = [ [ 0.0 ] * 6001 for _ in range ( Y + max ( V ) + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1.0 <NEWLINE> for i in range ( Y ) : <NEWLINE> <INDENT> for j in range ( 5001 ) : <NEWLINE> <INDENT> if dp [ i ] [ j ] <= 0.0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in V : <NEWLINE> <INDENT> t = i + k <NEWLINE> if t > Y : <NEWLINE> <INDENT> dp [ Y ] [ j ] += dp [ i ] [ j ] / X <NEWLINE> <DEDENT> elif E [ t ] == 1 : <NEWLINE> <INDENT> dp [ min ( Y , t + A [ t ] ) ] [ j ] += dp [ i ] [ j ] / X <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ t ] [ max ( 0 , j + A [ t ] ) ] += dp [ i ] [ j ] / X <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> s = 0 <NEWLINE> for i in range ( 5001 ) : <NEWLINE> <INDENT> if dp [ Y ] [ i ] <= 0.0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> s += i * dp [ Y ] [ i ] <NEWLINE> <DEDENT> print int ( s ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> X , Y , Z = map ( int , input ( ) . split ( ) ) <NEWLINE> if X | Y | Z == 0 : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> V = map ( int , input ( ) . split ( ) ) <NEWLINE> E = [ 0 ] * 100 <NEWLINE> A = [ 0 ] * 100 <NEWLINE> for _ in range ( Z ) : <NEWLINE> <INDENT> n , e , a = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ n ] = e <NEWLINE> if e == 3 : <NEWLINE> <INDENT> A [ n ] = - a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ n ] = a <NEWLINE> <DEDENT> <DEDENT> solve ( X , Y , Z , V , E , A ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y , z = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 and z == 0 : break <NEWLINE> v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> event = [ [ ] for _ in xrange ( y + 1 ) ] <NEWLINE> maxm = 0 <NEWLINE> for i in xrange ( z ) : <NEWLINE> <INDENT> n , e , a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> event [ n ] . append ( e ) <NEWLINE> event [ n ] . append ( a ) <NEWLINE> if e == 2 : <NEWLINE> <INDENT> maxm += a <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ [ 0 ] * ( 5005 ) for _ in xrange ( y + 1 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> x = float ( x ) <NEWLINE> for i in xrange ( y ) : <NEWLINE> <INDENT> for k in xrange ( maxm + 1 ) : <NEWLINE> <INDENT> for j in xrange ( int ( x ) ) : <NEWLINE> <INDENT> if i + v [ j ] >= y : <NEWLINE> <INDENT> dp [ y ] [ k ] += dp [ i ] [ k ] / x <NEWLINE> continue <NEWLINE> <NL> <DEDENT> if event [ i + v [ j ] ] == [ ] : <NEWLINE> <INDENT> dp [ i + v [ j ] ] [ k ] += dp [ i ] [ k ] / x <NEWLINE> <NL> <DEDENT> elif event [ i + v [ j ] ] [ 0 ] == 1 : <NEWLINE> <INDENT> skip = event [ i + v [ j ] ] [ 1 ] <NEWLINE> dp [ min ( y , i + skip ) ] [ k ] += dp [ i ] [ k ] / x <NEWLINE> <NL> <DEDENT> elif event [ i + v [ j ] ] [ 0 ] == 2 : <NEWLINE> <INDENT> m = event [ i + v [ j ] ] [ 1 ] <NEWLINE> dp [ i + v [ j ] ] [ k + m ] += dp [ i ] [ k ] / x <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> m = event [ i + v [ j ] ] [ 1 ] <NEWLINE> dp [ i + v [ j ] ] [ max ( 0 , k - m ) ] += dp [ i ] [ k ] / x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0.0 <NEWLINE> for i in xrange ( maxm + 1 ) : <NEWLINE> <INDENT> ans += dp [ y ] [ i ] * i <NEWLINE> <DEDENT> print ( int ( ans ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y , z = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == 0 and y == 0 and z == 0 : break <NEWLINE> dp = [ [ 0.0 for col in range ( 5101 ) ] for row in range ( 61 ) ] <NEWLINE> m = { } <NEWLINE> for i in range ( y + 10 ) : <NEWLINE> <INDENT> m [ i ] = ( 0 , 0 ) <NEWLINE> <DEDENT> v = [ ] <NEWLINE> v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( z ) : <NEWLINE> <INDENT> n , e , a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m [ n ] = ( e , a ) <NEWLINE> <DEDENT> dp [ 0 ] [ 0 ] = 1.0 <NEWLINE> for i in range ( y ) : <NEWLINE> <INDENT> for j in range ( 5001 ) : <NEWLINE> <INDENT> for k in range ( x ) : <NEWLINE> <INDENT> nx = i + v [ k ] <NEWLINE> if m [ nx ] [ 0 ] == 1 : <NEWLINE> <INDENT> dp [ min ( y , nx + m [ nx ] [ 1 ] ) ] [ j ] += dp [ i ] [ j ] / x <NEWLINE> <DEDENT> elif m [ nx ] [ 0 ] == 2 : <NEWLINE> <INDENT> dp [ nx ] [ j + m [ nx ] [ 1 ] ] += dp [ i ] [ j ] / x <NEWLINE> <DEDENT> elif m [ nx ] [ 0 ] == 3 : <NEWLINE> <INDENT> dp [ nx ] [ max ( 0 , j - m [ nx ] [ 1 ] ) ] += dp [ i ] [ j ] / x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ min ( y , nx ) ] [ j ] += dp [ i ] [ j ] / x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = 0.0 <NEWLINE> for i in range ( 5001 ) : <NEWLINE> <INDENT> ans += dp [ y ] [ i ] * i <NEWLINE> <DEDENT> print int ( ans ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> if t == 0 : break <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x += ( lambda lst : lst [ - 1 ] - lst [ 0 ] ) ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> print ( <STRING> if t <= x else ( t - x ) ) <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> if t == 0 : break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> t -= sum ( map ( lambda lst : lst [ - 1 ] - lst [ 0 ] , [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( int ( input ( ) ) ) ] ) ) <NEWLINE> print ( <STRING> if t <= 0 else t ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> b = 0 <NEWLINE> if t == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s , f = map ( int , input ( ) . split ( ) ) <NEWLINE> a = f - s <NEWLINE> b += a <NEWLINE> <DEDENT> if t <= b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( t - b ) <NEWLINE> <DEDENT> <DEDENT>
def f ( v ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if l [ i ] < v [ i ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> data = { } <NEWLINE> for n in range ( N ) : <NEWLINE> <INDENT> i , p , q , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> data [ i ] = [ p , q , r ] <NEWLINE> <DEDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> flag = False <NEWLINE> for i , v in data . items ( ) : <NEWLINE> <INDENT> c = 4 * v [ 0 ] + 9 * v [ 1 ] + 4 * v [ 2 ] <NEWLINE> v . append ( c ) <NEWLINE> if f ( v ) : <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import string <NEWLINE> from collections import Counter <NEWLINE> <NL> f = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( f . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> counters = { c : Counter ( ) for c in string . ascii_lowercase } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for word in f . readline ( ) . strip ( ) . split ( ) : <NEWLINE> <INDENT> counters [ word [ 0 ] ] . update ( [ word ] ) <NEWLINE> <DEDENT> <DEDENT> c = f . readline ( ) . strip ( ) <NEWLINE> <NL> candidate = counters [ c ] . most_common ( ) <NEWLINE> candidate . sort ( key = operator . itemgetter ( 0 ) ) <NEWLINE> candidate . sort ( key = operator . itemgetter ( 1 ) , reverse = True ) <NEWLINE> candidate = [ word for word , count in candidate [ : 5 ] ] <NEWLINE> if len ( candidate ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * candidate ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> dic = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> msg = raw_input ( ) . split ( ) <NEWLINE> for word in msg : <NEWLINE> <INDENT> if word in dic : <NEWLINE> <INDENT> dic [ word ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dic [ word ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> alpha = raw_input ( ) <NEWLINE> flag = 0 <NEWLINE> for k , v in sorted ( sorted ( dic . items ( ) ) , key = lambda x : x [ 1 ] , reverse = True ) : <NEWLINE> <INDENT> if k [ 0 ] == alpha : <NEWLINE> <INDENT> print k , <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> print <STRING> if flag else <STRING> <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> [ n , m ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> D = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> D [ 0 ] = range ( 1 , n + 1 ) <NEWLINE> nflg = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> [ u , v ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> D [ u ] . append ( v ) <NEWLINE> D [ v ] . append ( u ) <NEWLINE> if len ( D [ u ] ) > 2 or len ( D [ v ] ) > 2 : <NEWLINE> <INDENT> nflg = 1 <NEWLINE> <DEDENT> <DEDENT> if nflg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bkf = 0 <NEWLINE> while ( len ( D [ 0 ] ) > 0 ) : <NEWLINE> <INDENT> st = D [ 0 ] . pop ( ) <NEWLINE> st0 = st <NEWLINE> while len ( D [ st ] ) != 0 : <NEWLINE> <INDENT> nxt = D [ st ] . pop ( ) <NEWLINE> if nxt != st0 : <NEWLINE> <INDENT> D [ 0 ] . remove ( nxt ) <NEWLINE> D [ nxt ] . remove ( st ) <NEWLINE> st = nxt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> bkf = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if bkf : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
print ( sum ( [ int ( input ( ) ) for i in range ( 10 ) ] ) <NEWLINE>
m = [ 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 ] <NEWLINE> ( a , b , c ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print [ <STRING> , <STRING> ] [ a * 4 + b * 2 + c ] <NEWLINE>
s = raw_input ( ) <NEWLINE> if s == <STRING> or s == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> h1 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for h in h1 : <NEWLINE> <INDENT> h2 = [ x for x in h1 if x != h ] <NEWLINE> g = [ h2 [ i + 1 ] - h2 [ i ] for i in range ( n - 1 ) ] <NEWLINE> if len ( set ( g ) ) == 1 : <NEWLINE> <INDENT> print h <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except RuntimeError , e : <NEWLINE> <INDENT> print n , h1 <NEWLINE> print e . message <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> da = [ a [ i + 1 ] - a [ i ] for i in range ( n ) ] <NEWLINE> d = sorted ( list ( set ( da ) ) , key = lambda x : da . count ( x ) [ 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 and a [ i ] + d != a [ i + 1 ] : <NEWLINE> <INDENT> if a [ i ] + 2 * d == a [ i + 2 ] : <NEWLINE> <INDENT> print a [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a [ i ] <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> elif a [ i ] + d != a [ i + 1 ] : <NEWLINE> <INDENT> print a [ i + 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> w = raw_input ( ) <NEWLINE> if w == <STRING> : break <NEWLINE> if int ( w ) % 1111 == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> ans = 0 <NEWLINE> while ( w != <STRING> ) : <NEWLINE> <INDENT> w = str ( int ( <STRING> . join ( sorted ( w , reverse = True ) ) ) - int ( <STRING> . join ( sorted ( w ) ) ) ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
def calculate ( num , i ) : <NEWLINE> <INDENT> num . sort ( reverse = True ) <NEWLINE> if num [ 0 ] == num [ 3 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> L = num [ 0 ] * 1000 + num [ 1 ] * 100 + num [ 2 ] * 10 + num [ 3 ] <NEWLINE> S = num [ 3 ] * 1000 + num [ 2 ] * 100 + num [ 1 ] * 10 + num [ 0 ] <NEWLINE> new_N = L - S <NEWLINE> if new_N == 6174 : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <DEDENT> return calculate ( map ( int , str ( new_N ) ) , i + 1 ) <NEWLINE> <DEDENT> ans = [ ] <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> input_str = raw_input ( ) <NEWLINE> if input_str == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif input_str == <STRING> : <NEWLINE> <INDENT> ans . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = map ( int , input_str ) <NEWLINE> ans . append ( calculate ( num , 0 ) ) <NEWLINE> <DEDENT> <DEDENT> for value in ans : <NEWLINE> <INDENT> print value <NEWLINE> <DEDENT>
data = [ str ( i + 1 ) * 4 for i in range ( 9 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif n in data : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> c = 0 <NEWLINE> while n != <STRING> : <NEWLINE> <INDENT> L = int ( <STRING> . join ( sorted ( list ( n ) , key = int , reverse = True ) ) ) <NEWLINE> S = int ( <STRING> . join ( sorted ( list ( n ) , key = int ) ) ) <NEWLINE> n = str ( L - S ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print c <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = list ( raw_input ( ) ) <NEWLINE> if n [ 0 ] == n [ 1 ] == n [ 2 ] == n [ 3 ] == <STRING> : break <NEWLINE> elif n [ 0 ] == n [ 1 ] == n [ 2 ] == n [ 3 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> count = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if n == [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> print count <NEWLINE> break <NEWLINE> <DEDENT> m = sorted ( n ) [ : : - 1 ] <NEWLINE> l = sorted ( n ) [ n . count ( <STRING> ) : ] <NEWLINE> n = list ( str ( int ( <STRING> . join ( map ( str , m ) ) ) - int ( <STRING> . join ( map ( str , l ) ) ) ) ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> p = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> j = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> j . sort ( ) ; j . reverse ( ) ; <NEWLINE> sum = 0 ; num = n ; <NEWLINE> for m in p : <NEWLINE> <INDENT> sum += m <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if ( num - 1 ) * ( sum + j [ i ] ) < num * sum : break <NEWLINE> num -= 1 ; sum += j [ i ] <NEWLINE> <DEDENT> print num * sum <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys , math , os , datetime <NEWLINE> <NL> <COMMENT> <NL> PYDEV = os . environ . get ( <STRING> ) <NEWLINE> <COMMENT> <NL> sys . stdin = open ( <STRING> , <STRING> ) <NEWLINE> <NL> dpm = [ 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] <COMMENT> <NEWLINE> <NL> <NL> def get_day ( year , month , day ) : <NEWLINE> <INDENT> if month <= 2 : <NEWLINE> <INDENT> year -= 1 <NEWLINE> month += 12 <NEWLINE> <DEDENT> dy = 365 * ( year - 1 ) <NEWLINE> c = year // 100 <NEWLINE> dl = ( year >> 2 ) - c + ( c >> 2 ) <NEWLINE> dm = ( month * 979 - 1033 ) >> 5 <NEWLINE> return dy + dl + dm + day - 1 <NEWLINE> <NL> <DEDENT> def from_day ( n ) : <NEWLINE> <INDENT> a = n + 32044 ; <NEWLINE> b = ( 4 * n + 3 ) // 146097 <NEWLINE> c = a - ( 146097 * b ) // 4 <NEWLINE> d = ( 4 * c + 3 ) // 1461 <NEWLINE> e = c - ( 1461 * d ) // 4 <NEWLINE> m = ( 5 * e + 2 ) // 153 <NEWLINE> m1 = m // 10 <NEWLINE> day = e - ( 153 * m + 2 ) // 5 + 1 <NEWLINE> month = m + 3 - 12 * m1 <NEWLINE> year = 100 * b + d - 4800 + m1 <NEWLINE> if year <= 0 : <NEWLINE> <INDENT> year = - year + 1 <NEWLINE> <DEDENT> return year , month , day <NEWLINE> <NL> <NL> <DEDENT> offset = get_day ( 2012 , 12 , 21 ) <NEWLINE> maya = [ 144000 , 7200 , 360 , 20 , 1 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> inp = input ( ) . strip ( ) <NEWLINE> if inp == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> inp = [ int ( _ ) for _ in inp . split ( <STRING> ) ] <NEWLINE> if len ( inp ) == 3 : <NEWLINE> <COMMENT> <NL> <INDENT> n = ( get_day ( inp [ 0 ] , inp [ 1 ] , inp [ 2 ] ) - offset ) % 1872000 <NEWLINE> out = <STRING> <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> out += str ( n // maya [ k ] ) + <STRING> <NEWLINE> n %= maya [ k ] <NEWLINE> <DEDENT> out += str ( n ) <NEWLINE> print ( out ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> n = sum ( [ maya [ k ] * inp [ k ] for k in range ( 5 ) ] ) <NEWLINE> <COMMENT> <NL> year , month , day = from_day ( n + 2456283 + 1 ) <NEWLINE> print ( str ( year ) + <STRING> + str ( month ) + <STRING> + str ( day ) ) <NEWLINE> <DEDENT> <DEDENT>
import datetime <NEWLINE> <NL> def is_leap_year ( y ) : <NEWLINE> <INDENT> return y % 4 == 0 and ( y % 100 != 0 or y % 400 == 0 ) <NEWLINE> <NL> <DEDENT> def leap_year_count ( target_y , benchmark_y ) : <NEWLINE> <INDENT> target = target_y // 4 - target_y // 100 + target_y // 400 <NEWLINE> benchmark = benchmark_y // 4 - benchmark_y // 100 + benchmark_y // 400 <NEWLINE> return target - benchmark <NEWLINE> <NL> <DEDENT> def ad2mayan ( y , m , d ) : <NEWLINE> <INDENT> diff = 0 <NEWLINE> if datetime . MAXYEAR < y : <NEWLINE> <INDENT> day_of_2012 = ( datetime . date ( 2013 , 1 , 1 ) - datetime . date ( 2012 , 12 , 21 ) ) . days <NEWLINE> day_of_the_year = ( datetime . date ( 1 , m , d ) - datetime . date ( 1 , 1 , 1 ) ) . days if is_leap_year ( y ) else ( datetime . date ( 4 , m , d ) - datetime . date ( 4 , 1 , 1 ) ) . days <NEWLINE> <NL> days = ( y - 2013 ) * 365 + leap_year_count ( y , 2013 ) <NEWLINE> <NL> diff = day_of_2012 + days + day_of_the_year <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> benchmark = datetime . date ( 2012 , 12 , 21 ) <NEWLINE> diff = ( datetime . date ( y , m , d ) - benchmark ) . days <NEWLINE> <NL> <DEDENT> ki , diff = diff % 20 , diff // 20 <NEWLINE> w , diff = diff % 18 , diff // 18 <NEWLINE> t , diff = diff % 20 , diff // 20 <NEWLINE> ka , diff = diff % 20 , diff // 20 <NEWLINE> b = diff % 13 <NEWLINE> <NL> return b , ka , t , w , ki <NEWLINE> <NL> <DEDENT> def mayan2ad ( b , ka , t , w , ki ) : <NEWLINE> <INDENT> ka += b * 20 <NEWLINE> t += ka * 20 <NEWLINE> w += t * 18 <NEWLINE> ki += w * 20 <NEWLINE> time = datetime . date ( 2012 , 12 , 21 ) + datetime . timedelta ( ki ) <NEWLINE> return time . year , time . month , time . day <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> for line in f : <NEWLINE> <INDENT> t = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> if len ( t ) == 3 : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , ad2mayan ( * t ) ) ) ) <NEWLINE> <DEDENT> elif len ( t ) == 5 : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( str , mayan2ad ( * t ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
BIN = [ 0 ] * 32 <NEWLINE> <NL> v = 1 <NEWLINE> for i in range ( 24 , 0 , - 1 ) : <NEWLINE> <INDENT> BIN [ i ] = v <NEWLINE> v *= 2 <NEWLINE> <DEDENT> v = float ( 1 ) / 2 <NEWLINE> for i in range ( 25 , 32 ) : <NEWLINE> <INDENT> BIN [ i ] = v <NEWLINE> v /= 2 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> Q = int ( input ( ) ) <NEWLINE> if not Q : break <NEWLINE> <NL> for i in range ( Q ) : <NEWLINE> <INDENT> inp = format ( int ( input ( ) , 16 ) , <STRING> ) . zfill ( 32 ) <NEWLINE> res = float ( 0 ) <NEWLINE> for j , v in enumerate ( list ( inp ) [ 1 : ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> res += BIN [ j + 1 ] * int ( v ) <NEWLINE> <NL> <DEDENT> print ( ( <STRING> if inp [ 0 ] == <STRING> else <STRING> ) + str ( res ) ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p = [ 0 ] * ( max ( c ) + 1 ) <NEWLINE> for i in c : <NEWLINE> <INDENT> p [ i ] = 1 <NEWLINE> <NL> <DEDENT> for k in range ( q ) : <NEWLINE> <INDENT> m = int ( raw_input ( ) ) <NEWLINE> flag = 0 <NEWLINE> ans = 0 <NEWLINE> for i in range ( m - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for pi in p [ i : : m ] : <NEWLINE> <INDENT> if pi : <NEWLINE> <INDENT> ans = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ans > 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
for i in range ( 7 ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a - b ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a - b <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a - b <NEWLINE> <DEDENT>
n = int ( input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> q , w , e , r = 0 , 0 , 0 , 0 <NEWLINE> q , w = a * c , b * d <NEWLINE> e = q + w <NEWLINE> if c <= 5 and d <= 2 : <NEWLINE> <INDENT> r = e * 0.8 <NEWLINE> <DEDENT> print ( r ) <NEWLINE> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> c , a , n = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> cnt1 = min ( c , a , n ) <NEWLINE> c -= cnt1 <NEWLINE> a -= cnt1 <NEWLINE> cnt2 = min ( c // 2 , a ) <NEWLINE> c -= cnt2 * 2 <NEWLINE> cnt3 = c // 3 <NEWLINE> print ( cnt1 + cnt2 + cnt3 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> c , a , n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> res = min ( n , a , c ) <NEWLINE> c -= res <NEWLINE> a -= res <NEWLINE> if c >= 2 and a >= 1 : <NEWLINE> <INDENT> cca += min ( c // 2 , a ) <NEWLINE> c -= cca * 2 <NEWLINE> <NL> <DEDENT> if c >= 3 : <NEWLINE> <INDENT> res += c // 3 <NEWLINE> <NL> <DEDENT> print ( res ) <NEWLINE> <DEDENT>
n , r , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> log = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( r ) ] <NEWLINE> log . insert ( 0 , [ 1 , 0 , 0 ] ) <NEWLINE> log . append ( [ 1 , l , 0 ] ) <NEWLINE> id_t = [ 0 ] * n <NEWLINE> id_x = [ 0 ] * n <NEWLINE> max_id = 0 <NEWLINE> for i in range ( 1 , r + 2 ) : <NEWLINE> <INDENT> cur_id = log [ i ] [ 0 ] - 1 <NEWLINE> id_t [ max_id ] += log [ i ] [ 1 ] - log [ i - 1 ] [ 1 ] <NEWLINE> id_x [ cur_id ] += log [ i ] [ 2 ] <NEWLINE> if log [ i ] [ 2 ] < 0 : <NEWLINE> <INDENT> max_id = id_x . index ( max ( id_x ) ) <NEWLINE> <DEDENT> elif id_x [ max_id ] < id_x [ cur_id ] or ( id_x [ max_id ] == id_x [ cur_id ] and max_id > cur_id ) : <NEWLINE> <INDENT> max_id = cur_id <NEWLINE> <DEDENT> <DEDENT> print id_t . index ( max ( id_t ) ) + 1 <NEWLINE>
d , c = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( d * c ) <NEWLINE>
import sys <NEWLINE> <NL> T = input ( ) <NEWLINE> for i in range ( 0 , T ) : <NEWLINE> <INDENT> K , P = raw_input ( ) . split ( <STRING> ) <NEWLINE> K = int ( K ) <NEWLINE> P = int ( P ) <NEWLINE> print ( K % P - 1 + P ) % P + 1 <NEWLINE> <DEDENT>
def op1 ( p ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> p [ 0 ] , p [ 1 ] , p [ 2 ] , p [ 3 ] , p [ 4 ] , p [ 5 ] , p [ 21 ] , p [ 22 ] , p [ 23 ] , p [ 11 ] , p [ 10 ] , p [ 9 ] , p [ 17 ] , p [ 13 ] , p [ 14 ] , <NEWLINE> p [ 15 ] , p [ 16 ] , p [ 12 ] , p [ 18 ] , p [ 19 ] , p [ 20 ] , p [ 6 ] , p [ 7 ] , p [ 8 ] , p [ 24 ] , p [ 25 ] , p [ 26 ] , p [ 27 ] , p [ 28 ] , p [ 29 ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> def op2 ( p ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> p [ 27 ] , p [ 28 ] , p [ 29 ] , p [ 3 ] , p [ 4 ] , p [ 5 ] , p [ 6 ] , p [ 7 ] , p [ 8 ] , p [ 9 ] , p [ 10 ] , p [ 11 ] , p [ 12 ] , p [ 13 ] , p [ 15 ] , <NEWLINE> p [ 14 ] , p [ 16 ] , p [ 17 ] , p [ 20 ] , p [ 19 ] , p [ 18 ] , p [ 21 ] , p [ 22 ] , p [ 23 ] , p [ 24 ] , p [ 25 ] , p [ 26 ] , p [ 0 ] , p [ 1 ] , p [ 2 ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> def op3 ( p ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> p [ 23 ] , p [ 1 ] , p [ 2 ] , p [ 26 ] , p [ 4 ] , p [ 5 ] , p [ 29 ] , p [ 7 ] , p [ 8 ] , p [ 20 ] , p [ 10 ] , p [ 11 ] , p [ 12 ] , p [ 13 ] , p [ 14 ] , <NEWLINE> p [ 15 ] , p [ 16 ] , p [ 17 ] , p [ 18 ] , p [ 19 ] , p [ 9 ] , p [ 21 ] , p [ 22 ] , p [ 0 ] , p [ 24 ] , p [ 25 ] , p [ 3 ] , p [ 27 ] , p [ 28 ] , p [ 6 ] <NEWLINE> <DEDENT> ) <NEWLINE> <DEDENT> def op4 ( p ) : <NEWLINE> <INDENT> return ( <NEWLINE> <INDENT> p [ 0 ] , p [ 1 ] , p [ 21 ] , p [ 3 ] , p [ 4 ] , p [ 24 ] , p [ 6 ] , p [ 7 ] , p [ 27 ] , p [ 9 ] , p [ 10 ] , p [ 18 ] , p [ 14 ] , p [ 13 ] , p [ 12 ] , <NEWLINE> p [ 15 ] , p [ 16 ] , p [ 17 ] , p [ 11 ] , p [ 19 ] , p [ 20 ] , p [ 2 ] , p [ 22 ] , p [ 23 ] , p [ 5 ] , p [ 25 ] , p [ 26 ] , p [ 8 ] , p [ 28 ] , p [ 29 ] <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <DEDENT> def valid ( p ) : <NEWLINE> <INDENT> for i in range ( 1 , 9 ) : <NEWLINE> <INDENT> if ( p [ 0 ] != p [ i ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 10 , 12 ) : <NEWLINE> <INDENT> if ( p [ 9 ] != p [ i ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 13 , 15 ) : <NEWLINE> <INDENT> if ( p [ 12 ] != p [ i ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 16 , 18 ) : <NEWLINE> <INDENT> if ( p [ 15 ] != p [ i ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 19 , 21 ) : <NEWLINE> <INDENT> if ( p [ 18 ] != p [ i ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 22 , 30 ) : <NEWLINE> <INDENT> if ( p [ 21 ] != p [ i ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def solve ( n , p ) : <NEWLINE> <NL> <INDENT> if ( n > 8 ) : <NEWLINE> <INDENT> return 100 <NEWLINE> <NL> <DEDENT> if ( valid ( p ) ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> s = [ solve ( n + 1 , op1 ( p ) ) , solve ( n + 1 , op2 ( p ) ) , solve ( n + 1 , op3 ( p ) ) , solve ( n + 1 , op4 ( p ) ) ] <NEWLINE> s . sort ( ) <NEWLINE> return s [ 0 ] + 1 <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> p = tuple ( [ int ( term ) - 1 for term in input ( ) . split ( ) ] ) <NEWLINE> print ( solve ( 0 , p ) ) <NEWLINE> <DEDENT>
<NL> def check ( p ) : <NEWLINE> <INDENT> for i in range ( 1 , 9 ) : <NEWLINE> <INDENT> if p [ i ] != p [ 0 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> for i in range ( 10 , 12 ) : <NEWLINE> <INDENT> if p [ i ] != p [ 9 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> for i in range ( 13 , 15 ) : <NEWLINE> <INDENT> if p [ i ] != p [ 12 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> for i in range ( 16 , 18 ) : <NEWLINE> <INDENT> if p [ i ] != p [ 15 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> for i in range ( 19 , 21 ) : <NEWLINE> <INDENT> if p [ i ] != p [ 18 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> for i in range ( 22 , 30 ) : <NEWLINE> <INDENT> if p [ i ] != p [ 21 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def turn1 ( p ) : <NEWLINE> <INDENT> p [ 6 ] , p [ 21 ] = p [ 21 ] , p [ 6 ] <NEWLINE> p [ 7 ] , p [ 22 ] = p [ 22 ] , p [ 7 ] <NEWLINE> p [ 8 ] , p [ 23 ] = p [ 23 ] , p [ 8 ] <NEWLINE> p [ 12 ] , p [ 17 ] = p [ 17 ] , p [ 12 ] <NEWLINE> p [ 9 ] , p [ 11 ] = p [ 11 ] , p [ 9 ] <NEWLINE> <NL> <NL> <DEDENT> def turn2 ( p ) : <NEWLINE> <INDENT> p [ 0 ] , p [ 27 ] = p [ 27 ] , p [ 0 ] <NEWLINE> p [ 1 ] , p [ 28 ] = p [ 28 ] , p [ 1 ] <NEWLINE> p [ 2 ] , p [ 29 ] = p [ 29 ] , p [ 2 ] <NEWLINE> p [ 14 ] , p [ 15 ] = p [ 15 ] , p [ 14 ] <NEWLINE> p [ 18 ] , p [ 20 ] = p [ 20 ] , p [ 18 ] <NEWLINE> <NL> <DEDENT> def turn3 ( p ) : <NEWLINE> <INDENT> p [ 0 ] , p [ 23 ] = p [ 23 ] , p [ 0 ] <NEWLINE> p [ 3 ] , p [ 26 ] = p [ 26 ] , p [ 3 ] <NEWLINE> p [ 6 ] , p [ 29 ] = p [ 29 ] , p [ 6 ] <NEWLINE> p [ 20 ] , p [ 9 ] = p [ 9 ] , p [ 20 ] <NEWLINE> p [ 17 ] , p [ 15 ] = p [ 15 ] , p [ 17 ] <NEWLINE> <NL> <DEDENT> def turn4 ( p ) : <NEWLINE> <INDENT> p [ 2 ] , p [ 21 ] = p [ 21 ] , p [ 2 ] <NEWLINE> p [ 5 ] , p [ 24 ] = p [ 24 ] , p [ 5 ] <NEWLINE> p [ 8 ] , p [ 27 ] = p [ 27 ] , p [ 8 ] <NEWLINE> p [ 18 ] , p [ 11 ] = p [ 11 ] , p [ 18 ] <NEWLINE> p [ 14 ] , p [ 12 ] = p [ 12 ] , p [ 14 ] <NEWLINE> <NL> <NL> <DEDENT> def search ( p , cnt ) : <NEWLINE> <INDENT> if cnt > 8 : <NEWLINE> <INDENT> return 99 <NEWLINE> <DEDENT> if check ( p ) : <NEWLINE> <INDENT> return cnt <NEWLINE> <NL> <DEDENT> r = 100 <NEWLINE> turn1 ( p ) <NEWLINE> r = min ( r , search ( p , cnt + 1 ) ) <NEWLINE> turn1 ( p ) <NEWLINE> turn2 ( p ) <NEWLINE> r = min ( r , search ( p , cnt + 1 ) ) <NEWLINE> turn2 ( p ) <NEWLINE> turn3 ( p ) <NEWLINE> r = min ( r , search ( p , cnt + 1 ) ) <NEWLINE> turn3 ( p ) <NEWLINE> turn4 ( p ) <NEWLINE> r = min ( r , search ( p , cnt + 1 ) ) <NEWLINE> turn4 ( p ) <NEWLINE> <NL> return r <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> for l in range ( N ) : <NEWLINE> <INDENT> p = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( search ( p , 0 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from collections import deque <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> def main ( args ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> N , M , Q = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> members = list ( range ( N ) ) <NEWLINE> numbers = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> queries = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <NL> for n in numbers : <NEWLINE> <INDENT> if n % 2 == 0 : <NEWLINE> <INDENT> members . rotate ( - n ) <NEWLINE> members . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> members . rotate ( n ) <NEWLINE> members . popleft ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for q in queries : <NEWLINE> <INDENT> ans = 1 if q in members else 0 <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
def create_edge ( fr , to , weight , si ) : <NEWLINE> <INDENT> edges = [ ] <NEWLINE> if si == <STRING> : <NEWLINE> <INDENT> edges . append ( ( fr , to , weight ) ) <NEWLINE> edges . append ( ( to , fr , 0 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edges . append ( ( to , fr , - weight ) ) <NEWLINE> <DEDENT> return edges <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def bellmanford ( edges , length ) : <NEWLINE> <INDENT> start_vertex = 0 <NEWLINE> <NL> distance = [ float ( <STRING> ) ] * length <NEWLINE> distance [ start_vertex ] = 0 <NEWLINE> <NL> for i in range ( length ) : <NEWLINE> <INDENT> for fr , to , weight in edges : <NEWLINE> <INDENT> if distance [ to ] > distance [ fr ] + weight : <NEWLINE> <INDENT> distance [ to ] = distance [ fr ] + weight <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for fr , to , weight in edges : <NEWLINE> <INDENT> if distance [ to ] > distance [ fr ] + weight : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> return max ( distance ) <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> import re <NEWLINE> import math <NEWLINE> import itertools <NEWLINE> <NL> n , c = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> <NL> p = re . compile ( <STRING> ) <NEWLINE> constraints = [ p . match ( line ) . groups ( ) for line in f ] <NEWLINE> <NL> fixed_edges = [ ] <NEWLINE> floating_edges = [ ] <NEWLINE> for ai , oi , bi , si , di in constraints : <NEWLINE> <INDENT> fr , to , weight = int ( ai ) - 1 , int ( bi ) - 1 , int ( di ) <NEWLINE> <NL> if oi == <STRING> : <NEWLINE> <INDENT> floating_edges . append ( ( create_edge ( fr , to , weight , si ) , create_edge ( to , fr , weight , si ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if oi == <STRING> : <NEWLINE> <INDENT> fr , to = to , fr <NEWLINE> <DEDENT> fixed_edges . extend ( create_edge ( fr , to , weight , si ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> distance = [ ] <NEWLINE> for edges in itertools . product ( * floating_edges ) : <NEWLINE> <INDENT> distance . append ( bellmanford ( fixed_edges + [ y for x in edges for y in x ] , n ) ) <NEWLINE> <NL> <DEDENT> print ( max ( distance ) ) <NEWLINE>
print ( sum ( map ( int , input ( ) . split ( ) ) ) <NEWLINE>
print ( sum ( divmod ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> score = [ 0 ] * 101 <NEWLINE> for x in p : <NEWLINE> <INDENT> score [ x ] += 1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if sum ( score [ i : ] ) < i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( i - 1 ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> p = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> p . sort ( ) <NEWLINE> pp = list ( set ( p ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( len ( pp ) ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> scnt = 0 <NEWLINE> for j in range ( len ( p ) ) : <NEWLINE> <INDENT> if pp [ i ] <= pp [ j ] : <NEWLINE> <INDENT> scnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == scnt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> <INDENT> print ( i * 32 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
h , r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( int ( ( h + r ) / abs ( h + r ) ) ) <NEWLINE>
import fractions <NEWLINE> A , B , C = [ int ( k ) for k in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> print ( C * ( ( A * B ) / ( fractions . gcd ( A , B ) ** 2 ) ) ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> ls = list ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> e = sorted ( [ int ( x ) for x in split ( input ( ) ) ] ) <NEWLINE> if e in ls : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls . append ( e ) <NEWLINE> <DEDENT> <DEDENT> print ( N - len ( ls ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> l = [ ] <NEWLINE> s = set ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> l . append ( a ) <NEWLINE> l . append ( b ) <NEWLINE> l . append ( c ) <NEWLINE> l . sort ( ) <NEWLINE> s . add ( l ) <NEWLINE> l = [ ] <NEWLINE> <DEDENT> print ( N - len ( s ) ) <NEWLINE>
a , b , c , d = sorted ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if a == b and c == d else <STRING> ) <NEWLINE>
e = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> if e [ 0 ] == e [ 1 ] and e [ 2 ] == e [ 3 ] ) <NEWLINE>
lst = list ( input ( ) . split ( ) ) <NEWLINE> lst . sort ( ) <NEWLINE> if lst [ 0 ] == lst [ 1 ] == lst [ 2 ] == lst [ 3 ] andlst [ 4 ] == lst [ 5 ] == lst [ 6 ] == lst [ 7 ] andlst [ 8 ] == lst [ 9 ] == lst [ 10 ] == lst [ 11 ] : <NEWLINE> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ls . sort ( ) <NEWLINE> if ls [ 0 ] == ls [ 1 ] == ls [ 2 ] == ls [ 3 ] and ls [ 4 == ls [ 5 ] == ls [ 6 ] == ls [ 7 ] and ls [ 8 ] == ls [ 9 ] == ls [ 10 ] == ls [ 11 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = [ ( a [ i + 1 ] - a [ i ] , i ) for i in range ( n - 1 ) ] <NEWLINE> b . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> if b [ 0 ] [ 1 ] < n - 2 : print ( ( a [ - 1 ] + a [ - 2 ] ) / c ) <NEWLINE> elif b [ 0 ] [ 1 ] == n - 3 : <NEWLINE> <INDENT> if b [ 1 ] [ 1 ] == n - 2 : print ( max ( ( a [ - 1 ] + a [ - 2 ] ) / b [ 2 ] [ 0 ] , ( a [ - 1 ] + a [ - 4 ] ) / b [ 0 ] [ 0 ] , ( a [ - 3 ] + a [ - 4 ] ) / b [ 1 ] [ 0 ] ) ) <NEWLINE> else : print ( max ( ( a [ - 1 ] + a [ - 2 ] ) / b [ 1 ] [ 0 ] , ( a [ - 1 ] + a [ - 4 ] ) / b [ 0 ] [ 0 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if b [ 1 ] [ 1 ] == n - 3 : print ( max ( ( a [ - 1 ] + a [ - 2 ] ) / b [ 2 ] [ 0 ] , ( a [ - 1 ] + a [ - 4 ] ) / b [ 1 ] [ 0 ] , ( a [ - 3 ] + a [ - 4 ] ) / b [ 0 ] [ 0 ] ) ) <NEWLINE> else : print ( max ( ( a [ - 1 ] + a [ - 2 ] ) / b [ 1 ] [ 0 ] , ( a [ - 3 ] + a [ - 4 ] ) / b [ 0 ] [ 0 ] ) ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> u = raw_input ( ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> <NL> def cmd_set ( q , u ) : <NEWLINE> <INDENT> x = int ( q [ 0 ] ) <NEWLINE> y = int ( q [ 1 ] ) <NEWLINE> z = q [ 2 ] <NEWLINE> <NL> h = u [ : x - 1 ] <NEWLINE> t = u [ y : ] <NEWLINE> zz = z * ( y - x + 1 ) <NEWLINE> <NL> return h + zz + t <NEWLINE> <NL> <DEDENT> def cmd_comp ( q , u ) : <NEWLINE> <INDENT> a = int ( q [ 0 ] ) <NEWLINE> b = int ( q [ 1 ] ) <NEWLINE> c = int ( q [ 2 ] ) <NEWLINE> d = int ( q [ 3 ] ) <NEWLINE> <NL> s = u [ a - 1 : b ] <NEWLINE> t = u [ c - 1 : d ] <NEWLINE> if s < t : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif s > t : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> q = raw_input ( ) . split ( ) <NEWLINE> cmd = q [ 0 ] <NEWLINE> q . pop ( 0 ) <NEWLINE> <NL> if cmd == <STRING> : <NEWLINE> <INDENT> cmd_comp ( q , u ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> u = cmd_set ( q , u ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> print ( ( a + b ) // 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> if a % 7 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a % 7 == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a % 7 == 3 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a % 7 == 4 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a % 7 == 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a % 7 == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a %= = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 7 == 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif n % 7 == 1 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif n % 7 == 2 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif n % 7 == 3 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif n % 7 == 4 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> elif n % 7 == 5 : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , list ( input ( ) . split ( <STRING> ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = [ 0 for i in range ( 1002 ) ] <NEWLINE> ans = 0 <NEWLINE> c [ a ] += 1 <NEWLINE> c [ b ] -= 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s , f = map ( int , list ( input ( ) . split ( <STRING> ) ) ) <NEWLINE> c [ s ] += 1 <NEWLINE> c [ f ] -= 1 <NEWLINE> <DEDENT> for i in range ( 1002 ) : <NEWLINE> <INDENT> c [ i + 1 ] += c [ i ] <NEWLINE> if ( c [ i ] > 1 ) : <NEWLINE> <INDENT> ans = 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
print ( ( lambda x , y : x + y + 1 - ( lambda * x , f = lambda f , x , y : f ( f , y , x % y ) if y else x : f ( f , * x ) ) ( x , y ) ) ( int ( input ( ) ) , int ( input ( ) ) ) ) <NEWLINE>
h , n = map ( int , input ( ) . split ( ) ) <NEWLINE> c = [ set ( ) for i in range ( h + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c [ b ] . add ( a ) <NEWLINE> <DEDENT> c [ h ] = set ( [ 1 , 2 ] ) <NEWLINE> count = 0 <NEWLINE> for i in range ( h - 1 ) : <NEWLINE> <INDENT> l = c [ i ] | c [ i + 1 ] <NEWLINE> p = None <NEWLINE> if l == set ( ) : <NEWLINE> <INDENT> count += 2 <NEWLINE> c [ i + 1 ] . add ( 1 ) <NEWLINE> c [ i + 1 ] . add ( 2 ) <NEWLINE> <DEDENT> elif 0 not in l and 1 not in l : <NEWLINE> <INDENT> p = 1 <NEWLINE> <DEDENT> elif 2 not in l and 3 not in l : <NEWLINE> <INDENT> p = 3 <NEWLINE> <DEDENT> elif 1 not in l and 2 not in l : <NEWLINE> <INDENT> p = 2 <NEWLINE> <DEDENT> if p : <NEWLINE> <INDENT> j = 0 <NEWLINE> while i + j + 1 < h + 1 : <NEWLINE> <INDENT> if c [ i + j + 1 ] | c [ i + j + 1 ] == set ( ) : <NEWLINE> <INDENT> j += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if p != 2 and 3 - p not in c [ i + j + 1 ] and 4 - p not in c [ i + j + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> c [ i + 1 ] . add ( p - 1 ) <NEWLINE> c [ i + 1 ] . add ( p ) <NEWLINE> continue <NEWLINE> <DEDENT> if ( j - 1 ) % 2 or j < 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> c [ i + 1 ] . add ( p - 1 ) <NEWLINE> c [ i + 1 ] . add ( p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
a , b = map ( int , split ( ) ) <NEWLINE> print ( abs ( a - b ) ) <NEWLINE>
friends = input ( ) <NEWLINE> friends . split ( <STRING> ) <NEWLINE> friends_all = friends [ 0 ] <NEWLINE> friends_cakes = friends [ 1 ] <NEWLINE> person = int ( friends_all ) + 1 <NEWLINE> cakes = input ( ) <NEWLINE> cakes_amount = 0 <NEWLINE> for a in cakes . split ( <STRING> ) : <NEWLINE> <INDENT> cakes_amount += int ( a ) <NEWLINE> <DEDENT> one_person = cakes_amount // person <NEWLINE> <NL> if cakes_amount % person != 0 : <NEWLINE> <INDENT> one_person += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> print ( one_person ) <NEWLINE> <NL>
import sys <NEWLINE> e = iter ( sys . stdin ) <NEWLINE> while 1 : <NEWLINE> <INDENT> a = b = 0 ; n = int ( e ) <NEWLINE> if n == 0 : break <NEWLINE> for i in [ 0 ] * n : <NEWLINE> <INDENT> s , t = map ( int , e . split ( ) ) <NEWLINE> if s > t : a += s + t <NEWLINE> elif s < t : b += s + t <NEWLINE> else : a += s ; b += t <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> a , b = ( 0 , 0 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x [ 0 ] > x [ 1 ] : <NEWLINE> <INDENT> a += x [ 0 ] + x [ 1 ] <NEWLINE> <DEDENT> elif x [ 0 ] < x [ 1 ] : <NEWLINE> <INDENT> b += x [ 0 ] + x [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += x [ 0 ] <NEWLINE> b += x [ 0 ] <NEWLINE> <DEDENT> <DEDENT> print str ( a ) + <STRING> + str ( b ) <NEWLINE> <DEDENT>
a_score , b_score = 0 , 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> input_list = map ( int , raw_input ( ) , split ( ) ) <NEWLINE> if len ( input_list ) == 1 and input_list [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif len ( input_list ) == 1 : <NEWLINE> <INDENT> print a_score , b_score <NEWLINE> a_score , b_score = 0 , 0 <NEWLINE> <DEDENT> elif len ( input_list ) == 2 : <NEWLINE> <INDENT> a , b = input_list <NEWLINE> if a > b : <NEWLINE> <INDENT> a_score += a + b <NEWLINE> <DEDENT> elif b > a : <NEWLINE> <INDENT> b_score += a + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_score += a <NEWLINE> b_score += b <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = b = 0 ; n = int ( input ( ) ) <NEWLINE> if n : <NEWLINE> <INDENT> for i in [ 0 ] * n : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> if s > t : a += s + t <NEWLINE> elif s < t : b += s + t <NEWLINE> else : a += s ; b += t <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> n = int ( i ) <NEWLINE> num_a = 0 <NEWLINE> num_b = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> ta , tb = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ta > tb : <NEWLINE> <INDENT> num_a += ( ta + tb ) <NEWLINE> <DEDENT> elif ta < tb : <NEWLINE> <INDENT> num_b += ( ta + tb ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_a += ta <NEWLINE> num_b += tb <NEWLINE> <DEDENT> <DEDENT> print <STRING> % ( num_a , num_b ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> A = 0 <NEWLINE> B = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> A += a + b <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> B += a + b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A += a <NEWLINE> B += b <NEWLINE> <DEDENT> print ( <STRING> . format ( A , B ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <DEDENT> <DEDENT>
a = [ 0 ] * 10000 <NEWLINE> b = [ 0 ] * 10000 <NEWLINE> ct = 0 <NEWLINE> a_scores = [ ] <NEWLINE> b_scores = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> a_score = 0 <NEWLINE> b_score = 0 <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> a [ ct + i ] , b [ ct + i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a [ ct + i ] > b [ ct + i ] : <NEWLINE> <INDENT> a_score += a [ ct + i ] + b [ ct + i ] <NEWLINE> <DEDENT> elif a [ ct + i ] == b [ ct + i ] : <NEWLINE> <INDENT> a_score += a [ ct + i ] <NEWLINE> b_score += b [ ct + i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b_score += b [ ct + i ] + a [ ct + i ] <NEWLINE> <DEDENT> <DEDENT> print a_score , b_score <NEWLINE> ct += n <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> sum_a = sum_b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : sum_a = sum_a + a + b <NEWLINE> elif a < b : sum_b = sum_b + a + b <NEWLINE> else : <NEWLINE> <INDENT> sum_a = sum_a + a <NEWLINE> sum_b = sum_b + b <NEWLINE> <DEDENT> <DEDENT> print ( sum_a , sum_b ) <NEWLINE> <DEDENT>
def run ( infile , outfile ) : <NEWLINE> <INDENT> n = int ( infile . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> foo ( infile , outfile , n ) <NEWLINE> <NL> <DEDENT> def foo ( infile , outfile , n ) : <NEWLINE> <INDENT> ax = 0 <COMMENT> <NEWLINE> bx = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = infile . readline ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a > b : <NEWLINE> <INDENT> ax += ( a + b ) <NEWLINE> <DEDENT> elif b > a : <NEWLINE> <INDENT> bx += ( a + b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> assert False <NEWLINE> <DEDENT> <DEDENT> print >> outfile , ax , bx <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> run ( sys . stdin , sys . stdout ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> sum_a = 0 <NEWLINE> sum_b = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> sum_a = sum_a + a + b <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> sum_b = sum_b + a + b <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> sum_a = sum_a + a <NEWLINE> sum_b = sum_b + b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> % ( sum_a , sum_b ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT>
__Author__ = <STRING> <NEWLINE> <COMMENT> <NL> <NL> <NL> def AskUser ( number ) : <NEWLINE> <INDENT> player_A , player_B = [ ] , [ ] <NEWLINE> for value in range ( 0 , number ) : <NEWLINE> <INDENT> answer = raw_input ( ) <NEWLINE> answer = answer . split ( ) <NEWLINE> player_A . append ( int ( answer [ 0 ] ) ) <NEWLINE> player_B . append ( int ( answer [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> return player_A , player_B <NEWLINE> <NL> <DEDENT> def CalcScore ( player_A , player_B ) : <NEWLINE> <INDENT> score_A , score_B = 0 , 0 <NEWLINE> <NL> for value in range ( 0 , len ( player_A ) ) : <NEWLINE> <INDENT> if player_A [ value ] < player_B [ value ] : <NEWLINE> <INDENT> score_B = score_B + player_A [ value ] + player_B [ value ] <NEWLINE> <DEDENT> elif player_A [ value ] > player_B [ value ] : <NEWLINE> <INDENT> score_A = score_A + player_A [ value ] + player_B [ value ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score_A = score_A + player_A [ value ] <NEWLINE> score_B = score_B + player_B [ value ] <NEWLINE> <NL> <DEDENT> <DEDENT> return score_A , score_B <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> total_A , total_B = [ ] , [ ] <NEWLINE> <NL> while ( number = int ( raw_input ( ) ) ) != 0 : <NEWLINE> <INDENT> player_A , player_B = AskUser ( number ) <NEWLINE> score_A , score_B = CalcScore ( player_A , player_B ) <NEWLINE> total_A . append ( score_A ) <NEWLINE> total_B . append ( score_B ) <NEWLINE> <NL> <DEDENT> for value in range ( 0 , len ( total_A ) ) : <NEWLINE> <INDENT> print total_A [ value ] , total_B [ value ] <NEWLINE> <DEDENT> <DEDENT>
a = 0 <NEWLINE> b = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> i = 0 <NEWLINE> if n != 0 : <NEWLINE> <INDENT> while i != n : <NEWLINE> <INDENT> set = raw_input ( ) . split ( ) <NEWLINE> set [ 0 ] = int ( set [ 0 ] ) <NEWLINE> set [ 1 ] = int ( set [ 1 ] ) <NEWLINE> <NL> if set [ 0 ] == set [ 1 ] : <NEWLINE> <INDENT> a += set [ 0 ] <NEWLINE> b += set [ 1 ] <NEWLINE> <NL> <DEDENT> elif set [ 0 ] > set [ 1 ] : <NEWLINE> <INDENT> a += ( set [ 0 ] + set [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b += ( set [ 0 ] + set [ 1 ] ) <NEWLINE> <NL> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print a , b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = 0 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def calc ( ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = 0 <NEWLINE> b = 0 <NEWLINE> ans = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> while n > 0 : <NEWLINE> <INDENT> if ans [ 0 ] > ans [ 1 ] : <NEWLINE> <INDENT> a += ans [ 0 ] + ans [ 1 ] <NEWLINE> <DEDENT> elif ans [ 1 ] < ans [ 0 ] : <NEWLINE> <INDENT> b += ans [ 0 ] + ans [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += ans [ 0 ] <NEWLINE> b += ans [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print a , b <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> calc ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = b = 0 ; n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> for i in [ 0 ] * n : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> b += s if s < t else a += s <NEWLINE> a += t if s > t else b += t <NEWLINE> <DEDENT> print ( a , b ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = dict ( [ raw_input ( ) . split ( ) for _ in range ( n ) ] ) <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> s = <STRING> . join ( [ raw_input ( ) for _ in range ( m ) ] ) <NEWLINE> print <STRING> . join ( [ d . get ( c ) if c in d else c for c in s ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> s = sys . stdin <NEWLINE> r = readline ( ) <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( s . r ) <NEWLINE> if n == 0 : break <NEWLINE> d = { } <NEWLINE> for _ in [ 0 ] * n : <NEWLINE> <INDENT> k , v = s . r . strip ( ) . split ( ) <NEWLINE> d [ k ] = v <NEWLINE> <DEDENT> a = <STRING> <NEWLINE> for _ in [ 0 ] * int ( s . readline ( ) ) : <NEWLINE> <INDENT> e = s . r . strip ( ) <NEWLINE> a += d [ e ] if e in d else e <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dcl = dict ( ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> inp = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> dcl [ inp [ 0 ] ] = inp [ 1 ] <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> x = int ( input ( ) ) <NEWLINE> y = str ( input ( ) ) <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> y = str ( input ( ) ) <NEWLINE> if y in dcl : <NEWLINE> <INDENT> ans += dcl [ y ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += y <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> d [ a ] = b <NEWLINE> <DEDENT> m = int ( input ( ) ) <NEWLINE> tmp = [ input ( ) . strip ( ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> ans = [ d [ a ] if a in d . keys ( ) else a for a in tmp ] <NEWLINE> print ( <STRING> . join ( ans ) ) <NEWLINE> <DEDENT>
import string <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> from = [ ] <NEWLINE> to = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> l = raw_input ( ) . split ( ) <NEWLINE> from . append ( l [ 0 ] ) <NEWLINE> to . append ( l [ 1 ] ) <NEWLINE> <DEDENT> a = string . maketrans ( <STRING> . join ( from ) , <STRING> . join ( to ) ) <NEWLINE> s = [ ] <NEWLINE> for i in xrange ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> s . append ( raw_input ( ) . strip ( ) ) <NEWLINE> <DEDENT> print s . translate ( a ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT>
out = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> trans = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k , v = raw_input ( ) . split ( ) <NEWLINE> trans [ k ] = v . rstrip ( ) <NEWLINE> <DEDENT> cnt = int ( raw_input ( ) ) <NEWLINE> res = <STRING> <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a = raw_input ( ) . rstrip ( ) <NEWLINE> if a in trans : a = trans [ a ] <NEWLINE> res += a <NEWLINE> <DEDENT> out . append ( a ) <NEWLINE> <DEDENT> for o in out : print o <NEWLINE>
while ( 1 ) : <NEWLINE> <INDENT> table = { } <NEWLINE> output = <STRING> <NEWLINE> table_number = int ( input ( ) ) <NEWLINE> if table_number == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( table_number ) : <NEWLINE> <INDENT> a , b = raw_input ( ) . split ( ) <NEWLINE> table [ a ] = b <NEWLINE> <DEDENT> string_number = int ( input ( ) ) <NEWLINE> for i in ( string_number ) : <NEWLINE> <INDENT> string = raw_input ( ) [ 0 ] <NEWLINE> if string in table : <NEWLINE> <INDENT> output += table [ string ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output += string <NEWLINE> <DEDENT> <DEDENT> print output <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> x = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k , v = sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> x [ k ] = v <NEWLINE> <DEDENT> y = [ ] <NEWLINE> for i in range ( int ( input ( ) ) : <NEWLINE> <INDENT> a = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if a in x : <NEWLINE> <INDENT> y . append ( x [ a ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . append ( a ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( y ) ) <NEWLINE> <DEDENT>
conv_map = { } <NEWLINE> str_result = <STRING> <NEWLINE> <NL> while True : <NEWLINE> <INDENT> conv_map = { } <NEWLINE> str_result = <STRING> <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for idx in range ( 0 , n ) : <NEWLINE> <INDENT> lst = raw_input ( ) . split ( ) <NEWLINE> conv_map [ lst [ 0 ] ] = lst [ 1 ] <NEWLINE> <NL> <DEDENT> m = input ( ) <NEWLINE> tmp = <STRING> <NEWLINE> for idx in range ( 0 , m ) : <NEWLINE> <INDENT> tmp = raw_input ( ) <NEWLINE> str_result += conv_map . get ( tmp , tmp ) <NEWLINE> <NL> <DEDENT> print str_result <NEWLINE> <DEDENT>
def input_num ( infile ) : <NEWLINE> <INDENT> num = int ( infile . readline ( ) ) <NEWLINE> return num <NEWLINE> <NL> <DEDENT> def makedict ( infile , outfile , n ) : <NEWLINE> <INDENT> dict = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> key , val = infile . readline ( ) . split ( ) <NEWLINE> dict [ key ] = val <NEWLINE> <DEDENT> m = input_num ( sys . stdin ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> x = infile . readline ( ) . sprit ( ) [ 0 ] <NEWLINE> outfile . write ( dict . get ( x , x ) ) <NEWLINE> <DEDENT> print >> outfile <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> <NEWLINE> <INDENT> import sys <NEWLINE> while True : <NEWLINE> <INDENT> n = input_num ( sys . stdin ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> makedict ( sys . stdin , sys . stdout , n ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> dict = { } <NEWLINE> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> for x in xrange ( n ) : <NEWLINE> <INDENT> a , b = raw_input ( ) . split ( ) <NEWLINE> dict [ a ] = b <NEWLINE> <DEDENT> res = <STRING> <NEWLINE> for x in xrange ( input ( ) ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> if a in dict : <NEWLINE> <INDENT> res += dict [ a ] <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> res += a <NEWLINE> <DEDENT> <DEDENT> print a <NEWLINE> <DEDENT>
import sys <NEWLINE> s = sys . stdin . readline <NEWLINE> for n in iter ( s , <STRING> ) : <NEWLINE> <INDENT> d = { } <NEWLINE> for _ in [ 0 ] * int ( n ) : <NEWLINE> <INDENT> k , v = s ( ) [ : - 1 ] . split ( ) <NEWLINE> d [ k ] = v <NEWLINE> <DEDENT> print ( d . get ( * [ s ( ) [ 0 ] ] * 2 ) for _ in [ 0 ] * int ( s ( ) ) , sep = <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> x = { } <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> k , v = sys . stdin . readline ( ) . rstrip ( ) . split ( ) <NEWLINE> dic [ k ] = v <NEWLINE> <DEDENT> n = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> y = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> c = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> if c in x : <NEWLINE> <INDENT> y . append ( x [ c ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( y ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while 1 : <NEWLINE> <INDENT> T , U , N , E , W , S = 1 , 6 , 5 , 3 , 4 , 2 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ans = T <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> di = raw_input ( ) <NEWLINE> if di == <STRING> : <NEWLINE> <INDENT> N , T , S , U = T , S , U , N <NEWLINE> <DEDENT> elif di == <STRING> : <NEWLINE> <INDENT> E , U , W , T = T , E , U , W <NEWLINE> <DEDENT> elif di == <STRING> : <NEWLINE> <INDENT> T , S , U , N = N , T , S , U <NEWLINE> <DEDENT> elif di == <STRING> : <NEWLINE> <INDENT> T , E , U , W = E , U , W , T <NEWLINE> <DEDENT> elif di == <STRING> : <NEWLINE> <INDENT> E , S , W , N = S , W , N , E <NEWLINE> <DEDENT> elif di == <STRING> : <NEWLINE> <INDENT> S , W , N , E = E , S , W , N <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> , di <NEWLINE> raise IOError <NEWLINE> <DEDENT> ans += T <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
def North ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 3 ] <NEWLINE> new_dice [ 1 ] = dice [ 0 ] <NEWLINE> new_dice [ 2 ] = dice [ 2 ] <NEWLINE> new_dice [ 3 ] = dice [ 5 ] <NEWLINE> new_dice [ 4 ] = dice [ 4 ] <NEWLINE> new_dice [ 5 ] = dice [ 1 ] <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def East ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 4 ] <NEWLINE> new_dice [ 1 ] = dice [ 1 ] <NEWLINE> new_dice [ 2 ] = dice [ 0 ] <NEWLINE> new_dice [ 3 ] = dice [ 3 ] <NEWLINE> new_dice [ 4 ] = dice [ 5 ] <NEWLINE> new_dice [ 5 ] = dice [ 2 ] <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def West ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 5 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 4 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def South ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 5 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 3 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def Right ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 5 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def Left ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 5 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> print ( ) <NEWLINE> break <NEWLINE> <DEDENT> dice = [ 1 , 5 , 3 , 2 , 4 , 6 ] <COMMENT> <NEWLINE> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> instruct = raw_input ( ) <NEWLINE> if instruct == <STRING> : <NEWLINE> <INDENT> dice = North ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = East ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = South ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = West ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = Right ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = Left ( dice ) <NEWLINE> <COMMENT> <NL> <DEDENT> sum += dice [ 0 ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
def North ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 3 ] <NEWLINE> new_dice [ 1 ] = dice [ 0 ] <NEWLINE> new_dice [ 2 ] = dice [ 2 ] <NEWLINE> new_dice [ 3 ] = dice [ 5 ] <NEWLINE> new_dice [ 4 ] = dice [ 4 ] <NEWLINE> new_dice [ 5 ] = dice [ 1 ] <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def East ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 4 ] <NEWLINE> new_dice [ 1 ] = dice [ 1 ] <NEWLINE> new_dice [ 2 ] = dice [ 0 ] <NEWLINE> new_dice [ 3 ] = dice [ 3 ] <NEWLINE> new_dice [ 4 ] = dice [ 5 ] <NEWLINE> new_dice [ 5 ] = dice [ 2 ] <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def West ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 5 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 4 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def South ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 5 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 3 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def Right ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 5 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def Left ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 5 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice = [ 1 , 5 , 3 , 2 , 4 , 6 ] <NEWLINE> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> instruct = raw_input ( ) <NEWLINE> if instruct == <STRING> : <NEWLINE> <INDENT> dice = North ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = East ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = South ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = West ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = Right ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = Left ( dice ) <NEWLINE> <COMMENT> <NL> <DEDENT> sum += dice [ 0 ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> operator = sys . stdin . read ( ) . split ( ) <NEWLINE> <NL> top = 1 <NEWLINE> bottom = 6 <NEWLINE> south = 2 <NEWLINE> north = 5 <NEWLINE> east = 3 <NEWLINE> west = 4 <NEWLINE> sum = 1 <NEWLINE> <NL> for var in operator [ 1 : ] : <NEWLINE> <INDENT> if var == <STRING> : <NEWLINE> <INDENT> north , top , south , bottom = top , south , bottom , north <NEWLINE> sum += top <NEWLINE> <DEDENT> elif var == <STRING> : <NEWLINE> <INDENT> south , top , north , bottom = top , north , bottom , south <NEWLINE> sum += top <NEWLINE> <DEDENT> elif var == <STRING> : <NEWLINE> <INDENT> west , top , east , bottom = top , east , bottom , west <NEWLINE> sum += top <NEWLINE> <DEDENT> elif var == <STRING> : <NEWLINE> <INDENT> east , top , west , bottom = top , west , bottom , east <NEWLINE> sum += top <NEWLINE> <DEDENT> elif var == <STRING> : <NEWLINE> <INDENT> south , east , north , west = east , north , west , south <NEWLINE> sum += top <NEWLINE> <DEDENT> elif var == <STRING> : <NEWLINE> <INDENT> south , west , north , east = west , north , east , south <NEWLINE> sum += top <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print sum <NEWLINE> top = 1 <NEWLINE> bottom = 6 <NEWLINE> south = 2 <NEWLINE> north = 5 <NEWLINE> east = 3 <NEWLINE> west = 4 <NEWLINE> sum = 1 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> s = sys . stdin <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( s . readline ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = 1 ; s = <STRING> <NEWLINE> for _ in [ 0 ] * n : <NEWLINE> <INDENT> s = [ s [ int ( e ) ] for e in { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } [ s . readline ( ) [ 0 ] ] ] <NEWLINE> a += int ( s [ 0 ] ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <NL> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice = [ 1 , 2 , 3 , 4 , 5 , 6 ] <NEWLINE> <COMMENT> <NL> direction = <STRING> <NEWLINE> total = 1 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> direction = str ( raw_input ( ) ) <NEWLINE> if direction == <STRING> : <NEWLINE> <INDENT> North ( dice ) <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> East ( dice ) <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> West ( dice ) <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> South ( dice ) <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> Right ( dice ) <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> Left ( dice ) <NEWLINE> <DEDENT> total += dice [ 0 ] <NEWLINE> <DEDENT> print total <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> <NL> def North ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 3 ] <NEWLINE> new_dice [ 1 ] = dice [ 0 ] <NEWLINE> new_dice [ 2 ] = dice [ 2 ] <NEWLINE> new_dice [ 3 ] = dice [ 5 ] <NEWLINE> new_dice [ 4 ] = dice [ 4 ] <NEWLINE> new_dice [ 5 ] = dice [ 1 ] <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def East ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 4 ] <NEWLINE> new_dice [ 1 ] = dice [ 1 ] <NEWLINE> new_dice [ 2 ] = dice [ 0 ] <NEWLINE> new_dice [ 3 ] = dice [ 3 ] <NEWLINE> new_dice [ 4 ] = dice [ 5 ] <NEWLINE> new_dice [ 5 ] = dice [ 2 ] <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def West ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 5 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 4 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def South ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 5 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 3 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def Right ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 5 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> def Left ( dice ) : <NEWLINE> <INDENT> new_dice = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> new_dice [ 0 ] = dice [ 0 ] <COMMENT> <NEWLINE> new_dice [ 1 ] = dice [ 2 ] <COMMENT> <NEWLINE> new_dice [ 2 ] = dice [ 3 ] <COMMENT> <NEWLINE> new_dice [ 3 ] = dice [ 4 ] <COMMENT> <NEWLINE> new_dice [ 4 ] = dice [ 1 ] <COMMENT> <NEWLINE> new_dice [ 5 ] = dice [ 5 ] <COMMENT> <NEWLINE> return new_dice <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice = [ 1 , 5 , 3 , 2 , 4 , 6 ] <COMMENT> <NEWLINE> sum = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> instruct = raw_input ( ) <NEWLINE> if instruct == <STRING> : <NEWLINE> <INDENT> dice = North ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = East ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = South ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = West ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = Right ( dice ) <NEWLINE> <DEDENT> elif instruct == <STRING> : <NEWLINE> <INDENT> dice = Left ( dice ) <NEWLINE> <COMMENT> <NL> <DEDENT> sum += dice [ 0 ] <NEWLINE> <DEDENT> print ( sum ) <NEWLINE> <DEDENT>
def input_n ( infile , outfile ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( infile . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice ( infile , outfile , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dice ( infile , outfile , n ) : <NEWLINE> <INDENT> point = 1 <NEWLINE> top = 1 <NEWLINE> east = 3 <NEWLINE> south = 2 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> buff = top <NEWLINE> command = infile . readline ( ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> point += south <NEWLINE> top = south <NEWLINE> south = ( 7 - buff ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> point += ( 7 - south ) <NEWLINE> top = ( 7 - south ) <NEWLINE> south = buff <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> point += ( 7 - east ) <NEWLINE> top = ( 7 - east ) <NEWLINE> east = buff <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> point += east <NEWLINE> top = east <NEWLINE> east = ( 7 - buff ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> remember = south <NEWLINE> south = east <NEWLINE> east = ( 7 - remember ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> remember = east <NEWLINE> east = south <NEWLINE> south = ( 7 - remember ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print >> outfile , point <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> input_n ( sys . stdin , sys . stdout ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> count = input ( ) <NEWLINE> if count == 0 : break <NEWLINE> previous_cube = [ 1 , 2 , 3 , 4 , 5 , 6 ] <NEWLINE> operation = { <STRING> : [ 1 , 5 , 2 , 3 , 0 , 4 ] , <STRING> : [ 3 , 1 , 0 , 5 , 4 , 2 ] , <STRING> : [ 2 , 1 , 5 , 0 , 4 , 3 ] , <STRING> : [ 4 , 0 , 2 , 3 , 5 , 1 ] , <STRING> : [ 0 , 2 , 4 , 1 , 3 , 5 ] , <STRING> : [ 0 , 3 , 1 , 4 , 2 , 5 ] } <NEWLINE> sum = 1 <NEWLINE> for i in xrange ( count ) : <NEWLINE> <INDENT> new_cube = [ ] <NEWLINE> for e in xrange ( 5 ) : <NEWLINE> <INDENT> new_cube . append ( previous_cube [ operation [ raw_input ( ) . strip ( ) ] [ e ] ] ) <NEWLINE> <DEDENT> sum += new_cube [ 0 ] <NEWLINE> previous_cube = new_cube <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> places = dict ( zip ( range ( m ) , [ 0 ] * m ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> vote = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> places [ j ] += vote [ j ] <NEWLINE> <DEDENT> <DEDENT> for k , v sorted ( places . items , key = lambda x : x [ 1 ] , reverse = 1 ) : <NEWLINE> <INDENT> print k + 1 <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> students , places = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if students == 0 and places == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = dict ( zip ( range ( places ) , [ 0 ] * places ) ) <NEWLINE> for i in range ( students ) : <NEWLINE> <INDENT> points = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( places ) : <NEWLINE> <INDENT> res [ j ] += points [ j ] <NEWLINE> <DEDENT> <DEDENT> for k , v in sorted ( res . items ( ) , key = lambda x : x [ 1 ] , reverse = True ) : <NEWLINE> <INDENT> print k + 1 , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
def hoge ( numbers ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> answer = [ ] <NEWLINE> prev_number = number [ 0 ] <NEWLINE> for i , number in enumerate ( numbers ) : <NEWLINE> <INDENT> if number == numbers [ i - 1 ] or count == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif number != numbers [ i - 1 ] : <NEWLINE> <INDENT> asnwer . append ( count ) <NEWLINE> answer . append ( number ) <NEWLINE> count = 0 <NEWLINE> <DEDENT> <DEDENT> return answer <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> number_list = hoge ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> for n in range ( N - 1 ) : <NEWLINE> <INDENT> number_list = hoge ( number_list ) <NEWLINE> <DEDENT> for number in number_list : <NEWLINE> <INDENT> print number , <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> ns = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : ns = str ( input ( ) ) <NEWLINE> temp = <STRING> <NEWLINE> count = 1 <NEWLINE> for j in range ( len ( ns ) - 1 ) : <NEWLINE> <INDENT> if ns [ j ] == ns [ j + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp += str ( count ) + ns [ j ] <NEWLINE> count = 1 <NEWLINE> <DEDENT> <DEDENT> temp += str ( count ) + ns [ - 1 ] <NEWLINE> ns = temp <NEWLINE> <DEDENT> print ns <NEWLINE> <DEDENT>
def foo ( n ) : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> n = str ( n ) <NEWLINE> cnt = 1 <NEWLINE> for i in range ( 1 , len ( n ) ) : <NEWLINE> <INDENT> if n [ i - 1 ] == n [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += str ( cnt ) + n [ i - 1 ] <NEWLINE> cnt = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ret += str ( cnt ) + n [ - 1 ] <NEWLINE> <NL> return long ( ret ) <NEWLINE> <NL> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = foo ( m ) <NEWLINE> <DEDENT> print m <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> fp = open ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> def operate ( string ) : <NEWLINE> <INDENT> count = 1 <NEWLINE> prev = string [ 0 ] <NEWLINE> ret = <STRING> <NEWLINE> for c in string [ 1 : ] : <NEWLINE> <INDENT> if c == prev : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ret += str ( count ) + prev <NEWLINE> count = 1 <NEWLINE> <DEDENT> prev = c <NEWLINE> <DEDENT> ret += str ( count ) + prev <NEWLINE> <COMMENT> <NL> return ret <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( fp . readline ( ) [ : - 1 ] ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> orig = fp . readline ( ) [ : - 1 ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> orig = operate ( orig ) <NEWLINE> <NL> <DEDENT> print orig <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if j == 0 : ns = str ( input ( ) ) <NEWLINE> temp = <STRING> <NEWLINE> count = 1 <NEWLINE> for i in range ( len ( ns ) - 1 ) : <NEWLINE> <INDENT> if ns [ i ] == ns [ i + 1 ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp += str ( count ) + ns [ i ] <NEWLINE> count = 1 <NEWLINE> <DEDENT> <DEDENT> temp += str ( count ) + ns [ - 1 ] <NEWLINE> ns = temp <NEWLINE> <DEDENT> print ns <NEWLINE> <DEDENT>
def dfs ( s , com ) : <NEWLINE> <INDENT> if s == 0 : <NEWLINE> <INDENT> for i in xrange ( len ( com ) - 1 ) : <NEWLINE> <INDENT> if com [ i ] < com [ i + 1 ] : return <NEWLINE> <DEDENT> ans . append ( com ) <NEWLINE> <DEDENT> for i in xrange ( s , 0 , - 1 ) : <NEWLINE> <INDENT> if s >= i : <NEWLINE> <INDENT> com += str ( i ) <NEWLINE> dfs ( s - i , com ) <NEWLINE> com = com [ 0 : len ( com ) - 1 ] <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ans = [ ] <NEWLINE> ans = dfs ( n , <STRING> ) <NEWLINE> for i in xrange ( len ( ans ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( ans [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
l = [ 0 for i in range ( 20 ) ] <NEWLINE> pos = goal = 0 <NEWLINE> def solve ( cur , sum ) : <NEWLINE> <INDENT> global pos , goal <NEWLINE> if cur == goal : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , l [ : pos ] ) ) <NEWLINE> return <NEWLINE> <DEDENT> for i in range ( sum , 0 , - 1 ) : <NEWLINE> <INDENT> if cur + i <= goal : <NEWLINE> <INDENT> l [ pos ] = i <NEWLINE> pos += 1 <NEWLINE> solve ( cur + i , i ) <NEWLINE> pos -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> goal = int ( raw_input ( ) ) <NEWLINE> if goal == 0 : break <NEWLINE> solve ( 0 , goal ) <NEWLINE> <DEDENT>
s = sum ( map ( int , raw_input ( ) . split ( ) ) <NEWLINE> t = sum ( map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print max ( s , t ) <NEWLINE>
A = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> max = max ( [ max ( A ) , max ( B ) ] ) <NEWLINE> print ( max ) <NEWLINE>
while True : <NEWLINE> <INDENT> a , b , c , d = map ( int , input ( ) . split ( ) ) <NEWLINE> e , f , g , h = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b + c + d <NEWLINE> y = e + f + g + h <NEWLINE> if x <= y : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( sum ( a , b ) ) ) <NEWLINE>
students = list ( range ( 30 ) ) <NEWLINE> [ students . remove ( int ( input ( ) ) ) for _ in range ( 28 ) ] <NEWLINE> [ print ( student ) for student in students ] <NEWLINE>
ref = [ i for i in range ( 1 , 31 ) ] <NEWLINE> for i in range ( 28 ) : <NEWLINE> <INDENT> ref . pop ( int ( raw_input ( ) ) - 1 ) <NEWLINE> <DEDENT> for i in ref : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
a = [ False for i in range ( 31 ) ] <NEWLINE> <NL> for i in range ( 30 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> a [ x ] = True <NEWLINE> <DEDENT> for i in range ( 1 , 30 ) : <NEWLINE> <INDENT> if a [ i ] == False : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT>
data = [ x + 1 for x in xrange ( 30 ) ] <NEWLINE> <COMMENT> <NL> <NL> for i in xrange ( 30 ) : <NEWLINE> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> <NL> data . remove ( a ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> for i in data : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
dic = <STRING> <NEWLINE> code = raw_input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for w in code : <NEWLINE> <INDENT> ans += dic [ ( dic . index ( w ) + 24 ) % 27 ] <NEWLINE> <DEDENT> print ans <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> deck = [ i for i in range ( 1 , 2 * n + 1 ) ] <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> k = int ( raw_input ( ) ) <NEWLINE> if k == 0 : <NEWLINE> <INDENT> deck1 = [ ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> deck1 += deck [ i ] + deck [ n + i ] <NEWLINE> <DEDENT> deck = deck1 <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> deck = deck [ k + 1 : ] + deck [ : k + 1 ] <NEWLINE> <DEDENT> <DEDENT> for i in deck : <NEWLINE> <INDENT> print deck <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> m = sum ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> fixed = [ 2 ] * m <NEWLINE> failures = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> i , j , k , r = map ( int , input ( ) . split ( ) ) <NEWLINE> i , j , k = ( x - 1 for x in ( i , j , k ) ) <NEWLINE> if r : <NEWLINE> <INDENT> fixed [ i ] = fixed [ j ] = fixed [ k ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> failures . append ( ( i , j , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i , j , k in failures : <NEWLINE> <INDENT> fi , fj , fk = ( fixed [ x ] for x in ( i , j , k ) ) <NEWLINE> if fi == 1 : <NEWLINE> <INDENT> if fj == 1 : <NEWLINE> <INDENT> fixed [ k ] = 0 <NEWLINE> <DEDENT> elif fk == 1 : <NEWLINE> <INDENT> fixed [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> elif fj == 1 and fk == 1 : <NEWLINE> <INDENT> fi = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( str ( x ) for x in fixed ) + <STRING> ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if l [ 0 ] == 0 and l [ 1 ] == 0 and l [ 2 ] == 0 : break <NEWLINE> n = l [ 0 ] + l [ 1 ] + l [ 2 ] <NEWLINE> s = [ ] <COMMENT> <NEWLINE> a = set ( range ( n ) ) <COMMENT> <NEWLINE> b = set ( ) <COMMENT> <NEWLINE> c = set ( ) <COMMENT> <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> x , y , z , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x -= 1 ; y -= 1 ; z -= 1 ; <NEWLINE> if r == 0 : s . append ( set ( [ x , y , z ] ) ) <NEWLINE> else : <NEWLINE> <INDENT> c . add ( x ) ; c . add ( y ) ; c . add ( z ) ; <NEWLINE> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> f = True <NEWLINE> for lst in s : <NEWLINE> <INDENT> if len ( lst & c ) >= 2 : <NEWLINE> <INDENT> s . remove ( lst ) <NEWLINE> lst = lst - c <NEWLINE> if len ( lst ) >= 1 : b . add ( lst . pop ( ) ) <NEWLINE> f = False <NEWLINE> <DEDENT> <DEDENT> if f : break <NEWLINE> <DEDENT> a = a - b ; a = a - c ; <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i in a : print 2 <NEWLINE> elif i in b : print 0 <NEWLINE> else : print 1 <NEWLINE> <DEDENT> <DEDENT>
p = [ [ 0 for i in xrange ( 16 ) ] for j in xrange ( 16 ) ] <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == b == 0 : break <NEWLINE> n = input ( ) <NEWLINE> for i in xrange ( b ) : <NEWLINE> <INDENT> for j in xrange ( a ) : <NEWLINE> <INDENT> p [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p [ y - 1 ] [ x - 1 ] = - 10 ** 6 <NEWLINE> <DEDENT> p [ 0 ] [ 0 ] = 1 <NEWLINE> for i in xrange ( b ) : <NEWLINE> <INDENT> for j in xrange ( a ) : <NEWLINE> <INDENT> if p [ i ] [ j ] < 0 : continue <NEWLINE> p [ i + 1 ] [ j ] += p [ i ] [ j ] ; p [ i ] [ j + 1 ] += p [ i ] [ j ] ; <NEWLINE> <DEDENT> <DEDENT> print p [ b - 1 ] [ a - 1 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import copy <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> <COMMENT> <NL> while line . split ( ) != [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> analy ( line ) <NEWLINE> line = sys . stdin . readline ( ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> def analy ( line ) : <NEWLINE> <COMMENT> <NL> <INDENT> field = [ int ( n ) for n in line . split ( ) ] <NEWLINE> <COMMENT> <NL> num = int ( sys . stdin . readline ( ) ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> a = sys . stdin . readline ( ) <NEWLINE> b = [ int ( n ) for n in a . split ( ) ] <NEWLINE> <COMMENT> <NL> data . append ( b ) <NEWLINE> <DEDENT> print ( compute ( field , data ) ) <NEWLINE> <NL> <DEDENT> def compute ( field , ng ) : <NEWLINE> <INDENT> list = [ ] <NEWLINE> for i in range ( field [ 1 ] ) : <NEWLINE> <INDENT> for j in range ( field [ 0 ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> if i == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> if [ j + 1 , i + 1 ] in ng : <NEWLINE> <INDENT> list . append ( 0 ) <NEWLINE> <DEDENT> elif j == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> list . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( list [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if [ j + 1 , i + 1 ] in ng : <NEWLINE> <INDENT> list [ j ] = 0 <NEWLINE> <DEDENT> elif j != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> list [ j ] = list [ j - 1 ] + list [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return list [ len ( list ) - 1 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( x , y ) : <NEWLINE> <INDENT> if x == a and y == b : return 1 <NEWLINE> if x > a or y > b or [ x , y ] in block : return 0 <NEWLINE> return solve ( x + 1 , y ) + solve ( x , y + 1 ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> block = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( input ( ) ) ] <NEWLINE> print solve ( 1 , 1 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <COMMENT> <NL> fp = sys . stdin <NEWLINE> <NL> while True : <NEWLINE> <INDENT> req = map ( int , fp . readline ( ) [ : - 1 ] . split ( <STRING> ) ) <NEWLINE> if req [ 0 ] + req [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> n = req [ 0 ] <NEWLINE> k = req [ 1 ] <NEWLINE> <NL> sum_max = 0 <NEWLINE> num_list = [ ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> num = int ( fp . readline ( ) [ : - 1 ] ) <NEWLINE> num_list . append ( num ) <NEWLINE> if k > 0 : <NEWLINE> <INDENT> sum_max += num <NEWLINE> k -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_list . pop ( 0 ) <NEWLINE> sum_tmp = sum ( num_list ) <NEWLINE> if sum_tmp > sum_max : <NEWLINE> <INDENT> sum_max = sum_tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print sum_max <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == k == 0 : break <NEWLINE> L = [ input ( ) for i in range ( n ) ] <NEWLINE> maxInt = - 100000 <NEWLINE> for i in range ( n - k ) : <NEWLINE> <INDENT> maxInt = max ( maxInt , sum ( L [ i : i + k ] ) ) <NEWLINE> <DEDENT> print maxInt <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> b = [ 0 ] * ( n - k ) <NEWLINE> for ki in range ( k ) : <NEWLINE> <INDENT> for i in range ( n - k ) : <NEWLINE> <INDENT> b [ i ] += a [ i + ki ] <NEWLINE> <DEDENT> <DEDENT> print max ( b ) <NEWLINE> <DEDENT>
def func ( n , k ) : <NEWLINE> <INDENT> SUM = 0 <NEWLINE> ans = 0 <NEWLINE> A = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> SUM += A [ i ] <NEWLINE> <DEDENT> for i in range ( k , len ( A ) ) : <NEWLINE> <INDENT> ans = max ( ans , SUM + A [ i ] - A [ i - k ] ) <NEWLINE> SUM = SUM + A [ i ] - A [ i - k ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> for _ in range ( 10 ) <NEWLINE> <INDENT> n , k = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> if n == 0 and k == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> func ( n , k ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , k = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if not n and k : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> b = [ 0 ] * len ( a ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b [ i ] = b [ i - 1 ] + a [ i ] <NEWLINE> <DEDENT> b = b + [ 0 ] <NEWLINE> <NL> c = [ b [ i + k - 1 ] - b [ i - 1 ] for i in range ( n - k + 1 ) ] <NEWLINE> <NL> print ( max ( c ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> N , K = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = sorted ( [ int ( rraw_input ( ) ) for i in range ( 0 , K ) ] ) <NEWLINE> <NL> if ( N , K ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if A [ 0 ] == 0 : <NEWLINE> <INDENT> flag = True <NEWLINE> A = A [ 1 : ] <NEWLINE> K -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> diff = [ ] <NEWLINE> ans = 0 <NEWLINE> prev = 0 <NEWLINE> prev_prev = 0 <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , K ) : <NEWLINE> <INDENT> if A [ i ] - A [ i - 1 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> ans = max ( ans , count - prev_prev ) <NEWLINE> <DEDENT> elif A [ i ] - A [ i - 1 ] == 2 : <NEWLINE> <INDENT> if flag is True : <NEWLINE> <INDENT> count += 1 <NEWLINE> ans = max ( ans , count - prev_prev ) <NEWLINE> prev_prev = prev <NEWLINE> prev = count - prev <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> count = 0 <NEWLINE> <DEDENT> <DEDENT> print ( ans + A [ 0 ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> xy = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> S = set ( map ( tuple , xy ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x1 , y1 = xy [ i ] <NEWLINE> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> x2 , y2 = xy [ j ] <NEWLINE> a = ( x2 - y2 + y1 , y2 + x2 - x1 ) <NEWLINE> b = ( x1 - y2 + y1 , y1 + x2 - x1 ) <NEWLINE> if a in S and b in S : <NEWLINE> <INDENT> ans = max ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
import itertools <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> xy = sorted ( [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] ) <NEWLINE> dxy = [ [ xy1 [ 0 ] - xy2 [ 0 ] , xy1 [ 1 ] - xy2 [ 1 ] ] for xy1 , xy2 in itertools . combinations ( xy , 2 ) ] <NEWLINE> for i in range ( len ( dxy ) - 1 , - 1 , ) : <NEWLINE> <INDENT> if dxy . count ( dxy [ i ] ) < 2 : del dxy [ i ] <NEWLINE> <DEDENT> dxy = sorted ( dxy , key = lambda d : d [ 0 ] ** 2 + d [ 1 ] ** 2 , reverse = True ) <NEWLINE> for dx , dy in dxy : <NEWLINE> <INDENT> if dxy . count ( [ dy , - dx ] ) > 1 or dxy . count ( [ - dy , - dx ] ) > 1 : <NEWLINE> <INDENT> print dx ** 2 + dy ** 2 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> <DEDENT>
sys . setrecursionlimit ( 100000 ) <NEWLINE> V , E = int ( input ( ) ) , int ( input ( ) ) <NEWLINE> L = [ ] <NEWLINE> visited = [ 0 for i in range ( V ) ] <NEWLINE> edges = [ [ ] for i in range ( V ) ] <NEWLINE> <COMMENT> <NL> <NL> def visit ( x ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if not visited [ x ] : <NEWLINE> <INDENT> visited [ x ] = 1 <NEWLINE> for e in edges [ x ] : <NEWLINE> <INDENT> visit ( e ) <NEWLINE> <DEDENT> L . insert ( 0 , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( E ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> edges [ s - 1 ] . append ( t - 1 ) <NEWLINE> <NL> <DEDENT> for i in range ( V ) : <NEWLINE> <INDENT> if not visited [ i ] : <NEWLINE> <INDENT> visit ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> print ( L [ i ] + 1 ) <NEWLINE> if not flag and i < V - 1 and ( L [ i + 1 ] not in edges [ L [ i ] ] ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> <DEDENT> <DEDENT> print ( flag ) <NEWLINE>
<NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <DEDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Mobile : <NEWLINE> <INDENT> def __init__ ( self , leftratio = 0 , rightratio = 0 , left = - 1 , right = - 1 ) : <NEWLINE> <INDENT> self . weight = 0 <NEWLINE> self . leftratio = leftratio <NEWLINE> self . rightratio = rightratio <NEWLINE> self . left = left <NEWLINE> self . leftweight = 0 <NEWLINE> self . right = right <NEWLINE> self . rightweight = 0 <NEWLINE> <NL> <DEDENT> def calc ( self ) : <NEWLINE> <INDENT> if self . weight != 0 : return self . weight <NEWLINE> <NL> if self . left == - 1 : <NEWLINE> <INDENT> self . leftweight = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . leftweight = Mobile . calc ( self . left ) <NEWLINE> <DEDENT> if self . right == - 1 : <NEWLINE> <INDENT> self . rightweight = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . rightweight = Mobile . calc ( self . right ) <NEWLINE> <NL> <DEDENT> lmoment = self . leftratio * self . leftweight <NEWLINE> rmoment = self . rightratio * self . rightweight <NEWLINE> lcs = lmoment * rmoment // gcd ( lmoment , rmoment ) <NEWLINE> self . weight = ( lcs // self . leftratio ) + ( lcs // self . rightratio ) <NEWLINE> <NL> return self . weight <NEWLINE> <NL> <DEDENT> def stdout ( self ) : <NEWLINE> <INDENT> print ( self . left , self . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> barlist = [ Mobile ( ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , q , r , b = map ( int , input ( ) . split ( ) ) <NEWLINE> barlist [ i ] . leftratio = p <NEWLINE> barlist [ i ] . rightratio = q <NEWLINE> if r != 0 : barlist [ i ] . left = barlist [ r - 1 ] <NEWLINE> if b != 0 : barlist [ i ] . right = barlist [ b - 1 ] <NEWLINE> <NL> <DEDENT> maxi = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> maxi = max ( barlist [ i ] . calc ( ) , maxi ) <NEWLINE> <NL> <DEDENT> print ( maxi ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> def GCD ( a , b ) : <NEWLINE> <INDENT> dummy1 = max ( a , b ) <NEWLINE> dummy2 = min ( a , b ) <NEWLINE> while True : <NEWLINE> <INDENT> dummy = dummy1 % dummy2 <NEWLINE> dummy1 = dummy2 <NEWLINE> dummy2 = dummy <NEWLINE> if ( dummy == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return dummy1 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> if not N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cost = [ ] <NEWLINE> E = [ ] <NEWLINE> root = N * ( N - 1 ) / 2 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S = raw_input ( ) . split ( ) <NEWLINE> c1 , c2 , e1 , e2 = list ( map ( int , S ) ) <NEWLINE> cost . append ( ( c1 , c2 ) ) <NEWLINE> root -= e1 + e2 <NEWLINE> e1 -= 1 <NEWLINE> e2 -= 1 <NEWLINE> E . append ( ( e1 , e2 ) ) <NEWLINE> <DEDENT> def nums ( e ) : <NEWLINE> <INDENT> N_lst1 = [ ] <NEWLINE> N_lst2 = [ ] <NEWLINE> val_lst1 = [ ] <NEWLINE> val_lst2 = [ ] <NEWLINE> if E [ e ] [ 0 ] != - 1 : <NEWLINE> <INDENT> N_lst1 , val_lst1 = nums ( E [ e ] [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N_lst1 = [ 1 ] <NEWLINE> val_lst1 = [ ] <NEWLINE> <NL> <DEDENT> if E [ e ] [ 1 ] != - 1 : <NEWLINE> <INDENT> N_lst2 , val_lst2 = nums ( E [ e ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> N_lst2 = [ 1 ] <NEWLINE> val_lst2 = [ ] <NEWLINE> <NL> <DEDENT> mul1 = cost [ e ] [ 0 ] <NEWLINE> for num in val_lst1 : <NEWLINE> <INDENT> mul1 *= num <NEWLINE> <DEDENT> mul2 = cost [ e ] [ 1 ] <NEWLINE> for num in val_lst2 : <NEWLINE> <INDENT> mul2 *= num <NEWLINE> <DEDENT> for i in range ( len ( N_lst1 ) ) : <NEWLINE> <INDENT> N_lst1 [ i ] *= mul2 <NEWLINE> <DEDENT> for i in range ( len ( N_lst2 ) ) : <NEWLINE> <INDENT> N_lst2 [ i ] *= mul1 <NEWLINE> <NL> <DEDENT> return N_lst1 + N_lst2 , val_lst1 + val_lst2 + [ cost [ e ] [ 0 ] + cost [ e ] [ 1 ] ] <NEWLINE> <DEDENT> N_lst , v_lst = nums ( root - 1 ) <NEWLINE> <COMMENT> <NL> num_GCD = N_lst [ 0 ] <NEWLINE> for num in N_lst : <NEWLINE> <INDENT> num_GCD = GCD ( num , num_GCD ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( N_lst ) ) : <NEWLINE> <INDENT> N_lst [ i ] //= num_GCD <NEWLINE> <COMMENT> <NL> <DEDENT> print sum ( N_lst ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> c = 0 <NEWLINE> a = int ( input ( ) ) <NEWLINE> me = 1000 - a <NEWLINE> while me != 0 : <NEWLINE> <INDENT> if me >= 500 : <NEWLINE> <INDENT> me -= 500 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif me >= 100 : <NEWLINE> <INDENT> me -= 100 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif me >= 50 : <NEWLINE> <INDENT> me -= 50 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif me >= 10 : <NEWLINE> <INDENT> me -= 10 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif me >= 5 : <NEWLINE> <INDENT> me -= 5 <NEWLINE> c += 1 <NEWLINE> <DEDENT> elif me >= 1 : <NEWLINE> <INDENT> me -= 1 <NEWLINE> c += 1 <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT>
import sys <NEWLINE> x = sys . stdin . read ( ) . split ( ) <NEWLINE> <NL> def otsuri ( x ) : <NEWLINE> <INDENT> a = 0 <NEWLINE> y = 1000 - x <NEWLINE> if y == 1000 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> while y >= 0 : <NEWLINE> <INDENT> if y - 500 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y - 500 <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> while y >= 0 : <NEWLINE> <INDENT> if y - 100 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y - 100 <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> while y >= 0 : <NEWLINE> <INDENT> if y - 50 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y - 50 <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> while y >= 0 : <NEWLINE> <INDENT> if y - 10 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y - 10 <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> while y >= 0 : <NEWLINE> <INDENT> if y - 5 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y - 5 <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> while y >= 0 : <NEWLINE> <INDENT> if y - 1 < 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y - 1 <NEWLINE> a = a + 1 <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> x = map ( int , x ) <NEWLINE> for change in x : <NEWLINE> <INDENT> print otsuri ( change ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = 1000 - input ( ) <NEWLINE> if n == 0 : break <NEWLINE> m = [ 500 , 100 , 50 , 10 , 5 , 1 ] <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> x = n / m [ i ] ; n -= m [ i ] * x ; m [ i ] = x ; <NEWLINE> <DEDENT> print reduce ( lambda a , x : a + x , m ) <NEWLINE> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> while 1 : <NEWLINE> <INDENT> b , c = 1000 - int ( e ) , 0 <NEWLINE> for i in [ 500 , 100 , 50 , 10 , 5 ] : <NEWLINE> <INDENT> d , b = divmod ( b , i ) <NEWLINE> c += d <NEWLINE> <DEDENT> print ( b + c ) <NEWLINE> <DEDENT>
c = [ 500 , 100 , 50 , 10 , 5 , 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> e = 1000 - int ( raw_input ( ) ) <NEWLINE> if e == 0 : break <NEWLINE> i , m = 0 , 0 <NEWLINE> while e > 0 : <NEWLINE> <INDENT> if e >= c [ i ] : <NEWLINE> <INDENT> e -= c [ i ] <NEWLINE> m += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print m <NEWLINE> <DEDENT>
coins = [ 500 , 100 , 50 , 10 , 5 , 1 ] <NEWLINE> <NL> def count ( x , y ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> while x >= y : <NEWLINE> <INDENT> x -= y <NEWLINE> ret += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 0 <NEWLINE> n = 1000 - n <NEWLINE> for val in coins : <NEWLINE> <INDENT> n , t = count ( n , val ) <NEWLINE> ans += t <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> s = input ( <STRING> ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> cut_ss = [ s [ i : i + 3 ] for i in range ( len ( s [ : - 2 ] ) ) ] <NEWLINE> <NL> n_joi = 0 <NEWLINE> n_ioi = 0 <NEWLINE> for cut_s in cut_ss : <NEWLINE> <INDENT> if cut_s == <STRING> : <NEWLINE> <INDENT> n_joi += 1 <NEWLINE> <DEDENT> if cut_s == <STRING> : <NEWLINE> <INDENT> n_ioi += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( n_joi ) <NEWLINE> print ( n_ioi ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> joi = 0 <NEWLINE> ioi = 0 <NEWLINE> s_list = [ s [ i : i + 3 ] for i in range ( len ( s ) - 2 ) ] <NEWLINE> for i in s_list : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> joi += 1 <NEWLINE> <DEDENT> if i == <STRING> : <NEWLINE> <INDENT> ioi += 1 <NEWLINE> <DEDENT> <DEDENT> print ( joi ) <NEWLINE> print ( ioi ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> p = sorted ( [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] ) <NEWLINE> d = [ [ p [ i ] [ 0 ] - p [ 0 ] [ 0 ] , p [ i ] [ 1 ] - p [ 0 ] [ 1 ] ] for i in range ( 1 , n ) ] <NEWLINE> m = input ( ) <NEWLINE> q = sorted ( [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( m ) ] ) <NEWLINE> for p1 in q : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> f = True <NEWLINE> for p2 in q : <NEWLINE> <INDENT> if p1 [ 0 ] + d [ i ] [ 0 ] == p2 [ 0 ] and p1 [ 1 ] + d [ i ] [ 1 ] == p2 [ 1 ] : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print p1 [ 0 ] - p [ 0 ] [ 0 ] , p1 [ 1 ] - p [ 0 ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> a = list ( { tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( e ) ) } ) <NEWLINE> s , t = a [ 0 ] <NEWLINE> b = { list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( input ( ) ) ) } <NEWLINE> for x , y in b : <NEWLINE> <INDENT> flag = True <NEWLINE> for u , v in a [ 1 : ] : <NEWLINE> <INDENT> if [ x + u - s , y + v - t ] not in b : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( x - s , y - t ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> a = sorted ( [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * int ( e ) ] , key = lambda x : x [ 0 ] ) <NEWLINE> b = sorted ( [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * int ( input ( ) ) ] , key = lambda x : x [ 0 ] ) <NEWLINE> for s , t in b : <NEWLINE> <INDENT> if not set ( ( u + s - a [ 0 ] [ 0 ] , v + t - a [ 0 ] [ 1 ] ) for u , v in a ) - set ( b ) : print ( x , y ) ; break <NEWLINE> <DEDENT> <DEDENT>
import operator <NEWLINE> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> target = [ [ * map ( int , input ( ) . split ( ) ) ] for _ in [ 0 ] * int ( e ) ] <NEWLINE> s , t = min ( target ) <NEWLINE> target = { ( x - bx , y - by ) for x , y in target } <NEWLINE> max_tx = max ( map ( lambda x : x [ 0 ] , target ) ) <NEWLINE> b = { tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * int ( input ( ) ) } <NEWLINE> max_sx = max ( map ( operator . itemgetter ( 0 ) , b ) ) <NEWLINE> lim_x = max_sx - max_tx <NEWLINE> for x , y in b : <NEWLINE> <INDENT> if x > lim_x : continue <NEWLINE> for u , v in target : <NEWLINE> <INDENT> if ( x + u , y + v ) not in b : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - s , y - t ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if not m : break <NEWLINE> seiza = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> seiza . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> kijun = seiza . pop ( 0 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> hosi = [ ] <NEWLINE> point = { } <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> point [ x , y ] = 1 <NEWLINE> hosi . append ( [ x , y ] ) <NEWLINE> <NL> <DEDENT> for a in hosi : <NEWLINE> <INDENT> dx , dy = a [ 0 ] - kijun [ 0 ] , a [ 1 ] - kijun [ 1 ] <NEWLINE> for b in seiza : <NEWLINE> <INDENT> if not ( b [ 0 ] + dx , b [ 1 ] + dy ) in point : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( dx , dy ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
while 1 : <NEWLINE> <INDENT> m = int ( raw_input ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> st = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( m ) ] <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> pi = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n ) ] <NEWLINE> d = [ [ st [ i ] [ 0 ] - st [ 0 ] [ 0 ] , st [ i ] [ 1 ] - st [ 0 ] [ 1 ] ] for i in xrange ( 1 , m ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> mo = [ [ pi [ j ] [ 0 ] - pi [ i ] [ 0 ] , pi [ j ] [ 1 ] - pi [ i ] [ 1 ] ] for j in xrange ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for k in xrange ( m - 1 ) : <NEWLINE> <INDENT> if not d [ k ] in mo : continue <NEWLINE> else : cnt += 1 <NEWLINE> <DEDENT> if cnt == m - 1 : <NEWLINE> <INDENT> print pi [ i ] [ 0 ] - st [ 0 ] [ 0 ] , pi [ i ] [ 1 ] - st [ 0 ] [ 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def f ( e ) : <NEWLINE> <INDENT> a = list ( [ * map ( int , input ( ) . split ( ) ) ] for _ in range ( int ( e ) ) ) <NEWLINE> s , t = a [ 0 ] <NEWLINE> b = { ( * map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( input ( ) ) ) } <NEWLINE> for x , y in b : <NEWLINE> <INDENT> for u , v in a [ 1 : ] : <NEWLINE> <INDENT> if ( x + u - s , y + v - t ) not in b : break <NEWLINE> <DEDENT> else : return print ( x - s , y - t ) <NEWLINE> <DEDENT> <DEDENT> for e in iter ( input , <STRING> ) : f ( e ) <NEWLINE>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> a = { tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( e ) ) } <NEWLINE> s , t = a [ 0 ] <NEWLINE> b = { tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( int ( input ( ) ) ) } <NEWLINE> for x , y in b : <NEWLINE> <INDENT> flag = True <NEWLINE> for u , v in a [ 1 : ] : <NEWLINE> <INDENT> if ( x + u - s , y + v - t ) not in b : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> print ( x - s , y - t ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import operator <NEWLINE> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> target = [ [ * map ( int , input ( ) . split ( ) ) ] for _ in [ 0 ] * int ( e ) ] <NEWLINE> bx , by = min ( target ) <NEWLINE> target = { ( x - bx , y - by ) for x , y in target } <NEWLINE> max_tx = max ( map ( operator . itemgetter ( 0 ) , target ) ) <NEWLINE> b = { tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * int ( input ( ) ) } <NEWLINE> max_sx = max ( map ( operator . itemgetter ( 0 ) , b ) ) <NEWLINE> lim_x = max_sx - max_tx <NEWLINE> for x , y in b : <NEWLINE> <INDENT> if x > lim_x : continue <NEWLINE> for u , v in target : <NEWLINE> <INDENT> if ( x + tx , y + ty ) not in b : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x - bx , y - by ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def f ( ) : <NEWLINE> <INDENT> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * int ( e ) ] <NEWLINE> u , v = a [ 0 ] <NEWLINE> b = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in [ 0 ] * int ( input ( ) ) ] <NEWLINE> for x , y in b : <NEWLINE> <INDENT> for s , t in a [ 1 : ] : <NEWLINE> <INDENT> if ( x + s - u , y + t - v ) not in b : return print ( x - sx , y - sy ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> f ( ) <NEWLINE>
def hantei ( field , r , c ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> countc = 0 <NEWLINE> for j in range ( r ) : <NEWLINE> <INDENT> countc = countc + field [ j ] [ i ] <NEWLINE> <DEDENT> count = max ( countc , r - countc ) + count <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def turnr ( field , rn , r , c ) : <NEWLINE> <INDENT> if rn == r : <NEWLINE> <INDENT> return hantei ( field , r , c ) <NEWLINE> <DEDENT> field1 = field <NEWLINE> field2 = field <NEWLINE> field2 [ rn ] = [ not x for x in field [ rn ] ] <NEWLINE> return max ( turnr ( field1 , rn + 1 , r , c ) , turnr ( field2 , rn + 1 , r , c ) ) <NEWLINE> <NL> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> [ r , c ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> field = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> field . append ( [ int ( x ) for x in raw_input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> print turnr ( field , 0 , r , c ) <NEWLINE> <DEDENT> <DEDENT>
import copy <NEWLINE> <NL> def culc ( k ) : <NEWLINE> <INDENT> cnt_0 = 0 <NEWLINE> cnt_1 = 0 <NEWLINE> for i in xrange ( r ) : <NEWLINE> <INDENT> if osenbei1 [ i ] [ k ] == 1 : <NEWLINE> <INDENT> cnt_1 += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt_0 += 1 <NEWLINE> <DEDENT> <DEDENT> return max ( cnt_0 , cnt_1 ) <NEWLINE> <NL> <DEDENT> def rev ( j ) : <NEWLINE> <INDENT> for i in xrange ( c ) : <NEWLINE> <INDENT> if osenbei1 [ j ] [ i ] == 1 : <NEWLINE> <INDENT> osenbei1 [ j ] [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> osenbei1 [ j ] [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r == c == 0 : break <NEWLINE> osenbei = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( r ) ] <NEWLINE> r_cnt = [ [ 0 ] * 2 for _ in xrange ( r ) ] <NEWLINE> c_cnt = [ [ 0 ] * 2 for _ in xrange ( c ) ] <NEWLINE> dp = [ [ 0 ] * ( c + 1 ) for _ in xrange ( 1 << r ) ] <NEWLINE> for i in xrange ( 1 << r ) : <NEWLINE> <INDENT> osenbei1 = copy . deepcopy ( osenbei ) <NEWLINE> for j in xrange ( r ) : <NEWLINE> <INDENT> if i & ( 1 << j ) : <NEWLINE> <INDENT> rev ( j ) <NEWLINE> <DEDENT> <DEDENT> for k in xrange ( c ) : <NEWLINE> <INDENT> dp [ i ] [ k + 1 ] = dp [ i ] [ k ] + culc ( k ) <NEWLINE> <DEDENT> <DEDENT> ans = - 1 <NEWLINE> for i in xrange ( 1 << r ) : <NEWLINE> <INDENT> ans = max ( ans , max ( dp [ i ] ) ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r == c == 0 : break <NEWLINE> state = [ raw_input ( ) . split ( ) for i in range ( r ) ] <NEWLINE> state = map ( list , zip ( * state ) ) <NEWLINE> new_state = [ int ( <STRING> . join ( ls ) , 2 ) for ls in state ] <NEWLINE> ans = 0 <NEWLINE> h = r / 2 <NEWLINE> for i in range ( pow ( 2 , r ) ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for j in new_state : <NEWLINE> <INDENT> b = format ( i ^ j , <STRING> ) <NEWLINE> n = b . count ( <STRING> ) <NEWLINE> cnt += n if n > h else r - n <NEWLINE> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> r = int ( e . split ( ) [ 0 ] ) <NEWLINE> d = [ int ( <STRING> . join ( x ) , 2 ) for x in zip ( * [ input ( ) . split ( ) for _ in [ 0 ] * r ] ) ] <NEWLINE> a = 0 <NEWLINE> b = 1 << r <NEWLINE> c = [ 1 ] * b <NEWLINE> for m in range ( b ) : <NEWLINE> <INDENT> if c [ m ] : <NEWLINE> <INDENT> c [ ~ m ] = 0 <NEWLINE> t = 0 <NEWLINE> for s in d : <NEWLINE> <INDENT> c = bin ( m ^ s ) . count ( <STRING> ) <NEWLINE> t += c if c > r // 2 else r - c <NEWLINE> <DEDENT> if a < t : a = t <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r == 0 : break <NEWLINE> old = [ None for i in range ( r ) ] <NEWLINE> new = [ [ True ] * c for i in range ( r ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> old [ i ] = <STRING> . join ( map ( str , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> n = 1 << r <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> if i & ( 1 << j ) : <NEWLINE> <INDENT> for k in range ( c ) : <NEWLINE> <INDENT> new [ j ] [ k ] = bool ( int ( old [ j ] [ k ] ) ) ^ True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( c ) : <NEWLINE> <INDENT> new [ j ] [ k ] = bool ( int ( old [ j ] [ k ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ret = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( r ) : <NEWLINE> <INDENT> if not new [ k ] [ j ] : cnt += 1 <NEWLINE> <DEDENT> ret += cnt if cnt > r / 2 else r - cnt <NEWLINE> <DEDENT> ans = max ( ans , ret ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import * <NEWLINE> s = sys . stdin . readline <NEWLINE> def g ( s , g ) : <NEWLINE> <INDENT> F = [ 1e7 ] * - ~ n ; F [ s ] = 0 <NEWLINE> H = [ ( 0 , s ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == g : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : F [ v ] = t ; heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> for e in iter ( s , <STRING> ) : <NEWLINE> <INDENT> n , k = map ( int , e . split ( ) ) <NEWLINE> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = [ * map ( int , s ( ) . split ( ) ) ] <NEWLINE> if f [ 0 ] : <NEWLINE> <INDENT> c , d , e = f [ 1 : ] <NEWLINE> E [ c ] += [ ( e , d ) ] ; E [ d ] += [ ( e , c ) ] <NEWLINE> <DEDENT> else : print ( g ( * f [ 1 : ] ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> def g ( n , E , S , G ) : <NEWLINE> <INDENT> from heapq import * <NEWLINE> F = [ 1e7 ] * - ~ n ; F [ S ] = 0 <NEWLINE> H = [ ( 0 , S ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == G : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : <NEWLINE> <INDENT> F [ v ] = t <NEWLINE> heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def s ( n , k ) : <NEWLINE> <INDENT> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = r ( ) <NEWLINE> if <STRING> == f [ 0 ] : print ( g ( n , E , * map ( int , f [ 2 : ] . split ( ) ) ) ) <NEWLINE> else : <NEWLINE> <INDENT> c , d , e = map ( int , f [ 2 : ] . split ( ) ) <NEWLINE> E [ c ] += [ ( e , d ) ] ; E [ d ] += [ ( e , c ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> for e in iter ( r , <STRING> ) : s ( * map ( int , e . split ( ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import * <NEWLINE> r = sys . stdin . readline <NEWLINE> def g ( n , E , S , G ) : <NEWLINE> <INDENT> F = [ 1e7 ] * - ~ n ; F [ S ] = 0 <NEWLINE> H = [ ( 0 , S ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == G : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : <NEWLINE> <INDENT> F [ v ] = t <NEWLINE> heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def s ( n , k ) : <NEWLINE> <INDENT> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = r ( ) <NEWLINE> if <STRING> == f [ 0 ] : print ( g ( n , E , * map ( int , f [ 2 : ] . split ( ) ) ) ) <NEWLINE> else : <NEWLINE> <INDENT> c , d , e = map ( int , f [ 2 : ] . split ( ) ) <NEWLINE> E [ c ] += [ ( e , d ) ] ; E [ d ] += [ ( e , c ) ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE> <INDENT> for e in iter ( r , <STRING> ) : s ( * map ( int , e . split ( ) ) ) <NEWLINE> <DEDENT>
from heapq import * <NEWLINE> import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> def g ( n , E , S , G ) : <NEWLINE> <INDENT> F = [ 1e7 ] * - ~ n ; F [ S ] = 0 ; H = [ ( 0 , S ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == G : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : F [ v ] = t ; heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def s ( n , k ) : <NEWLINE> <INDENT> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = r ( ) <NEWLINE> if <STRING> == f [ 0 ] : print ( g ( n , E , * map ( int , f [ 2 : ] . split ( ) ) ) ) <NEWLINE> else : c = [ * map ( int , f [ 2 : ] . split ( ) ) ] ; E [ c ] += [ [ e , d ] ] ; E [ d ] += [ [ e , c ] ] <NEWLINE> <DEDENT> <DEDENT> for e in iter ( r , <STRING> ) : s ( * map ( int , e . split ( ) ) ) <NEWLINE>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> I = float ( <STRING> ) <NEWLINE> for e in iter ( r , <STRING> ) : <NEWLINE> <INDENT> n , k = map ( int , e . split ( ) ) <NEWLINE> F = [ [ I ] * - ~ n for _ in [ 0 ] * - ~ n ] <NEWLINE> for i in range ( 1 , n + 1 ) : F [ i ] [ i ] = 0 <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = r ( ) ; g = map ( int , f [ 2 : ] . split ( ) ) <NEWLINE> if <STRING> == f [ 0 ] : a , b = g ; A = F [ a ] [ b ] ; print ( [ A , - 1 ] [ A == I ] ) <NEWLINE> else : <NEWLINE> <INDENT> c , d , e = g <NEWLINE> if e < F [ c ] [ d ] : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , i ) : <NEWLINE> <INDENT> F [ i ] [ j ] = F [ j ] [ i ] = min ( F [ i ] [ j ] , F [ i ] [ c ] + e + F [ d ] [ j ] , F [ i ] [ d ] + e + F [ c ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
from heapq import * <NEWLINE> def g ( s , g ) : <NEWLINE> <INDENT> F = [ 1e7 ] * - ~ n ; F [ s ] = 0 <NEWLINE> H = [ ( 0 , s ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == g : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : F [ v ] = t ; heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> n , k = map ( int , e . split ( ) ) <NEWLINE> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = [ * map ( int , input ( ) . split ( ) ) ] <NEWLINE> if f [ 0 ] : <NEWLINE> <INDENT> c , d , e = f [ 1 : ] <NEWLINE> E [ c ] += [ ( e , d ) ] ; E [ d ] += [ ( e , c ) ] <NEWLINE> <DEDENT> else : print ( g ( * f [ 1 : ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
from heapq import * <NEWLINE> import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> def g ( n , E , S , G ) : <NEWLINE> <INDENT> F = [ 1e7 ] * - ~ n ; F [ S ] , H = 0 , [ ( 0 , S ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == G : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : F [ v ] = t ; heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def s ( n , k ) : <NEWLINE> <INDENT> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = r ( ) ; p = map ( int , f [ 2 : ] . split ( ) ) <NEWLINE> if <STRING> == f [ 0 ] : print ( g ( n , E , * p ) ) <NEWLINE> else : c , d , e = p ; E [ c ] , E [ d ] = E [ c ] + [ ( e , d ) ] , E [ d ] , [ ( e , c ) ] <NEWLINE> <DEDENT> <DEDENT> for e in iter ( r , <STRING> ) : s ( * map ( int , e . split ( ) ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> from heapq import * <NEWLINE> import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> def g ( n , E , S , G ) : <NEWLINE> <INDENT> F = [ 1e7 ] * - ~ n ; F [ S ] , H = 0 , [ ( 0 , S ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == G : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : F [ v ] = t ; heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> def s ( n , k ) : <NEWLINE> <INDENT> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = r ( ) ; p = map ( int , f [ 2 : ] . split ( ) ) <NEWLINE> if <STRING> == f [ 0 ] : print ( g ( n , E , * p ) ) <NEWLINE> else : c , d , e = p ; E [ c ] += [ ( e , d ) ] ; E [ d ] += [ ( e , c ) ] <NEWLINE> <DEDENT> <DEDENT> for e in iter ( r , <STRING> ) : s ( * map ( int , e . split ( ) ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from heapq import * <NEWLINE> def g ( s , g ) : <NEWLINE> <INDENT> F = [ 1e7 ] * - ~ n ; F [ s ] = 0 <NEWLINE> H = [ ( 0 , s ) ] <NEWLINE> while H : <NEWLINE> <INDENT> c , u = heappop ( H ) <NEWLINE> if u == g : return c <NEWLINE> for f , v in E [ u ] : <NEWLINE> <INDENT> t = c + f <NEWLINE> if t < F [ v ] : <NEWLINE> <INDENT> F [ v ] = t <NEWLINE> heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <DEDENT> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> n , k = map ( int , e . split ( ) ) <NEWLINE> E = [ [ ] for _ in [ 0 ] * - ~ n ] <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> f = input ( ) <NEWLINE> if <STRING> == f [ 0 ] : <NEWLINE> <INDENT> c , d , e = map ( int , f [ 2 : ] . split ( ) ) <NEWLINE> E [ c ] += [ ( e , d ) ] ; E [ d ] += [ ( e , c ) ] <NEWLINE> <DEDENT> else : print ( g ( * map ( int , f [ 2 : ] . split ( ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> top = - 1 <NEWLINE> fault = [ 0 ] <NEWLINE> S = 0 <NEWLINE> for i in range ( n / 2 ) : <COMMENT> <NEWLINE> <INDENT> s = int ( raw_input ( ) ) <COMMENT> <NEWLINE> if top != s : <NEWLINE> <INDENT> fault . append ( i ) <NEWLINE> top = s <NEWLINE> <DEDENT> s = int ( raw_input ( ) ) <COMMENT> <NEWLINE> if top != s : <NEWLINE> <INDENT> fault . pop ( ) <NEWLINE> top = s <NEWLINE> <DEDENT> <DEDENT> i = len ( fault ) - 1 <NEWLINE> while i > 0 : <NEWLINE> <INDENT> S = S + ( fault [ i ] - fault [ i - 1 ] ) * 2 <NEWLINE> i = i - 2 <NEWLINE> <DEDENT> if not top : <NEWLINE> <INDENT> S = 2 * ( n / 2 ) - S <NEWLINE> <DEDENT> if n % 2 == 1 : <NEWLINE> <INDENT> s = int ( raw_input ( ) ) <NEWLINE> S = S + ( 1 - s ) <NEWLINE> <DEDENT> print S <NEWLINE> <DEDENT> <DEDENT>
import re <NEWLINE> <NL> white = re . compile ( <STRING> ) <NEWLINE> black = re . compile ( <STRING> ) <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s = <STRING> <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 != 0 : <NEWLINE> <INDENT> s += raw_input ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> p = raw_input ( ) <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> m = white . search ( s ) <NEWLINE> s = white . sub ( <STRING> * len ( m . group ( 1 ) ) , s ) <NEWLINE> s += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = black . search ( s ) <NEWLINE> s = black . sub ( <STRING> * len ( m . group ( 1 ) ) , s ) <NEWLINE> s += <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print s . count ( <STRING> ) <NEWLINE> <DEDENT>
<NL> while True : <NEWLINE> <INDENT> stones = [ 0 , 0 ] <NEWLINE> n = input ( ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> stones . append ( input ( ) ) <NEWLINE> stones [ 0 ] = ( stones [ 2 ] + 1 ) % 2 <NEWLINE> stones . append ( 1 ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> m = input ( ) <NEWLINE> if i % 2 == 1 : <NEWLINE> <INDENT> if stones [ - 2 ] == m : <NEWLINE> <INDENT> stones [ - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stones . append ( m ) <NEWLINE> stones . append ( 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if stones [ - 2 ] == m : <NEWLINE> <INDENT> stones [ - 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stones [ - 3 ] += stones [ - 1 ] + 1 <NEWLINE> stones = stones [ : - 2 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for j in range ( 0 , len ( stones ) , 2 ) : <NEWLINE> <INDENT> if stones [ j ] == 0 : <NEWLINE> <INDENT> ans += stones [ j + 1 ] <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s , t = raw_input ( ) , raw_input ( ) <NEWLINE> if len ( s ) < len ( t ) : s , t = t , s <NEWLINE> ans = 0 <NEWLINE> for sp in range ( len ( t ) ) : <NEWLINE> <INDENT> for L in range ( len ( t ) - sp ) : <NEWLINE> <INDENT> if t [ sp : sp + L ] in s : <NEWLINE> <INDENT> ans = max ( ans , L ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> s1 = raw_input ( ) <NEWLINE> s2 = raw_input ( ) <NEWLINE> if len ( s1 ) < len ( s2 ) : s1 , s2 = s2 , s1 <NEWLINE> l = sum ( min ( s1 . count ( i ) , s2 . count ( i ) ) for i in set ( list ( s1 ) ) & set ( list ( s2 ) ) ) <NEWLINE> if l == 0 : print 0 ; continue <NEWLINE> f = False <NEWLINE> for i in range ( l , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( s2 ) - i + 1 ) : <NEWLINE> <INDENT> if s2 [ j : j + i ] in s1 : <NEWLINE> <INDENT> f = True <NEWLINE> print i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : break <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
from bisect import * <NEWLINE> while 1 : <NEWLINE> <INDENT> n , lmt = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> p = [ input ( ) for i in range ( n ) ] + [ 0 ] <NEWLINE> p = sorted ( set ( i + j for i in p for j in p ) ) <NEWLINE> s = bisect ( p , lmt ) <NEWLINE> print max ( i + p [ bisect ( p [ : s ] , lmt - i ) - 1 ] for i in p [ : s ] ) <NEWLINE> <DEDENT>
from bisect import * <NEWLINE> while 1 : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> P = [ int ( raw_input ( ) ) for i in range ( N ) ] + [ 0 ] <NEWLINE> P = sorted ( [ i + j for i in P for j in P ] ) <NEWLINE> s = bisect ( P , M ) - 1 <NEWLINE> print max ( i + P [ bisect ( P , M - i ) - 1 ] for i in P [ : s ] ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> while True : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == M == 0 : break <NEWLINE> L = [ input ( ) for i in range ( N ) ] <NEWLINE> L . append ( 0 ) <NEWLINE> S = set ( i + j for i in L for j in L ) <NEWLINE> B = sorted ( S ) <NEWLINE> maxInt = 0 <NEWLINE> t = bisect . bisect ( B , M ) - 1 <NEWLINE> for i in B [ : t ] : <NEWLINE> <INDENT> idx = bisect . bisect ( B , M - i ) <NEWLINE> maxInt = max ( maxInt , i + B [ idx - 1 ] ) <NEWLINE> <DEDENT> print maxInt <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> [ N , M ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> b = [ a [ x ] + a [ y ] for x in range ( N + 1 ) for y in range ( x , N + 1 ) ] <NEWLINE> <COMMENT> <NL> c = sorted ( b ) <NEWLINE> largest = 0 <NEWLINE> id = 0 <NEWLINE> for i in range ( 1 , len ( c ) + 1 ) : <NEWLINE> <INDENT> if id == len ( c ) or largest == M : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while ( id < len ( c ) and c [ - i ] + c [ id ] <= M ) : <NEWLINE> <INDENT> largest = max ( largest , c [ - i ] + c [ id ] ) <NEWLINE> id += 1 <NEWLINE> <DEDENT> <DEDENT> print largest <NEWLINE> <DEDENT>
import datetime <NEWLINE> <NL> <NL> def while_in_time ( two_times ) : <NEWLINE> <INDENT> times = two_times . split ( ) <COMMENT> <NEWLINE> <NL> in_time_str = <STRING> . join ( times [ : 3 ] ) <COMMENT> <NEWLINE> out_time_str = <STRING> . join ( times [ 3 : ] ) <COMMENT> <NEWLINE> <NL> in_time = datetime . datetime . strptime ( in_time_str , <STRING> ) <COMMENT> <NEWLINE> out_time = datetime . datetime . strptime ( out_time_str , <STRING> ) <NEWLINE> <NL> while_time = out_time - in_time <COMMENT> <NEWLINE> str_while_time = while_time . datetime . strftime ( while_time , <STRING> ) <NEWLINE> <NL> return str_while_time <NEWLINE> <NL> <NL> <DEDENT> A_time = input ( ) <NEWLINE> B_time = input ( ) <NEWLINE> C_time = input ( ) <NEWLINE> <NL> print ( while_in_time ( A_time ) ) <NEWLINE> print ( while_in_time ( B_time ) ) <NEWLINE> print ( while_in_time ( C_time ) ) <NEWLINE>
ef main ( ) : <NEWLINE> <NL> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> a = data [ : 3 ] <NEWLINE> <COMMENT> <NL> b = data [ 3 : ] <NEWLINE> <COMMENT> <NL> ans = [ 0 for x in range ( 3 ) ] <NEWLINE> <NL> t = b [ 2 ] - a [ 2 ] <NEWLINE> if t < 0 : <NEWLINE> <INDENT> ans [ 2 ] = t + 60 <NEWLINE> b [ 1 ] -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 2 ] = t <NEWLINE> <NL> <NL> <DEDENT> t = b [ 1 ] - a [ 1 ] <NEWLINE> if t < 0 : <NEWLINE> <INDENT> ans [ 1 ] = t + 60 <NEWLINE> b [ 0 ] -= 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> ans [ 1 ] = t <NEWLINE> <NL> <DEDENT> ans [ 0 ] = b [ 0 ] - a [ 0 ] <NEWLINE> <COMMENT> <NL> for a in ans [ : - 1 ] : <NEWLINE> <INDENT> print ( a , end = <STRING> ) <NEWLINE> <DEDENT> print ( ans [ - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for a in range ( 3 ) : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> w = [ ] <NEWLINE> k = [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> w . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> k . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> w . sort ( ) <NEWLINE> k . sort ( ) <NEWLINE> print ( sum ( w [ 7 : ] ) , sum ( k [ 7 : ] ) ) <NEWLINE> <DEDENT>
W = [ ] <NEWLINE> K = [ ] <NEWLINE> <NL> for i in range ( 20 ) : <NEWLINE> <INDENT> W . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( 20 ) : <NEWLINE> <INDENT> K . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> W . sort ( reverse = True ) <NEWLINE> K . sort ( reverse = True ) <NEWLINE> <NL> print ( W [ 0 ] + W [ 1 ] + W [ 2 ] ) <NEWLINE> print ( K [ 0 ] + K [ 1 ] + K [ 2 ] ) <NEWLINE>
w , k = [ ] , [ ] <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> w . append ( int ( raw_input ( ) ) <NEWLINE> <DEDENT> for i in range ( 10 ) : <NEWLINE> <INDENT> k . append ( int ( raw_input ( ) ) <NEWLINE> <DEDENT> print sum ( sorted ( w ) [ - 3 : ] ) , sum ( sorted ( k ) [ - 3 : ] ) <NEWLINE>
W = [ input ( ) for i in range ( 10 ) ] . sort ( ) <NEWLINE> K = [ input ( ) for i in range ( 10 ) ] . sort ( ) <NEWLINE> print sum ( W [ : 3 ] ) , sum ( K [ : 3 ] ) <NEWLINE>
from collections import deque <NEWLINE> while 1 : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> r = input ( ) <NEWLINE> if c == 0 : break <NEWLINE> l = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( r ) ] <NEWLINE> ans = 0 <NEWLINE> d = [ ( - 1 , 0 ) , ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) ] <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> q = deque ( ) <NEWLINE> a = [ [ 0 ] * c for x in range ( r ) ] <NEWLINE> if l [ j ] [ i ] == 0 : continue <NEWLINE> a [ j ] [ i ] = 1 <NEWLINE> q . append ( ( j , i ) ) <NEWLINE> while len ( q ) != 0 : <NEWLINE> <INDENT> cy , cx = q . popleft ( ) <NEWLINE> for x , y in d : <NEWLINE> <INDENT> dx = x + cx ; dy = y + cy ; <NEWLINE> if 0 <= dx < c and 0 <= dy < r and a [ dy ] [ dx ] == 0 and l [ dy ] [ dx ] == 1 : <NEWLINE> <INDENT> q . append ( ( dy , dx ) ) <NEWLINE> a [ dy ] [ dx ] = a [ cy ] [ cx ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( c ) : <NEWLINE> <INDENT> for j in range ( r ) : <NEWLINE> <INDENT> ans = max ( ans , a [ j ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> from array import array <NEWLINE> <NL> while True : <NEWLINE> <INDENT> m = int ( raw_input ( ) ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> if m == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> begin = [ array ( <STRING> , [ False ] * m ) for y in xrange ( n ) ] <NEWLINE> <NL> for y in xrange ( n ) : <NEWLINE> <INDENT> line = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> for x in xrange ( m ) : <NEWLINE> <INDENT> if line [ x ] == 1 : <NEWLINE> <INDENT> begin [ y ] [ x ] = True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> que = [ ] <NEWLINE> for x in xrange ( m ) : <NEWLINE> <INDENT> for y in xrange ( n ) : <NEWLINE> <INDENT> if begin [ y ] [ x ] : <NEWLINE> <INDENT> stage = deepcopy ( begin ) <NEWLINE> stage [ y ] [ x ] = False <NEWLINE> que . append ( ( stage , ( x , y ) , 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dx = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dy = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> while que : <NEWLINE> <INDENT> stage = que . pop ( ) <NEWLINE> for i in xrange ( 4 ) : <NEWLINE> <INDENT> nx = dx [ i ] + stage [ 1 ] [ 0 ] <NEWLINE> ny = dy [ i ] + stage [ 1 ] [ 1 ] <NEWLINE> if 0 <= nx < m and 0 <= ny < n and stage [ 0 ] [ ny ] [ nx ] : <NEWLINE> <INDENT> field = deepcopy ( stage [ 0 ] ) <NEWLINE> field [ ny ] [ nx ] = False <NEWLINE> ans = max ( ans , stage [ 2 ] + 1 ) <NEWLINE> que . append ( ( field , ( nx , ny ) , stage [ 2 ] + 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> dx = [ 0 , 0 , 1 , - 1 ] <NEWLINE> dy = [ 1 , - 1 , 0 , 0 ] <NEWLINE> <NL> def dfs ( y , x , cnt ) : <NEWLINE> <INDENT> Ice_cp [ y ] [ x ] = 0 <NEWLINE> cnt += 1 <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> mx = x + dx [ i ] <NEWLINE> my = y + dy [ i ] <NEWLINE> if 0 <= mx < m and 0 <= my < n and Ice_cp [ my ] [ mx ] == 1 : <NEWLINE> <INDENT> return dfs ( my , mx , cnt ) <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m = input ( ) <NEWLINE> n = input ( ) <NEWLINE> if n == m == 0 : break <NEWLINE> maxInt = 0 <NEWLINE> Ice = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( m ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> Ice_cp = deepcopy ( Ice ) <NEWLINE> if Ice_cp [ i ] [ j ] == 1 : <NEWLINE> <INDENT> maxInt = max ( maxInt , dfs ( i , j , cnt ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print maxInt <NEWLINE> <DEDENT>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> def s ( ) : <NEWLINE> <INDENT> def b ( M , x , y , n = 1 ) : <NEWLINE> <INDENT> M [ x ] [ y ] = 0 ; a = n <NEWLINE> if M [ x - 1 ] [ y ] : a = max ( a , b ( M , x - 1 , y , n + 1 ) ) <NEWLINE> if M [ x ] [ y - 1 ] : a = max ( a , b ( M , x , y - 1 , n + 1 ) ) <NEWLINE> if M [ x + 1 ] [ y ] : a = max ( a , b ( M , x + 1 , y , n + 1 ) ) <NEWLINE> if M [ x ] [ y + 1 ] : a = max ( a , b ( M , x , y + 1 , n + 1 ) ) <NEWLINE> M [ x ] [ y ] = 1 <NEWLINE> return a <NEWLINE> <DEDENT> for e in iter ( r , <STRING> ) : <NEWLINE> <INDENT> n , m = int ( e ) , int ( r ( ) ) <NEWLINE> P = [ [ 0 ] * ( n + 2 ) for _ in [ 0 ] * ( m + 2 ) ] <NEWLINE> for i in range ( m ) : P [ i + 1 ] [ 1 : - 1 ] = map ( int , r ( ) . split ( ) ) <NEWLINE> print ( max ( b ( P , i , j ) for i in range ( 1 , m + 1 ) for j in range ( 1 , n + 1 ) if P [ i ] [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
def s ( ) : <NEWLINE> <INDENT> def b ( M , x , y , n = 1 ) : <NEWLINE> <INDENT> M [ x ] [ y ] = 0 ; a = n <NEWLINE> if M [ x - 1 ] [ y ] : <NEWLINE> <INDENT> t = b ( M , x - 1 , y , n + 1 ) <NEWLINE> if a < t : a = t <NEWLINE> <DEDENT> if M [ x ] [ y - 1 ] : <NEWLINE> <INDENT> t = b ( M , x , y - 1 , n + 1 ) <NEWLINE> if a < t : a = t <NEWLINE> <DEDENT> if M [ x + 1 ] [ y ] : <NEWLINE> <INDENT> t = b ( M , x + 1 , y + 1 , n + 1 ) <NEWLINE> if a < t : a = t <NEWLINE> <DEDENT> if M [ x ] [ y + 1 ] : <NEWLINE> <INDENT> t = b ( M , x , y + 1 , n + 1 ) <NEWLINE> if a < t : a = t <NEWLINE> <DEDENT> M [ x ] [ y ] = 1 <NEWLINE> return a <NEWLINE> <DEDENT> for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> n , m = int ( e ) , int ( input ( ) ) <NEWLINE> P = [ [ 0 ] * ( n + 2 ) for _ in [ 0 ] * ( m + 2 ) ] <NEWLINE> for i in range ( m ) : P [ i + 1 ] [ 1 : - 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( max ( b ( P , i , j ) for i in range ( 1 , m + 1 ) for j in range ( 1 , n + 1 ) if P [ i ] [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
def allocate ( remains , limit_h , limit_w ) : <NEWLINE> <INDENT> global m <NEWLINE> if not remains : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if limit_w == 1 : <NEWLINE> <INDENT> return int ( remains <= limit_h ) <NEWLINE> <DEDENT> return sum ( allocate ( remains - i , i , limit_w - 1 ) for i in <NEWLINE> <INDENT> range ( min ( limit_h , remains , m - limit_w ) , ( remains - 1 ) // limit_w , - 1 ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> remains = s - sum ( range ( 1 , n ** 2 + 1 ) ) <NEWLINE> print ( allocate ( remains , remains , n ** 2 ) ) <NEWLINE> <DEDENT>
def listrep ( n , m , s ) : <NEWLINE> <INDENT> tab = [ [ [ 0 ] * ( s + 1 ) for j in range ( n + 1 ) ] <NEWLINE> tab [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for k in range ( s + 1 ) : <NEWLINE> <INDENT> if i <= k : <NEWLINE> <INDENT> tab [ i ] [ k ] += tab [ i ] [ k - i ] + tab [ i - 1 ] [ k - i ] <NEWLINE> <DEDENT> if j - 1 >= m : <NEWLINE> <INDENT> tab [ i ] [ k ] -= tab [ i - 1 ] [ j - 1 - m ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return tab [ n ] [ m ] [ s ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , m , s = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> n *= n <NEWLINE> print ( listrep ( n , m , s ) ) <NEWLINE> <DEDENT>
from string import find <NEWLINE> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> m = input ( ) <NEWLINE> s = raw_input ( ) <NEWLINE> t = <STRING> <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> t += <STRING> <NEWLINE> <DEDENT> i = ans = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> tmp = find ( s [ i : - 1 ] , t ) <NEWLINE> if tmp < 0 : break <NEWLINE> i += tmp + 1 <NEWLINE> ans += 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> a = raw_input ( ) <NEWLINE> P = <STRING> + <STRING> * n <NEWLINE> l = 1 + 2 * n <NEWLINE> c = 0 <NEWLINE> for i in range ( m - l + 1 ) : <NEWLINE> <INDENT> if a [ i : i + l ] = P : <NEWLINE> <DEDENT> print c <NEWLINE> <DEDENT>
def print_sum ( input ) : <NEWLINE> <INDENT> d , n , m = input [ 0 ] , input [ 1 ] , input [ 2 ] <NEWLINE> S , K = set ( [ 0 ] + input [ 3 : 3 + n - 1 ] ) , input [ 3 + n - 1 : ] <NEWLINE> sum = 0 <NEWLINE> for k in K : <NEWLINE> <INDENT> i = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if ( k + i ) % d in S or ( k - i ) % d in S : break <NEWLINE> i += 1 <NEWLINE> <DEDENT> sum += i <NEWLINE> <DEDENT> print sum <NEWLINE> <DEDENT> while ( True ) : <NEWLINE> <INDENT> d = int ( raw_input ( ) ) <NEWLINE> if d == 0 : break <NEWLINE> n , m = int ( raw_input ( ) ) , int ( raw_input ( ) ) <NEWLINE> input = [ d , n , m ] <NEWLINE> for i in range ( n - 1 + m ) : <NEWLINE> <INDENT> next_int = int ( raw_input ( ) ) <NEWLINE> input . append ( next_int ) <NEWLINE> <DEDENT> print_sum ( input ) <NEWLINE> <DEDENT>
def find ( l , e , start , end ) : <NEWLINE> <INDENT> mid = ( start + end ) // 2 <NEWLINE> if ( l [ mid ] == e ) : <NEWLINE> <INDENT> return ( e , e ) <NEWLINE> <DEDENT> elif ( l [ mid ] > e ) : <NEWLINE> <INDENT> if ( l [ mid - 1 ] < e ) : <NEWLINE> <INDENT> return ( l [ mid - 1 ] , l [ mid ] ) <NEWLINE> <DEDENT> return find ( l , e , start , mid ) <NEWLINE> <DEDENT> elif ( l [ mid ] < e ) : <NEWLINE> <INDENT> if ( l [ mid + 1 ] > e ) : <NEWLINE> <INDENT> return ( l [ mid ] , l [ mid + 1 ] ) <NEWLINE> <DEDENT> return find ( l , e , mid , end ) <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_sum ( input ) : <NEWLINE> <INDENT> d , n , m = input [ 0 ] , input [ 1 ] , input [ 2 ] <NEWLINE> S , K = input [ 3 : 3 + n - 1 ] , input [ 3 + n - 1 : ] <NEWLINE> S = sorted ( S ) <NEWLINE> S = [ S [ - 1 ] - d , 0 ] + S + [ d ] <NEWLINE> sum = 0 <NEWLINE> for k in K : <NEWLINE> <INDENT> low , high = find ( S , k , 0 , len ( S ) ) <NEWLINE> sum += min ( k - low , high - k ) <NEWLINE> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> output = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> d = int ( raw_input ( ) ) <NEWLINE> if d == 0 : break <NEWLINE> n , m = int ( raw_input ( ) ) , int ( raw_input ( ) ) <NEWLINE> input = [ d , n , m ] <NEWLINE> for i in range ( n - 1 + m ) : <NEWLINE> <INDENT> next_int = int ( raw_input ( ) ) <NEWLINE> input . append ( next_int ) <NEWLINE> <DEDENT> output . append ( str ( calc_sum ( input ) ) + <STRING> ) <NEWLINE> <DEDENT> print <STRING> . join ( output ) <NEWLINE>
mass = [ 0 ] * 1000 <NEWLINE> num = [ 0 ] * 1000 <NEWLINE> while True : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> mass [ i ] = input ( ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> num [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> p += num [ i ] ; <NEWLINE> p += mass [ p ] <NEWLINE> if p >= N - 1 : <NEWLINE> <INDENT> print i + 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = [ input ( ) for i in xrange ( n ) ] <NEWLINE> p = 0 ; ans = 0 ; <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> d = input ( ) <NEWLINE> p += d <NEWLINE> if p >= n - 1 or p + b [ p ] >= n - 1 : <NEWLINE> <INDENT> ans = i + 1 <NEWLINE> break <NEWLINE> <DEDENT> p += b [ p ] <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
def s ( ) : <NEWLINE> <INDENT> import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> for e in iter ( r , <STRING> ) : <NEWLINE> <INDENT> N , M = map ( int , e . split ( ) ) <NEWLINE> k , p = 1 , 0 <NEWLINE> S = [ int ( r ( ) ) for _ in [ 0 ] * N ] <NEWLINE> for d in [ int ( r ( ) ) for _ in [ 0 ] * M ] : <NEWLINE> <INDENT> p += d if N <= p + d else d + S [ p + d ] <NEWLINE> if N <= p + 1 : break <NEWLINE> k += 1 <NEWLINE> <DEDENT> print ( k ) <NEWLINE> <DEDENT> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> N , M = map ( int , e . split ( ) ) <NEWLINE> S = [ int ( input ( ) ) for _ in [ 0 ] * N ] <NEWLINE> p = b = 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> d = int ( input ( ) ) <NEWLINE> p += d <NEWLINE> p += S [ ~ - p ] <NEWLINE> if ( N <= p ) * b : print ( - ~ i ) ; b = 0 <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def line ( ) : return sys . stdin . readline ( ) . strip ( ) <NEWLINE> def cin ( ) : return sys . stdin . readline ( ) . strip ( ) . split ( ) <NEWLINE> while True : <NEWLINE> <INDENT> N , M = [ int ( i ) for i in cin ( ) ] <NEWLINE> if N == 0 : break <NEWLINE> X = [ int ( line ( ) ) for _ in range ( N ) ] <NEWLINE> c = 1 <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> c += int ( line ( ) ) <NEWLINE> if c < N and X [ c - 1 ] != 0 : <NEWLINE> <INDENT> c += X [ c - 1 ] <NEWLINE> <DEDENT> if c >= N : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> for e in iter ( r , <STRING> ) : <NEWLINE> <INDENT> N , M = map ( int , e . split ( ) ) <NEWLINE> k , p = 1 , 0 <NEWLINE> S = [ int ( r ( ) ) for _ in [ 0 ] * N ] <NEWLINE> for d in [ int ( r ( ) ) for _ in [ 0 ] * M ] : <NEWLINE> <INDENT> p += d ; <NEWLINE> if N <= p : p += S [ p ] <NEWLINE> if N <= p + 1 : break <NEWLINE> k += 1 <NEWLINE> <DEDENT> print ( k ) <NEWLINE> <DEDENT>
l = [ ] <NEWLINE> t = [ ] <NEWLINE> ans = [ False ] * 500 <NEWLINE> while True : <NEWLINE> <INDENT> l = [ ] <NEWLINE> t = [ ] <NEWLINE> ans = [ False ] * 500 <NEWLINE> N = input ( ) <NEWLINE> M = input ( ) <NEWLINE> if N == 0 and M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l . append ( [ a , b ] ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> t . append ( b ) <NEWLINE> <DEDENT> if b == 1 : <NEWLINE> <INDENT> t . append ( a ) <NEWLINE> <DEDENT> <DEDENT> for i in t : <NEWLINE> <INDENT> ans [ i ] = True <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> if l [ j ] [ 0 ] == i : <NEWLINE> <INDENT> ans [ l [ j ] [ 1 ] ] = True <NEWLINE> <DEDENT> if l [ j ] [ 1 ] == i : <NEWLINE> <INDENT> ans [ l [ j ] [ 0 ] ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res = 0 <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> if ans [ i ] and i != 1 : <NEWLINE> <INDENT> print <STRING> % ( i ) <NEWLINE> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print res <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> if n in <STRING> : break <NEWLINE> m = input ( ) <NEWLINE> S , L = set ( ) , [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == 1 : <NEWLINE> <INDENT> S . add ( b ) <NEWLINE> <DEDENT> elif b == 1 : <NEWLINE> <INDENT> S . add ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( ( a , b ) ) <NEWLINE> <DEDENT> <DEDENT> for i in S : <NEWLINE> <INDENT> for s in L : <NEWLINE> <INDENT> if i in s : <NEWLINE> <INDENT> S = S . union ( s ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print len ( S ) <NEWLINE> <DEDENT>
import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> for e in iter ( r , <STRING> ) : <NEWLINE> <INDENT> R = [ [ ] for _ in [ 0 ] * - ~ int ( e ) ] <NEWLINE> for _ in [ 0 ] * int ( r ( ) ) : <NEWLINE> <INDENT> a , b = map ( int , r ( ) . split ( ) ) <NEWLINE> R [ a ] += [ b ] ; R [ b ] += [ a ] <NEWLINE> <DEDENT> for m in R [ 1 ] [ : ] : R [ 1 ] += R [ m ] <NEWLINE> print ( len ( { * R [ 1 ] } - { 1 } ) ) <NEWLINE> <DEDENT>
from itertools import permutations as P <NEWLINE> import sys <NEWLINE> r = sys . stdin . readline <NEWLINE> for e in iter ( r , <STRING> ) : <NEWLINE> <INDENT> n , k = int ( e ) , int ( r ( ) ) <NEWLINE> C = [ r ( ) for _ in [ 0 ] * n ] <NEWLINE> print ( len ( set ( <STRING> . join ( s ) for s in P ( C , k ) ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from itertools import permutations <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> k = input ( ) <NEWLINE> if n == k == 0 : <NEWLINE> <INDENT> sys . exit ( 0 ) <NEWLINE> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> while True : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> if n in <STRING> : break <NEWLINE> try : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> <DEDENT> except SyntaxError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> L = [ raw_input ( ) for i in range ( int ( n ) ) ] <NEWLINE> S = set ( ) <NEWLINE> for t in itertools . permutations ( L , k ) : <NEWLINE> <INDENT> S . add ( <STRING> . join ( t ) ) <NEWLINE> <DEDENT> print len ( S ) <NEWLINE> <DEDENT>
for e in iter ( input , <STRING> ) : <NEWLINE> <INDENT> w , h = map ( int , e . split ( ) ) <NEWLINE> M = [ [ [ 1 , 0 ] * 2 for _ in [ 0 ] * h ] for _ in [ 0 ] * w ] <NEWLINE> for i in range ( 1 , w ) : <NEWLINE> <INDENT> for j in range ( 1 , h ) : <NEWLINE> <INDENT> a = M [ i - 1 ] [ j ] [ : 2 ] <NEWLINE> b = M [ i ] [ j - 1 ] [ 2 : ] <NEWLINE> M [ i ] [ j ] = [ b [ 1 ] , a , a [ 1 ] , b ] <NEWLINE> <DEDENT> <DEDENT> print ( ( sum ( M [ w - 2 ] [ h - 1 ] [ : 2 ] ) + sum ( M [ w - 1 ] [ h - 2 ] [ 2 : ] ) ) % 10 ** 5 ) <NEWLINE> <DEDENT>
DIV = 100000 <NEWLINE> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l = [ input ( ) for _ in range ( n - 1 ) ] <NEWLINE> ans = [ 0 ] * ( n - 1 ) <NEWLINE> pos = 0 <NEWLINE> for _ in xrange ( m ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> if k > 0 : <NEWLINE> <INDENT> for i in xrange ( k ) : ans [ pos + i ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in xrange ( - 1 , k - 1 , - 1 ) : <NEWLINE> <INDENT> ans [ pos + i ] += 1 <NEWLINE> <DEDENT> <DEDENT> pos += k <NEWLINE> <DEDENT> print sum ( ( ans [ i ] * l [ i ] ) % DIV for i in xrange ( n - 1 ) ) % DIV <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> from itertools import accumulate <NEWLINE> <NL> def data_req ( ) : <NEWLINE> <INDENT> n_yado , m_ryotei = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> yado_distance = [ ] <NEWLINE> ryotei = [ ] <NEWLINE> for _ in range ( n_yado ) : <NEWLINE> <INDENT> yado_distance . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( m_ryotei ) : <NEWLINE> <INDENT> ryotei . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> return yado_distance , ryotei <NEWLINE> <NL> <NL> <DEDENT> def search ( distance , ryotei ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> acc = [ 0 ] + list ( accumulate ( distance , lambda x , y : x + y ) ) <NEWLINE> ryotei_index = [ 0 ] + list ( accumulate ( ryotei , lambda x , y : x + y ) ) <NEWLINE> <COMMENT> <NL> res = [ ] <NEWLINE> for index in enumerate ( ryotei_index ) : <NEWLINE> <INDENT> if index [ 0 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> index = index [ 0 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> dist = abs ( acc [ ryotei_index [ index ] ] - acc [ ryotei_index [ index - 1 ] ] ) <NEWLINE> res . append ( dist ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> return sum ( res ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dis , ryotei = data_req ( ) <NEWLINE> search ( dis , ryotei ) <NEWLINE> <DEDENT>
INF = 1 << 31 <NEWLINE> n = input ( ) <NEWLINE> l = [ 0 ] * ( n + 1 ) <NEWLINE> for i in xrange ( 1 , n ) : <NEWLINE> <INDENT> l [ i ] = input ( ) <NEWLINE> <DEDENT> dp = [ [ INF ] * 2 for i in xrange ( n + 1 ) ] <NEWLINE> dp [ 1 ] [ 0 ] = 0 <NEWLINE> for i in xrange ( 1 , n ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , 0 , - 1 ) : <NEWLINE> <INDENT> dp [ j ] [ 1 ] = min ( dp [ j ] [ 1 ] , dp [ j ] [ 0 ] + l [ i ] ) <NEWLINE> dp [ j ] [ 0 ] = min ( dp [ j - 1 ] [ 0 ] , dp [ j - 1 ] [ 1 ] + l [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print min ( dp [ n / 2 ] ) <NEWLINE>
def orderN ( N , L , ices ) : <NEWLINE> <INDENT> upPeak = L - ices [ 0 ] <NEWLINE> downPeak = L - ices [ 0 ] <NEWLINE> peaks = [ ] <NEWLINE> for i in range ( len ( ices ) ) : <NEWLINE> <INDENT> if i < N - 1 : <NEWLINE> <INDENT> if ices [ i ] < ices [ i + 1 ] : <NEWLINE> <INDENT> peaks . append ( downPeak ) <NEWLINE> downPeak = L - ices [ i + 1 ] <NEWLINE> upPeak += L - ices [ i + 1 ] <NEWLINE> <DEDENT> elif ices [ i ] > ices [ i + 1 ] : <NEWLINE> <INDENT> peaks . append ( upPeak ) <NEWLINE> upPeak = L - ices [ i + 1 ] <NEWLINE> downPeak += L - ices [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> elif i == N - 1 : <NEWLINE> <INDENT> peaks . append ( upPeak ) <NEWLINE> peaks . append ( downPeak ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( peaks ) ) <NEWLINE> <NL> <DEDENT> N , L = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> ices = [ int ( raw_input ( ) . strip ( ) ) for _ in xrange ( N ) ] <NEWLINE> <NL> orderN ( N , L , ices ) <NEWLINE>
n , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = [ 0 ] + [ int ( raw_input ( ) ) for _ in xrange ( n ) ] + [ 0 ] <NEWLINE> ti = [ 0 ] * ( n + 2 ) <NEWLINE> while a != [ 0 ] * ( n + 2 ) : <NEWLINE> <INDENT> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if a [ i - 1 ] < a [ i ] and a [ i ] > a [ i + 1 ] : <NEWLINE> <INDENT> ti [ i ] += l - a [ i ] <NEWLINE> a [ i ] = 0 <NEWLINE> if a [ i - 1 ] != 0 : <NEWLINE> <INDENT> ti [ i - 1 ] = max ( ti [ i - 1 ] , ti [ i ] ) <NEWLINE> <DEDENT> if a [ i + 1 ] != 0 : <NEWLINE> <INDENT> ti [ i + 1 ] = max ( ti [ i + 1 ] , ti [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( ti ) ) <NEWLINE>
<COMMENT> <NL> def loadIcicle ( ) : <NEWLINE> <INDENT> icicles = [ ] <NEWLINE> line = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> N , L = int ( line [ 0 ] ) , int ( line [ 1 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> icicles . append ( int ( input ( ) . strip ( ) ) ) <NEWLINE> if len ( icicles ) == N : break <NEWLINE> <DEDENT> return icicles , N , L <NEWLINE> <DEDENT> icicles , N , L = loadIcicle ( ) <NEWLINE> <NL> def calcDiff ( icicles , N ) : <NEWLINE> <INDENT> diff_2times = [ 0 ] * len ( icicles ) <NEWLINE> <NL> for idx in range ( len ( icicles ) ) : <NEWLINE> <INDENT> dif_right = icicles [ idx + 1 ] - icicles [ idx ] if idx != N - 1 else - icicles [ idx ] <NEWLINE> dif_left = icicles [ idx ] - icicles [ idx - 1 ] if idx != 0 else icicles [ idx ] <NEWLINE> <NL> dif_right = 1 if dif_right > 0 else - 1 <NEWLINE> dif_left = 1 if dif_left > 0 else - 1 <NEWLINE> <NL> if dif_right - dif_left < 0 : diff_2times [ idx ] = - 1 <NEWLINE> elif dif_right - dif_left > 0 : diff_2times [ idx ] = 1 <NEWLINE> else : diff_2times [ idx ] = 0 <NEWLINE> <NL> <DEDENT> return diff_2times <NEWLINE> <NL> <DEDENT> diff_2times = calcDiff ( icicles , N ) <NEWLINE> <NL> time = [ - 1 ] * len ( icicles ) <NEWLINE> <NL> peakX = [ i for i in range ( len ( diff_2times ) ) if diff_2times [ i ] == - 1 ] <COMMENT> <NEWLINE> for i in peakX : <NEWLINE> <INDENT> time [ i ] = L - icicles [ i ] <NEWLINE> <NL> isLocalMinL , isLocalMinR = False , False <NEWLINE> posL = i <NEWLINE> posR = i <NEWLINE> while not ( isLocalMinL and isLocalMinR ) : <NEWLINE> <INDENT> posL -= 1 <NEWLINE> <COMMENT> <NL> if not isLocalMinL : <NEWLINE> <INDENT> if time [ posL ] == - 1 : <NEWLINE> <INDENT> time [ posL ] = ( L - icicles [ posL ] ) + time [ posL + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time [ posL ] = ( L - icicles [ posL ] ) + max ( time [ posL - 1 ] , time [ posL + 1 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> if diff_2times [ posL ] == 1 or posL == 0 : <NEWLINE> <INDENT> isLocalMinL = True <NEWLINE> <NL> <DEDENT> posR += 1 <NEWLINE> if not isLocalMinR : <NEWLINE> <INDENT> if time [ posR ] == - 1 : <NEWLINE> <INDENT> time [ posR ] = ( L - icicles [ posR ] ) + time [ posR - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time [ posR ] = ( L - icicles [ posR ] ) + max ( time [ posR - 1 ] , time [ posR + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> if diff_2times [ posR ] == 1 or posR == N - 1 : <NEWLINE> <INDENT> isLocalMinR = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( time ) ) <NEWLINE>
def orderN ( N , L , ices ) : <NEWLINE> <INDENT> upPeak = L - ices [ 0 ] <NEWLINE> downPeak = L - ices [ 0 ] <NEWLINE> peaks = [ ] <NEWLINE> for i in xrange ( len ( ices ) ) : <NEWLINE> <INDENT> if i < N - 1 : <NEWLINE> <INDENT> if ices [ i ] < ices [ i + 1 ] : <NEWLINE> <INDENT> peaks . append ( downPeak ) <NEWLINE> downPeak = L - ices [ i + 1 ] <NEWLINE> upPeak += L - ices [ i + 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> peaks . append ( upPeak ) <NEWLINE> upPeak = L - ices [ i + 1 ] <NEWLINE> downPeak += L - ices [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> peaks . append ( upPeak ) <NEWLINE> peaks . append ( downPeak ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( peaks ) ) <NEWLINE> <NL> <DEDENT> N , L = map ( int , rawinput ( ) . strip ( ) . split ( ) ) <NEWLINE> ices = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> ice = int ( rawinput ( ) . strip ( ) ) <NEWLINE> ices . append ( ice ) <NEWLINE> if len ( ices ) == N : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> orderN ( N , L , ices ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> line = raw_input ( ) . rstrip ( ) . split ( ) <NEWLINE> N , L = map ( int , line ) <NEWLINE> <NL> <NL> def solve ( trr , hour = 0 ) : <NEWLINE> <INDENT> N = len ( trr ) <NEWLINE> if sum ( trr ) == 0 : <NEWLINE> <INDENT> return hour <NEWLINE> <DEDENT> elif N == 1 : <NEWLINE> <INDENT> trr [ 0 ] += 1 <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> if trr [ 0 ] > trr [ 1 ] : <NEWLINE> <INDENT> trr [ 0 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trr [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> elif N > 2 : <NEWLINE> <INDENT> if trr [ 0 ] > trr [ 1 ] : <NEWLINE> <INDENT> trr [ 0 ] += 1 <NEWLINE> <DEDENT> if trr [ N - 1 ] > trr [ N - 2 ] : <NEWLINE> <INDENT> trr [ N - 1 ] += 1 <NEWLINE> <DEDENT> for i in xrange ( 1 , N - 1 ) : <NEWLINE> <INDENT> if N > 2 and trr [ i - 1 ] < trr [ i ] > trr [ i + 1 ] : <NEWLINE> <INDENT> trr [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return solve ( map ( lambda t : 0 if t == L else t , trr ) , hour + 1 ) <NEWLINE> <NL> <NL> <DEDENT> print solve ( [ int ( raw_input ( ) . rstrip ( ) ) for _ in xrange ( N ) ] ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> n , l = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> length = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> pare = [ ( length [ i ] , i ) for i in range ( n ) ] <NEWLINE> pare . sort ( reverse = True ) <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> for p in pare : <NEWLINE> <INDENT> i = p [ 0 ] <NEWLINE> if i == 0 : <NEWLINE> <INDENT> dp [ i ] = dp [ i + 1 ] + ( l - length [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i - 1 ] , dp [ i + 1 ] ) + ( l - length [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( max ( dp ) ) <NEWLINE> <DEDENT> solve ( ) <NEWLINE>
[ N , L ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> icelist = [ 0 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> icelist . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> icelist . append ( 0 ) <NEWLINE> incindex = [ ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> if icelist [ i ] > icelist [ i - 1 ] and icelist [ i ] > icelist [ i + 1 ] : <NEWLINE> <INDENT> incindex . append ( i ) <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> popped = 0 <NEWLINE> while popped < N : <NEWLINE> <INDENT> addindex = [ ] <NEWLINE> delindex = [ ] <NEWLINE> t = L - max ( [ icelist [ i ] for i in incindex ] ) <NEWLINE> ans += t <NEWLINE> for ii in incindex : <NEWLINE> <INDENT> icelist [ ii ] += t <NEWLINE> if icelist [ ii ] == L : <NEWLINE> <INDENT> popped += 1 <NEWLINE> delindex . append ( ii ) <NEWLINE> icelist [ ii ] = 0 <NEWLINE> if ii - 1 > 0 : <NEWLINE> <INDENT> if icelist [ ii - 1 ] > icelist [ ii - 2 ] : <NEWLINE> <INDENT> addindex . append ( ii - 1 ) <NEWLINE> <DEDENT> <DEDENT> if ii + 1 < N + 1 : <NEWLINE> <INDENT> if icelist [ ii + 1 ] > icelist [ ii + 2 ] : <NEWLINE> <INDENT> addindex . append ( ii + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for k in delindex : <NEWLINE> <INDENT> incindex . remove ( k ) <NEWLINE> <DEDENT> for j in addindex : <NEWLINE> <INDENT> incindex . append ( j ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
def loadIcicle ( ) : <NEWLINE> <INDENT> icicles = [ ] <NEWLINE> line = input ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> N , L = int ( line [ 0 ] ) , int ( line [ 1 ] ) <NEWLINE> while True : <NEWLINE> <INDENT> icicles . append ( int ( input ( ) . strip ( ) ) ) <NEWLINE> if len ( icicles ) == N : break <NEWLINE> <DEDENT> return icicles , N , L <NEWLINE> <NL> <DEDENT> def calcDiff ( icicles , N ) : <NEWLINE> <INDENT> diff_2times = [ 0 ] * N <NEWLINE> <NL> for idx in range ( N ) : <NEWLINE> <INDENT> dif_right = icicles [ idx + 1 ] - icicles [ idx ] if idx != N - 1 else - icicles [ idx ] <NEWLINE> dif_left = icicles [ idx ] - icicles [ idx - 1 ] if idx != 0 else icicles [ idx ] <NEWLINE> <NL> dif_right = 1 if dif_right > 0 else - 1 <NEWLINE> dif_left = 1 if dif_left > 0 else - 1 <NEWLINE> <NL> if dif_right - dif_left < 0 : diff_2times [ idx ] = - 1 <NEWLINE> elif dif_right - dif_left > 0 : diff_2times [ idx ] = 1 <NEWLINE> else : diff_2times [ idx ] = 0 <NEWLINE> <NL> <DEDENT> return diff_2times <NEWLINE> <NL> <DEDENT> icicles , N , L = loadIcicle ( ) <NEWLINE> diff_2times = calcDiff ( icicles , N ) <NEWLINE> <NL> time = [ - 1 ] * N <NEWLINE> peakX = [ i for i in range ( N ) if diff_2times [ i ] == - 1 ] <NEWLINE> for i in peakX : <NEWLINE> <INDENT> time [ i ] = L - icicles [ i ] <NEWLINE> <NL> isLocalMinL , isLocalMinR = False , False <NEWLINE> posL , posR = i , i <NEWLINE> while not ( isLocalMinL and isLocalMinR ) : <NEWLINE> <INDENT> posL -= 1 <NEWLINE> if posL < 0 : <NEWLINE> <INDENT> isLocalMinL = True <NEWLINE> <NL> <DEDENT> if not isLocalMinL : <NEWLINE> <INDENT> left = 0 if posL - 1 < 0 else time [ posL - 1 ] <NEWLINE> time [ posL ] = ( L - icicles [ posL ] ) + max ( left , time [ posL + 1 ] ) <NEWLINE> <NL> if diff_2times [ posL ] == 1 : isLocalMinL = True <NEWLINE> <NL> <DEDENT> if not isLocalMinR : <NEWLINE> <INDENT> right = 0 if posR + 1 > N - 1 else time [ posR + 1 ] <NEWLINE> time [ posR ] = ( L - icicles [ posR ] ) + max ( time [ posR - 1 ] , right ) <NEWLINE> <NL> if diff_2times [ posR ] == 1 : isLocalMinR = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( time ) ) <NEWLINE>
s = sum ( [ input ( ) for i in [ 1 ] * 4 ] ) <NEWLINE> print s // 60 , <STRING> , s % 60 <NEWLINE>
<NL> <NL> keyword = raw_input ( ) <NEWLINE> N = int ( raw_input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for _ in xrange ( N ) : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if keyword in ( s + s ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print count <NEWLINE>
N = input ( ) <NEWLINE> L = [ [ 0 ] * N for i in range ( N ) ] <NEWLINE> R , B , Y = 1 , 2 , 3 <NEWLINE> C = R <NEWLINE> for y in range ( N / 2 + 1 ) : <NEWLINE> <INDENT> for x in range ( y , N - y ) : <NEWLINE> <INDENT> L [ y ] [ x ] = C <NEWLINE> L [ N - y - 1 ] [ x ] = C <NEWLINE> <DEDENT> C = C % 3 + 1 <NEWLINE> <DEDENT> C = R <NEWLINE> for x in range ( N / 2 + 1 ) : <NEWLINE> <INDENT> for y in range ( x , N - x ) : <NEWLINE> <INDENT> L [ y ] [ x ] = C <NEWLINE> L [ y ] [ N - x - 1 ] = C <NEWLINE> <DEDENT> C = C % 3 + 1 <NEWLINE> <NL> <DEDENT> for i in range ( input ( ) ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print L [ b - 1 ] [ a - 1 ] <NEWLINE> <DEDENT>
s = input ( ) <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = input ( ) - 1 , input ( ) - 1 <NEWLINE> p = min ( x , y , s - x - 1 , s - y - 1 ) <NEWLINE> print p % 3 + 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ [ 0 ] * 21 for i in range ( n ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( 21 ) : <NEWLINE> if dp [ i ] [ j ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <INDENT> if 0 <= j + a [ i ] <= 20 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j + a [ i ] ] += dp [ i ] [ j ] <NEWLINE> <DEDENT> if 0 <= j - a [ i ] <= 20 : <NEWLINE> <INDENT> dp [ i + 1 ] [ j - a [ i ] ] += dp [ i ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n - 1 ] [ a [ n - 1 ] ] ) <NEWLINE>
while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> dp = [ [ 0 for j in range ( 21 ) ] for i in range ( N - 1 ) ] <NEWLINE> <NL> dp [ 0 ] [ a [ 0 ] ] = 1 <NEWLINE> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> for j in range ( 21 ) : <NEWLINE> <INDENT> if ( j - a [ i ] ) in range ( 21 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] += dp [ i - 1 ] [ j - a [ i ] ] <NEWLINE> <DEDENT> if ( j + a [ i ] ) in range ( 21 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] += dp [ i - 1 ] [ j + a [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N - 2 ] [ a [ N - 1 ] ] ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = s [ - 1 ] <NEWLINE> dp = [ [ 0 ] * 21 for i in range ( n ) ] <NEWLINE> dp [ 0 ] [ s [ 0 ] ] = 1 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> for j in range ( 21 ) : <NEWLINE> <INDENT> if dp [ i - 1 ] [ j ] == 0 : continue <NEWLINE> vp = j + s [ i ] <NEWLINE> vm = j - s [ i ] <NEWLINE> if vp <= 20 : <NEWLINE> <INDENT> dp [ i ] [ vp ] += dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> if 0 <= vm : <NEWLINE> <INDENT> dp [ i ] [ vm ] += dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print dp [ n - 2 ] [ ans <NEWLINE>
<NL> def getStart ( field ) : <NEWLINE> <INDENT> search_field = field [ 1 : ] <COMMENT> <NEWLINE> for y in range ( len ( search_field ) ) : <NEWLINE> <INDENT> for x in range ( len ( search_field [ 0 ] ) ) : <NEWLINE> <INDENT> if search_field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def bfs ( field , start_x , start_y , goal_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> gotten_cheese = 1 <NEWLINE> distance = 0 <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y , gotten_cheese , distance ] ) <NEWLINE> INF = 1 <NEWLINE> min_path = [ [ INF for j in range ( field [ 0 ] [ 1 ] ) ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < field [ 0 ] [ 1 ] and 1 <= ny < field [ 0 ] [ 0 ] + 1 and field [ ny ] [ nx ] != <STRING> and min_path [ ny - 1 ] [ nx ] == INF : <NEWLINE> <INDENT> if field [ ny ] [ nx ] == current [ 2 ] : <COMMENT> <NEWLINE> <INDENT> if field [ ny ] [ nx ] == goal_N : <COMMENT> <NEWLINE> <INDENT> print ( current [ 3 ] + 1 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> que = [ ] <NEWLINE> que . append ( [ nx , ny , current [ 2 ] + 1 , current [ 3 ] + 1 ] ) <NEWLINE> min_path = [ [ INF for j in range ( field [ 0 ] [ 1 ] ) ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny , current [ 2 ] , current [ 3 ] + 1 ] ) <NEWLINE> min_path [ ny - 1 ] [ nx ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( field ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> sx , sy = getStart ( field ) <NEWLINE> bfs ( field , sx , sy , field [ 0 ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> matrix = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> row = input ( ) . rstrip ( ) . split ( ) <NEWLINE> if len ( row ) == 1 : <NEWLINE> <INDENT> re_row = [ ] <NEWLINE> for char in row [ 0 ] : <NEWLINE> <INDENT> if char . isdigit ( ) : <NEWLINE> <INDENT> re_row . append ( int ( char ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_row . append ( char ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( re_row ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> matrix . append ( row ) <NEWLINE> <DEDENT> if len ( matrix ) == int ( matrix [ 0 ] [ 0 ] ) + 1 : <NEWLINE> <INDENT> main ( matrix ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> class Main ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> h , w , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> board = [ [ None for j in range ( w + 1 ) ] for i in range ( h + 1 ) ] <NEWLINE> s = ( None , None ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> row = raw_input ( ) <NEWLINE> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> board [ i ] [ j ] = row [ j - 1 ] <NEWLINE> if board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> s = ( i , j , ans , [ ] ) <NEWLINE> <DEDENT> elif board [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> g = ( i , j ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> d = [ ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( - 1 , 0 ) ] <NEWLINE> <NL> <COMMENT> <NL> q = [ s ] <NEWLINE> for nxt in range ( 1 , n + 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> while q != [ ] : <NEWLINE> <INDENT> y , x , ans , used = q . pop ( 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> if y == g [ 0 ] and x == g [ 1 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans += 1 <NEWLINE> for dy , dx in d : <NEWLINE> <INDENT> if 0 < y + dy <= h and 0 < x + dx <= w and board [ y + dy ] [ x + dx ] != <STRING> and ( not ( y + dy , x + dx ) in used ) : <NEWLINE> <INDENT> q . append ( ( y + dy , x + dx , ans , used + [ ( y , x ) ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> q = [ ( y , x , ans , [ ] ) ] <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if board [ i ] [ j ] == str ( nxt + 1 ) : <NEWLINE> <INDENT> g = ( i , j ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> return None <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m = Main ( ) <NEWLINE> m . solve ( ) <NEWLINE> <DEDENT>
def bfs ( field , H , W , start_x , start_y , tmp_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y ] ) <NEWLINE> INF = 1000000 <NEWLINE> min_path = [ [ INF ] * W for i in range ( H ) ] <NEWLINE> min_path [ start_y ] [ start_x ] = 0 <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < W and 0 <= ny < H and field [ ny ] [ nx ] != <STRING> and min_path [ ny ] [ nx ] == INF : <NEWLINE> <INDENT> min_path [ ny ] [ nx ] = min_path [ current [ 1 ] ] [ current [ 0 ] ] + 1 <NEWLINE> if field [ ny ] [ nx ] == tmp_N : <NEWLINE> <INDENT> return nx , ny , min_path [ ny ] [ nx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getField ( ) : <NEWLINE> <INDENT> matrix = [ ] <NEWLINE> first = input ( ) . strip ( ) <NEWLINE> H , W , N = map ( int , first . split ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> row = list ( input ( ) . strip ( ) ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if row [ j ] . isdigit ( ) : <NEWLINE> <INDENT> row [ j ] = int ( row [ j ] ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( row ) <NEWLINE> <DEDENT> return matrix , H , W , N <NEWLINE> <NL> <DEDENT> def getStart ( field ) : <NEWLINE> <INDENT> for y in range ( len ( field ) ) : <NEWLINE> <INDENT> for x in range ( len ( field [ 0 ] ) ) : <NEWLINE> <INDENT> if field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> matrix , H , W , N = getField ( ) <NEWLINE> sx , sy = getStart ( matrix ) <NEWLINE> distance = 0 <NEWLINE> tmp_x , tmp_y , tmp_dist = bfs ( matrix , H , W , sx , sy , k + 1 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ tmp_x , tmp_y ] <NEWLINE> for k in range ( N - 1 ) : <NEWLINE> <INDENT> tmp_x , tmp_y , tmp_dist = bfs ( matrix , H , W , tmps [ 0 ] , tmps [ 1 ] , k + 2 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ tmp_x , tmp_y ] <NEWLINE> <DEDENT> print ( distance ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def get_shortest_distance ( field , locations , current_HP ) : <NEWLINE> <INDENT> is_visit = [ [ False for _ in range ( len ( field [ 0 ] ) ) ] for __ in range ( len ( field ) ) ] <NEWLINE> frontier = set ( ) <NEWLINE> frontier . add ( locations [ current_HP - 1 ] ) <NEWLINE> for step in xrange ( 10 ** 10 ) : <NEWLINE> <INDENT> for cx , cy in frontier : <NEWLINE> <INDENT> if ( cx , cy ) == locations [ current_HP ] : return step <NEWLINE> is_visit [ cx ] [ cy ] = True <NEWLINE> <DEDENT> next_frontier = set ( ) <NEWLINE> for cx , cy in list ( frontier ) : <NEWLINE> <INDENT> for dx , dy in [ [ 0 , 1 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ - 1 , 0 ] ] : <NEWLINE> <INDENT> nx = cx + dx <NEWLINE> ny = cy + dy <NEWLINE> if not ( 0 <= nx < len ( field ) ) : continue <NEWLINE> if not ( 0 <= ny < len ( field [ nx ] ) ) : continue <NEWLINE> if field [ nx ] [ ny ] == <STRING> : continue <NEWLINE> if is_visit [ nx ] [ ny ] : continue <NEWLINE> next_frontier . add ( ( nx , ny ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> frontier = next_frontier <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> def solve ( field , locations ) : <NEWLINE> <INDENT> total_step = 0 <NEWLINE> for current_HP in range ( 1 , len ( locations ) ) : <NEWLINE> <INDENT> total_step += get_shortest_distance ( field , locations , current_HP ) <NEWLINE> <DEDENT> return total_step <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> line = input ( ) . strip ( ) <NEWLINE> H , W , N = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> field , locations = list ( ) , dict ( ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> field . append ( list ( input ( ) . strip ( ) ) ) <NEWLINE> for j , x in enumerate ( field [ - 1 ] ) : <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> locations [ 0 ] = ( i , j , ) <NEWLINE> <DEDENT> if x . isdigit ( ) : <NEWLINE> <INDENT> x = int ( x ) <NEWLINE> field [ - 1 ] [ j ] = x <NEWLINE> locations [ x ] = ( i , j , ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( solve ( field , locations ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> moves = [ ( 0 , - 1 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) ] <NEWLINE> <NL> <NL> def search ( dataset ) : <NEWLINE> <INDENT> min_time = 0 <NEWLINE> mouse = 1 <NEWLINE> gx , gy = get_start ( dataset ) <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> gx , gy , min_time_tmp = bfs ( dataset , ( gx , gy ) , mouse ) <NEWLINE> mouse += 1 <NEWLINE> min_time += min_time_tmp <NEWLINE> <DEDENT> print min_time <NEWLINE> <NL> <NL> <DEDENT> def bfs ( dataset , start , mouse ) : <NEWLINE> <INDENT> INF = 10000000 <NEWLINE> min_time = [ [ INF for j in xrange ( W ) ] for i in xrange ( H ) ] <NEWLINE> min_time [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> queue = [ start ] <NEWLINE> <NL> while len ( queue ) != 0 : <NEWLINE> <INDENT> dx , dy = queue . pop ( 0 ) <NEWLINE> for i , j in moves : <NEWLINE> <INDENT> nx = dx + i <NEWLINE> ny = dy + j <NEWLINE> if 0 <= nx < H and 0 <= ny < W and dataset [ nx ] [ ny ] != <STRING> and min_time [ nx ] [ ny ] == INF : <NEWLINE> <INDENT> cell = dataset [ nx ] [ ny ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if type ( cell ) is int : <NEWLINE> <INDENT> if mouse == int ( cell ) : <NEWLINE> <INDENT> min_time [ nx ] [ ny ] = min_time [ dx ] [ dy ] + 1 <NEWLINE> return nx , ny , min_time [ nx ] [ ny ] <NEWLINE> <DEDENT> <DEDENT> min_time [ nx ] [ ny ] = min_time [ dx ] [ dy ] + 1 <NEWLINE> queue . append ( ( nx , ny ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def get_start ( dataset ) : <NEWLINE> <INDENT> for i in xrange ( H ) : <NEWLINE> <INDENT> rows = dataset [ i ] <NEWLINE> for j in xrange ( W ) : <NEWLINE> <INDENT> cell = rows [ j ] <NEWLINE> if cell == <STRING> : <NEWLINE> <INDENT> return i , j <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dataset = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) . rstrip ( ) . split ( ) <NEWLINE> if len ( line ) == 3 : <NEWLINE> <INDENT> H , W , N = map ( int , line ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row = [ ] <NEWLINE> for e in line [ 0 ] : <NEWLINE> <INDENT> if e . isdigit ( ) : <NEWLINE> <INDENT> row . append ( int ( e ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row . append ( e ) <NEWLINE> <DEDENT> <DEDENT> dataset . append ( row ) <NEWLINE> <DEDENT> if len ( dataset ) == H : <NEWLINE> <INDENT> search ( dataset ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> stage = [ input ( ) for i in range ( h ) ] <NEWLINE> starts = [ str ( i ) for i in range ( n ) ] <NEWLINE> goals = [ str ( i + 1 ) for i in range ( n ) ] <NEWLINE> starts_y = [ 0 for i in range ( n ) ] <NEWLINE> starts_x = [ 0 for i in range ( n ) ] <NEWLINE> goals_y = [ 0 for i in range ( n ) ] <NEWLINE> goals_x = [ 0 for i in range ( n ) ] <NEWLINE> <NL> starts [ 0 ] = <STRING> <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if stage [ y ] [ x ] in starts : <NEWLINE> <INDENT> starts_y [ starts . index ( stage [ y ] [ x ] ) ] = y <NEWLINE> starts_x [ starts . index ( stage [ y ] [ x ] ) ] = x <NEWLINE> <DEDENT> if stage [ y ] [ x ] in goals : <NEWLINE> <INDENT> goals_y [ goals . index ( stage [ y ] [ x ] ) ] = y <NEWLINE> goals_x [ goals . index ( stage [ y ] [ x ] ) ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> move_x = [ 0 , 0 , 1 , - 1 ] <NEWLINE> sum = 0 <NEWLINE> <NL> for start_y , start_x , goal_y , goal_x in zip ( starts_y , starts_x , goals_y , goals_x ) : <NEWLINE> <INDENT> bfs_map = [ [ - 1 for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> data_y = [ start_y ] <NEWLINE> data_x = [ start_x ] <NEWLINE> bfs_map [ start_y ] [ start_x ] = 0 <NEWLINE> goal = False <NEWLINE> <NL> while len ( data_y ) != 0 and not goal : <NEWLINE> <INDENT> y = data_y . pop ( 0 ) <NEWLINE> x = data_x . pop ( 0 ) <NEWLINE> goal = False <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> y += [ 1 , - 1 , 0 , 0 ] [ i ] <NEWLINE> x += move_x [ i ] <NEWLINE> <NL> if y >= 0 and y < h and x >= 0 and x < w : <NEWLINE> <INDENT> if bfs_map [ y ] [ x ] == - 1 and stage [ y ] [ x ] != <STRING> : <NEWLINE> <INDENT> bfs_map [ y ] [ x ] = bfs_map [ y - move_y [ i ] ] [ x - move_x [ i ] ] + 1 <NEWLINE> data_y . append ( y ) <NEWLINE> data_x . append ( x ) <NEWLINE> <DEDENT> if bfs_map [ goal_y ] [ goal_x ] != - 1 : <NEWLINE> <INDENT> sum += bfs_map [ goal_y ] [ goal_x ] <NEWLINE> goal = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> y -= move_y [ i ] <NEWLINE> x -= move_x [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def bfs ( field , H , W , start_x , start_y , tmp_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y ] ) <NEWLINE> INF = 1000000 <NEWLINE> min_path = [ [ INF ] * W for i in xrange ( H ) ] <NEWLINE> min_path [ start_y ] [ start_x ] = 0 <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < W and 0 <= ny < H and field [ ny ] [ nx ] != <STRING> and min_path [ ny ] [ nx ] == INF : <NEWLINE> <INDENT> min_path [ ny ] [ nx ] = min_path [ current [ 1 ] ] [ current [ 0 ] ] + 1 <NEWLINE> if field [ ny ] [ nx ] == tmp_N : <NEWLINE> <INDENT> return nx , ny , min_path [ ny ] [ nx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getField ( ) : <NEWLINE> <INDENT> matrix = [ ] <NEWLINE> first = raw_input ( ) . rstrip ( ) <NEWLINE> H , W , N = map ( int , first . split ( ) ) <NEWLINE> for i in xrange ( H ) : <NEWLINE> <INDENT> row = list ( input ( ) . strip ( ) ) <NEWLINE> for j in xrange ( W ) : <NEWLINE> <INDENT> if row [ j ] . isdigit ( ) : <NEWLINE> <INDENT> row [ j ] = int ( row [ j ] ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( row ) <NEWLINE> <DEDENT> return matrix , H , W , N <NEWLINE> <NL> <DEDENT> def getStart ( field ) : <NEWLINE> <INDENT> for y in xrange ( len ( field ) ) : <NEWLINE> <INDENT> for x in xrange ( len ( field [ 0 ] ) ) : <NEWLINE> <INDENT> if field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> matrix , H , W , N = getField ( ) <NEWLINE> sx , sy = getStart ( matrix ) <NEWLINE> distance = 0 <NEWLINE> tmp_x , tmp_y , tmp_dist = bfs ( matrix , H , W , sx , sy , 1 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ tmp_x , tmp_y ] <NEWLINE> for k in xrange ( N - 1 ) : <NEWLINE> <INDENT> tmp_x , tmp_y , tmp_dist = bfs ( matrix , H , W , tmps [ 0 ] , tmps [ 1 ] , k + 2 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ tmp_x , tmp_y ] <NEWLINE> <DEDENT> print distance <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
moves = [ ( 0 , - 1 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 1 , 0 ) ] <NEWLINE> <NL> <NL> def search ( dataset ) : <NEWLINE> <INDENT> min_time = 0 <NEWLINE> mouse = 1 <NEWLINE> gx , gy = get_start ( dataset ) <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> gx , gy , min_time_tmp = bfs ( dataset , ( gx , gy ) , mouse ) <NEWLINE> mouse += 1 <NEWLINE> min_time += min_time_tmp <NEWLINE> <DEDENT> print ( min_time ) <NEWLINE> <NL> <NL> <DEDENT> def bfs ( dataset , start , mouse ) : <NEWLINE> <INDENT> INF = 10000000 <NEWLINE> min_time = [ [ INF for j in range ( W ) ] for i in range ( H ) ] <NEWLINE> min_time [ start [ 0 ] ] [ start [ 1 ] ] = 0 <NEWLINE> queue = [ start ] <NEWLINE> <NL> while len ( queue ) != 0 : <NEWLINE> <INDENT> dx , dy = queue . pop ( 0 ) <NEWLINE> for i , j in moves : <NEWLINE> <INDENT> nx = dx + i <NEWLINE> ny = dy + j <NEWLINE> if 0 <= nx < H and 0 <= ny < W and dataset [ nx ] [ ny ] != <STRING> and min_time [ nx ] [ ny ] == INF : <NEWLINE> <INDENT> cell = dataset [ nx ] [ ny ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if type ( cell ) is int : <NEWLINE> <INDENT> if mouse == int ( cell ) : <NEWLINE> <INDENT> min_time [ nx ] [ ny ] = min_time [ dx ] [ dy ] + 1 <NEWLINE> return nx , ny , min_time [ nx ] [ ny ] <NEWLINE> <DEDENT> <DEDENT> min_time [ nx ] [ ny ] = min_time [ dx ] [ dy ] + 1 <NEWLINE> queue . append ( ( nx , ny ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def get_start ( dataset ) : <NEWLINE> <INDENT> for i in range ( H ) : <NEWLINE> <INDENT> rows = dataset [ i ] <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> cell = rows [ j ] <NEWLINE> if cell == <STRING> : <NEWLINE> <INDENT> return i , j <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dataset = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = input ( ) . rstrip ( ) . split ( ) <NEWLINE> if len ( line ) == 3 : <NEWLINE> <INDENT> H , W , N = map ( int , line ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row = [ ] <NEWLINE> for e in line [ 0 ] : <NEWLINE> <INDENT> if e . isdigit ( ) : <NEWLINE> <INDENT> row . append ( int ( e ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> row . append ( e ) <NEWLINE> <DEDENT> <DEDENT> dataset . append ( row ) <NEWLINE> <DEDENT> if len ( dataset ) == H : <NEWLINE> <INDENT> search ( dataset ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 100000000 ) <NEWLINE> <NL> <NL> def getStart ( field ) : <NEWLINE> <INDENT> search_field = field [ 1 : ] <COMMENT> <NEWLINE> for y in range ( len ( search_field ) ) : <NEWLINE> <INDENT> for x in range ( len ( search_field [ 0 ] ) ) : <NEWLINE> <INDENT> if search_field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def bfs ( field , start_x , start_y , goal_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> gotten_cheese = 1 <NEWLINE> distance = 0 <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y , gotten_cheese , distance ] ) <NEWLINE> INF = 1 <NEWLINE> min_path = [ [ INF for j in range ( field [ 0 ] [ 1 ] ) ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> print ( <STRING> , current ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < field [ 0 ] [ 1 ] and 1 <= ny < field [ 0 ] [ 0 ] + 1 and field [ ny ] [ nx ] != <STRING> and min_path [ ny - 1 ] [ nx ] == INF : <NEWLINE> <INDENT> if field [ ny ] [ nx ] == current [ 2 ] : <COMMENT> <NEWLINE> <INDENT> if field [ ny ] [ nx ] == goal_N : <COMMENT> <NEWLINE> <INDENT> print ( current [ 3 ] + 1 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> que = [ ] <NEWLINE> que . append ( [ nx , ny , current [ 2 ] + 1 , current [ 3 ] + 1 ] ) <NEWLINE> min_path = [ [ INF for j in range ( field [ 0 ] [ 1 ] ) ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny , current [ 2 ] , current [ 3 ] + 1 ] ) <NEWLINE> min_path [ ny - 1 ] [ nx ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( field ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> sx , sy = getStart ( field ) <NEWLINE> bfs ( field , sx , sy , field [ 0 ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> matrix = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> row = input ( ) . split ( ) <NEWLINE> if len ( row ) == 1 : <NEWLINE> <INDENT> re_row = [ ] <NEWLINE> for char in row [ 0 ] : <NEWLINE> <INDENT> if char . isdigit ( ) : <NEWLINE> <INDENT> re_row . append ( int ( char ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_row . append ( char ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( re_row ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> matrix . append ( row ) <NEWLINE> <DEDENT> if len ( matrix ) == int ( matrix [ 0 ] [ 0 ] ) + 1 : <NEWLINE> <INDENT> main ( ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from Queue import Queue <NEWLINE> INF = 20000000 <NEWLINE> q = Queue ( ) <NEWLINE> dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> smp = [ [ INF for i in range ( 1002 ) ] for j in range ( 1002 ) ] <NEWLINE> mp = [ [ <STRING> for i in range ( 1002 ) ] for j in range ( 1002 ) ] <NEWLINE> ipt = raw_input ( ) . split ( <STRING> ) <NEWLINE> H , W , n = map ( int , ipt [ 0 ] . split ( ) ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> mp [ i ] [ j ] = ipt [ i ] [ j - 1 ] ; <NEWLINE> <DEDENT> <DEDENT> x = y = 0 <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> if mp [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> x = j ; y = i ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c = 0 ; ans = 0 ; <NEWLINE> q . put ( [ x , y ] ) ; smp [ y ] [ x ] = 0 ; <NEWLINE> while c < n : <NEWLINE> <INDENT> p = q . get ( ) <NEWLINE> x = p [ 0 ] ; y = p [ 1 ] ; <NEWLINE> if mp [ y ] [ x ] == chr ( ord ( <STRING> ) + c ) : <NEWLINE> <INDENT> ans += smp [ y ] [ x ] ; c += 1 ; <NEWLINE> if c == n : break ; <NEWLINE> while q . empty ( ) == False : q . get ( ) <NEWLINE> for i in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> smp [ i ] [ j ] = INF <NEWLINE> <DEDENT> <DEDENT> smp [ y ] [ x ] = 0 <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if mp [ y + dy [ i ] ] [ x + dx [ i ] ] != <STRING> and smp [ y + dy [ i ] ] [ x + dx [ i ] ] == INF : <NEWLINE> <INDENT> q . put ( [ x + dx [ i ] , y + dy [ i ] ] ) ; <NEWLINE> smp [ y + dy [ i ] ] [ x + dx [ i ] ] = smp [ y ] [ x ] + 1 ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def bfs ( field , H , W , start_x , start_y , tmp_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y ] ) <NEWLINE> INF = 1000000 <NEWLINE> min_path = [ [ INF ] * W for i in range ( H ) ] <NEWLINE> min_path [ start_y ] [ start_x ] = 0 <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < W and 0 <= ny < H and field [ ny ] [ nx ] != <STRING> and min_path [ ny ] [ nx ] == INF : <NEWLINE> <INDENT> min_path [ ny ] [ nx ] = min_path [ current [ 1 ] ] [ current [ 0 ] ] + 1 <NEWLINE> if field [ ny ] [ nx ] == tmp_N : <NEWLINE> <INDENT> return nx , ny , min_path [ ny ] [ nx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getField ( ) : <NEWLINE> <INDENT> matrix = [ ] <NEWLINE> first = input ( ) . strip ( ) <NEWLINE> H , W , N = map ( int , first . split ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> row = list ( input ( ) . strip ( ) ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if row [ j ] . isdigit ( ) : <NEWLINE> <INDENT> row [ j ] = int ( row [ j ] ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( row ) <NEWLINE> <DEDENT> return matrix , H , W , N <NEWLINE> <NL> <DEDENT> def getStart ( field ) : <NEWLINE> <INDENT> for y in range ( len ( field ) ) : <NEWLINE> <INDENT> for x in range ( len ( field [ 0 ] ) ) : <NEWLINE> <INDENT> if field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> matrix , H , W , N = getField ( ) <NEWLINE> sx , sy = getStart ( matrix ) <NEWLINE> distance = 0 <NEWLINE> tmp_x , tmp_y , tmp_dist = bfs ( matrix , H , W , sx , sy , k + 1 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ tmp_x , tmp_y ] <NEWLINE> for k in range ( N - 1 ) : <NEWLINE> <INDENT> tmp_x , tmp_y , tmp_dist = bfs ( matrix , H , W , tmps [ 0 ] , tmps [ 1 ] , k + 2 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ tmp_x , tmp_y ] <NEWLINE> <DEDENT> print ( distance ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> def bfs ( field , start_x , start_y , tmp_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y ] ) <NEWLINE> INF = 1000000 <NEWLINE> min_path = [ [ INF ] * field [ 0 ] [ 1 ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> min_path [ start_y ] [ start_x ] = 0 <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < field [ 0 ] [ 1 ] and 0 <= ny < field [ 0 ] [ 0 ] and field [ ny ] [ nx ] != <STRING> and min_path [ ny ] [ nx ] == INF : <NEWLINE> <INDENT> min_path [ ny ] [ nx ] = min_path [ current [ 1 ] ] [ current [ 0 ] ] + 1 <NEWLINE> if field [ ny ] [ nx ] == tmp_N : <COMMENT> <NEWLINE> <INDENT> return nx , ny , min_path [ ny ] [ nx ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getField ( ) : <NEWLINE> <INDENT> matrix = [ ] <NEWLINE> first = input ( ) . strip ( ) <NEWLINE> H , W , N = map ( int , first . split ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> row = list ( input ( ) . strip ( ) ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if row [ j ] . isdigit ( ) : <NEWLINE> <INDENT> row [ j ] = int ( row [ j ] ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( row ) <NEWLINE> <DEDENT> return matrix , N <NEWLINE> <NL> <DEDENT> def getStart ( field ) : <NEWLINE> <INDENT> for y in range ( len ( field ) ) : <NEWLINE> <INDENT> for x in range ( len ( field [ 0 ] ) ) : <NEWLINE> <INDENT> if search_field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> matrix , N = getField ( ) <NEWLINE> sx , sy = getStart ( matrix ) <NEWLINE> distance = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if k != 0 : <NEWLINE> <INDENT> tmp_x , tmp_y , tmp_dist = dfs ( matrix , tmps [ 0 ] , tmps [ 1 ] , k + 1 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ ] <NEWLINE> tmps . append ( tmp_x , tmp_y , tmp_dist ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp_x , tmp_y , tmp_dist = dfs ( matrix , sx , sy , k + 1 ) <NEWLINE> distance += tmp_dist <NEWLINE> tmps = [ ] <NEWLINE> tmps . append ( tmp_x , tmp_y ) <NEWLINE> <DEDENT> <DEDENT> print ( distance ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<NL> def getStart ( field ) : <NEWLINE> <INDENT> search_field = field [ 1 : ] <COMMENT> <NEWLINE> for y in range ( len ( search_field ) ) : <NEWLINE> <INDENT> for x in range ( len ( search_field [ 0 ] ) ) : <NEWLINE> <INDENT> if search_field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def bfs ( field , start_x , start_y , goal_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> gotten_cheese = 1 <NEWLINE> distance = 0 <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y ] ) <NEWLINE> INF = 1000000 <NEWLINE> min_path = [ [ INF ] * field [ 0 ] [ 1 ] ] for i in range ( field [ 0 ] [ 0 ] ) ] <COMMENT> <NEWLINE> min_path [ start_y - 1 ] [ start_x ] = 0 <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < field [ 0 ] [ 1 ] and 1 <= ny < field [ 0 ] [ 0 ] + 1 and field [ ny ] [ nx ] != <STRING> and min_path [ ny - 1 ] [ nx ] == INF : <NEWLINE> <INDENT> distance += min_path [ current [ 1 ] - 1 ] [ current [ 0 ] ] + 1 <NEWLINE> if field [ ny ] [ nx ] == gotten_cheese : <COMMENT> <NEWLINE> <INDENT> if field [ ny ] [ nx ] == goal_N : <COMMENT> <NEWLINE> <INDENT> print ( distance ) <NEWLINE> return <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> que = [ ] <NEWLINE> que . append ( [ nx , ny ] ) <NEWLINE> gotten_cheese += 1 <NEWLINE> min_path = [ [ INF ] * field [ 0 ] [ 1 ] ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> min_path [ ny - 1 ] [ nx ] = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( field ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> sx , sy = getStart ( field ) <NEWLINE> bfs ( field , sx , sy , field [ 0 ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> matrix = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> row = input ( ) . rstrip ( ) . split ( ) <NEWLINE> if len ( row ) == 3 : <NEWLINE> <INDENT> re_row = [ ] <NEWLINE> for i in row : <NEWLINE> <INDENT> re_row . append ( int ( i ) ) <NEWLINE> <DEDENT> matrix . append ( re_row ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_row = [ ] <NEWLINE> for char in row [ 0 ] : <NEWLINE> <INDENT> if char . isdigit ( ) : <NEWLINE> <INDENT> re_row . append ( int ( char ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> re_row . append ( char ) <NEWLINE> <DEDENT> <DEDENT> matrix . append ( re_row ) <NEWLINE> <DEDENT> if len ( matrix ) == int ( matrix [ 0 ] [ 0 ] ) + 1 : <NEWLINE> <INDENT> print ( matrix ) <NEWLINE> main ( matrix ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
<NL> def getStart ( field ) : <NEWLINE> <INDENT> search_field = field [ 1 : ] <COMMENT> <NEWLINE> for y in range ( len ( search_field ) ) : <NEWLINE> <INDENT> for x in range ( len ( search_field [ 0 ] ) ) : <NEWLINE> <INDENT> if search_field [ y ] [ x ] == <STRING> : <NEWLINE> <INDENT> return x , y + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def bfs ( field , start_x , start_y , goal_N ) : <NEWLINE> <INDENT> direction = [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] ] <NEWLINE> gotten_cheese = 1 <NEWLINE> distance = 0 <NEWLINE> que = [ ] <NEWLINE> que . append ( [ start_x , start_y , gotten_cheese , distance ] ) <NEWLINE> INF = 1 <NEWLINE> min_path = [ [ INF for j in range ( field [ 0 ] [ 1 ] ) ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> while len ( que ) != 0 : <NEWLINE> <INDENT> current = que . pop ( 0 ) <NEWLINE> for d in direction : <NEWLINE> <INDENT> nx = current [ 0 ] + d [ 0 ] <NEWLINE> ny = current [ 1 ] + d [ 1 ] <NEWLINE> if 0 <= nx < field [ 0 ] [ 1 ] and 1 <= ny < field [ 0 ] [ 0 ] + 1 and field [ ny ] [ nx ] != <STRING> and min_path [ ny - 1 ] [ nx ] == INF : <NEWLINE> <INDENT> if field [ ny ] [ nx ] == current [ 2 ] : <COMMENT> <NEWLINE> <INDENT> if field [ ny ] [ nx ] == goal_N : <COMMENT> <NEWLINE> <INDENT> print ( current [ 3 ] + 1 ) <NEWLINE> return <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> que = [ ] <NEWLINE> que . append ( [ nx , ny , current [ 2 ] + 1 , current [ 3 ] + 1 ] ) <NEWLINE> min_path = [ [ INF for j in range ( field [ 0 ] [ 1 ] ) ] for i in range ( field [ 0 ] [ 0 ] ) ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> que . append ( [ nx , ny , current [ 2 ] , current [ 3 ] + 1 ] ) <NEWLINE> min_path [ ny - 1 ] [ nx ] = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( field ) : <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> sx , sy = getStart ( field ) <NEWLINE> bfs ( field , sx , sy , field [ 0 ] [ 2 ] ) <NEWLINE> <NL> <DEDENT> f = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> row = input ( ) . split ( ) <NEWLINE> for i in range ( len ( row ) ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> row [ i ] = int ( row [ i ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> <DEDENT> field . append ( row ) <NEWLINE> if len ( f ) == field [ 0 ] [ 0 ] + 1 : <NEWLINE> <INDENT> main ( f ) <NEWLINE> break <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
h , w , n = map ( int , input ( ) . split ( ) ) <NEWLINE> stage = [ input ( ) for i in range ( h ) ] <NEWLINE> starts = [ str ( i ) for i in range ( n ) ] <NEWLINE> goals = [ str ( i + 1 ) for i in range ( n ) ] <NEWLINE> starts_y = [ 0 for i in range ( n ) ] <NEWLINE> starts_x = [ 0 for i in range ( n ) ] <NEWLINE> goals_y = [ 0 for i in range ( n ) ] <NEWLINE> goals_x = [ 0 for i in range ( n ) ] <NEWLINE> <NL> starts [ 0 ] = <STRING> <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if stage [ y ] [ x ] in starts : <NEWLINE> <INDENT> starts_y [ starts . index ( stage [ y ] [ x ] ) ] = y <NEWLINE> starts_x [ starts . index ( stage [ y ] [ x ] ) ] = x <NEWLINE> <DEDENT> if stage [ y ] [ x ] in goals : <NEWLINE> <INDENT> goals_y [ goals . index ( stage [ y ] [ x ] ) ] = y <NEWLINE> goals_x [ goals . index ( stage [ y ] [ x ] ) ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> <NL> for start_y , start_x , goal_y , goal_x in zip ( starts_y , starts_x , goals_y , goals_x ) : <NEWLINE> <INDENT> bfs_map = [ [ - 1 for j in range ( w ) ] for i in range ( h ) ] <NEWLINE> data_y = [ start_y ] <NEWLINE> data_x = [ start_x ] <NEWLINE> bfs_map [ start_y ] [ start_x ] = 0 <NEWLINE> goal = False <NEWLINE> <NL> while len ( data_y ) != 0 and not goal : <NEWLINE> <INDENT> y = data_y . pop ( 0 ) <NEWLINE> x = data_x . pop ( 0 ) <NEWLINE> goal = False <NEWLINE> <NL> for i in range ( 4 ) : <NEWLINE> <INDENT> y += [ 1 , - 1 , 0 , 0 ] [ i ] <NEWLINE> x += [ 0 , 0 , 1 , - 1 ] [ i ] <NEWLINE> <NL> if y >= 0 and y < h and x >= 0 and x < w : <NEWLINE> <INDENT> if bfs_map [ y ] [ x ] == - 1 and stage [ y ] [ x ] != <STRING> : <NEWLINE> <INDENT> bfs_map [ y ] [ x ] = bfs_map [ y - move_y [ i ] ] [ x - move_x [ i ] ] + 1 <NEWLINE> data_y . append ( y ) <NEWLINE> data_x . append ( x ) <NEWLINE> <DEDENT> if bfs_map [ goal_y ] [ goal_x ] != - 1 : <NEWLINE> <INDENT> sum += bfs_map [ goal_y ] [ goal_x ] <NEWLINE> goal = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> y -= move_y [ i ] <NEWLINE> x -= move_x [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
<COMMENT> <NL> x_dir = [ 0 , 1 , 0 , - 1 ] <NEWLINE> y_dir = [ 1 , 0 , - 1 , 0 ] <NEWLINE> <NL> <COMMENT> <NL> visited = [ ] <NEWLINE> maps = [ ] <NEWLINE> <NL> <COMMENT> <NL> def bfs ( h , w , cheese , sx , sy , moves ) : <NEWLINE> <INDENT> que = [ ( moves , sx , sy ) ] <NEWLINE> <NL> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> visited [ i ] [ j ] = ( maps [ i ] [ j ] != <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> visited [ sy ] [ sx ] = False <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> c_moves , c_x , c_y = que . pop ( 0 ) <NEWLINE> if maps [ c_y ] [ c_x ] == cheese : <NEWLINE> <INDENT> return ( c_moves , c_x , c_y ) <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> n_x = c_x + x_dir [ i ] <NEWLINE> n_y = c_y + y_dir [ i ] <NEWLINE> <NL> if ( 0 <= n_x < w and 0 <= n_y < h and visited [ n_y ] [ n_x ] ) : <NEWLINE> <INDENT> que . append ( ( c_moves + 1 , n_x , n_y ) ) <NEWLINE> visited [ n_y ] [ n_x ] = False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ( - 1 , - 1 , - 1 ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> str = ( input ( ) ) . split ( ) <NEWLINE> <NL> H = int ( str [ 0 ] ) <NEWLINE> W = int ( str [ 1 ] ) <NEWLINE> N = int ( str [ 2 ] ) <NEWLINE> <NL> visited = [ [ True for i in range ( W ) ] for j in range ( H ) ] <NEWLINE> maps = [ <STRING> for i in range ( H ) ] <NEWLINE> <NL> x , y = 0 , 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> maps [ i ] = input ( ) <NEWLINE> for j in range ( W ) : <NEWLINE> <INDENT> if maps [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> x , y = j , i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> moves = 0 <NEWLINE> for i in range ( 1 , N + 1 , 1 ) : <NEWLINE> <INDENT> moves , x , y = bfs ( H , W , str ( i ) , x , y , moves ) <NEWLINE> <NL> <DEDENT> print ( str ( moves ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> M , N = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> Map = [ ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> Map . append ( input ) <NEWLINE> <NL> <DEDENT> def get_slide_sum ( Map , kw ) : <NEWLINE> <INDENT> l = [ ] <NEWLINE> for r in range ( M ) : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for c in range ( N ) : <NEWLINE> <INDENT> ll = 0 if c == 0 else tmp [ c - 1 ] <NEWLINE> ul = 0 if r == 0 or c == 0 else l [ r - 1 ] [ c - 1 ] <NEWLINE> ur = 0 if r == 0 else l [ r - 1 ] [ c ] <NEWLINE> count = ll + ur - ul <NEWLINE> if Map [ r ] [ c ] == kw : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> tmp . append ( count ) <NEWLINE> <DEDENT> l . append ( tmp ) <NEWLINE> <DEDENT> return l <NEWLINE> <NL> <DEDENT> J = get_slide_sum ( Map , <STRING> ) <NEWLINE> O = get_slide_sum ( Map , <STRING> ) <NEWLINE> I = get_slide_sum ( Map , <STRING> ) <NEWLINE> <NL> def get_sum ( inp , L ) : <NEWLINE> <INDENT> a , b , c , d = list ( map ( int , inp . split ( ) ) ) <NEWLINE> ll = 0 if a == 1 else L [ a - 2 ] [ d - 1 ] <NEWLINE> ul = 0 if a == 1 or b == 1 else L [ a - 2 ] [ b - 2 ] <NEWLINE> ur = 0 if b == 1 else L [ c - 1 ] [ b - 2 ] <NEWLINE> return L [ c - 1 ] [ d - 1 ] - ll - ur + ul <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> print ( get_sum ( inp , J ) , get_sum ( inp , O ) , get_sum ( inp , I ) ) <NEWLINE> <DEDENT>
M , N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> K = input ( ) <NEWLINE> <NL> d = { } <NEWLINE> <NL> for i in range ( M ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> d [ i + 1 , j + 1 ] = a [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> D = { } <NEWLINE> <NL> for i in range ( M + 1 ) : <NEWLINE> <INDENT> for j in range ( N + 1 ) : <NEWLINE> <INDENT> if i == 0 or j == 0 : <NEWLINE> <INDENT> D [ i , j ] = 0 , 0 <NEWLINE> <DEDENT> elif d [ i , j ] == <STRING> : <NEWLINE> <INDENT> D [ i , j ] = ( D [ i - 1 , j ] [ 0 ] + D [ i , j - 1 ] [ 0 ] - D [ i - 1 , j - 1 ] [ 0 ] + 1 , <NEWLINE> <INDENT> D [ i - 1 , j ] [ 1 ] + D [ i , j - 1 ] [ 1 ] - D [ i - 1 , j - 1 ] [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif d [ i , j ] == <STRING> : <NEWLINE> <INDENT> D [ i , j ] = ( D [ i - 1 , j ] [ 0 ] + D [ i , j - 1 ] [ 0 ] - D [ i - 1 , j - 1 ] [ 0 ] , <NEWLINE> <INDENT> D [ i - 1 , j ] [ 1 ] + D [ i , j - 1 ] [ 1 ] - D [ i - 1 , j - 1 ] [ 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> D [ i , j ] = ( D [ i - 1 , j ] [ 0 ] + D [ i , j - 1 ] [ 0 ] - D [ i - 1 , j - 1 ] [ 0 ] , <NEWLINE> <INDENT> D [ i - 1 , j ] [ 1 ] + D [ i , j - 1 ] [ 1 ] - D [ i - 1 , j - 1 ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for _ in range ( K ) : <NEWLINE> <INDENT> b0 , b1 , b2 , b3 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> nJ = D [ b2 , b3 ] [ 0 ] - D [ b0 - 1 , b3 ] [ 0 ] - D [ b2 , b1 - 1 ] [ 0 ] + D [ b0 - 1 , b1 - 1 ] [ 0 ] <NEWLINE> nO = D [ b2 , b3 ] [ 1 ] - D [ b0 - 1 , b3 ] [ 1 ] - D [ b2 , b1 - 1 ] [ 1 ] + D [ b0 - 1 , b1 - 1 ] [ 1 ] <NEWLINE> nI = ( b2 - b0 + 1 ) * ( b3 - b1 + 1 ) - nJ - nO <NEWLINE> print nJ , nO , nI <NEWLINE> <DEDENT>
n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in xrange ( 10 ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> v , j = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g [ j - 1 ] . append ( v ) <NEWLINE> <DEDENT> for i in xrange ( 10 ) : <NEWLINE> <INDENT> g [ i ] . sort ( ) <NEWLINE> g [ i ] . reverse ( ) <NEWLINE> <NL> <DEDENT> books = [ [ 0 ] * ( k + 1 ) for _ in xrange ( 10 ) ] <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> for j in xrange ( 1 , len ( g [ i ] ) + 1 ) : <NEWLINE> <INDENT> books [ i ] [ j ] = books [ i ] [ j - 1 ] + g [ i ] [ j - 1 ] + 2 * ( j - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ [ 0 ] * ( k + 1 ) for _ in xrange ( 11 ) ] <NEWLINE> for i in xrange ( 10 ) : <NEWLINE> <INDENT> for j in xrange ( 1 , k + 1 ) : <NEWLINE> <INDENT> for l in xrange ( j + 1 ) : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = max ( dp [ i + 1 ] [ j ] , dp [ i ] [ j - l ] + books [ i ] [ l ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ 10 ] [ k ] ) <NEWLINE>
[ N , K ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> C = [ [ ] for i in range ( 11 ) ] <NEWLINE> D = [ [ 0 for j in range ( K + 1 ) ] for i in range ( 11 ) ] <NEWLINE> M = [ 0 for i in range ( 11 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> c , g = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> C [ g ] . append ( c ) <NEWLINE> M [ g ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , 11 ) : <NEWLINE> <INDENT> y = sorted ( C [ i ] , reverse = True ) <NEWLINE> for j in range ( len ( y ) ) : <NEWLINE> <INDENT> n = j + 1 <NEWLINE> D [ i ] [ n ] = y [ j ] + D [ i ] [ n - 1 ] + 2 * ( n - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> DP = [ [ 0 for i in range ( K + 1 ) ] for j in range ( 11 ) ] <NEWLINE> <NL> for g in range ( 1 , 11 ) : <NEWLINE> <INDENT> for k in range ( K + 1 ) : <NEWLINE> <INDENT> DP [ g ] [ k ] = max ( [ DP [ g - 1 ] [ k - x ] + D [ g ] [ x ] for x in range ( min ( k + 1 , M [ g ] + 1 ) ) ] + [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print DP [ 10 ] [ K ] <NEWLINE> <NL>
print min ( [ input ( ) for i in [ 1 , 1 , 1 ] ) + min ( [ input ( ) for i in [ 1 , 1 ] ] ) - 50 <NEWLINE>
t = int ( input ( ) ) <NEWLINE> point_l = [ 0 for i in range ( t ) ] <NEWLINE> for i in range ( ( t * ( t - 1 ) ) / 2 ) : <NEWLINE> <INDENT> input_line = input ( ) <NEWLINE> tmp = [ int ( x ) for x in input_line . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> if tmp [ 2 ] > tmp [ 3 ] : <NEWLINE> <INDENT> point_l [ tmp [ 0 ] - 1 ] += 3 <NEWLINE> <DEDENT> elif tmp [ 3 ] > tmp [ 2 ] : <NEWLINE> <INDENT> point_l [ tmp [ 1 ] - 1 ] += 3 <NEWLINE> <DEDENT> elif tmp [ 2 ] == tmp [ 3 ] : <NEWLINE> <INDENT> point_l [ tmp [ 0 ] - 1 ] += 1 <NEWLINE> point_l [ tmp [ 1 ] - 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> rank_l = [ 0 for i in range ( t ) ] <NEWLINE> rank = 1 <NEWLINE> for l in sorted ( point_l , reverse = True ) : <NEWLINE> <INDENT> dup = point_l . count ( l ) <NEWLINE> for j in range ( dup ) : <NEWLINE> <INDENT> rank_l [ point_l . index ( l ) ] += rank <NEWLINE> point_l [ point_l . index ( l ) ] = - 1 <NEWLINE> <DEDENT> rank += dup <NEWLINE> <NL> <DEDENT> for l in rank_l : <NEWLINE> <INDENT> print ( l ) <NEWLINE> <DEDENT>
A , B = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> C = input ( ) <NEWLINE> D = [ input ( ) for _ in range ( N ) ] <NEWLINE> D = sorted ( D ) [ : : - 1 ] <NEWLINE> price = A <NEWLINE> cal = C <NEWLINE> ans = cal / price <NEWLINE> for d in D : <NEWLINE> <INDENT> cal += d <NEWLINE> price += B <NEWLINE> ans = max ( ans , cal / price ) <NEWLINE> <DEDENT> print ans <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> N , K = [ int ( x ) for x in sys . stdin . readline ( ) . split ( <STRING> ) ] <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> f . close ( ) <NEWLINE> <NL> schedule = [ 0 ] * N <NEWLINE> for line in lines : <NEWLINE> <INDENT> strs = line . split ( <STRING> ) <NEWLINE> schedule [ int ( strs [ 0 ] ) - 1 ] = int ( strs [ 1 ] ) <NEWLINE> <NL> <DEDENT> number = [ 0 ] * 9 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> l1 = i // 3 <NEWLINE> l2 = i % 3 <NEWLINE> if ( schedule [ 0 ] != l1 + 1 and schedule [ 0 ] != 0 ) : <NEWLINE> <INDENT> number [ i ] = 0 <NEWLINE> <DEDENT> elif ( schedule [ 1 ] != l2 + 1 and schedule [ 1 ] != 0 ) : <NEWLINE> <INDENT> number [ i ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> number [ i ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for s in schedule [ 2 : ] : <NEWLINE> <INDENT> new_number = [ 0 ] * 9 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> l1 = i // 3 <NEWLINE> l2 = i % 3 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> new_number [ i ] += number [ l2 * 3 + j ] if ( ( s == 0 or s == l1 + 1 ) and not ( l2 == j and l1 == j ) ) else 0 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 9 ) : <NEWLINE> <INDENT> number [ i ] = new_number [ i ] % 10000 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for n in number : <NEWLINE> <INDENT> sum += n <NEWLINE> <DEDENT> print ( sum % 10000 ) <NEWLINE>
s = raw_input ( ) <NEWLINE> k = x = 0 <NEWLINE> while x < len ( s ) * 0.4 : <NEWLINE> <INDENT> x += 1 <NEWLINE> if <STRING> * x + <STRING> * x + <STRING> * x in s : <NEWLINE> <INDENT> k = x <NEWLINE> <DEDENT> elif not <STRING> * x in s : <NEWLINE> <INDENT> print ( k ) <NEWLINE> break <NEWLINE> <DEDENT> elif not <STRING> * x in s : <NEWLINE> <INDENT> print ( k ) <NEWLINE> break <NEWLINE> <DEDENT> elif not <STRING> * x in s : <NEWLINE> <INDENT> print ( k ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
a = raw_input ( ) <NEWLINE> sp = min ( a . count ( <STRING> ) , a . count ( <STRING> ) , a . count ( <STRING> ) ) <NEWLINE> for k in range ( sp , 0 , - 1 ) : <NEWLINE> <INDENT> joi = <STRING> * k + <STRING> * k + <STRING> * k <NEWLINE> if joi in a : <NEWLINE> <INDENT> print k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT>
S = raw_input ( ) <NEWLINE> N = len ( S ) <NEWLINE> for k in range ( N / 3 , 0 , - 1 ) : <NEWLINE> <INDENT> s = <STRING> * k + <STRING> * k + <STRING> * k <NEWLINE> if S . count ( s ) > 0 : <NEWLINE> <INDENT> print k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> s1 = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s2 = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> result = 0 <NEWLINE> <NL> for i in range ( B ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> cnt = 0 <NEWLINE> for j , n in enumerate ( s2 [ i : ] ) : <NEWLINE> <INDENT> while k < A and n != s1 [ k ] : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> if n == s1 [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> if k == A : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if cnt > result : <NEWLINE> <INDENT> result = cnt <NEWLINE> <NL> <DEDENT> <DEDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
s = map ( int , input ( ) . split ( ) ) <NEWLINE> if len ( s ) == 2 : c = s [ 0 ] ; d = s [ 1 ] <NEWLINE> else : c = s [ 0 ] ; d = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> e = 0 ; i = 0 <NEWLINE> while i < d - e : <NEWLINE> <INDENT> p = i ; q = 0 <NEWLINE> for j in range ( c ) : <NEWLINE> <INDENT> if a [ j ] == b [ p ] : q += 1 ; p += 1 <NEWLINE> <DEDENT> e = max ( e , q ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( e ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if len ( l ) == 2 : <NEWLINE> <INDENT> a = l [ 0 ] ; b = l [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = l [ 0 ] ; b = input ( ) <NEWLINE> <DEDENT> p = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> <COMMENT> <NL> for i in range ( a ) : <NEWLINE> <INDENT> if b - i <= ans or a - i <= ans : break <NEWLINE> j = 0 ; k = i <NEWLINE> cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if p [ j ] == q [ k ] : <NEWLINE> <INDENT> cnt += 1 ; j += 1 ; k += 1 <NEWLINE> <DEDENT> else : j += 1 <NEWLINE> if j == a : break <NEWLINE> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ans <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> if b - i <= ans : break <NEWLINE> j = 0 ; k = i <NEWLINE> cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if p [ j ] == q [ k ] : <NEWLINE> <INDENT> cnt += 1 ; j += 1 ; k += 1 <NEWLINE> <DEDENT> else : j += 1 <NEWLINE> if j == a : break <NEWLINE> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> print ans <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> input_lines = [ ] <NEWLINE> input_lines . append ( raw_input ( ) ) <NEWLINE> N , T , S = [ int ( x ) for x in input_lines [ 0 ] . split ( <STRING> ) ] <NEWLINE> data = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> input_lines . append ( raw_input ( ) ) <NEWLINE> a , b = [ int ( x ) for x in input_lines [ i + 1 ] . split ( <STRING> ) ] <NEWLINE> data . append ( [ a , b ] ) <NEWLINE> <DEDENT> dp = [ [ 0 for i in range ( T + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> judge = 0 <NEWLINE> judge2 = 0 <NEWLINE> def rec ( i , t ) : <NEWLINE> <INDENT> global judge <NEWLINE> global judge2 <NEWLINE> if judge2 == 1 and t < T - S : <NEWLINE> <INDENT> judge = 1 <NEWLINE> <DEDENT> if dp [ i ] [ t ] != 0 : <NEWLINE> <INDENT> return dp [ i ] [ t ] <NEWLINE> <DEDENT> if i == N : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> elif t < data [ i ] [ 1 ] or ( judge == 0 and t - data [ i ] [ 1 ] < T - S and data [ i ] [ 1 ] > T - S ) : <NEWLINE> <INDENT> res = rec ( i + 1 , t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if judge == 0 and t - data [ i ] [ 1 ] < T - S and data [ i ] [ 1 ] <= T - S : <NEWLINE> <INDENT> judge2 = 1 <NEWLINE> res = max ( rec ( i + 1 , t ) , rec ( i + 1 , T - S - data [ i ] [ 1 ] ) + data [ i ] [ 0 ] ) <NEWLINE> judge = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = max ( rec ( i + 1 , t ) , rec ( i + 1 , t - data [ i ] [ 1 ] ) + data [ i ] [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] [ t ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> print rec ( 0 , T ) <NEWLINE>
while True : <NEWLINE> <INDENT> l = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> if a % c == 0 and b % d == 0 : <NEWLINE> <INDENT> if a / c >= b / d : <NEWLINE> <INDENT> print ( l - ( a // c ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l - ( b // d ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> x = ( a // c ) + 1 <NEWLINE> y = ( b // d ) + 1 <NEWLINE> if x >= y : <NEWLINE> <INDENT> print ( l - x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( l - y ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> import array <NEWLINE> <NL> input_lines = sys . stdin . read ( ) . splitlines ( ) <NEWLINE> N , K = [ int ( x ) for x in input_lines [ 0 ] . split ( <STRING> ) ] <NEWLINE> x_grid = set ( ) <NEWLINE> y_grid = set ( ) <NEWLINE> d_grid = set ( ) <NEWLINE> for line in input_lines [ 1 : ] : <NEWLINE> <INDENT> x1 , y1 , d1 , x2 , y2 , d2 = [ int ( x ) for x in line . split ( <STRING> ) ] <NEWLINE> x_grid . add ( x1 ) <NEWLINE> x_grid . add ( x2 ) <NEWLINE> y_grid . add ( y1 ) <NEWLINE> y_grid . add ( y2 ) <NEWLINE> d_grid . add ( d1 ) <NEWLINE> d_grid . add ( d2 ) <NEWLINE> <NL> <DEDENT> x_grid = sorted ( x_grid ) <NEWLINE> y_grid = sorted ( y_grid ) <NEWLINE> d_grid = sorted ( d_grid ) <NEWLINE> x_grid_index = { x [ 1 ] : x [ 0 ] for x in enumerate ( x_grid ) } <NEWLINE> y_grid_index = { y [ 1 ] : y [ 0 ] for y in enumerate ( y_grid ) } <NEWLINE> d_grid_index = { d [ 1 ] : d [ 0 ] for d in enumerate ( d_grid ) } <NEWLINE> <NL> fish_dist = array . array ( <STRING> , [ 0 for x in xrange ( len ( x_grid ) * len ( y_grid ) * len ( d_grid ) ) ] ) <NEWLINE> <NL> def index2arr ( x , y , d ) : <NEWLINE> <INDENT> return x + len ( x_grid ) * y + len ( x_grid ) * len ( y_grid ) * d <NEWLINE> <NL> <DEDENT> def arr2index ( index ) : <NEWLINE> <INDENT> x = index % len ( x_grid ) <NEWLINE> y = ( ( index - x ) / len ( x_grid ) ) % len ( y_grid ) <NEWLINE> d = ( index - x - len ( x_grid ) * y ) / len ( x_grid ) / len ( d_grid ) <NEWLINE> return x , y , d <NEWLINE> <NL> <DEDENT> for line in input_lines [ 1 : ] : <NEWLINE> <INDENT> x1 , y1 , d1 , x2 , y2 , d2 = [ int ( x ) for x in line . split ( <STRING> ) ] <NEWLINE> x1_index = x_grid_index [ x1 ] <NEWLINE> x2_index = x_grid_index [ x2 ] <NEWLINE> y1_index = y_grid_index [ y1 ] <NEWLINE> y2_index = y_grid_index [ y2 ] <NEWLINE> d1_index = d_grid_index [ d1 ] <NEWLINE> d2_index = d_grid_index [ d2 ] <NEWLINE> for x in xrange ( x1_index , x2_index ) : <NEWLINE> <INDENT> for y in xrange ( y1_index , y2_index ) : <NEWLINE> <INDENT> for d in xrange ( d1_index , d2_index ) : <NEWLINE> <INDENT> fish_dist [ index2arr ( x , y , d ) ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> volume = 0 <NEWLINE> for index , num in [ x for x in enumerate ( fish_dist ) if x [ 1 ] >= K ] : <NEWLINE> <INDENT> x_index , y_index , d_index = arr2index ( index ) <NEWLINE> x_begin = x_grid [ x_index ] <NEWLINE> y_begin = y_grid [ y_index ] <NEWLINE> d_begin = d_grid [ d_index ] <NEWLINE> x_end = x_grid [ x_index + 1 ] <NEWLINE> y_end = y_grid [ y_index + 1 ] <NEWLINE> d_end = d_grid [ d_index + 1 ] <NEWLINE> volume += ( x_end - x_begin ) * ( y_end - y_begin ) * ( d_end - d_begin ) <NEWLINE> <DEDENT> print ( volume ) <NEWLINE>
lista = [ ] <NEWLINE> t = 0 <NEWLINE> ch = 0 <NEWLINE> e = 0 <NEWLINE> d = 0 <NEWLINE> tflag = 1 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lista . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> def func01 ( a , b , c ) : <NEWLINE> <INDENT> global t <NEWLINE> global ch <NEWLINE> global e <NEWLINE> global d <NEWLINE> if a + b > c : <NEWLINE> <INDENT> t += 1 <NEWLINE> if a ** 2 + b ** 2 == c ** 2 : <NEWLINE> <INDENT> ch += 1 <NEWLINE> <DEDENT> elif a ** 2 + b ** 2 > c ** 2 : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> elif a ** 2 + b ** 2 < c ** 2 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tflag = 0 <NEWLINE> <DEDENT> <DEDENT> while ( tflag == 1 ) : <NEWLINE> <INDENT> for i in range ( len ( lista ) ) : <NEWLINE> <INDENT> x = sorted ( lista [ i ] ) <NEWLINE> func01 ( x [ 0 ] , x [ 1 ] , x [ 2 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( t , ch , e , d ) <NEWLINE>
sankaku = 0 <NEWLINE> tyokkaku = 0 <NEWLINE> eikaku = 0 <NEWLINE> donkaku = 0 <NEWLINE> while True : <NEWLINE> <INDENT> inputed_line = input ( ) <NEWLINE> data_str = inputed_line . split ( <STRING> ) <NEWLINE> data = [ int ( i ) for i in data_str ] <NEWLINE> data . sort ( ) <NEWLINE> if data [ - 1 ] < data [ 0 ] + data [ 1 ] : <NEWLINE> <INDENT> sankaku += 1 <NEWLINE> if data [ - 1 ] ** 2 == data [ 0 ] ** 2 + data [ 1 ] ** 2 : <NEWLINE> <INDENT> tyokkaku += 1 <NEWLINE> <DEDENT> elif data [ - 1 ] ** 2 < data [ 0 ] ** 2 + data [ 1 ] ** 2 : <NEWLINE> <INDENT> eikaku += 1 <NEWLINE> <DEDENT> elif data [ - 1 ] ** 2 > data [ 0 ] ** 2 + data [ 1 ] ** 2 : <NEWLINE> <INDENT> donkaku += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> answer_list = [ sankaku , tyokkaku , eikaku , donkaku ] <NEWLINE> answer_str = <STRING> . join ( answer_list ) <NEWLINE> print ( answer_str ) <NEWLINE> <NL>
result = [ 0 ] * 3 <NEWLINE> while True : <NEWLINE> <INDENT> a , b , c = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if a + b <= c : <NEWLINE> <COMMENT> <NL> flag = a ** 2 + b ** 2 - c * c <NEWLINE> if flag == 0 : <NEWLINE> <INDENT> result [ 0 ] += 1 <NEWLINE> <DEDENT> elif flag > 0 : <NEWLINE> <INDENT> result [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT>
r = a = o = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> l , m , n = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if l + m <= n : break <NEWLINE> c = l * l + m * m - n * n <NEWLINE> if c > 0 : a += 1 <NEWLINE> elif c < 0 : o += 1 <NEWLINE> else : r += 1 <NEWLINE> <DEDENT> print ( sum ( r , a , o ) , r , a , o ) <NEWLINE>
f = True <NEWLINE> cnt = 0 <NEWLINE> l = [ 0 , 0 , 0 ] <NEWLINE> while f : <NEWLINE> <INDENT> t = [ ] <NEWLINE> t . append ( int ( input ( ) ) ) <NEWLINE> t . append ( int ( input ( ) ) ) <NEWLINE> t . append ( int ( input ( ) ) ) <NEWLINE> t . sort ( ) <NEWLINE> if t [ 0 ] + t [ 1 ] <= t [ 2 ] : <NEWLINE> <INDENT> f = False <NEWLINE> continue <NEWLINE> <DEDENT> if t [ 0 ] ** 2 + t [ 1 ] ** 2 > t [ 2 ] ** 2 : <NEWLINE> <INDENT> l [ 0 ] += 1 <NEWLINE> <DEDENT> elif t [ 0 ] ** 2 + t [ 1 ] ** 2 == t [ 2 ] ** 2 : <NEWLINE> <INDENT> l [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( l ) , [ s for s in l ] ) <NEWLINE> <NL>
ans = [ 0 for i in range ( 4 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> sides = sorted ( [ int ( input ( ) ) for i in range ( 3 ) ] ) <NEWLINE> if sides [ 2 ] >= sides [ 1 ] + sides [ 0 ] : <NEWLINE> <INDENT> print ( ans [ 0 ] , ans [ 1 ] , ans [ 2 ] , ans [ 3 ] ) <NEWLINE> break <NEWLINE> <DEDENT> if sides [ 2 ] ** 2 >= sides [ 1 ] ** 2 + sides [ 0 ] ** 2 : <NEWLINE> <INDENT> ans [ 3 ] += 1 <NEWLINE> <DEDENT> elif sides [ 2 ] ** 2 == sides [ 1 ] ** 2 + sides [ 0 ] ** 2 : <NEWLINE> <INDENT> ans [ 2 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans [ 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> def t_check ( a , b , c ) : <NEWLINE> <INDENT> if a + b > c : <NEWLINE> <INDENT> if b + c > a : <NEWLINE> <INDENT> if a + c > b : return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <NL> <DEDENT> def f_check ( a_ , b_ , c_ ) : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> tmp . append ( a_ ) <NEWLINE> tmp . append ( b_ ) <NEWLINE> tmp . append ( c_ ) <NEWLINE> sqrts = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> sqrts . append ( tmp [ i ] ** 2 ) <NEWLINE> <DEDENT> m = max ( sqrts ) <NEWLINE> s = sum ( sqrts ) <NEWLINE> <NL> if m == ( s - m ) : return ( 0 ) <NEWLINE> if m > ( s - m ) : return ( 2 ) <NEWLINE> if m < ( s - m ) : return ( 1 ) <NEWLINE> <NL> <NL> <DEDENT> counter = [ 0 , 0 , 0 ] <NEWLINE> <NL> <NL> while ( 1 ) : <NEWLINE> <INDENT> input_f = input ( ) <NEWLINE> <NL> <NL> t = input_f . split ( <STRING> ) [ i ] . split ( ) <NEWLINE> fn , sn , tn = int ( t [ 0 ] ) , int ( t [ 1 ] ) , int ( t [ 2 ] ) <NEWLINE> if t_check ( fn , sn , tn ) : <NEWLINE> <INDENT> counter [ f_check ( fn , sn , tn ) ] += 1 <NEWLINE> <DEDENT> else : break <NEWLINE> <NL> <NL> <DEDENT> print ( sum ( counter ) , counter [ 0 ] , counter [ 1 ] , counter [ 2 ] ) <NEWLINE> <NL> <NL> <NL>
result = [ 0 ] * 3 <NEWLINE> while 1 : <NEWLINE> <INDENT> a , b , c = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if a + b > c : <NEWLINE> <INDENT> flag = c * c - b * b - a * a <NEWLINE> if flag == 0 : <NEWLINE> <INDENT> result [ 0 ] += 1 <NEWLINE> <DEDENT> elif flag > 0 : <NEWLINE> <INDENT> result [ 1 ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result [ 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ( result ) , * result ) <NEWLINE>
import sys <NEWLINE> from enum import Enum , auto <NEWLINE> <NL> class Triangle ( Enum ) : <NEWLINE> <INDENT> NOTRIANGLE = 0 <NEWLINE> ACUTE = 1 <NEWLINE> RIGHT = 2 <NEWLINE> OBTUSE = 3 <NEWLINE> <NL> <DEDENT> def triangle_check ( a , b , c ) : <NEWLINE> <INDENT> e1 , e2 , e3 = sorted ( [ a , b , c ] , reverse = True ) <NEWLINE> if e1 <= 0 or e2 <= 0 or e3 <= 0 : return Triangle . NOTRIANGLE <NEWLINE> if e1 < e2 + e3 : return Triangle . NOTRIANGLE <NEWLINE> if e1 ** 2 == e2 ** 2 + e3 ** 2 : return Triangle . RIGHT <NEWLINE> elif e1 ** 2 < e2 ** 2 + e3 ** 2 : return Triangle . ACUTE <NEWLINE> elif e1 ** 2 > e2 ** 2 + e3 ** 2 : return Triangle . OBTUSE <NEWLINE> <NL> <DEDENT> ans = [ 0 for i in range ( 4 ) ] <NEWLINE> <NL> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> a , b , c = list ( map ( int , line . split ( <STRING> ) ) ) <NEWLINE> rst = triangle_check ( a , b , c ) <NEWLINE> if rst == 0 : <NEWLINE> <INDENT> print ( <STRING> . join ( list ( map ( str , ans ) ) ) ) <NEWLINE> break <NEWLINE> <DEDENT> ans [ 0 ] += 1 <NEWLINE> ans [ int ( rst ) ] += 1 <NEWLINE> <DEDENT>
a , b , c , d = 0 , 0 , 0 , 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> lng = list ( int ( input ( ) . split ( ) ) ) <NEWLINE> lng . sort ( ) <NEWLINE> if lng [ 0 ] + lng [ 1 ] <= lng [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> % ( a , b , c , d ) ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += 1 <NEWLINE> if lng [ 0 ] ** 2 + lng [ 1 ] ** 2 == lng [ 2 ] ** 2 : <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> elif lng [ 0 ] ** 2 + lng [ 1 ] ** 2 >= lng [ 2 ] ** 2 : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> values = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> minv = min ( vs ) + 1 <NEWLINE> print ( 1 ) <NEWLINE> i = 2 <NEWLINE> ng_value = [ 1 ] * minv <NEWLINE> while i < minv : <NEWLINE> <INDENT> if not 0 in [ 1 if values [ k ] % i == 0 else 0 for k in range ( n ) ] : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i , minv , i ) : <NEWLINE> <INDENT> ng_value [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> b = True <NEWLINE> for j in range ( i + 1 , minv ) : <NEWLINE> <INDENT> if ng_value [ j ] : <NEWLINE> <INDENT> i = j <NEWLINE> b = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if b : break <NEWLINE> <DEDENT>
input ( ) <NEWLINE> n = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> m = n [ 0 ] <NEWLINE> a = { } <NEWLINE> for x in range ( 1 , int ( m ** .5 ) + 1 ) : <NEWLINE> <INDENT> if m % x == 0 : a |= { x , m // x } <NEWLINE> <DEDENT> for c in sorted ( list ( a ) ) : <NEWLINE> <INDENT> for k in n [ 1 : ] : <NEWLINE> <INDENT> if k % c : break <NEWLINE> <DEDENT> else : print ( c ) <NEWLINE> <DEDENT>
a = sorted ( [ int ( input ( ) ) for _ in [ 0 ] * int ( input ( ) ) ] ) [ : 4 ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> for d in a [ i : 4 ] : <NEWLINE> <INDENT> c = a [ i ] <NEWLINE> b += [ c * 10 ** len ( d ) + d , d * 10 ** len ( c ) + c ] <NEWLINE> <DEDENT> <DEDENT> print ( sorted ( b ) [ 2 ] ) <NEWLINE>
import itertools <NEWLINE> L = [ input ( ) for i in range ( input ( ) ) ] <NEWLINE> S = [ 1000000000 , 1000000000 , 1000000000 ] <NEWLINE> for i in itertools . permutations ( L , 2 ) : <NEWLINE> <INDENT> S . append ( int ( <STRING> . join ( map ( str , i ) ) ) ) <NEWLINE> S = sorted ( S ) [ : 3 ] <NEWLINE> <DEDENT> print S [ 2 ] <NEWLINE>
import itertools <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = sorted ( [ int ( input ( ) ) for i in range ( n ) ] ) [ : 4 ] <NEWLINE> b = [ ] <NEWLINE> for c , d in intertools . permutations ( a , 2 ) : <NEWLINE> <INDENT> b += [ c * 10 ** len ( str ( d ) ) + d ] <NEWLINE> <DEDENT> print ( sorted ( b ) [ 2 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> a = a . sort ( ) <NEWLINE> a = a [ : 3 ] <NEWLINE> b = [ ] <NEWLINE> for i in [ 0 , 1 , 2 ] : <NEWLINE> <INDENT> for j in [ 0 , 1 , 2 ] : <NEWLINE> <INDENT> if i != j : <NEWLINE> <INDENT> b . append ( int ( str ( a [ i ] + a [ j ] ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> b . sort ( ) <NEWLINE> print ( b [ 2 ] ) <NEWLINE> <NL>
a = 0 <NEWLINE> o = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if s in [ <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> o = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = eval ( str ( a ) + o + s ) <NEWLINE> <DEDENT> <DEDENT> print a <NEWLINE>
b = [ 1 ] * 2 ** 32 <NEWLINE> for i in range ( 3 , 2 ** 16 , 2 ) : <NEWLINE> <INDENT> if b [ i // 2 ] : b [ i * i // 2 : : i ] = [ 0 ] * len ( b [ i * i // 2 : : i ] ) <NEWLINE> <DEDENT> print ( sum ( b [ int ( input ( ) ) ] for _ in [ 0 ] * int ( input ( ) ) ) ) <NEWLINE>
def comb ( a , b ) : <NEWLINE> <INDENT> if ( a < b or b < 0 ) : return 0 <NEWLINE> if ( b == 0 ) : return 1 <NEWLINE> if ( b > a - b ) : return comb ( a , a - b ) <NEWLINE> return comb ( a , b - 1 ) * ( a - b + 1 ) / b <NEWLINE> <NL> <DEDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c -= a * b <NEWLINE> print comb ( c + a - 1 , c ) <NEWLINE>
n , m , r = map ( int , input ( ) . split ( ) ) ; <NEWLINE> a = n + r - n * m - 1 ; b = r - n * m ; <NEWLINE> s = 1 ; <NEWLINE> if a < b or a < 0 or b < 0 : s = 0 ; <NEWLINE> else : <NEWLINE> <INDENT> if b > a - b : b = a - b ; <NEWLINE> for i in range ( b ) : s = s * ( a - i ) / ( i + 1 ) ; <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
def kaijou ( n ) : <NEWLINE> <INDENT> res = 1 <NEWLINE> for i in xrange ( 1 , x + 1 ) : <NEWLINE> <INDENT> res *= i <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def comb ( a , b ) : <NEWLINE> <INDENT> if ( a < b or b < 0 ) : return 0 <NEWLINE> if ( b == 0 ) : return 1 <NEWLINE> return kaijou ( a ) / kaijou ( b ) / kaijou ( a - b ) <NEWLINE> <NL> <DEDENT> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c -= a * b <NEWLINE> print comb ( c + a - 1 , c ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> import sys <NEWLINE> from sys import stdin <NEWLINE> from collections import namedtuple , Counter <NEWLINE> input = stdin . readline <NEWLINE> <NL> <NL> class RMQ ( object ) : <NEWLINE> <INDENT> INT_MAX = 2 ** 31 - 1 <NEWLINE> <NL> def __init__ ( self , nn , init_val = 0 ) : <NEWLINE> <INDENT> self . n = 1 <NEWLINE> while self . n < nn : <NEWLINE> <INDENT> self . n *= 2 <NEWLINE> <DEDENT> self . dat = [ init_val ] * ( ( 2 * self . n ) - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , k , a ) : <NEWLINE> <COMMENT> <NL> <INDENT> k += ( self . n - 1 ) <NEWLINE> self . dat [ k ] = a <NEWLINE> <NL> while k > 0 : <NEWLINE> <INDENT> k = ( k - 1 ) // 2 <COMMENT> <NEWLINE> self . dat [ k ] = min ( self . dat [ k * 2 + 1 ] , self . dat [ k * 2 + 2 ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , a , b , k , l , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if r <= a or b <= l : <COMMENT> <NEWLINE> <INDENT> return RMQ . INT_MAX <NEWLINE> <DEDENT> if a <= l and r <= b : <NEWLINE> <INDENT> return self . dat [ k ] <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = self . query ( a , b , k * 2 + 1 , l , ( l + r ) // 2 ) <COMMENT> <NEWLINE> vr = self . query ( a , b , k * 2 + 2 , ( l + r ) // 2 , r ) <COMMENT> <NEWLINE> return min ( vl , vr ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , s , t ) : <NEWLINE> <INDENT> return self . query ( s , t + 1 , 0 , 0 , self . n ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> event = namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) <NEWLINE> def main ( args ) : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> rq = RMQ ( 1001 , 999999 ) <NEWLINE> events = [ event ( i + 1 , int ( input ( ) ) ) for i in range ( N ) ] <COMMENT> <NEWLINE> events . reverse ( ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for e in events : <NEWLINE> <INDENT> rq . update ( e . cost , e . num ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> votes = [ ] <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> v = int ( input ( ) ) <NEWLINE> result = rq . find ( 0 , v ) <COMMENT> <NEWLINE> votes . append ( result ) <NEWLINE> <DEDENT> ans = Counter ( votes ) . most_common ( 1 ) [ 0 ] [ 0 ] <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( sys . argv [ 1 : ] ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> import heapq <NEWLINE> <NL> def dijkstra ( s , g , m ) : <NEWLINE> <INDENT> color = [ 0 ] * n <NEWLINE> dis = [ float ( <STRING> ) ] * n <NEWLINE> dis [ s ] = 0 <NEWLINE> heapq . heappush ( pq , [ 0 , s ] ) <NEWLINE> while len ( pq ) != 0 : <NEWLINE> <INDENT> t , u = heapq . heappop ( pq ) <NEWLINE> color [ u ] = 2 <NEWLINE> if dis [ u ] < t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for v in g [ u ] : <NEWLINE> <INDENT> if color [ v ] != 2 : <NEWLINE> <INDENT> if dis [ u ] + m [ u ] [ v ] < dis [ v ] : <NEWLINE> <INDENT> dis [ v ] = dis [ u ] + m [ u ] [ v ] <NEWLINE> color [ v ] = 1 <NEWLINE> heapq . heappush ( pq , [ dis [ v ] , v ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dis <NEWLINE> <NL> <DEDENT> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> cr = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n ) ] <NEWLINE> g = [ [ ] * n for _ in xrange ( n ) ] <NEWLINE> m = [ [ 0 ] * n for _ in xrange ( n ) ] <NEWLINE> for i in xrange ( k ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( b - 1 ) <NEWLINE> g [ b - 1 ] . append ( a - 1 ) <NEWLINE> m [ a - 1 ] [ b - 1 ] = 1 <NEWLINE> m [ b - 1 ] [ a - 1 ] = 1 <NEWLINE> <NL> <DEDENT> pq = [ ] <NEWLINE> d = [ [ ] * n for _ in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> d [ i ] = dijkstra ( i , g , m ) <NEWLINE> <NL> <DEDENT> cost = [ [ float ( <STRING> ) ] * n for _ in xrange ( n ) ] <NEWLINE> newg = [ [ ] * n for _ in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( n ) : <NEWLINE> <INDENT> if d [ i ] [ j ] <= cr [ i ] [ 1 ] : <NEWLINE> <INDENT> cost [ i ] [ j ] = cr [ i ] [ 0 ] <NEWLINE> newg [ i ] . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> pq = [ ] <NEWLINE> dis = dijkstra ( 0 , newg , cost ) <NEWLINE> print ( dis [ n - 1 ] ) <NEWLINE>
import sys <NEWLINE> import bisect <NEWLINE> <NL> f = sys . stdin <NEWLINE> <NL> <COMMENT> <NL> a = list ( map ( int , f ) ) <NEWLINE> a [ 0 ] = 0 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> a [ i ] += a [ i - 1 ] <NEWLINE> <NL> <DEDENT> sum_a = a [ - 1 ] <NEWLINE> third = sum_a // 3 <NEWLINE> <NL> ret = [ ] <NEWLINE> <NL> for i in range ( bisect . bisect_left ( a , third ) ) : <NEWLINE> <INDENT> nick1 = bisect . bisect_left ( a , a [ i ] + third , lo = i ) <NEWLINE> <NL> for ni1 in ( nick1 - 1 , nick1 ) : <NEWLINE> <INDENT> second = min ( third , ( sum_a - ( a [ ni1 ] - a [ i ] ) ) // 2 ) <NEWLINE> nick2 = bisect . bisect_left ( a , a [ ni1 ] + second , lo = nick ) <NEWLINE> for ni2 in ( nick2 - 1 , nick2 ) : <NEWLINE> <INDENT> if len ( a ) <= ni2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> piece1 = a [ ni1 ] - a [ i ] <NEWLINE> piece2 = a [ ni2 ] - a [ ni1 ] <NEWLINE> piece3 = sum_a - piece1 - piece2 <NEWLINE> ret . append ( min ( piece1 , piece2 , piece3 ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max ( ret ) ) <NEWLINE>
def d ( p , q ) : <NEWLINE> <INDENT> return pos [ p ] - pos [ q ] <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> p0 , p1 , p2 = 0 , 0 , 0 <NEWLINE> best = 0 <NEWLINE> fail = False <NEWLINE> while p0 < N : <NEWLINE> <INDENT> if fail : <NEWLINE> <INDENT> p0 += 1 <NEWLINE> <COMMENT> <NL> while d ( p2 , p1 ) > d ( p1 , p0 ) and p2 > p1 : <NEWLINE> <INDENT> p2 -= 1 <NEWLINE> <DEDENT> fail = False <NEWLINE> <COMMENT> <NL> <DEDENT> if p1 <= p0 : p1 = p0 + 1 <NEWLINE> while d ( p1 , p0 ) <= best and p1 - p0 < N : <NEWLINE> <INDENT> p1 += 1 <NEWLINE> <DEDENT> if d ( p1 , p0 ) <= best : <NEWLINE> <INDENT> fail = True <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if p2 <= p1 : p2 = p1 + 1 <NEWLINE> while d ( p2 , p1 ) < d ( p1 , p0 ) and p2 - p0 < N : <NEWLINE> <INDENT> p2 += 1 <NEWLINE> <DEDENT> if d ( p2 , p1 ) < d ( p1 , p0 ) : <NEWLINE> <INDENT> fail = True <NEWLINE> continue <NEWLINE> <COMMENT> <NL> <DEDENT> if L - d ( p2 , p0 ) >= d ( p1 , p0 ) : <NEWLINE> <INDENT> best = d ( p1 , p0 ) <NEWLINE> if best >= L // 3 : <NEWLINE> <INDENT> return best <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> fail = True <NEWLINE> <DEDENT> <DEDENT> return best <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> L = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( input ( ) ) <NEWLINE> L += A [ i ] <NEWLINE> <DEDENT> pos = [ 0 ] * ( 2 * N ) <NEWLINE> for i in range ( 1 , 2 * N ) : <NEWLINE> <INDENT> pos [ i ] = pos [ i - 1 ] + A [ ( i - 1 ) % N ] <NEWLINE> <NL> <DEDENT> print ( solve ( ) ) <NEWLINE>
import math <NEWLINE> class seg_tree : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . depth = math . ceil ( math . log ( n , 2 ) ) <NEWLINE> self . size = 1 << self . depth <NEWLINE> self . bit = [ 0 ] * 2 * self . size <NEWLINE> self . renew = [ 0 ] * 2 * self . size <NEWLINE> <NL> <DEDENT> def add ( self , p , v ) : <NEWLINE> <INDENT> p += self . size ; <NEWLINE> while p : <NEWLINE> <INDENT> self . bit [ p ] += v <NEWLINE> p >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , l , r ) : <NEWLINE> <INDENT> l += self . size <NEWLINE> r += self . size <NEWLINE> ret = 0 <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> ret += self . bit [ l ] <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> ret += self . bit [ r ] <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def set_renew ( self , l , r ) : <NEWLINE> <INDENT> l += self . size <NEWLINE> r += self . size <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> if l & 1 : <NEWLINE> <INDENT> self . renew [ l ] = 1 <NEWLINE> l += 1 <NEWLINE> <DEDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> self . renew [ r ] = 1 <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def is_renew ( self , p ) : <NEWLINE> <INDENT> p += self . size <NEWLINE> while p : <NEWLINE> <INDENT> if self . renew [ p ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> p >>= 1 <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def unset_renew ( self , p ) : <NEWLINE> <INDENT> p += self . size <NEWLINE> for i in range ( self . depth - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if self . renew [ p >> i ] : <NEWLINE> <INDENT> self . renew [ p >> i ] = 0 <NEWLINE> self . renew [ ( p >> i ) * 2 ] = self . renew [ ( p >> i ) * 2 + 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> self . renew [ p ] = 0 <NEWLINE> <DEDENT> def get_lf ( self , r ) : <NEWLINE> <INDENT> l = self . size <NEWLINE> r += self . size <NEWLINE> while l < r : <NEWLINE> <INDENT> if r & 1 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> if self . bit [ r ] : <NEWLINE> <INDENT> while r < self . size : <NEWLINE> <INDENT> r <<= 1 <NEWLINE> if self . bit [ r + 1 ] : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> return r - self . size <NEWLINE> <DEDENT> <DEDENT> if l & 1 : <NEWLINE> <INDENT> l += 1 <NEWLINE> <DEDENT> l >>= 1 <NEWLINE> r >>= 1 <NEWLINE> <DEDENT> return - 1 <NEWLINE> <DEDENT> <DEDENT> from collections import UserList <NEWLINE> class union_find ( UserList ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> UserList . __init__ ( self ) <NEWLINE> <DEDENT> def root ( self , p ) : <NEWLINE> <INDENT> if self . data [ p ] < 0 : <NEWLINE> <INDENT> return p <NEWLINE> <DEDENT> self . data [ p ] = self . root ( self . data [ p ] ) <NEWLINE> return self . data [ p ] <NEWLINE> <DEDENT> def join ( self , p , q ) : <NEWLINE> <INDENT> p , q = self . root ( p ) , self . root ( q ) <NEWLINE> <NL> if p == q : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . data [ p ] < self . data [ q ] : <NEWLINE> <INDENT> p , q = q , p <NEWLINE> <DEDENT> self . data [ p ] , self . data [ q ] = self . data [ q ] , p <NEWLINE> return True <NEWLINE> <DEDENT> <DEDENT> def bisect ( a , v ) : <NEWLINE> <INDENT> l , r = 0 , len ( a ) <NEWLINE> while l < r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if a [ m ] < v : <NEWLINE> <INDENT> l = m + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> <DEDENT> return l <NEWLINE> <DEDENT> def adjust ( seg , uf , target , p ) : <NEWLINE> <INDENT> if seg . is_renew ( p ) : <NEWLINE> <INDENT> uf . append ( - 1 ) <NEWLINE> seg . unset_renew ( p ) <NEWLINE> target [ p ] = len ( uf ) - 1 <NEWLINE> <DEDENT> <DEDENT> from operator import itemgetter <NEWLINE> @ profile <NEWLINE> def main ( f ) : <NEWLINE> <INDENT> w , h , n = map ( int , f . readline ( ) . split ( ) ) <NEWLINE> abcd = [ list ( map ( int , line . split ( ) ) ) for line in f ] <NEWLINE> <NL> abcd . extend ( [ [ 0 , 0 , w , 0 ] , <NEWLINE> <INDENT> [ 0 , 0 , 0 , h ] , <NEWLINE> [ w , 0 , w , h ] , <NEWLINE> [ 0 , h , w , h ] ] ) <NEWLINE> <NL> <DEDENT> xs = { x : i for i , x in enumerate ( sorted ( set ( [ abcdi [ 0 ] for abcdi in abcd ] + [ abcdi [ 2 ] for abcdi in abcd ] + [ - 1 ] ) ) ) } <NEWLINE> abcd = [ ( xs [ a ] , b , xs [ c ] , d ) for a , b , c , d in abcd ] <NEWLINE> <NL> target = [ - 1 ] * n * 2 <NEWLINE> target [ 0 ] = 0 <NEWLINE> uf = union_find ( ) <NEWLINE> uf . append ( - 1 ) <NEWLINE> seg = seg_tree ( len ( xs ) ) <NEWLINE> seg . add ( 0 , 1 ) <COMMENT> <NEWLINE> <NL> a = [ ] <NEWLINE> for x1 , y1 , x2 , y2 in abcd : <NEWLINE> <INDENT> if x1 == x2 : <NEWLINE> <INDENT> a . append ( ( y1 , 0 , x1 , - 1 ) ) <NEWLINE> a . append ( ( y2 , 2 , x1 , - 1 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( ( y1 , 1 , x1 , x2 ) ) <NEWLINE> <DEDENT> <DEDENT> a . sort ( key = itemgetter ( 0 , 1 ) ) <NEWLINE> ret = 0 <NEWLINE> for _ , act , left , right in a : <NEWLINE> <INDENT> if act == 0 : <NEWLINE> <INDENT> lf = seg . get_lf ( left ) <NEWLINE> <NL> adjust ( seg , uf , target , lf ) <NEWLINE> adjust ( seg , uf , target , left ) <NEWLINE> target [ left ] = target [ lf ] <NEWLINE> <NL> seg . add ( left , 1 ) <NEWLINE> <DEDENT> elif act == 1 : <NEWLINE> <INDENT> count = seg . query ( left , right + 1 ) <NEWLINE> if count < 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ret += count - 1 ; <NEWLINE> <NL> seg . set_renew ( left , seg . get_lf ( right + 1 ) ) <NEWLINE> <DEDENT> elif act == 2 : <NEWLINE> <INDENT> lf = seg . get_lf ( left ) <NEWLINE> adjust ( seg , uf , target , lf ) <NEWLINE> adjust ( seg , uf , target , left ) <NEWLINE> if uf . join ( target [ lf ] , target [ left ] ) : <NEWLINE> <INDENT> ret -= 1 <NEWLINE> <DEDENT> seg . add ( left , - 1 ) <NEWLINE> <DEDENT> <DEDENT> print ( ret ) <NEWLINE> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> main ( f ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> B = int ( input ( ) ) <NEWLINE> C = int ( input ( ) ) <NEWLINE> D = int ( input ( ) ) <NEWLINE> P = int ( input ( ) ) <NEWLINE> print ( min ( P * A , B if C <= P else B + ( P - C ) * D ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> abc = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n - 1 ) ] <NEWLINE> cnt = [ 0 ] * ( n - 1 ) <NEWLINE> for i in xrange ( m - 1 ) : <NEWLINE> <INDENT> p [ i ] -= 1 <NEWLINE> p [ i + 1 ] -= 1 <NEWLINE> if p [ i ] < p [ i + 1 ] : <NEWLINE> <INDENT> for j in xrange ( p [ i ] , p [ i + 1 ] ) : <NEWLINE> <INDENT> cnt [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in xrange ( p [ i ] , p [ i + 1 ] , - 1 ) : <NEWLINE> <INDENT> cnt [ j - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> p [ i ] += 1 <NEWLINE> p [ i + 1 ] += 1 <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for i in xrange ( n - 1 ) : <NEWLINE> <INDENT> ans += min ( abc [ i ] [ 0 ] * cnt [ i ] , abc [ i ] [ 1 ] * cnt [ i ] + abc [ i ] [ 2 ] ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
from collections import deque <NEWLINE> import heapq <NEWLINE> <NL> def dijkstra ( s , g ) : <NEWLINE> <INDENT> color = [ 0 ] * n <NEWLINE> dis = { } <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> dis [ i ] = float ( <STRING> ) <NEWLINE> <DEDENT> dis [ s ] = 0 <NEWLINE> heapq . heappush ( pq , [ 0 , s ] ) <NEWLINE> while len ( pq ) != 0 : <NEWLINE> <INDENT> t , u = heapq . heappop ( pq ) <NEWLINE> color [ u ] = 2 <NEWLINE> if dis [ u ] < t : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for v , c in g [ u ] : <NEWLINE> <INDENT> if color [ v ] != 2 : <NEWLINE> <INDENT> if dis [ u ] + c < dis [ v ] : <NEWLINE> <INDENT> dis [ v ] = dis [ u ] + c <NEWLINE> color [ v ] = 1 <NEWLINE> heapq . heappush ( pq , [ dis [ v ] , v ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dis <NEWLINE> <NL> <DEDENT> n , m , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in xrange ( n ) ] <NEWLINE> totalcost = 0 <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> a , b , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g [ a - 1 ] . append ( [ b - 1 , d ] ) <NEWLINE> g [ b - 1 ] . append ( [ a - 1 , d ] ) <NEWLINE> totalcost += d <NEWLINE> <NL> <DEDENT> pq = [ ] <NEWLINE> dis = dijkstra ( 0 , g , cost ) <NEWLINE> dis = sorted ( dis . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> ans = float ( <STRING> ) <NEWLINE> visited = [ 0 ] * n <NEWLINE> for u , x in dis : <NEWLINE> <INDENT> visited [ u ] = 1 <NEWLINE> for v , c in g [ u ] : <NEWLINE> <INDENT> if visited [ v ] == 1 : <NEWLINE> <INDENT> totalcost -= c <NEWLINE> <DEDENT> <DEDENT> ans = min ( ans , totalcost + c * x ) <NEWLINE> <DEDENT> print ans <NEWLINE>
a , b , c , d , e , f = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a + b + c + d + e + f <NEWLINE> y = 100000 <NEWLINE> for i in ( a , b , c , d ) : <NEWLINE> <INDENT> if y > i : y = i <NEWLINE> <DEDENT> z = 0 <NEWLINE> if e < f : z = f <NEWLINE> else : z = e <NEWLINE> print ( x - y - z ) <NEWLINE>
points = [ ] <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> points . append ( int ( input ( ) ) <NEWLINE> <DEDENT> print ( sum ( sorted ( points , reverse = True ) [ : 3 ] ) ) <NEWLINE>
n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> d = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d [ i + 1 ] = int ( input ( ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> if j == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if d [ i ] % k > d [ i + 1 ] % k : <NEWLINE> <INDENT> t = d [ i ] <NEWLINE> d [ i ] = d [ i + 1 ] <NEWLINE> d [ i + 1 ] = t <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( d [ i + 1 ] ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> from collections import deque <NEWLINE> from sys import setrecursionlimit <NEWLINE> <NL> <NL> n , m , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> e = [ ] <NEWLINE> g1 = [ [ ] for _ in xrange ( n ) ] <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> u , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> u -= 1 ; v -= 1 <NEWLINE> g1 [ u ] . append ( v ) <NEWLINE> g1 [ v ] . append ( u ) <NEWLINE> e . append ( ( u , v ) ) <NEWLINE> <DEDENT> d1 = [ 10 ** 9 ] * n <NEWLINE> d1 [ 0 ] = 0 <NEWLINE> dq = deque ( [ 0 ] ) <NEWLINE> while len ( dq ) > 0 : <NEWLINE> <INDENT> now = dq . popleft ( ) <NEWLINE> for nx in g1 [ now ] : <NEWLINE> <INDENT> if d1 [ nx ] > d1 [ now ] + 1 : <NEWLINE> <INDENT> dq . append ( nx ) <NEWLINE> d1 [ nx ] = d1 [ now ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> pe = deepcopy ( e ) <NEWLINE> qu = [ ] <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> r = int ( raw_input ( ) ) <NEWLINE> r -= 1 <NEWLINE> pe [ r ] = ( - 1 , - 1 ) <NEWLINE> qu . append ( r ) <NEWLINE> <DEDENT> g2 = [ [ ] for _ in xrange ( n ) ] <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> u , v = pe [ i ] <NEWLINE> if u == - 1 and v == - 1 : continue <NEWLINE> g2 [ u ] . append ( v ) <NEWLINE> g2 [ v ] . append ( u ) <NEWLINE> <DEDENT> d2 = [ 10 ** 9 ] * n <NEWLINE> d2 [ 0 ] = 0 <NEWLINE> dq = deque ( [ 0 ] ) <NEWLINE> while len ( dq ) > 0 : <NEWLINE> <INDENT> now = dq . popleft ( ) <NEWLINE> for nx in g2 [ now ] : <NEWLINE> <INDENT> if d2 [ nx ] > d2 [ now ] + 1 : <NEWLINE> <INDENT> dq . append ( nx ) <NEWLINE> d2 [ nx ] = d2 [ now ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> setrecursionlimit ( 10 ** 8 ) <NEWLINE> def dfs ( now ) : <NEWLINE> <INDENT> global cnt <NEWLINE> ok [ now ] = True <NEWLINE> cnt += 1 <NEWLINE> for nx in g2 [ now ] : <NEWLINE> <INDENT> if not ok [ nx ] and d2 [ now ] + 1 == d1 [ nx ] : <NEWLINE> <INDENT> d2 [ nx ] = d2 [ now ] + 1 <NEWLINE> dfs ( nx ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> ok = [ False ] * n <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if d1 [ i ] == d2 [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ok [ i ] = True <NEWLINE> <DEDENT> <DEDENT> ans = [ 0 ] * ( q + 1 ) <NEWLINE> ans [ q ] = n - cnt <NEWLINE> for i in xrange ( q - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> r = qu [ i ] <NEWLINE> u , v = e [ r ] <NEWLINE> if ( d2 [ u ] != 10 ** 9 and d2 [ u ] == d2 [ v ] ) or ( ok [ u ] and ok [ v ] ) : <NEWLINE> <INDENT> ans [ i ] = n - cnt <NEWLINE> continue <NEWLINE> <DEDENT> if not ok [ u ] and not ok [ v ] : <NEWLINE> <INDENT> ans [ i ] = n - cnt <NEWLINE> g2 [ u ] . append ( v ) <NEWLINE> g2 [ v ] . append ( u ) <NEWLINE> continue <NEWLINE> <DEDENT> if ok [ u ] : <NEWLINE> <INDENT> g2 [ u ] . append ( v ) <NEWLINE> g2 [ v ] . append ( u ) <NEWLINE> if d2 [ u ] + 1 == d1 [ v ] : <NEWLINE> <INDENT> d2 [ v ] = d2 [ u ] + 1 <NEWLINE> dfs ( v ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> g2 [ u ] . append ( v ) <NEWLINE> g2 [ v ] . append ( u ) <NEWLINE> if d2 [ v ] + 1 == d1 [ u ] : <NEWLINE> <INDENT> d2 [ u ] = d2 [ v ] + 1 <NEWLINE> dfs ( u ) <NEWLINE> <DEDENT> <DEDENT> ans [ i ] = n - cnt <NEWLINE> <DEDENT> for i in xrange ( 1 , q + 1 ) : <NEWLINE> <INDENT> print ans [ i ] <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> >> > import time <NEWLINE> >> > time . sleep ( 1 ) <NEWLINE> if ( a >= 0 ) : <NEWLINE> <INDENT> print ( ( b - a ) * e ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a * - c + d + b * e ) ; <NEWLINE> <DEDENT>
for i in range ( 5 ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = int ( input ( ) ) <NEWLINE> d = int ( input ( ) ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> if a < 0 and a < b : <NEWLINE> <INDENT> x = abs ( a ) * c + d + b * e <NEWLINE> print ( x ) <NEWLINE> <DEDENT> elif a > 0 and a < b : <NEWLINE> <INDENT> y = ( b - a ) * e <NEWLINE> print ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> cnt = [ 0 for _ in range ( n ) ] <NEWLINE> cntS = [ [ 0 for _ in range ( n ) ] for _ in range ( m ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k = input ( ) - 1 <NEWLINE> cnt [ k ] += 1 <NEWLINE> cntS [ k ] [ i ] = 1 <NEWLINE> <NL> <DEDENT> for k in range ( m ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> cntS [ k ] [ i + 1 ] += cntS [ k ] [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ sys . maxint / 4 for _ in range ( 1 << m ) ] <NEWLINE> dp [ 0 ] = 0 <NEWLINE> <NL> for S in range ( ( 1 << m ) - 1 ) : <NEWLINE> <INDENT> for k in range ( m ) : <NEWLINE> <INDENT> if not ( S >> k & 1 ) : <NEWLINE> <INDENT> idx = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if S >> i & 1 : <NEWLINE> <INDENT> idx += cnt [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if idx + cnt [ k ] <= n : <NEWLINE> <INDENT> dp [ S | 1 << k ] = min ( dp [ S | 1 << k ] , dp [ S ] + cnt [ k ] - ( cntS [ k ] [ idx + cnt [ k ] - 1 ] - ( cntS [ k ] [ idx - 1 ] if idx - 1 >= 0 else 0 ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print dp [ ( 1 << m ) - 1 ] <NEWLINE>
def check ( y , x ) : <NEWLINE> <INDENT> if 0 <= y <= h - 1 and 0 <= x <= w - 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( h ) ] <NEWLINE> pos = [ - 1 ] * ( h * w ) <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> for j in xrange ( w ) : <NEWLINE> <INDENT> pos [ g [ i ] [ j ] - 1 ] = [ i , j ] <NEWLINE> <NL> <DEDENT> <DEDENT> dy = ( 1 , 0 , - 1 , 0 ) <NEWLINE> dx = ( 0 , 1 , 0 , - 1 ) <NEWLINE> stop = [ [ ] for _ in xrange ( h * w ) ] <NEWLINE> ans = 0 <NEWLINE> for i in xrange ( h * w ) : <NEWLINE> <INDENT> y , x = pos [ i ] <NEWLINE> for j in xrange ( 4 ) : <NEWLINE> <INDENT> ny = y + dy [ j ] ; nx = x + dx [ j ] <NEWLINE> if check ( ny , nx ) : <NEWLINE> <INDENT> if g [ ny ] [ nx ] < g [ y ] [ x ] : <NEWLINE> <INDENT> for k in stop [ g [ ny ] [ nx ] - 1 ] : <NEWLINE> <INDENT> stop [ i ] . append ( k ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> cnt = len ( set ( stop [ i ] ) ) <NEWLINE> if cnt >= 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif cnt == 0 : <NEWLINE> <INDENT> stop [ i ] . append ( g [ y ] [ x ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
inputs = input ( ) . split ( <STRING> ) <NEWLINE> <NL> print ( math . ceil ( inputs [ 2 ] / ( inputs [ 0 ] + ( inputs [ 1 ] / 7 ) ) ) ) <NEWLINE> <NL>
ans = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> info = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ans != <STRING> : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> info_2 = info . split ( ) <NEWLINE> ans += str ( int ( info_2 [ 0 ] ) + int ( info_2 [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin . readline ( ) : <NEWLINE> <INDENT> a , b = map ( int , line . split ( ) ) <NEWLINE> print a + b <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a [ 0 ] + a [ 1 ] <NEWLINE> <DEDENT>
import time , sys <NEWLINE> start = time . time ( ) <NEWLINE> while time . time ( ) - start <= 4.978 : pass <NEWLINE> for input in sys . stdin : print ( sum ( map ( int , input . split ( ) ) ) ) <NEWLINE>
x = input ( ) <NEWLINE> while x : <NEWLINE> <INDENT> a , b = x . split ( <STRING> ) <NEWLINE> print ( int ( a ) + int ( b ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print ( sum ( [ eval ( x ) for x in input ( ) . split ( ) ] ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> brea <NEWLINE> <DEDENT> <DEDENT>
for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> print sum ( map ( int , line . rstrip ( ) . split ( ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for i , j in sys . stdin : <NEWLINE> <INDENT> print i + j <NEWLINE> <DEDENT>
score = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ( a , b ) = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> score . append ( a + b ) <NEWLINE> <DEDENT> for i in score : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> print sum ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> exit <NEWLINE> <DEDENT> <DEDENT>
x = map ( int , raw_input ( ) . split ( <STRING> ) <NEWLINE> print x [ 0 ] + x [ 1 ] <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> A , B = int ( line [ 0 ] ) , int ( line [ 3 ] ) <NEWLINE> print A + B <NEWLINE> <DEDENT>
def run ( infile , outfile ) : <NEWLINE> <INDENT> for line in infile . readline ( ) : <NEWLINE> <INDENT> x , y = map ( int , line . sprit ( ) ) <NEWLINE> print >> outfile , x + y <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> run ( sys . stdin , sys . stdout ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( n [ 0 ] + n [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> input = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> input_list = list2int ( raw_input ( ) . split ( ) ) <NEWLINE> if len ( input_list ) > 0 : <NEWLINE> <INDENT> input . append ( input_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for x in input : <NEWLINE> <INDENT> print ( sum ( x ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def list2int ( list ) : <NEWLINE> <INDENT> return [ int ( x ) for x in list ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import time , sys <NEWLINE> start = time . time ( ) <NEWLINE> while time . time ( ) - start <= 4.98 : pass <NEWLINE> for input in sys . stdin : print ( sum ( map ( int , input . split ( ) ) ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> text = raw_input ( <STRING> ) <NEWLINE> a , b = text . split ( ) <NEWLINE> print int ( a ) + int ( b ) <NEWLINE> <DEDENT>
def get_input ( ) : <NEWLINE> <INDENT> p = input ( ) . split ( ) <NEWLINE> return int ( p [ 0 ] ) , int ( p [ 1 ] ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> a , b = get_input ( ) <NEWLINE> print ( a + b ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> printe ( a + b ) <NEWLINE> <DEDENT> except EOFError as e : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if a != <STRING> : <NEWLINE> <INDENT> print ( sum ( list ( map ( int , a . split ( ) ) ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> def decode_keitai ( str ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> keitai_keys = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <COMMENT> <NL> results = [ ] <NEWLINE> <NL> <COMMENT> <NL> inputs = str . split ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> for input in inputs : <NEWLINE> <NL> <INDENT> result = <STRING> <COMMENT> <NEWLINE> <COMMENT> <NL> s_before = <STRING> <NEWLINE> <NL> <COMMENT> <NL> while len ( str ) > 0 : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> s = str [ 0 ] <NEWLINE> str = str [ 1 : ] <NEWLINE> print s <NEWLINE> <NL> <COMMENT> <NL> if s_before == <STRING> : <NEWLINE> <INDENT> s_before = s <NEWLINE> continue <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if not s in s_before : <NEWLINE> <INDENT> if s_before [ 0 ] == <STRING> : <NEWLINE> <INDENT> result += s_before [ : - 1 ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> id = int ( s_before [ 0 ] ) <NEWLINE> keylen = len ( keitai_keys [ id ] ) <NEWLINE> result += keitai_keys [ id ] [ ( len ( s_before ) - 1 ) % keylen ] <NEWLINE> <DEDENT> s_before = s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s_before += s <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if len ( s_before ) > 0 : <NEWLINE> <INDENT> if s_before [ 0 ] == <STRING> : <NEWLINE> <INDENT> result += s_before [ : - 1 ] . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> id = int ( s_before [ 0 ] ) <NEWLINE> keylen = len ( keitai_keys [ id ] ) <NEWLINE> result += keitai_keys [ id ] [ ( len ( s_before ) - 1 ) % keylen ] <NEWLINE> <NL> <DEDENT> <DEDENT> results . append ( result ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( results ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> lines . append ( line ) <NEWLINE> <DEDENT> print decode_keitai ( <STRING> . join ( lines ) ) <NEWLINE> <DEDENT>
a = [ [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> <INDENT> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] , <NEWLINE> [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ] <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> try : b = input ( ) + <STRING> <NEWLINE> except : pass <NEWLINE> c = 0 <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( b ) - 1 ) : <NEWLINE> <INDENT> if b [ i ] != b [ i + 1 ] : <NEWLINE> <INDENT> if b [ i ] != <STRING> : <NEWLINE> <INDENT> d = int ( b [ i ] ) - 1 <NEWLINE> ans += a [ d ] [ c % len ( a [ d ] ) ] <NEWLINE> <DEDENT> c = 0 <NEWLINE> <DEDENT> else : c += 1 <NEWLINE> if b [ i ] == b [ i + 1 ] == <STRING> : ans += <STRING> <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
ref = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> def inp ( s [ 0 ] , l ) : <NEWLINE> <INDENT> n = int ( s [ 0 ] ) <NEWLINE> p = ( l - 1 ) % len ( ref [ n ] ) <NEWLINE> return ref [ n ] [ p ] <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> s = <STRING> <NEWLINE> for push in raw_input ( ) : <NEWLINE> <INDENT> l = len ( s ) <NEWLINE> if push == <STRING> : <NEWLINE> <INDENT> if l > 0 : <NEWLINE> <INDENT> ans += inp ( s [ 0 ] , l ) <NEWLINE> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> <DEDENT> elif l == 0 or s [ - 1 ] == push : <NEWLINE> <INDENT> s += push <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += inp ( s [ 0 ] , l ) <NEWLINE> s = push <NEWLINE> <DEDENT> <DEDENT> if l > 0 : <NEWLINE> <INDENT> ans += <STRING> * l if s [ 0 ] == 0 else ans += inp ( s [ 0 ] , l ) : <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def prime_table ( n ) : <NEWLINE> <INDENT> list = [ True for _ in xrange ( n + 1 ) ] <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if list [ i ] : <NEWLINE> <INDENT> j = i + i <NEWLINE> <DEDENT> while j <= n : <NEWLINE> <INDENT> list [ j ] = False <NEWLINE> j += i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> table = [ i for i in xrange ( n + 1 ) if list [ i ] and i >= 2 ] <NEWLINE> return table <NEWLINE> <NL> <DEDENT> table = prime_table ( 10000 ) <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> l = ( i for i in xrange ( 1 , n + 1 ) ) <NEWLINE> r = ( i for i in xrange ( n , 0 , - 1 ) ) <NEWLINE> ans = 0 <NEWLINE> for j , k in zip ( l , r ) : <NEWLINE> <INDENT> if j in table and k in table : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
r = 10000 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 for i in range ( r ) ] <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i + 1 : : i + 1 ] = [ 0 for j in range ( 2 * i + 1 , r , i + 1 ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] * p [ n - i - 1 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> <COMMENT> <NL> def both_prime ( num ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> M = 10001 <NEWLINE> primes = [ 1 ] * M <NEWLINE> primes [ 0 ] , primes [ 1 ] = 0 , 0 <NEWLINE> for i in range ( 2 , M ) : <NEWLINE> <INDENT> if primes [ i ] : <NEWLINE> <INDENT> j = 2 <NEWLINE> while j * i < M : <NEWLINE> <INDENT> primes [ j * i ] = 0 <NEWLINE> j += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if num % 2 == 0 : <NEWLINE> <INDENT> if primes [ num - 1 ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> elif num == 3 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> c = 0 <COMMENT> <NEWLINE> for i in range ( num / 2 ) : <NEWLINE> <INDENT> if ( i + 1 ) % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if primes [ i + 1 ] and primes [ num - i ] : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c * 2 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> print both_prime ( int ( line . replace ( <STRING> , <STRING> ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> import bisect <NEWLINE> primes = [ 2 ] <NEWLINE> top = 2 <NEWLINE> nlist = [ 2 * x - 1 for x in range ( 2 , 5000 ) ] <NEWLINE> while top < math . sqrt ( 10000 ) : <NEWLINE> <INDENT> top = nlist [ 0 ] <NEWLINE> primes . append ( top ) <NEWLINE> newnlist = [ ] <NEWLINE> for i in nlist : <NEWLINE> <INDENT> if i % top != 0 : <NEWLINE> <INDENT> newnlist . append ( i ) <NEWLINE> <DEDENT> <DEDENT> nlist = newnlist <NEWLINE> <DEDENT> primes = primes + nlist <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n % 2 == 0 : <NEWLINE> <INDENT> if n - 1 in primes : <NEWLINE> <INDENT> print 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = 0 <NEWLINE> center = ( n + 1 ) / 2 <NEWLINE> distc = [ x - center for x in primes ] <NEWLINE> if 0 in distc : <NEWLINE> <INDENT> ans = 1 <NEWLINE> il = bisect . bisect_left ( distc , 0 ) - 1 <NEWLINE> ir = bisect . bisect_left ( distc , 0 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> il = bisect . bisect_left ( distc , 0 ) - 1 <NEWLINE> ir = bisect . bisect_left ( distc , 0 ) <NEWLINE> <DEDENT> while ( il >= 0 and ir < len ( primes ) ) : <NEWLINE> <INDENT> if primes [ ir ] < n + 1 : <NEWLINE> <INDENT> if distc [ il ] + distc [ ir ] == 0 : <NEWLINE> <INDENT> ans = ans + 2 <NEWLINE> il = il - 1 <NEWLINE> ir = ir + 1 <NEWLINE> <DEDENT> elif distc [ il ] + distc [ ir ] < 0 : <NEWLINE> <INDENT> ir = ir + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> il = il - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT> <DEDENT>
M = 1001 ; p = [ 1 ] * M ; <NEWLINE> p [ 0 ] , p [ 1 ] = 0 , 0 <NEWLINE> for i in xrange ( 32 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in xrange ( i * i , M , i ) : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) ; ans = 0 ; <NEWLINE> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> if p [ i ] and p [ n + 1 - i ] : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> r = 9999 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 * r ] <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i + 1 : : i + 1 ] = [ 0 for j in range ( 2 * i + 1 , r , i + 1 ) ] <NEWLINE> <DEDENT> <DEDENT> prime = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> prime . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in prime : <NEWLINE> <INDENT> if i > n - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if p [ n - i - 1 ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def ifprime ( num ) : <NEWLINE> <INDENT> if num == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , math . floor ( num ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if num % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> while ( True ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( 1 , num + 1 ) : <NEWLINE> <INDENT> if ifprime ( i ) and ifprime ( num - i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> s = [ map ( int , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> sh = set ( [ min ( s [ i ] ) for i in range ( n ) ] ) <NEWLINE> tl = set ( [ max ( [ s [ j ] [ i ] for j in range ( n ) ] ) for i in range ( n ) ] ) <NEWLINE> print list ( sh & tl ) [ 0 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> length = n * n + 1 <NEWLINE> columns = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> columns . append ( [ ] ) <NEWLINE> <DEDENT> rows = [ 0 ] * ( length ) <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> row = [ int ( r ) for r in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> rows [ min ( row ) ] = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> columns [ i ] . append ( row [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = 0 <NEWLINE> for c in columns : <NEWLINE> <INDENT> if rows [ max ( c ) ] : <NEWLINE> <INDENT> result = max ( c ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print result <NEWLINE> <DEDENT>
def cv ( t ) : <NEWLINE> <INDENT> return t / 100 * 60 + t % 100 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) ; p = input ( ) ; q = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> v = [ 0 ] * 1440 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> a = input ( ) ; b = input ( ) ; <NEWLINE> for l in range ( cv ( a ) , cv ( b ) ) : <NEWLINE> <INDENT> v [ l ] += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> m = c = 0 <NEWLINE> for i in range ( cv ( p ) , cv ( q ) ) : <NEWLINE> <INDENT> c = c + 1 if v [ i ] < n else 0 <NEWLINE> m = max ( m , c ) <NEWLINE> <DEDENT> print m <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , s , e = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> s = int ( s ) <NEWLINE> e = int ( e ) <NEWLINE> if not n + s + e : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = ( s // 100 ) * 60 + s % 100 <NEWLINE> e = ( e // 100 ) * 60 + e % 100 <NEWLINE> t = [ 0 ] * 60 * 24 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> ss , ee = input ( ) . split ( ) <NEWLINE> ss = int ( ss ) <NEWLINE> ee = int ( ee ) <NEWLINE> t [ ( ss // 100 ) * 60 + ss % 100 ] += 1 <NEWLINE> t [ ( ee // 100 ) * 60 + ee % 100 ] -= 1 <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> ans = 0 <NEWLINE> ma = - 1 <NEWLINE> for i in range ( e ) : <NEWLINE> <INDENT> cnt += t [ i ] <NEWLINE> if i < s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if not cnt : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ma < ans : <NEWLINE> <INDENT> ma = ans <NEWLINE> ans = 0 <NEWLINE> <DEDENT> <DEDENT> if ma < ans : <NEWLINE> <INDENT> ma = ans <NEWLINE> <DEDENT> <DEDENT> print ( ma ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> def convert_time ( n ) : <NEWLINE> <INDENT> return ( n / 100 ) * 60 + n % 100 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def kyotsu ( cm1 , cm2 ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> for i in range ( len ( cm2 ) / 2 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( len ( cm1 ) / 2 ) : <NEWLINE> <INDENT> st = max ( cm2 [ i * 2 ] , cm1 [ j * 2 ] ) <NEWLINE> ed = min ( cm2 [ i * 2 + 1 ] , cm1 [ j * 2 + 1 ] ) <NEWLINE> if ed - st > 0 : <NEWLINE> <INDENT> result . append ( st ) <NEWLINE> result . append ( ed ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> cond = [ int ( r ) for r in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> if cond [ 0 ] == cond [ 1 ] == cond [ 2 ] == 0 : <COMMENT> <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> start = convert_time ( cond [ 1 ] ) <NEWLINE> end = convert_time ( cond [ 2 ] ) <NEWLINE> <NL> cms = [ ] <NEWLINE> <COMMENT> <NL> for i in range ( cond [ 0 ] ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <COMMENT> <NEWLINE> input = [ convert_time ( int ( r ) ) for r in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> j = 0 <NEWLINE> cmstmp = [ ] <NEWLINE> while j < n : <NEWLINE> <INDENT> st = input [ 2 * j ] <NEWLINE> ed = input [ 2 * j + 1 ] <NEWLINE> if not i : <NEWLINE> <INDENT> cms . append ( st ) <NEWLINE> cms . append ( ed ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cmstmp . append ( st ) <NEWLINE> cmstmp . append ( ed ) <NEWLINE> <DEDENT> j += 1 <NEWLINE> <DEDENT> if i > 0 : <NEWLINE> <INDENT> cms = kyotsu ( cms , cmstmp ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> cms = [ start ] + cms + [ end ] <NEWLINE> print max ( [ cms [ i * 2 + 1 ] - cms [ i * 2 ] for i in range ( len ( cms ) / 2 ) ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> A = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> for i in set ( A ) : <NEWLINE> <INDENT> if ( n - A [ : : - 1 ] . index ( i ) - 1 ) - A . index ( i ) + 1 > n / 2 : <NEWLINE> <INDENT> print i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> nums = int ( input ( ) ) <NEWLINE> if nums != 0 : <NEWLINE> <INDENT> stars = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = [ 0 for i in range ( ( 2 ** 31 ) - 1 ) ] <NEWLINE> for x in stars : <NEWLINE> <INDENT> cnt [ x ] += 1 <NEWLINE> <DEDENT> m = max ( cnt ) <NEWLINE> if m > nums / 2 : <NEWLINE> <INDENT> res = cnt . index ( m ) <NEWLINE> print ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : break <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> S = set ( A ) <NEWLINE> for i in S : <NEWLINE> <INDENT> if A . count ( i ) > n / 2 : <NEWLINE> <INDENT> print i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> S = set ( A ) <NEWLINE> for c in S : <NEWLINE> <INDENT> if A . count ( c ) > n / 2 : <NEWLINE> <INDENT> print c <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def subset ( line ) : <NEWLINE> <INDENT> l = line . strip ( ) . split ( <STRING> ) <NEWLINE> a = list ( map ( int , l ) ) <NEWLINE> xy = list ( map ( lambda x : [ x // 10 , x % 10 ] , a ) ) <NEWLINE> dominos = [ [ 1 if x != y and ( [ x , y ] in xy or [ y , x ] in xy ) else 0 for x in range ( 0 , 7 ) ] for y in range ( 0 , 7 ) ] <NEWLINE> digits = [ ] <NEWLINE> for i in xy : <NEWLINE> <INDENT> digits . extend ( i ) <NEWLINE> <DEDENT> digits = list ( set ( digits ) ) <NEWLINE> digits . sort ( ) <NEWLINE> return digits , dominos <NEWLINE> <NL> <DEDENT> def add_matrix ( a , b ) : <NEWLINE> <INDENT> c = [ [ a [ j ] [ i ] + b [ j ] [ i ] for i in range ( 0 , 7 ) ] for j in range ( 0 , 7 ) ] <NEWLINE> return c <NEWLINE> <NL> <DEDENT> def mul_matrix ( a , b ) : <NEWLINE> <INDENT> c = [ [ 0 for i in range ( 0 , 7 ) ] for j in range ( 0 , 7 ) ] <NEWLINE> for j in range ( 0 , 7 ) : <NEWLINE> <INDENT> for i in range ( 0 , 7 ) : <NEWLINE> <INDENT> for k in range ( 0 , 7 ) : <NEWLINE> <INDENT> c [ j ] [ i ] += a [ j ] [ k ] * b [ k ] [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def is_connected ( d , g ) : <NEWLINE> <INDENT> a = g [ : ] <NEWLINE> z = [ [ 0 for i in range ( 0 , 7 ) ] for j in range ( 0 , 7 ) ] <NEWLINE> b = a <NEWLINE> for i in range ( 0 , 7 ) : <NEWLINE> <INDENT> z = add_matrix ( z , b ) <NEWLINE> b = mul_matrix ( b , a ) <NEWLINE> <DEDENT> zeros = 0 <NEWLINE> for i in d : <NEWLINE> <INDENT> if z [ d [ 0 ] ] [ i ] == 0 : <NEWLINE> <INDENT> zeros += 1 <NEWLINE> <DEDENT> <DEDENT> return zeros == 0 <NEWLINE> <NL> <DEDENT> lno = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> lno += 1 <NEWLINE> if lno == 1 : <NEWLINE> <INDENT> n = int ( line ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> digits , dominos = subset ( line ) <NEWLINE> if not is_connected ( digits , dominos ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> order = np . sum ( dominos , axis = 0 ) <NEWLINE> order = order % 2 <NEWLINE> if np . all ( order == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif len ( order [ order == 1 ] ) <= 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> lno = 0 <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> <NL> def suffle ( deck , c ) : <NEWLINE> <INDENT> l = len ( deck ) <NEWLINE> if l % 2 == 0 : mid = l // 2 <NEWLINE> else : mid = ( l - 1 ) // 2 <NEWLINE> deckA = deck [ mid : ] <NEWLINE> deckB = deck [ : mid ] <NEWLINE> deckC = [ ] <NEWLINE> <NL> while ( len ( deckA ) != 0 or len ( deckB ) != 0 ) : <NEWLINE> <INDENT> deckC . extend ( deckA [ : c ] ) <NEWLINE> deckA = deckA [ c : ] <NEWLINE> deckC . extend ( deckB [ : c ] ) <NEWLINE> deckB = deckB [ c : ] <NEWLINE> <NL> <DEDENT> return deckC <NEWLINE> <NL> <DEDENT> while ( True ) : <NEWLINE> <INDENT> deck = [ ] <NEWLINE> n , r = map ( int , sys . stdin . readline ( ) [ : - 1 ] . split ( ) ) <NEWLINE> deck = [ i for i in range ( n ) ] <NEWLINE> c_list = map ( int , sys . stdin . readline ( ) [ : - 1 ] . split ( ) ) <NEWLINE> for c in c_list : <NEWLINE> <INDENT> deck = suffle ( deck , c ) <NEWLINE> <NL> <DEDENT> print ( deck [ - 1 ] ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def solve ( ) : <NEWLINE> <NL> <INDENT> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <NL> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> d [ i ] += d [ i - 1 ] <NEWLINE> <DEDENT> print sum ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> n = raw_input ( ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> if not k : stop <NEWLINE> print sum ( map ( int , raw_input ( ) . split ( ) ) ) / ( k - 1 ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> k = input ( ) - 1 <NEWLINE> if k == 0 : break <NEWLINE> print sum ( map ( int , raw_input ( ) . split ( ) ) ) / k <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> coin = [ 1 , 5 , 10 , 50 , 100 , 500 ] <NEWLINE> <NL> def charge ( remain ) : <NEWLINE> <INDENT> ch = [ 0 ] * 6 <NEWLINE> index = 5 <NEWLINE> while remain > 0 : <NEWLINE> <INDENT> while remain >= coin [ index ] : <NEWLINE> <INDENT> ch [ index ] += 1 <NEWLINE> remain -= coin [ index ] <NEWLINE> <DEDENT> index -= 1 <NEWLINE> <DEDENT> return ch <NEWLINE> <NL> <DEDENT> def total_coins ( n ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> sum += n [ i ] * coin [ i ] <NEWLINE> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> def compute ( p , n ) : <NEWLINE> <INDENT> a = n <NEWLINE> remain = p <NEWLINE> <NL> pay = [ 0 ] * 6 <NEWLINE> index = 5 <NEWLINE> while remain > 0 : <NEWLINE> <INDENT> while remain >= coin [ index ] : <NEWLINE> <INDENT> if a [ index ] > 0 : <NEWLINE> <INDENT> pay [ index ] += 1 <NEWLINE> a [ index ] -= 1 <NEWLINE> remain -= coin [ index ] <NEWLINE> <DEDENT> <DEDENT> index -= 1 <NEWLINE> <DEDENT> ch = charge ( remain ) <NEWLINE> cand = [ sum ( pay ) + sum ( ch ) ] <NEWLINE> <NL> for i in range ( 5 , 0 , - 1 ) : <NEWLINE> <INDENT> b = a <NEWLINE> pay2 = pay <NEWLINE> if b [ i ] > 0 : <NEWLINE> <INDENT> pay2 [ i ] += 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> pay2 [ j ] = 0 <NEWLINE> <DEDENT> total = total_coins ( pay2 ) <NEWLINE> ch = charge ( total - p ) <NEWLINE> cand . append ( sum ( pay2 ) + sum ( ch ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return min ( cand ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for input in sys . stdin : <NEWLINE> <INDENT> input = map ( int , input . split ( ) ) <NEWLINE> p , n = input [ 0 ] , input [ 1 : ] <NEWLINE> if p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print compute ( p , n ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( sum ( [ int ( input ( ) ) for _ in range ( n ) ] ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> print ans ( input ( ) for i in range ( n / 4 ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ ] <NEWLINE> for i in range ( n / 4 ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) <NEWLINE> <DEDENT> print sum ( a ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> a = map ( str , raw_input ( ) . replace ( <STRING> , <STRING> ) . split ( ) ) <NEWLINE> if a == [ <STRING> ] : break <NEWLINE> print <STRING> . join ( map ( str , [ len ( a [ i ] ) for i in range ( len ( a ) ) ] ) ) <NEWLINE> <DEDENT>
upp = <STRING> <NEWLINE> low = <STRING> <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> a , type = raw_input ( ) . split ( ) <NEWLINE> if type == <STRING> : break <NEWLINE> ans = <STRING> <NEWLINE> if type == <STRING> : <NEWLINE> <INDENT> if <STRING> in a : <NEWLINE> <INDENT> words = a . split ( <STRING> ) <NEWLINE> for word in words : <NEWLINE> <INDENT> ans += upp [ low . index ( word [ 0 ] ) ] + word [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = upp [ low . index ( a [ 0 ] ) ] + a [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> elif type == <STRING> : <NEWLINE> <INDENT> if <STRING> in a : <NEWLINE> <INDENT> words = a . split ( <STRING> ) <NEWLINE> ans += words [ 0 ] <NEWLINE> for word in words [ 1 : ] : <NEWLINE> <INDENT> ans += upp [ low . index ( word [ 0 ] ) ] + word [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans = low [ upp . index ( a [ 0 ] ) ] + a [ 1 : ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> words = [ ] <NEWLINE> sp = 0 <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] in upp : <NEWLINE> <INDENT> words . append ( a [ sp : i ] . lower ( ) ) <NEWLINE> sp = i <NEWLINE> <DEDENT> <DEDENT> words . append ( a [ sp : ] . lower ( ) ) <NEWLINE> ans = <STRING> . join ( words ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> name , typ = raw_input ( ) . split ( ) <NEWLINE> if name == <STRING> and typ == <STRING> : break <NEWLINE> L = [ ] <NEWLINE> if <STRING> in name : <NEWLINE> <INDENT> L = name . split ( <STRING> ) <NEWLINE> <DEDENT> elif name [ 0 ] . islower ( ) : <NEWLINE> <INDENT> temp = <STRING> <NEWLINE> for ch in name : <NEWLINE> <INDENT> if ch . islower ( ) : <NEWLINE> <INDENT> temp += ch <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( temp ) <NEWLINE> temp = <STRING> <NEWLINE> temp += ch <NEWLINE> <DEDENT> <DEDENT> L . append ( temp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> temp = name [ 0 ] <NEWLINE> for ch in name [ 1 : ] : <NEWLINE> <INDENT> if ch . islower ( ) : <NEWLINE> <INDENT> temp += ch <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L . append ( temp ) <NEWLINE> temp = <STRING> <NEWLINE> temp += ch <NEWLINE> <DEDENT> <DEDENT> L . append ( temp ) <NEWLINE> <NL> <DEDENT> if typ == <STRING> : <NEWLINE> <INDENT> print <STRING> . join ( map ( lambda s : s . lower ( ) , L ) ) <NEWLINE> <DEDENT> elif typ == <STRING> : <NEWLINE> <INDENT> print <STRING> . join ( map ( lambda s : s . capitalize ( ) , L ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print L [ 1 ] + <STRING> . join ( map ( lambda s : s . capitalize ( ) , L [ 1 : ] ) ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( a , i , sa , sb ) : <NEWLINE> <INDENT> if 2 * sa >= all : return 2 * sa - all <NEWLINE> if 2 * sb >= all : return 2 * sb - all <NEWLINE> return min ( solve ( a , i + 1 , sa + a [ i ] , sb ) , solve ( a , i + 1 , sa , sb + a [ i ] ) ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> a = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> all = sum ( a ) <NEWLINE> print solve ( a , 0 , a [ 0 ] , 0 ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sm = sum ( s ) <NEWLINE> dp = [ 0 ] * ( sm + 1 ) <NEWLINE> ref = { i : [ i ] for i in s } <NEWLINE> for i in s : <NEWLINE> <INDENT> dp [ i ] = i <NEWLINE> <DEDENT> for i in s : <NEWLINE> <INDENT> for j in range ( sm + 1 ) : <NEWLINE> <INDENT> if dp [ j ] > 0 and j not in ref [ i ] : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dp [ j + i ] = dp [ j ] + i <NEWLINE> ref [ i ] . append ( j + i ) <NEWLINE> <DEDENT> except : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print min ( [ abs ( sm - 2 * dp [ i ] ) for i in range ( sm ) ] ) <NEWLINE> <DEDENT>
def S ( i , x , y ) : <NEWLINE> <INDENT> for w in [ x , y ] <NEWLINE> <INDENT> if 2 * w >= A : return 2 * w - A <NEWLINE> <DEDENT> return min ( S ( i + 1 , x + a [ i ] , y ) , S ( i + 1 , x , y + a [ i ] ) ) <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> a = sorted ( map ( int , raw_input ( ) . split ( ) ) ) [ : : - 1 ] <NEWLINE> A = sum ( a ) <NEWLINE> print S ( 1 , a [ 0 ] , 0 ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ref = [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> ref += [ i + j for j in ref if j < ans / 2 ] <NEWLINE> <DEDENT> print min ( abs ( sum ( a ) - 2 * i ) for i in ref ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> p = raw_input ( ) . split ( ) + [ <STRING> ] <NEWLINE> sp = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if str ( int ( p [ i ] ) + 1 ) != p [ i + 1 ] : <NEWLINE> <INDENT> print sp + <STRING> + p [ i ] , if sp != p [ i ] else sp , <NEWLINE> sp = p [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> p = raw_input ( ) . split ( ) + [ <STRING> ] <NEWLINE> sp = p [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if str ( int ( p [ i ] ) + 1 ) != p [ i + 1 ] : <NEWLINE> <INDENT> if sp != p [ i ] : <NEWLINE> <INDENT> print sp + <STRING> + p [ i ] , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print sp , <NEWLINE> <DEDENT> sp = p [ i + 1 ] <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> p = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = p [ 0 ] ; s = <STRING> ; <NEWLINE> for i in xrange ( 1 , n ) : <NEWLINE> <INDENT> if p [ i ] != p [ i - 1 ] + 1 : <NEWLINE> <INDENT> s += <STRING> % ( a , p [ i - 1 ] ) if a != p [ i - 1 ] else <STRING> + str ( a ) <NEWLINE> a = p [ i ] <NEWLINE> <DEDENT> <DEDENT> s += <STRING> % ( a , p [ n - 1 ] ) if a != p [ n - 1 ] else <STRING> + str ( a ) <NEWLINE> print s [ 1 : ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> island = [ ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> g , b = map ( int , input ( ) . split ( ) ) <NEWLINE> island . append ( ( g , b , b - g ) ) <NEWLINE> <DEDENT> sorted ( island , key = lambda x : ( x [ 2 ] , [ 0 ] , [ 1 ] ) ) <NEWLINE> <NL> gem = 0 <NEWLINE> for g , b , c in island : <NEWLINE> <INDENT> gem += g <NEWLINE> if b < gem : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> bridge = [ 0 for i in range ( n ) ] <NEWLINE> gold = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> gold [ i ] , bridge [ i ] = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT> dp = { 0 : 0 } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp_dp = dict ( ) <NEWLINE> for k , v in dp . iteritems ( ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> bit = 1 << j <NEWLINE> if ( k & bit != 0 ) or ( k | bit in tmp_dp ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if v + gold [ j ] <= bridge [ j ] : <NEWLINE> <INDENT> tmp_dp [ k | bit ] = v + gold [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp = tmp_dp <NEWLINE> <DEDENT> print <STRING> if ( 2 ** n - 1 ) in dp else <STRING> <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> def dijkstra ( ) : <NEWLINE> <INDENT> que = [ ] <NEWLINE> dist = { } <NEWLINE> heappush ( que , ( 0 , 0 ) ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> co , state = heappop ( que ) <NEWLINE> if dist [ state ] < co : continue <NEWLINE> if state == goal : return 1 <NEWLINE> for i , e in enumerate ( D ) : <NEWLINE> <INDENT> if state & ( 1 << i ) == 0 and co + e [ 0 ] <= e [ 1 ] : <NEWLINE> <INDENT> n_state = state | ( 1 << i ) <NEWLINE> if n_state not in dist : <NEWLINE> <INDENT> heappush ( que , ( co + e [ 0 ] , n_state ) ) <NEWLINE> dist [ n_state ] = co + e [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> D = [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( n ) ] <NEWLINE> su = sum ( e [ 0 ] for e in D ) <NEWLINE> goal = 2 ** n - 1 <NEWLINE> print <STRING> * dijkstra ( ) or <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> count_shima = input ( ) <NEWLINE> if count_shima == 0 : break <NEWLINE> <NL> A = [ list ( map ( int , raw_input ( ) . split ( ) ) ) for i in xrange ( count_shima ) ] <NEWLINE> <NL> A . sort ( ) <NEWLINE> <NL> weight = 0 <NEWLINE> frg = 0 <NEWLINE> for takara , turi in A : <NEWLINE> <INDENT> weight += takara <NEWLINE> if turi < weight : <NEWLINE> <INDENT> print <STRING> <NEWLINE> frg = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if frg == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
dp = [ .0 ] * 100001 <NEWLINE> dp [ 1 ] = 1. <NEWLINE> for i in range ( 2 , 100001 ) : <NEWLINE> <INDENT> a , b , j = .5 , 1 , 1 <NEWLINE> while j < i and b > 1e-5 : <NEWLINE> <INDENT> dp [ i ] += b * ( 1 - a ) * ( j + dp [ i - j - 1 ] ) <NEWLINE> b *= al ; a /= 2 ; j += 1 <NEWLINE> <DEDENT> dp [ i ] += i * b <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( dp [ n ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> import sys <NEWLINE> <INDENT> dp = [ 0.0 ] * 100001 <NEWLINE> dp [ 1 ] = 1.0 <NEWLINE> for i in xrange ( 2 , 100001 ) : <NEWLINE> <INDENT> p = 1.0 <NEWLINE> w = 0.5 <NEWLINE> for j in xrange ( 1 , i ) : <NEWLINE> <INDENT> if p < 1e-13 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp [ i ] += ( p * ( 1 - w ) ) * ( j + dp [ max ( 0 , i - j - 1 ) ] ) <NEWLINE> p *= w <NEWLINE> w *= 0.5 <NEWLINE> <DEDENT> dp [ i ] += i * p <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> print <STRING> % dp [ N ] <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> r , c = input ( ) <NEWLINE> if not r : break <NEWLINE> print <STRING> if not r * c % 2 else <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> player_nun = int ( input ( ) ) <NEWLINE> player_nun = 4 <NEWLINE> if player_nun == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> whole_data = [ ] <NEWLINE> for i in range ( 0 , player_nun ) : <NEWLINE> <INDENT> dat = input ( ) . split ( ) <NEWLINE> p_data = [ ] <NEWLINE> p_data . append ( dat [ 0 ] ) <NEWLINE> for x in dat [ 1 : ] : <NEWLINE> <INDENT> p_data . append ( int ( x ) ) <NEWLINE> <DEDENT> whole_data . append ( p_data ) <NEWLINE> <NL> <DEDENT> print ( whole_data ) <NEWLINE> <COMMENT> <NL> xel = { } <NEWLINE> for i in whole_data : <NEWLINE> <INDENT> for x in i [ 2 : ] : <NEWLINE> <INDENT> if x in xel : <NEWLINE> <INDENT> xel [ x ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> xel [ x ] = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> score = { } <NEWLINE> for y in xel . keys ( ) : <NEWLINE> <INDENT> score [ y ] = 5 - xel [ y ] <NEWLINE> <COMMENT> <NL> <DEDENT> result = [ ] <NEWLINE> for i in whole_data : <NEWLINE> <INDENT> player_score = [ ] <NEWLINE> player_score . append ( i [ 0 ] ) <NEWLINE> player_score . append ( 0 ) <NEWLINE> for x in i [ 2 : ] : <NEWLINE> <INDENT> player_score [ 1 ] += score [ x ] <NEWLINE> <DEDENT> result . append ( player_score ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> min_score = min ( x [ 1 ] for x in result ) <NEWLINE> winners = [ ] <NEWLINE> for x in result : <NEWLINE> <INDENT> if x [ 1 ] == min_score : <NEWLINE> <INDENT> winners . append ( x [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( str ( min_score ) + <STRING> + sorted ( winners ) [ 0 ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> flag = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if int ( input ( ) ) == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( n / 2 if flag else 0 ) ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> def prdct ( array ) : <NEWLINE> <INDENT> ref = 1 <NEWLINE> for a in array : ref *= a <NEWLINE> return ref <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> p = sorted ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> if 1 in p : <NEWLINE> <INDENT> print 0.0 <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( len ( p ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <INDENT> if p [ i ] == p [ j ] : <NEWLINE> <INDENT> del p [ i ] <NEWLINE> break <NEWLINE> <DEDENT> elif p [ i ] % p [ j ] == 0 : <NEWLINE> <INDENT> p [ i ] /= p [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> d = sum ( pi * ( n / pi * ( n / pi + 1 ) ) / 2 for pi in p ) <NEWLINE> m = sum ( n / pi for pi in p ) <NEWLINE> q = [ ] <NEWLINE> for i in range ( 2 , len ( p ) + 1 ) : <NEWLINE> <INDENT> q += [ prdct ( element ) for element in itertools . combinations ( p , i ) ] <NEWLINE> <DEDENT> d -= sum ( qi * ( n / qi * ( n / qi + 1 ) ) / 2 for qi in q ) <NEWLINE> m -= sum ( n / qi for qi in q ) <NEWLINE> print ( n * ( n + 1 ) / 2 - d ) * 1.0 / ( n - m ) if n - m > 0 else 0.0 <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if sum ( N ) == 0 : break <NEWLINE> md , gg , go = N [ 0 ] + N [ 3 ] , N [ 1 ] + N [ 4 ] , N [ 2 ] + N [ 5 ] <NEWLINE> mn = min ( md , gg , go ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( max ( 0 , w - 2 ) , w ) : <NEWLINE> <INDENT> ans = max ( ans , i + ( md - i ) / 3 + ( gg - i ) / 3 + ( go - i ) / 3 ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
def judge ( exp , torf , i ) : <NEWLINE> <INDENT> if i == len ( dic ) : <NEWLINE> <INDENT> return eval ( exp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return judge ( exp , torf + [ True ] , i + 1 ) or judge ( exp , torf + [ False ] , i + 1 ) <NEWLINE> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> exp = list ( raw_input ( ) ) <NEWLINE> if exp [ 0 ] == <STRING> : break <NEWLINE> dic = [ ] <NEWLINE> for i in range ( len ( exp ) ) : <NEWLINE> <INDENT> if exp [ i ] == <STRING> : exp [ i ] = <STRING> <NEWLINE> elif exp [ i ] == <STRING> : exp [ i ] = <STRING> <NEWLINE> elif exp [ i ] == <STRING> : exp [ i ] = <STRING> <NEWLINE> elif exp [ i ] != <STRING> and exp [ i ] != <STRING> : <NEWLINE> <INDENT> if exp [ i ] not in dic : <NEWLINE> <INDENT> dic . append ( exp [ i ] ) <NEWLINE> exp [ i ] = <STRING> + str ( len ( dic ) - 1 ) + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exp [ i ] = <STRING> + str ( dic . index ( exp [ i ] ) ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> exp = <STRING> . join ( map ( str , exp ) ) <NEWLINE> print <STRING> if judge ( exp , [ ] , 0 ) else <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> r , c , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r == 0 : break <NEWLINE> R = [ [ 0 , 0 ] for i in range ( r ) ] <NEWLINE> C = [ [ 0 , 0 ] for i in range ( c ) ] <NEWLINE> for i in range ( 1 , q + 1 ) : <NEWLINE> <INDENT> A , B , order = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if A == 0 : <NEWLINE> <INDENT> R [ B ] = [ i , order ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ B ] = [ i , order ] <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for ri in range ( r ) : <NEWLINE> <INDENT> ans += sum ( R [ ri ] [ 1 ] if R [ ri ] [ 0 ] > C [ ci ] [ 0 ] else C [ ci ] [ 1 ] for ci in range ( c ) ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> r = sorted ( [ int ( raw_input ( ) ) for i in range ( n ) ] , reverse = True ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if r [ i ] >= S : <NEWLINE> <INDENT> c += n - i - 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif r [ i ] < S / 2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if r [ i ] + r [ j ] > S : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print c <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and S == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r = [ input ( ) for i in range ( n ) ] <NEWLINE> ans = 0 <NEWLINE> r . sort ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = S - r [ i ] + 1 <NEWLINE> if ( tmp <= 0 ) : <NEWLINE> <INDENT> ans += n - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = r [ 0 : i ] + r [ i + 1 : ] <NEWLINE> left , right = 0 , n - 1 <NEWLINE> while ( right - left > 1 ) : <NEWLINE> <INDENT> med = ( right + left ) / 2 <NEWLINE> if ( d [ med ] <= tmp ) : <NEWLINE> <INDENT> left = med <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = med <NEWLINE> <DEDENT> <DEDENT> ans += ( len ( d ) - left ) - 1 <NEWLINE> <DEDENT> <DEDENT> print ans / 2 <NEWLINE> <DEDENT>
R = 101 <NEWLINE> while 1 : <NEWLINE> <INDENT> n , S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> r = [ 0 ] * R <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> r [ int ( raw_input ( ) ) ] += 1 <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( R ) : <NEWLINE> <INDENT> if 2 * i > S : <NEWLINE> <INDENT> ans += r [ i ] * ( r [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> ans += r [ i ] * sum ( [ r [ j ] for j in range ( max ( i + 1 , S - j + 1 ) , R ) ] ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
R = 101 <NEWLINE> while 1 : <NEWLINE> <INDENT> n , S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> d = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> r = [ d . count ( i ) for i in set ( d ) ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( R ) : <NEWLINE> <INDENT> if 2 * i > S : <NEWLINE> <INDENT> ans += r [ i ] * ( r [ i ] - 1 ) / 2 <NEWLINE> <DEDENT> ans += r [ i ] * sum ( [ r [ j ] for j in range ( max ( i + 1 , S - i + 1 ) , R ) ] ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> c += 1 <NEWLINE> x0 , y0 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> prev_x , prev_y = x0 , y0 <NEWLINE> tmp = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> tmp += prev_x * y - prev_y * x <NEWLINE> prev_x , prev_y = x , y <NEWLINE> <DEDENT> tmp += prev_x * y0 - prev_y * x0 <NEWLINE> print c , 0.5 * abs ( tmp ) <NEWLINE> skip = input ( ) <NEWLINE> <NL> <DEDENT>
def convex ( Pset ) : <NEWLINE> <INDENT> v1 = [ Pset [ 1 ] [ 0 ] - Pset [ 0 ] [ 0 ] , Pset [ 1 ] [ 1 ] - Pset [ 0 ] [ 1 ] ] <NEWLINE> v2 = [ Pset [ 2 ] [ 0 ] - Pset [ 1 ] [ 0 ] , Pset [ 2 ] [ 1 ] - Pset [ 1 ] [ 1 ] ] <NEWLINE> v3 = [ Pset [ 2 ] [ 0 ] - Pset [ 0 ] [ 0 ] , Pset [ 2 ] [ 1 ] - Pset [ 0 ] [ 1 ] ] <NEWLINE> c = v1 [ 0 ] * v2 [ 1 ] - v1 [ 1 ] * v2 [ 0 ] <NEWLINE> return c <= 0 <NEWLINE> <NL> <DEDENT> def area ( Pset ) : <NEWLINE> <INDENT> v1 = [ Pset [ 1 ] [ 0 ] - Pset [ 0 ] [ 0 ] , Pset [ 1 ] [ 1 ] - Pset [ 0 ] [ 1 ] ] <NEWLINE> v2 = [ Pset [ 2 ] [ 0 ] - Pset [ 1 ] [ 0 ] , Pset [ 2 ] [ 1 ] - Pset [ 1 ] [ 1 ] ] <NEWLINE> v3 = [ Pset [ 2 ] [ 0 ] - Pset [ 0 ] [ 0 ] , Pset [ 2 ] [ 1 ] - Pset [ 0 ] [ 1 ] ] <NEWLINE> return abs ( v1 [ 0 ] * v3 [ 1 ] - v1 [ 1 ] * v3 [ 0 ] ) / 2. <NEWLINE> <NL> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> P = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> P . append ( [ int ( x ) for x in raw_input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> while ( len ( P ) >= 3 ) : <NEWLINE> <INDENT> for i in range ( len ( P ) - 2 ) : <NEWLINE> <INDENT> Pset = P [ i : i + 3 ] <NEWLINE> if convex ( Pset ) : <NEWLINE> <INDENT> ans += area ( Pset ) <NEWLINE> del P [ i + 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> raw_input ( ) <NEWLINE> <DEDENT>
def getlcm ( a , b ) : <NEWLINE> <INDENT> aa = a <NEWLINE> bb = b <NEWLINE> while aa != 0 : <NEWLINE> <INDENT> [ aa , bb ] = [ bb % aa , aa ] <NEWLINE> <DEDENT> return a * b / bb <NEWLINE> <NL> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> [ n , a , b ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> [ a , b ] = [ min ( a , b ) , max ( a , b ) ] <NEWLINE> LCM = getlcm ( a , b ) <NEWLINE> able = [ ] <NEWLINE> for i in range ( LCM / a ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if a * i + b * j >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> able . append ( a * i + b * j ) <NEWLINE> <DEDENT> <DEDENT> ans = n - len ( able ) <NEWLINE> print ans <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> dp = [ 0 ] * ( n + 1 ) <NEWLINE> dp [ a ] = dp [ b ] = 1 <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] == 1 : <NEWLINE> <INDENT> if i + a < n + 1 : dp [ i + a ] = 1 <NEWLINE> if i + b < n + 1 : dp [ i + b ] = 1 <NEWLINE> <DEDENT> <DEDENT> print n - sum ( dp ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == a == b == 0 : break <NEWLINE> count = n <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> x = i <NEWLINE> while x >= 0 : <NEWLINE> <INDENT> if x % a == 0 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> break <NEWLINE> <DEDENT> x -= b <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> dp = [ 0 ] * ( max ( n , a , b ) + 1 ) <NEWLINE> dp [ a ] = dp [ b ] = 1 <NEWLINE> for i in range ( n + 1 - min ( a , b ) ) : <NEWLINE> <INDENT> if dp [ i ] : <NEWLINE> <INDENT> dp [ i + a ] = dp [ i + b ] = 1 <NEWLINE> <DEDENT> <DEDENT> print n - sum ( dp [ : n + 1 ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> z = input ( ) <NEWLINE> if z == 0 : break <NEWLINE> z3 = pow ( z , 3 ) <NEWLINE> maxInt = 0 <NEWLINE> for x in range ( 1 , z ) : <NEWLINE> <INDENT> x3 = pow ( x , 3 ) <NEWLINE> for y in range ( 1 , z ) : <NEWLINE> <INDENT> y3 = pow ( y , 3 ) <NEWLINE> if x3 + y3 <= z3 : <NEWLINE> <INDENT> maxInt = max ( maxInt , x3 + y3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print z3 - maxInt <NEWLINE> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> z = int ( raw_input ( ) ) <NEWLINE> if z == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> k = 0 <NEWLINE> for x in range ( 1 , z + 1 ) : <NEWLINE> <INDENT> for y in range ( 1 , z + 1 ) : <NEWLINE> <INDENT> if x ** 3 + y ** 3 > z ** 3 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k = max ( k , x ** 3 + y ** 3 ) <NEWLINE> <DEDENT> <DEDENT> print z ** 3 - k <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> z3 = m = input ( ) ** 3 <NEWLINE> if z3 == 0 : break <NEWLINE> x = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> x += 1 <NEWLINE> x3 = x ** 3 <NEWLINE> y = int ( ( n3 - i3 ) ** ( 1 / 3. ) ) <NEWLINE> if y < x : break <NEWLINE> n = z3 - x3 - y ** 3 <NEWLINE> if n < m : m = n <NEWLINE> <DEDENT> print m <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> n3 = n ** 3 <NEWLINE> if n == 0 : break <NEWLINE> mn = n3 <NEWLINE> i = j = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> i += 1 <NEWLINE> j = i <NEWLINE> i3 = i ** 3 <NEWLINE> if n3 - i3 - j ** 3 < 0 : break <NEWLINE> while 1 : <NEWLINE> <INDENT> j += 1 <NEWLINE> m = n3 - i3 - j ** 3 <NEWLINE> if m < 0 : break <NEWLINE> if m < mn : mn = m <NEWLINE> <DEDENT> <DEDENT> print mn <NEWLINE> <DEDENT>
import re <NEWLINE> while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> P = [ ] ; D = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , s , d = raw_input ( ) . replace ( <STRING> , <STRING> ) . split ( ) <NEWLINE> r = re . compile ( s + d ) <NEWLINE> if p [ 0 ] == <STRING> : <NEWLINE> <INDENT> P . append ( r ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( r ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> s , d , name = raw_input ( ) . split ( ) <NEWLINE> tf = any ( r . search ( s + d ) for r in P ) and not any ( r . search ( s + d ) for r in D ) <NEWLINE> if tf : <NEWLINE> <INDENT> print s , d , name <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
answers = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( N , M ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rules = [ ] <NEWLINE> for _ in xrange ( N ) : <NEWLINE> <INDENT> f , p1 , p2 = raw_input ( ) . split ( ) <NEWLINE> rules += [ ( f , p1 + p2 ) ] <NEWLINE> <DEDENT> rules = rules [ : : - 1 ] <NEWLINE> def check ( s ) : <NEWLINE> <INDENT> def match ( pattern , address ) : <NEWLINE> <INDENT> for p , a in zip ( pattern , address ) : <NEWLINE> <INDENT> if p == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if p != a : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> a1 , a2 , _ = s . split ( ) <NEWLINE> for flag , pattern in rules : <NEWLINE> <INDENT> if flag == <STRING> and match ( pattern , a1 + a2 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if flag == <STRING> and match ( pattern , a1 + a2 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = filter ( check , [ raw_input ( ) for _ in xrange ( M ) ] ) <NEWLINE> answers += str ( len ( ans ) ) + <STRING> <NEWLINE> answers += <STRING> . join ( ans ) + <STRING> <NEWLINE> <DEDENT> print answers . strip ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> line = raw_input ( ) . split ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N = int ( line [ 0 ] ) <NEWLINE> s = line [ 1 : ] <NEWLINE> while len ( s ) < N : <NEWLINE> <INDENT> s += raw_input ( ) . split ( ) <NEWLINE> <DEDENT> original = make_graph ( s ) <NEWLINE> line = raw_input ( ) . split ( ) <NEWLINE> M = int ( line [ 0 ] ) <NEWLINE> t = line [ 1 : ] <NEWLINE> while len ( t ) < M : <NEWLINE> <INDENT> t += raw_input ( ) . split ( ) <NEWLINE> <DEDENT> for k in rotate_all_iter ( make_graph ( t ) ) : <NEWLINE> <INDENT> if check ( original , k ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def check ( key1 , key2 ) : <NEWLINE> <INDENT> def dfs ( n1 , n2 ) : <NEWLINE> <INDENT> f1 = n1 in used1 <NEWLINE> f2 = n2 in used2 <NEWLINE> if f1 != f2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if f1 == f2 == True : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> used1 [ n1 ] = used2 [ n2 ] = True <NEWLINE> for k in n1 . edges . keys ( ) : <NEWLINE> <INDENT> if n1 . edges [ k ] is None : <NEWLINE> <INDENT> if n2 . edges [ k ] is not None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> elif n2 . edges [ k ] is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif not dfs ( n1 . edges [ k ] , n2 . edges [ k ] ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> for n in key2 : <NEWLINE> <INDENT> used1 = { } <NEWLINE> used2 = { } <NEWLINE> if dfs ( key1 [ 0 ] , n ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def make_graph ( seq ) : <NEWLINE> <INDENT> D = { <STRING> : ( 1 , 0 , 0 ) , <STRING> : ( - 1 , 0 , 0 ) , <NEWLINE> <INDENT> <STRING> : ( 0 , 1 , 0 ) , <STRING> : ( 0 , - 1 , 0 ) , <NEWLINE> <STRING> : ( 0 , 0 , 1 ) , <STRING> : ( 0 , 0 , - 1 ) , } <NEWLINE> <DEDENT> R = { <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <STRING> : <STRING> , <STRING> : <STRING> , } <NEWLINE> <DEDENT> labels = { } <NEWLINE> pre = Node ( [ 0 , 0 , 0 ] ) <NEWLINE> nodes = { pre : pre } <NEWLINE> for s in seq : <NEWLINE> <INDENT> if s . isdigit ( ) : <NEWLINE> <INDENT> if s in labels : <NEWLINE> <INDENT> pre = labels [ s ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> labels [ s ] = pre <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> n = Node ( [ pre [ i ] + D [ s ] [ i ] for i in xrange ( 3 ) ] ) <NEWLINE> if n in nodes : <NEWLINE> <INDENT> n = nodes [ n ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nodes [ n ] = n <NEWLINE> <DEDENT> pre . add_edge ( s , n ) <NEWLINE> n . add_edge ( R [ s ] , pre ) <NEWLINE> pre = n <NEWLINE> <DEDENT> <DEDENT> return Node . traverse ( pre ) <NEWLINE> <NL> <DEDENT> def rotate_all_iter ( nodes ) : <NEWLINE> <INDENT> schedule = ( Node . roll_x , Node . roll_x , Node . roll_x , Node . roll_x , <NEWLINE> <INDENT> Node . roll_y , Node . roll_z , Node . roll_z , Node . roll_z , Node . roll_z , <NEWLINE> Node . roll_y , Node . roll_z , Node . roll_z , Node . roll_z , Node . roll_z , <NEWLINE> Node . roll_y , Node . roll_z , Node . roll_z , Node . roll_z , Node . roll_z , <NEWLINE> Node . roll_x , Node . roll_y , Node . roll_y , Node . roll_y , Node . roll_y , <NEWLINE> Node . roll_x , Node . roll_y , Node . roll_y , Node . roll_y , Node . roll_y , <NEWLINE> Node . roll_x , Node . roll_y , Node . roll_y , Node . roll_y , Node . roll_y , ) <NEWLINE> <DEDENT> for f in schedule : <NEWLINE> <INDENT> f ( nodes [ 0 ] ) <NEWLINE> yield nodes <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( tuple ) : <NEWLINE> <INDENT> def __init__ ( self , li ) : <NEWLINE> <INDENT> if len ( li ) != 3 : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> tuple . __init__ ( self , li ) <NEWLINE> self . edges = dict ( ( k , None ) for k in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> <NL> <DEDENT> def add_edge ( self , edge , node ) : <NEWLINE> <INDENT> if not edge in self . edges : <NEWLINE> <INDENT> raise ValueError <NEWLINE> <DEDENT> self . edges [ edge ] = node <NEWLINE> <NL> <DEDENT> @ classmethod <NEWLINE> def roll_x ( cls , node , memo = [ ] ) : <NEWLINE> <INDENT> if node in memo : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] = node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] <NEWLINE> for n in node . edges . values ( ) : <NEWLINE> <INDENT> if n is not None : <NEWLINE> <INDENT> cls . roll_x ( n , memo + [ node ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def roll_y ( cls , node , memo = [ ] ) : <NEWLINE> <INDENT> if node in memo : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] = node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] <NEWLINE> for n in node . edges . values ( ) : <NEWLINE> <INDENT> if n is not None : <NEWLINE> <INDENT> cls . roll_y ( n , memo + [ node ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def roll_z ( cls , node , memo = [ ] ) : <NEWLINE> <INDENT> if node in memo : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] = node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] , node . edges [ <STRING> ] <NEWLINE> for n in node . edges . values ( ) : <NEWLINE> <INDENT> if n is not None : <NEWLINE> <INDENT> cls . roll_z ( n , memo + [ node ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> @ classmethod <NEWLINE> def traverse ( cls , node , memo = [ ] ) : <NEWLINE> <INDENT> if node in memo : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> ret = [ node ] <NEWLINE> for n in node . edges . values ( ) : <NEWLINE> <INDENT> if n is not None : <NEWLINE> <INDENT> ret += cls . traverse ( n , memo + [ node ] ) <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from copy import deepcopy <NEWLINE> answer = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> while line . isspace ( ) or not line : <COMMENT> <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> <DEDENT> if line == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> P , S = map ( int , line . split ( ) ) <NEWLINE> def check ( data ) : <NEWLINE> <INDENT> return reduce ( lambda a , b : a + b , data ) . count ( <STRING> ) <NEWLINE> <DEDENT> def calc ( seq ) : <NEWLINE> <INDENT> if <STRING> not in seq or not ( 0 <= seq . count ( <STRING> ) <= 1 ) : <NEWLINE> <INDENT> return seq <NEWLINE> <DEDENT> if seq [ - 1 ] == <STRING> : <NEWLINE> <INDENT> return seq [ : - 1 ] + sum ( seq [ : - 1 ] ) <NEWLINE> <DEDENT> a = seq [ - 1 ] - sum ( s for s in seq [ : - 1 ] if s != <STRING> ) <NEWLINE> return [ s if s != <STRING> else a for s in seq ] <NEWLINE> <DEDENT> def update ( data ) : <NEWLINE> <INDENT> data = deepcopy ( data ) <NEWLINE> t_data = zip ( * data ) <NEWLINE> for i in xrange ( P ) : <NEWLINE> <INDENT> for j , d in enumerate ( calc ( data [ i ] ) ) : <NEWLINE> <INDENT> data [ i ] [ j ] = d <NEWLINE> <DEDENT> for j , d in enumerate ( calc ( t_data [ i ] ) ) : <NEWLINE> <INDENT> data [ j ] [ i ] = d <NEWLINE> <DEDENT> <DEDENT> return data <NEWLINE> <DEDENT> data = [ map ( lambda x : int ( x ) if x . isdigit ( ) else x , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> for _ in xrange ( P + 1 ) ] <NEWLINE> <DEDENT> cdata = deepcopy ( data ) <NEWLINE> for _ in xrange ( check ( cdata ) ) : <NEWLINE> <INDENT> cdata = update ( cdata ) <NEWLINE> <DEDENT> ans = <STRING> <NEWLINE> if check ( cdata ) == 0 : <NEWLINE> <INDENT> for d in zip ( data , cdata ) : <NEWLINE> <INDENT> for e1 , e2 in zip ( * d ) : <NEWLINE> <INDENT> if e1 == <STRING> : <NEWLINE> <INDENT> ans += <STRING> . format ( e2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> answer += ans + <STRING> <NEWLINE> <DEDENT> print answer . strip ( <STRING> ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , Q = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> counter = collections . Counter ( ) <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> date = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> if date [ 0 ] != 0 : <NEWLINE> <INDENT> counter . update ( date [ 1 : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> result = counter . most_common ( ) <NEWLINE> largest = result [ 0 ] [ 1 ] <NEWLINE> <NL> ret = - 1 <NEWLINE> if largest < Q : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> smallest = 100 <NEWLINE> for n , c in result : <NEWLINE> <INDENT> if c < largest : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if n < smallest : <NEWLINE> <INDENT> smallest = n <NEWLINE> <DEDENT> <DEDENT> print smallest <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> N , Q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == Q == 0 : break <NEWLINE> T = [ 0 ] * 51 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> L = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in L [ 1 : ] : <NEWLINE> <INDENT> T [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> m = max ( T ) <NEWLINE> print 0 if m < Q else T . index ( m ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> N , Q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if N == 0 and Q == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> t = [ map ( int , raw_input ( ) . split ( ) ) [ 1 : ] for _ in range ( N ) ] <NEWLINE> table = [ [ i , 0 ] for i in range ( 10 ) ] <NEWLINE> <NL> for i in t : <NEWLINE> <INDENT> for j in i : <NEWLINE> <INDENT> table [ j ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> table . sort ( reverse = True , key = lambda x : x [ 1 ] ) <NEWLINE> <NL> print table [ 0 ] [ 0 ] if table [ 0 ] [ 1 ] >= Q else 0 <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> N = int ( raw_input ( ) ) <NEWLINE> while N != 0 : <NEWLINE> <INDENT> ( W , H ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> PT = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> PT . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> Max = 0 <NEWLINE> ( S , T ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> PT . sort ( ) <NEWLINE> for i in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , H + 1 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> if i <= PT [ k ] [ 0 ] and PT [ k ] [ 0 ] < i + S and j <= PT [ k ] [ 1 ] and PT [ k ] [ 1 ] < j + T : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if Max < cnt : <NEWLINE> <INDENT> Max = cnt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print Max <NEWLINE> <NL> N = int ( raw_input ( ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p = [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( n ) ] <NEWLINE> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for b in xrange ( 1 , h - t + 2 ) : <NEWLINE> <INDENT> for a in xrange ( w - s + 2 ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for c , d in p : <NEWLINE> <INDENT> if 0 <= c - a < s and 0 <= d - b < t : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , cnt ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> W , H = map ( int , input ( ) . split ( ) ) <NEWLINE> fld = [ [ 0 for w in range ( W ) ] for h in range ( H ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> x , y = map ( lambda s : int ( s ) - 1 , raw_input ( ) . split ( ) ) <NEWLINE> fld [ y ] [ x ] = 1 <NEWLINE> <DEDENT> cums = [ [ 0 for w in range ( W + 1 ) ] for h in range ( H + 1 ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> cums [ y + 1 ] [ x + 1 ] = fld [ y ] [ x ] + cums [ y ] [ x + 1 ] + cums [ y + 1 ] [ x ] - cums [ y ] [ x ] <NEWLINE> <DEDENT> <DEDENT> S , T = map ( int , input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for y in range ( H - T + 1 ) : <NEWLINE> <INDENT> for x in range ( W - S + 1 ) : <NEWLINE> <INDENT> ans = max ( ans , cums [ y + T ] [ x + S ] - cums [ y + T ] [ x ] - cums [ y ] [ x + S ] + cums [ y ] [ x ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
mv = ( ( 1 , 0 ) , ( 0 , 1 ) ) <NEWLINE> <NL> def dfs ( x , y , ans ) : <NEWLINE> <INDENT> global res <NEWLINE> ans = max ( ans , int ( str ( ans ) + C [ y ] [ x ] ) ) <NEWLINE> res = max ( ans , res ) <NEWLINE> for dx , dy in mv : <NEWLINE> <INDENT> mx = x + dx <NEWLINE> my = y + dy <NEWLINE> if mx < 0 or mx >= W or my < 0 or my >= H : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if C [ my ] [ mx ] . isdigit ( ) : <NEWLINE> <INDENT> dfs ( mx , my , ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> W , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if W == H == 0 : break <NEWLINE> C = [ raw_input ( ) for i in range ( H ) ] <NEWLINE> res = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if C [ i ] [ j ] . isdigit ( ) and C [ i ] [ j ] != <STRING> : <NEWLINE> <INDENT> dfs ( j , i , 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print res <NEWLINE> <DEDENT>
def rec ( h , w , s ) : <NEWLINE> <INDENT> res = 0 <NEWLINE> for dh , dw in [ [ 1 , 0 ] , [ 0 , 1 ] ] : <NEWLINE> <INDENT> nh , nw = h + dh , w + dw <NEWLINE> if 0 <= nh < H and 0 <= nw < W and C [ nh ] [ nw ] . isdigit ( ) : <NEWLINE> <INDENT> res = max ( res , rec ( nh , nw , s + C [ nh ] [ nw ] ) ) <NEWLINE> <DEDENT> <DEDENT> return res if res > 0 else int ( s ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> W , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if W == 0 : break <NEWLINE> C = [ list ( raw_input ( ) ) for _ in xrange ( H ) ] <NEWLINE> ans = 0 <NEWLINE> for h in xrange ( H ) : <NEWLINE> <INDENT> for w in xrange ( W ) : <NEWLINE> <INDENT> if C [ h ] [ w ] . isdigit ( ) : <NEWLINE> <INDENT> if w > 0 and C [ h ] [ w - 1 ] . isdigit ( ) or h > 0 and C [ h - 1 ] [ w ] . isdigit ( ) : continue <NEWLINE> ans = max ( ans , rec ( h , w , C [ h ] [ w ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
def R ( xyzr1 , xyzr2 ) : <NEWLINE> <INDENT> x1 , y1 , z1 , r1 = xyzr1 <NEWLINE> x2 , y2 , z2 , r2 = xyzr2 <NEWLINE> return max ( 0 , ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 + ( z1 - z2 ) ** 2 ) ** 0.5 - r1 - r2 ) <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print 0.0 <NEWLINE> continue <NEWLINE> <DEDENT> xyzr = [ map ( float , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> ans = 1e10 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> L = R ( xyzr [ i ] , xyzr [ j ] ) <NEWLINE> if L < ans : <NEWLINE> <INDENT> ans = L <NEWLINE> s = [ i , j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> chain = [ xyzr . pop ( s [ 1 ] ) , xyzr . pop ( s [ 0 ] ) ] <NEWLINE> while xyzr : <NEWLINE> <INDENT> pipe = 1e10 <NEWLINE> for i in range ( len ( xyzr ) ) : <NEWLINE> <INDENT> for j in range ( len ( chain ) ) : <NEWLINE> <INDENT> L = R ( xyzr [ i ] , chain [ j ] ) <NEWLINE> if L < pipe : <NEWLINE> <INDENT> pipe = L <NEWLINE> p = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans += pipe <NEWLINE> chain . append ( xyzr . pop ( p ) ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
n = 1 <NEWLINE> r = 1 <NEWLINE> while n != 0 and r != 0 : <NEWLINE> <INDENT> n , r = input ( ) . split ( ) <NEWLINE> n , r = int ( n ) , int ( r ) <NEWLINE> <NL> card = [ [ int ( i ) for i in input ( ) . split ( ) ] for i in range ( r ) ] <NEWLINE> yama = list ( range ( n , 0 , - 1 ) ) <NEWLINE> <NL> <NL> for i in range ( r ) : <NEWLINE> <INDENT> p = card [ i ] [ 0 ] <NEWLINE> c = card [ i ] [ 1 ] <NEWLINE> x = yama [ : p - 1 ] <NEWLINE> y = yama [ p - 1 : p - 1 + c ] <NEWLINE> z = yama [ p - 1 + c : ] <NEWLINE> <NL> <NL> yama = ( y + x + z ) <NEWLINE> <NL> <DEDENT> print ( yama [ 0 ] ) <NEWLINE> <NL> <DEDENT>
l = input ( ) <NEWLINE> L = l . split ( ) <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> L [ i ] = int ( L [ i ] ) <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if L [ 0 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = [ L [ 0 ] - number for number in range ( L [ 0 ] ) ] <NEWLINE> for j in range ( L [ 1 ] ) : <NEWLINE> <INDENT> r = input ( ) <NEWLINE> R = r . split ( ) <NEWLINE> for k in range ( len ( R ) ) : <NEWLINE> <INDENT> R [ k ] = int ( R [ k ] ) <NEWLINE> <DEDENT> b = [ ] <NEWLINE> b += a [ R [ 0 ] - 1 : R [ 0 ] + R [ 1 ] - 1 ] <NEWLINE> b += a [ : R [ 0 ] - 1 ] <NEWLINE> b += a [ R [ 0 ] + R [ 1 ] - 1 : ] <NEWLINE> a . clear ( ) <NEWLINE> a = b . copy ( ) <NEWLINE> <DEDENT> print ( a [ 0 ] ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> sousa = input ( ) . sprit ( ) <COMMENT> <NEWLINE> sousa = [ int ( sousa [ 0 ] ) , int ( sousa [ 1 ] ) ] <NEWLINE> if sousa == [ 0 , 0 ] : break <NEWLINE> yama = [ ] <NEWLINE> for k in range ( sousa [ 0 ] ) : yama . append ( k + 1 ) <NEWLINE> yama = yama [ : : - 1 ] <NEWLINE> for r in range ( sousa [ 1 ] ) : <NEWLINE> <INDENT> [ p , c ] = input ( ) . sprit ( ) <NEWLINE> [ p , c ] = [ int ( p ) , int ( c ) ] <NEWLINE> yama [ : p + c - 1 ] = yama [ p - 1 : p + c - 1 ] + yama [ : p - 2 ] <NEWLINE> <DEDENT> print ( yama [ 0 ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> x , y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> pp = [ 1 , - 1 , 0 , 0 ] <NEWLINE> qq = [ 0 , 0 , 1 , - 1 ] <NEWLINE> m = [ ] <NEWLINE> for i in range ( y ) : <NEWLINE> <INDENT> m . append ( list ( input ( ) ) ) <NEWLINE> if <STRING> in m [ - 1 ] : <NEWLINE> <INDENT> ss = m [ - 1 ] . index ( <STRING> ) <NEWLINE> tt = i <NEWLINE> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> <NL> def move ( cx , cy ) : <NEWLINE> <INDENT> global cnt <NEWLINE> if cy >= y or cy < 0 or cx >= x or cx < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if m [ cy ] [ cx ] == <STRING> or m [ cy ] [ cx ] == <STRING> <NEWLINE> <INDENT> cnt += 1 <NEWLINE> m [ cy ] [ cx ] = <STRING> <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> move ( cx + pp [ i ] , cy + qq [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> move ( ss , tt ) <NEWLINE> print ( cnt ) <NEWLINE> <NL> <DEDENT>
def getter ( targ , x , y ) : <NEWLINE> <COMMENT> <NL> <INDENT> if 0 > x or x >= len ( targ ) or 0 > y or y >= len ( targ [ 0 ] ) or targ [ x ] [ y ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> targ [ x ] [ y ] = <STRING> <NEWLINE> return 1 + getter ( targ , x + 1 , y ) + getter ( targ , x - 1 , y ) + getter ( targ , x , y + 1 ) + getter ( targ , x , y - 1 ) <NEWLINE> <DEDENT> <DEDENT> with open ( <STRING> ) as f : <NEWLINE> <INDENT> width , height = [ int ( n ) for n in f . readline ( ) . split ( <STRING> ) ] <NEWLINE> global lab <NEWLINE> while True : <NEWLINE> <INDENT> lab , start = [ ] , [ ] <NEWLINE> for a in range ( height ) : <NEWLINE> <INDENT> disp = [ n for n in f . readline ( ) . rstrip ( <STRING> ) ] <NEWLINE> if <STRING> in disp : <NEWLINE> <INDENT> start . extend ( [ disp . index ( <STRING> ) , a ] ) <NEWLINE> <DEDENT> lab . append ( disp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a , b = start <NEWLINE> print ( getter ( lab , b , a ) ) <NEWLINE> width , height = [ int ( n ) for n in f . readline ( ) . split ( <STRING> ) ] <NEWLINE> if width == 0 and height == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> count = 0 <NEWLINE> def dfs ( i , j , island ) : <NEWLINE> <INDENT> global count <NEWLINE> <COMMENT> <NL> dxy = [ ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> <NL> if i < 0 or i >= len ( island ) or j < 0 or j >= len ( island [ 0 ] ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if island [ i ] [ j ] == <STRING> or island [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> island [ i ] [ j ] = <STRING> <NEWLINE> count += 1 <NEWLINE> <NL> for d in dxy : <NEWLINE> <INDENT> dfs ( i + d [ 0 ] , j + d [ 1 ] , island ) <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( w , h , island ) : <NEWLINE> <INDENT> s_i = 0 <NEWLINE> s_j = 0 <NEWLINE> for i , row in enumerate ( island ) : <NEWLINE> <INDENT> for j , s in enumerate ( row ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> s_i = i <NEWLINE> s_j = j <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dfs ( s_i , s_j , island ) <NEWLINE> print count <NEWLINE> <NL> <DEDENT> def func ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> global count <NEWLINE> wh = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> w = wh [ 0 ] <NEWLINE> h = wh [ 1 ] <NEWLINE> island = [ ] <NEWLINE> count = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> row = [ ] <NEWLINE> line = raw_input ( ) <NEWLINE> for j in line : <NEWLINE> <INDENT> row . append ( j ) <NEWLINE> <DEDENT> island . append ( row ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> solve ( w , h , island ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> func ( ) <NEWLINE>
re = open ( <STRING> ) <NEWLINE> count = 0 <NEWLINE> role = { <STRING> : True , <STRING> : False , <STRING> : False } <NEWLINE> def now ( xpoint , ypoint ) : <NEWLINE> <INDENT> return role [ room [ ypoint ] [ xpoint ] ] <NEWLINE> <NL> <DEDENT> def search ( xpoint , ypoint ) : <NEWLINE> <INDENT> global count <NEWLINE> if 0 <= xpoint < wh [ 0 ] and 0 <= ypoint < wh [ 1 ] and now ( xpoint , ypoint ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> room [ ypoint ] [ xpoint ] = <STRING> <NEWLINE> search ( xpoint - 1 , ypoint ) <NEWLINE> search ( xpoint + 1 , ypoint ) <NEWLINE> search ( xpoint , ypoint + 1 ) <NEWLINE> search ( xpoint , ypoint - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> wh = map ( int , re . readline ( ) . split ( ) ) <NEWLINE> room = [ ] <NEWLINE> count = 0 <NEWLINE> for ypoint in range ( wh [ 1 ] ) : <NEWLINE> <INDENT> line = re . readline ( ) . replace ( <STRING> , <STRING> ) <NEWLINE> if <STRING> in line : <NEWLINE> <INDENT> xp = line . index ( <STRING> ) <NEWLINE> yp = ypoint <NEWLINE> <DEDENT> room . append ( [ x for x in line ] ) <NEWLINE> <DEDENT> if not room : break <NEWLINE> room [ yp ] [ xp ] = <STRING> <NEWLINE> search ( xp , yp ) <NEWLINE> print count <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> h , w = 1 , 1 <NEWLINE> <NL> count = 0 <NEWLINE> <NL> def search ( x , y ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> global count <NEWLINE> if x < 0 or x > w - 1 or y < 0 or y > h - 1 or map_data [ y ] [ x ] == <STRING> : <NEWLINE> <NL> <INDENT> return <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> if reached [ y ] [ x ] : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> reached [ y ] [ x ] = 1 <NEWLINE> count += 1 <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> search ( x + 1 , y ) <COMMENT> <NEWLINE> search ( x - 1 , y ) <COMMENT> <NEWLINE> search ( x , y + 1 ) <COMMENT> <NEWLINE> search ( x , y - 1 ) <COMMENT> <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> while h != 0 and w != 0 : <NEWLINE> <NL> <INDENT> count = 0 <NEWLINE> <COMMENT> <NL> <NL> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> map_data = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> reached = [ [ 0 ] * w for _ in range ( h ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> ct = raw_input ( ) <NEWLINE> <COMMENT> <NL> for j in range ( w ) : <NEWLINE> <INDENT> map_data [ i ] [ j ] = ct [ j ] <NEWLINE> if ct [ j ] == <STRING> : <NEWLINE> <INDENT> sx = j <NEWLINE> sy = i <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> search ( sx , sy ) <NEWLINE> <NL> print ( count ) <NEWLINE> count = 0 <NEWLINE> w = 1 <NEWLINE> h = 1 <NEWLINE> <NL> <DEDENT>
import queue <NEWLINE> <NL> def solve ( w , h ) : <NEWLINE> <INDENT> q = queue . Queue ( ) <NEWLINE> m = [ [ <STRING> for i in range ( w + 2 ) ] for j in range ( h + 2 ) ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> inp = input ( ) <NEWLINE> for j in range ( w ) : <NEWLINE> <INDENT> m [ i + 1 ] [ j + 1 ] = inp [ j ] <NEWLINE> if m [ i + 1 ] [ j + 1 ] == <STRING> : <NEWLINE> <INDENT> start = [ i + 1 , j + 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> q . put ( start ) <NEWLINE> c = 1 <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> cur = q . get ( ) <NEWLINE> XY = [ ( 1 , 0 ) , ( - 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) ] <NEWLINE> for x , y in XY : <NEWLINE> <INDENT> cx = cur [ 0 ] + x <NEWLINE> cy = cur [ 1 ] + y <NEWLINE> if m [ cx ] [ cy ] == <STRING> : <NEWLINE> <INDENT> m [ cx ] [ cy ] = <STRING> <NEWLINE> q . put ( [ cx , cy ] ) <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> w , h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print solve ( w , h ) <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> <NL> def solve ( p , q , a , n , l = 1 ) : <NEWLINE> <INDENT> ans = 1 if p == 1 and q <= a and q >= l else 0 <NEWLINE> denom = max ( l , int ( q / p ) ) <NEWLINE> p_denom = denom * p <NEWLINE> while n * q >= p_denom and denom <= a : <COMMENT> <NEWLINE> <INDENT> p_ , q_ = p_denom - q , q * denom <NEWLINE> if p_ <= 0 : <NEWLINE> <INDENT> denom += 1 <NEWLINE> p_denom += p <NEWLINE> continue <NEWLINE> <DEDENT> gcd_ = gcd ( p_ , q_ ) <NEWLINE> p_ //= gcd_ <NEWLINE> q_ //= gcd_ <NEWLINE> if n == 2 and p_ == 1 and q_ * denom <= a and q_ >= denom : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += solve ( p_ , q_ , a // denom , n - 1 , denom ) <NEWLINE> <DEDENT> denom += 1 <NEWLINE> p_denom += p <NEWLINE> <COMMENT> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> p , q , a , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if p == q == a == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> gcd_ = gcd ( p , q ) <NEWLINE> p //= gcd_ <NEWLINE> q //= gcd_ <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 1 if p == 1 and q <= a else 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( solve ( p , q , a , n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> result = 0 <NEWLINE> <NL> def dfs ( num , dem , k , cur_num , p , q , a , n ) : <NEWLINE> <INDENT> global result <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if ( num * q ) == ( dem * p ) : <NEWLINE> <INDENT> result += 1 <NEWLINE> <COMMENT> <NL> return <NEWLINE> <NL> <DEDENT> if k == n : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if ( num * q ) > ( dem * p ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> i = cur_num <NEWLINE> while i * dem <= a : <NEWLINE> <INDENT> dfs ( ( num * i ) + dem , dem * i , k + 1 , i , p , q , a , n ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> return <NEWLINE> <NL> <DEDENT> def func ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> global result <NEWLINE> p , q , a , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if p == 0 and q == 0 and a == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> dfs ( 0 , 1 , 0 , 1 , p , q , a , n ) <NEWLINE> print result <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> func ( ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> size = 10000000 <NEWLINE> s = list ( range ( size + 1 ) ) <NEWLINE> s [ 1 ] = 0 <NEWLINE> sqrtn = int ( round ( size ** 0.5 ) ) <NEWLINE> for i in range ( 2 , sqrtn + 1 ) : <NEWLINE> <INDENT> if s [ i ] : <NEWLINE> <INDENT> s [ i * i : size + 1 : i ] = [ 0 ] * len ( range ( i * i , size + 1 , i ) ) <NEWLINE> <DEDENT> <DEDENT> primes = list ( filter ( None , s ) ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> a , d , n = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : break <NEWLINE> <NL> ans = 0 <NEWLINE> for p in primes : <NEWLINE> <INDENT> if p - a < 0 : continue <NEWLINE> if ( p - a ) % d == 0 : <NEWLINE> <INDENT> ans = p <NEWLINE> n -= 1 <NEWLINE> <DEDENT> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> l = range ( 0 , 1000001 ) <NEWLINE> l [ 1 ] = 0 <NEWLINE> for i in range ( 0 , 1000 ) : <NEWLINE> <INDENT> if l [ i ] != 0 : <NEWLINE> <INDENT> for k in range ( i + i , 1000001 , i ) : <NEWLINE> <INDENT> l [ k ] = 0 <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> <DEDENT> l = [ x for x in l if x ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> l2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if l2 == [ 0 , 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = l2 [ 0 ] <NEWLINE> d = l2 [ 1 ] <NEWLINE> n = l2 [ 2 ] <NEWLINE> c = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if a in l : <NEWLINE> <INDENT> c = c + 1 <NEWLINE> <DEDENT> if c == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = a + d <NEWLINE> <DEDENT> print a <NEWLINE> <DEDENT>
= int ( raw_input ( ) ) <NEWLINE> <NL> def comb ( tr ) : <NEWLINE> <INDENT> l = len ( tr ) <NEWLINE> res = [ ] <NEWLINE> for i in range ( l ) : <NEWLINE> <INDENT> head , tail = tr [ i : ] , tr [ : i ] <NEWLINE> headrev = head [ : : - 1 ] <NEWLINE> tailrev = tail [ : : - 1 ] <NEWLINE> res . append ( head + tail ) <NEWLINE> res . append ( headrev + tail ) <NEWLINE> res . append ( head + tailrev ) <NEWLINE> res . append ( headrev + tailrev ) <NEWLINE> res . append ( tail + head ) <NEWLINE> res . append ( tailrev + head ) <NEWLINE> res . append ( tail + headrev ) <NEWLINE> res . append ( tailrev + headrev ) <NEWLINE> <DEDENT> return len ( set ( res ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> tr = raw_input ( ) <NEWLINE> print comb ( tr ) <NEWLINE> <DEDENT>
import copy <NEWLINE> while 1 : <NEWLINE> <INDENT> W , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if W == 0 : break <NEWLINE> field = [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( H ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> if field [ y ] [ x ] == 2 : sx , sy = x , y <NEWLINE> <NL> <DEDENT> <DEDENT> que = [ [ sx , sy , 10 , field [ : ] ] ] <NEWLINE> while que : <NEWLINE> <INDENT> x , y , t , field = que . pop ( 0 ) <NEWLINE> if t == - 1 : continue <NEWLINE> if field [ y ] [ x ] == 3 : <NEWLINE> <INDENT> print 10 - t <NEWLINE> break <NEWLINE> <DEDENT> for dx , dy in zip ( [ 1 , 0 , - 1 , 0 ] , [ 0 , 1 , 0 , - 1 ] ) : <NEWLINE> <INDENT> _field = copy . deepcopy ( field [ : ] ) <NEWLINE> nx , ny = x + dx , y + dy <NEWLINE> while 0 <= nx < W and 0 <= ny < H : <NEWLINE> <INDENT> if _field [ ny ] [ nx ] == 3 : <NEWLINE> <INDENT> que . append ( [ nx , ny , t - 1 , _field [ : ] ] ) <NEWLINE> break <NEWLINE> <DEDENT> if _field [ ny ] [ nx ] == 1 : <NEWLINE> <INDENT> _field [ ny ] [ nx ] = 0 <NEWLINE> if abs ( nx - x ) + abs ( ny - y ) == 1 : break <NEWLINE> que . append ( [ nx - dx , ny - dy , t - 1 , _field [ : ] ] ) <NEWLINE> break <NEWLINE> <DEDENT> nx += dx ; ny += dy <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print - 1 <NEWLINE> <DEDENT> <DEDENT>
delta = ( ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) , ( 0 , - 1 ) ) <NEWLINE> def ds ( here , field , count , lb , ub , min_count ) : <NEWLINE> <INDENT> if count > min_count : <NEWLINE> <INDENT> return min_count <NEWLINE> <DEDENT> ans = min_count <NEWLINE> for dx , dy in delta : <NEWLINE> <INDENT> nx , ny = ( here [ 0 ] + dx , here [ 1 ] + dy ) <NEWLINE> neighbor = ( nx , ny ) <NEWLINE> while lb [ 0 ] <= nx <= ub [ 0 ] and lb [ 1 ] <= ny <= ub [ 1 ] : <NEWLINE> <INDENT> if field [ ny ] [ nx ] == 1 : <NEWLINE> <INDENT> if ( nx , ny ) != neighbor : <NEWLINE> <INDENT> field [ ny ] [ nx ] = 0 <NEWLINE> ans = ds ( ( nx - dx , ny - dy ) , field , count + 1 , lb , ub , ans ) <NEWLINE> <INDENT> field [ ny ] [ nx ] = 1 <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> if field [ ny ] [ nx ] == 3 : <NEWLINE> <INDENT> if count + 1 < ans : <NEWLINE> <INDENT> ans = count + 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> nx += dx <NEWLINE> ny += dy <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if w == h == 0 : break <NEWLINE> board = [ map ( int , raw_input ( ) . split ( <STRING> ) ) for _ in range ( h ) ] <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if board [ j ] [ i ] == 2 : <NEWLINE> <INDENT> start = ( i , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> result = ds ( start , board , 0 , ( 0 , 0 ) , ( w - 1 , h - 1 ) , 11 ) <NEWLINE> print result if result < 11 else - 1 <NEWLINE> <DEDENT>
<NL> dx = [ 0 , 1 , 0 , - 1 ] <NEWLINE> dy = [ 1 , 0 , - 1 , 0 ] <NEWLINE> N_MOVE = 4 <NEWLINE> EMPTY = 0 <NEWLINE> ROCK = 1 <NEWLINE> START = 2 <NEWLINE> GOAL = 3 <NEWLINE> <NL> INF = 100000 <NEWLINE> <NL> def in_field ( field , x , y ) : <NEWLINE> <INDENT> return y >= 0 and y < len ( field ) and x >= 0 and x < len ( field [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> def move_to_rock ( field , x , y , direction ) : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> x += dx [ direction ] <NEWLINE> y += dy [ direction ] <NEWLINE> if not in_field ( field , x , y ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif field [ y ] [ x ] == ROCK : <NEWLINE> <INDENT> x -= dx [ direction ] <NEWLINE> y -= dy [ direction ] <NEWLINE> break <NEWLINE> <DEDENT> elif field [ y ] [ x ] == GOAL : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return x , y <NEWLINE> <NL> <NL> <DEDENT> def dfs ( depth , field , x , y ) : <NEWLINE> <INDENT> if depth > 10 : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> cost = INF <NEWLINE> for r in range ( N_MOVE ) : <NEWLINE> <INDENT> nx , ny = x + dx [ r ] , y + dy [ r ] <NEWLINE> if not in_field ( field , nx , ny ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if field [ ny ] [ nx ] == ROCK : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> next_pos = move_to_rock ( field , x , y , r ) <NEWLINE> if next_pos is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> nx , ny = next_pos <NEWLINE> if field [ ny ] [ nx ] == GOAL : <NEWLINE> <INDENT> return depth <NEWLINE> <DEDENT> rock_pos_x , rock_pos_y = nx + dx [ r ] , ny + dy [ r ] <NEWLINE> assert field [ rock_pos_y ] [ rock_pos_x ] == ROCK <NEWLINE> field [ rock_pos_y ] [ rock_pos_x ] = EMPTY <NEWLINE> result = dfs ( depth + 1 , field , nx , ny ) <NEWLINE> if result is not None : <NEWLINE> <INDENT> cost = min ( cost , result ) <NEWLINE> <DEDENT> field [ rock_pos_y ] [ rock_pos_x ] = ROCK <NEWLINE> <DEDENT> return cost <NEWLINE> <NL> <NL> <DEDENT> def find_start_pos ( field ) : <NEWLINE> <INDENT> h = len ( field ) <NEWLINE> w = len ( field [ 0 ] ) <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if field [ y ] [ x ] == START : <NEWLINE> <INDENT> return x , y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return None <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 or h == 0 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> field = [ ] <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> field . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> x , y = find_start_pos ( field ) <NEWLINE> res = dfs ( 1 , field , x , y ) <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> answer = solve ( ) <NEWLINE> if answer == INF : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
dx = [ 1 , - 1 , 0 , 0 ] <NEWLINE> dy = [ 0 , 0 , 1 , - 1 ] <NEWLINE> <NL> <NL> def dfs ( x , y , cnt ) : <NEWLINE> <INDENT> global board , W , H , ans <NEWLINE> if ans <= cnt : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> mx , my = x , y <NEWLINE> mx += dx [ i ] <NEWLINE> my += dy [ i ] <NEWLINE> <NL> if 0 > mx or 0 > my or W <= mx or H <= my : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if board [ my ] [ mx ] == 1 : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if board [ my ] [ mx ] == 3 : <NEWLINE> <INDENT> ans = cnt <NEWLINE> return <NEWLINE> <NL> <DEDENT> mx += dx [ i ] <NEWLINE> mx += dy [ i ] <NEWLINE> <NL> if 0 > mx or 0 > my or W <= mx or H <= my : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if board [ my ] [ mx ] == 1 : <NEWLINE> <INDENT> board [ my ] [ mx ] = 0 <NEWLINE> dfs ( mx - dx [ i ] , my - dy [ i ] , cnt + 1 ) <NEWLINE> board [ my ] [ mx ] = 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> W , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if W == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ans = 11 <NEWLINE> board = [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( H ) ] <NEWLINE> for y in range ( H ) : <NEWLINE> <INDENT> for x in range ( W ) : <NEWLINE> <INDENT> if board [ y ] [ x ] == 2 : <NEWLINE> <INDENT> sx , xy = x , y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dfs ( sx , sy , 1 ) <NEWLINE> print ans if ans < 11 else - 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import itertools as it <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def check ( c ) : <NEWLINE> <INDENT> return ( ord ( c ) >= ord ( <STRING> ) and ord ( c ) <= ord ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> S1 , S2 = raw_input ( ) . split ( ) <NEWLINE> if S1 == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N = int ( S2 ) <NEWLINE> SS = <STRING> <NEWLINE> flag = False <NEWLINE> for i in range ( len ( S1 ) - 1 ) : <NEWLINE> <INDENT> SS += S1 [ i ] <NEWLINE> if check ( S1 [ i ] ) and not check ( S1 [ i + 1 ] ) and S1 [ i + 1 ] != <STRING> : <NEWLINE> <INDENT> SS += <STRING> <NEWLINE> flag = True <NEWLINE> <DEDENT> elif flag : <NEWLINE> <INDENT> SS += <STRING> <NEWLINE> flag = False <NEWLINE> <DEDENT> <DEDENT> SS += S1 [ len ( S1 ) - 1 ] <NEWLINE> if flag : <NEWLINE> <INDENT> SS += <STRING> <NEWLINE> <DEDENT> S1 = <STRING> + SS + <STRING> <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> S1 = S1 . replace ( <STRING> + chr ( ord ( <STRING> ) + i ) , <STRING> + chr ( ord ( <STRING> ) + i ) ) <NEWLINE> S1 = S1 . replace ( chr ( ord ( <STRING> ) + i ) + <STRING> , chr ( ord ( <STRING> ) + i ) + <STRING> ) <NEWLINE> <DEDENT> S1 = S1 [ 1 : - 1 ] <NEWLINE> S1 = S1 . replace ( <STRING> , <STRING> ) <NEWLINE> SS = <STRING> <NEWLINE> for i in range ( len ( S1 ) - 1 ) : <NEWLINE> <INDENT> SS += S1 [ i ] <NEWLINE> if not check ( S1 [ i ] ) and check ( S1 [ i + 1 ] ) : <NEWLINE> <INDENT> SS += <STRING> <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> SS += S1 [ len ( S1 ) - 1 ] <NEWLINE> if check ( S1 [ 0 ] ) : <NEWLINE> <INDENT> SS = <STRING> + SS <NEWLINE> <DEDENT> S1 = <STRING> + SS + <STRING> <NEWLINE> S1 = S1 . replace ( <STRING> , <STRING> ) <NEWLINE> hoge = eval ( S1 ) <NEWLINE> ans = 0 <NEWLINE> m = { } <NEWLINE> def func ( obj ) : <NEWLINE> <INDENT> if type ( obj ) == type ( <STRING> ) : <NEWLINE> <INDENT> m [ obj ] = len ( obj ) <NEWLINE> return len ( obj ) <NEWLINE> <DEDENT> num = obj [ 0 ] <NEWLINE> ret = 0 <NEWLINE> for i in range ( 1 , len ( obj ) ) : <NEWLINE> <INDENT> ret += num * func ( obj [ i ] ) <NEWLINE> <DEDENT> m [ obj ] = ret <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def func2 ( obj , index ) : <NEWLINE> <INDENT> if type ( obj ) == type ( <STRING> ) : <NEWLINE> <INDENT> return obj [ index ] <NEWLINE> <DEDENT> num = obj [ 0 ] <NEWLINE> S = m [ obj ] <NEWLINE> index %= S / num <NEWLINE> ret = 0 <NEWLINE> for i in range ( 1 , len ( obj ) ) : <NEWLINE> <INDENT> ret += m [ obj [ i ] ] <NEWLINE> if ret > index : <NEWLINE> <INDENT> ret -= m [ obj [ i ] ] <NEWLINE> return func2 ( obj [ i ] , index - ret ) <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> func ( hoge ) <NEWLINE> <COMMENT> <NL> if N >= m [ hoge ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print func2 ( hoge , N ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <COMMENT> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> while n >= 3 and n <= 100 : <COMMENT> <NEWLINE> <INDENT> a = [ 0 ] * n <COMMENT> <NEWLINE> for i in range ( n ) : <COMMENT> <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> a [ i ] = s <NEWLINE> <DEDENT> tensu = ( sum ( a ) - min ( a ) - max ( a ) ) / ( len ( a ) - 2 ) <COMMENT> <NEWLINE> print ( int ( tensu ) ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> def solve ( n ) : <NEWLINE> <INDENT> nums = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> temp = input ( ) <NEWLINE> nums . append ( temp ) <NEWLINE> <DEDENT> nums . sort ( ) <NEWLINE> sum = 0 <NEWLINE> for i in xrange ( 1 , n - 1 ) : <NEWLINE> <INDENT> sum += nums [ i ] <NEWLINE> <DEDENT> return sum / ( n - 2 ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> sys . exit ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print solve ( N ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> score = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> score . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( ( sorted ( score ) [ 1 : - 1 ] ) // ( n - 2 ) ) <NEWLINE> <DEDENT>
while ( True ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> sl = 1001 <NEWLINE> sh = 0 <NEWLINE> ret = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> sum += tmp <NEWLINE> if tmp < sl : <NEWLINE> <INDENT> sl = tmp <NEWLINE> <DEDENT> if tmp > sh : <NEWLINE> <INDENT> sh = tmp <NEWLINE> <DEDENT> <DEDENT> ret -= ( sl + sh ) <NEWLINE> print <STRING> % ( ret / n ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if 3 <NEWLINE> N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> S . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( ( sum ( S ) - max ( S ) - min ( S ) ) // ( len ( S ) - 2 ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> l = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> l . append ( int ( line ) ) <NEWLINE> <NL> <DEDENT> check = 0 <NEWLINE> point_list = [ ] <NEWLINE> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> if check == 0 : <NEWLINE> <INDENT> last_row = i + l [ i ] <NEWLINE> check = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> point_list . append ( i ) <NEWLINE> if i == last_row : <NEWLINE> <INDENT> point_list . sort ( ) <NEWLINE> point_list = point_list [ 1 : - 1 ] <NEWLINE> ave = sum ( point_list ) * 1.0 / len ( point_list ) <NEWLINE> print int ( math . floor ( ave ) ) <NEWLINE> check = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> f = true <NEWLINE> r = [ ] <NEWLINE> while f : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> r . append ( math . floor ( ( sum ( m ) - max ( m ) - min ( m ) / ( n - 2 ) ) ) ) <NEWLINE> <DEDENT> res = <STRING> <NEWLINE> for j in r : <NEWLINE> <INDENT> res += str ( j ) <NEWLINE> <DEDENT> print ( j ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
while True : <NEWLINE> <NL> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> l = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l . append ( int ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> print ( sum ( l ) - max ( l ) - min ( l ) ) / ( len ( l ) - 2 ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> points = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> points . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> points . remove ( max ( points ) ) <NEWLINE> points . remove ( min ( points ) ) <NEWLINE> print ( int ( sum ( points ) / len ( points ) ) ) <NEWLINE> if int ( input ( ) ) == 0 : break <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from bisect import * <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> ( N , M ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> r = int ( raw_input ( ) ) <NEWLINE> used = [ 0 ] * ( N + 1 ) <NEWLINE> imos = [ [ 0 ] * 1301 for i in range ( M + 1 ) ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> ( t , n , m , s ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if s == 1 and used [ n ] == 0 : <NEWLINE> <INDENT> used [ n ] = m <NEWLINE> imos [ m ] [ t ] = 1 <NEWLINE> <DEDENT> if s == 0 and used [ n ] == m : <NEWLINE> <INDENT> used [ n ] = 0 <NEWLINE> imos [ m ] [ t ] -= 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> ( qs , qe , user ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> tmp = 0 <NEWLINE> ans = 0 <NEWLINE> for j in range ( 540 , 1261 ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if tmp > 0 and j > qs and j <= qe : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> tmp += imos [ user ] [ j ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ans <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> sys . path . append ( <STRING> ) <NEWLINE> <NL> import lib <NEWLINE> import inspect <NEWLINE> import pyperclip <NEWLINE> from tqdm import tqdm <NEWLINE> <NL> <NL> def snippet ( module ) : <NEWLINE> <INDENT> text = inspect . getsource ( module ) <NEWLINE> pyperclip . copy ( text ) <NEWLINE> print ( text ) <NEWLINE> <NL> <NL> <DEDENT> def get_input ( inp ) : <NEWLINE> <INDENT> li = inp . split ( <STRING> ) <NEWLINE> <NL> def inner ( ) : <NEWLINE> <INDENT> return li . pop ( 0 ) <NEWLINE> <DEDENT> return inner <NEWLINE> <NL> <NL> <DEDENT> from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 100000 ) <NEWLINE> <NL> INPUT = <STRING> <NEWLINE> input = get_input ( INPUT ) <NEWLINE> <NL> <COMMENT> <NL> from sys import setrecursionlimit <NEWLINE> setrecursionlimit ( 100000 ) <NEWLINE> <NL> class Cake ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , N , W , D ) : <NEWLINE> <INDENT> self . P = [ - 1 ] * 2 * ( N + 1 ) <NEWLINE> self . L = [ - 1 ] * 2 * ( N + 1 ) <NEWLINE> self . R = [ - 1 ] * 2 * ( N + 1 ) <NEWLINE> self . W = [ 0 ] * 2 * ( N + 1 ) <NEWLINE> self . W [ 1 ] = W <NEWLINE> self . D = [ 0 ] * 2 * ( N + 1 ) <NEWLINE> self . D [ 1 ] = D <NEWLINE> <NL> <DEDENT> def find ( self , target ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 1 , 2 * N + 2 ) : <NEWLINE> <INDENT> count += ( self . L [ i ] == - 1 ) <NEWLINE> if count == target : <NEWLINE> <INDENT> return i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def cut ( self , target , s , l ) : <NEWLINE> <INDENT> w = self . W [ target ] <NEWLINE> d = self . D [ target ] <NEWLINE> L = w + d <NEWLINE> s %= L <NEWLINE> if s <= w : <NEWLINE> <INDENT> nw , nW = s , w - s <NEWLINE> if nw > nW : <NEWLINE> <INDENT> nw , nW = nW , nw <NEWLINE> <DEDENT> nd , nD = d , d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= w <NEWLINE> nd , nD = s , d - s <NEWLINE> if nd > nD : <NEWLINE> <INDENT> nd , nD = nD , nd <NEWLINE> <DEDENT> nw , nW = w , w <NEWLINE> <DEDENT> assert 0 < nw <NEWLINE> assert 0 < nd <NEWLINE> r = l + 1 <NEWLINE> self . L [ target ] , self . R [ target ] = l , r <NEWLINE> self . P [ l ] , self . P [ r ] = target , target <NEWLINE> self . W [ l ] , self . W [ r ] = nw , nW <NEWLINE> self . D [ l ] , self . D [ r ] = nd , nD <NEWLINE> <NL> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> tmp = [ ] <NEWLINE> for i in range ( 1 , len ( self . L ) ) : <NEWLINE> <INDENT> if self . L [ i ] == - 1 : <NEWLINE> <INDENT> tmp . append ( self . W [ i ] * self . D [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , sorted ( tmp ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> N , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> while W : <NEWLINE> <INDENT> cake = Cake ( N , W , D ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> p , s = map ( int , input ( ) . split ( ) ) <NEWLINE> target = cake . find ( p ) <NEWLINE> cake . cut ( target , s , 2 * ( i + 1 ) ) <NEWLINE> <DEDENT> cake . show ( ) <NEWLINE> N , W , D = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT>
def impossible ( taro_cards , hanako_cards , average ) : <NEWLINE> <INDENT> if ( sum ( taro_cards ) + sum ( hanako_cards ) ) % 2 == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif sum ( taro_cards ) + max ( taro_cards ) - min ( hanako_cards ) < average : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif sum ( hanako_cards ) + max ( hanako_cards ) - min ( taro_cards ) < average : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n_taro , n_hanako = map ( int , input ( ) . split ( ) ) <NEWLINE> if n_taro == 0 and n_hanako == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> taro_cards = [ ] <NEWLINE> hanako_cards = [ ] <NEWLINE> change_pairs = [ ] <NEWLINE> <NL> for _ in range ( n_taro ) : <NEWLINE> <INDENT> taro_cards . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for _ in range ( n_hanako ) : <NEWLINE> <INDENT> hanako_cards . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> average = ( sum ( taro_cards ) + sum ( hanako_cards ) ) // 2 <NEWLINE> <NL> if impossible ( taro_cards , hanako_cards , average ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> for i in range ( len ( taro_cards ) ) : <NEWLINE> <INDENT> for j in range ( len ( hanako_cards ) ) : <NEWLINE> <INDENT> if sum ( taro_cards [ : i ] ) + sum ( taro_cards [ i + 1 : ] ) + hanako_cards [ j ] == average : <NEWLINE> <INDENT> change_pairs . append ( ( taro_cards [ i ] , hanako_cards [ j ] ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if pairs_leastsum == [ ] : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pairs_leastsum = change_pairs [ 0 ] <NEWLINE> for i in range ( 1 , len ( change_pairs ) ) : <NEWLINE> <INDENT> if sum ( change_pairs [ i ] ) <= sum ( pairs_leastsum ) : <NEWLINE> <INDENT> pairs_leastsum = change_pairs [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( * pairs_leastsum ) <NEWLINE> <DEDENT> <DEDENT>
def answer ( n , m , taro , hanako ) : <NEWLINE> <INDENT> for t in sorted ( taro ) : <NEWLINE> <INDENT> fot h in ( hanako ) : <NEWLINE> <INDENT> if sum ( taro ) - t + h == sum ( hanako ) - h + t : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return - 1 <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> taro = [ ] <NEWLINE> hanako = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> taro . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> hanako . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( answer ( n , m , taro , hanako ) ) <NEWLINE> <NL> <NL> <DEDENT>
import math <NEWLINE> <NL> nummax = 300000 <NEWLINE> MSall = sorted ( [ 7 * x - 1 for x in range ( 1 , nummax / 7 ) ] + [ 7 * x + 1 for x in range ( 1 , nummax / 7 ) ] ) <NEWLINE> MSprime = [ ] <NEWLINE> smax = math . sqrt ( MSall [ - 1 ] ) <NEWLINE> i = 6 <NEWLINE> while i <= smax : <NEWLINE> <INDENT> for x in MSall : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> MSall . remove ( x ) <NEWLINE> <DEDENT> <DEDENT> MSprime . append ( i ) <NEWLINE> i = MSall [ 0 ] <NEWLINE> <DEDENT> MSprime = MSprime + MSall <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ok = [ ] <NEWLINE> i = 0 <NEWLINE> while MSprime [ i ] <= N : <NEWLINE> <INDENT> if N % MSprime [ i ] == 0 : <NEWLINE> <INDENT> ok . append ( MSprime [ i ] ) <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <DEDENT> print str ( N ) + <STRING> + <STRING> . join ( [ str ( x ) for x in ok ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> def sieve ( n ) : <NEWLINE> <INDENT> ms_prime = [ 0 , 0 , 0 , 0 , 0 , 0 ] <NEWLINE> ms_prime += [ 1 for i in range ( n - 5 ) ] <NEWLINE> ub = math . sqrt ( n ) + 1 <NEWLINE> d = 6 <NEWLINE> while d <= ub : <NEWLINE> <INDENT> if ms_prime [ d ] == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> continue <NEWLINE> <DEDENT> if d % 7 != 1 and d % 7 != 6 : <NEWLINE> <INDENT> ms_prime [ d ] = 0 <NEWLINE> d += 1 <NEWLINE> continue <NEWLINE> <DEDENT> prod = 2 <NEWLINE> while d * prod <= n : <NEWLINE> <INDENT> ms_prime [ d * prod ] = 0 <NEWLINE> prod += 1 <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> return ms_prime <NEWLINE> <DEDENT> ms_prime = sieve ( 300000 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> % n ) <NEWLINE> msp_factor = set ( ) <NEWLINE> for i in range ( 6 , n + 1 ) : <NEWLINE> <INDENT> tmp_factor = 0 <NEWLINE> if ms_prime [ i ] == 1 and n % i == 0 and ( ( n / i ) % 7 == 1 or ( n / i ) % 7 == 6 ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> % i ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> msprime = [ ] <NEWLINE> i = 6 <NEWLINE> MAX = 300000 <NEWLINE> isprime = [ 1 ] * 300001 <NEWLINE> while i * i <= MAX : <COMMENT> <NEWLINE> <INDENT> for p in msprime : <NEWLINE> <INDENT> if i % p == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> msprime . append ( i ) <NEWLINE> j = i * 2 <NEWLINE> while j <= MAX : <NEWLINE> <INDENT> isprime [ j ] = 0 <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> if i % 7 == 6 : <NEWLINE> <INDENT> i += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 5 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = i <NEWLINE> <NL> <DEDENT> for i in range ( tmp , MAX ) : <NEWLINE> <INDENT> if isprime [ i ] == 1 and i % 7 in ( 1 , 6 ) : <NEWLINE> <INDENT> msprime . append ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 1 : break <NEWLINE> fact = [ ] <NEWLINE> for i in msprime : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> fact . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print str ( n ) + <STRING> , <NEWLINE> for i in fact : <NEWLINE> <INDENT> print i , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import itertools as it <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> S_ = raw_input ( ) <NEWLINE> if S_ == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for p , q , r in it . product ( [ 0 , 1 , 2 ] , repeat = 3 ) : <NEWLINE> <INDENT> S = S_ <NEWLINE> S = S . replace ( <STRING> , str ( p ) ) . replace ( <STRING> , str ( q ) ) . replace ( <STRING> , str ( r ) ) <NEWLINE> <NL> for loop in range ( 100 ) : <NEWLINE> <INDENT> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> for a , b in it . product ( [ 0 , 1 , 2 ] , repeat = 2 ) : <NEWLINE> <INDENT> S = S . replace ( <STRING> % ( a , b ) , str ( min ( a , b ) ) ) <NEWLINE> S = S . replace ( <STRING> % ( a , b ) , str ( max ( a , b ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if S == <STRING> : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import heapq <NEWLINE> <NL> <NL> class Tuple : <NEWLINE> <INDENT> def __init__ ( self , cost , y , x , dir ) : <NEWLINE> <INDENT> self . cost = cost <NEWLINE> self . y = y <NEWLINE> self . x = x <NEWLINE> self . dir = dir <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return <STRING> + str ( self . y ) + <STRING> + <STRING> + str ( self . x ) + <STRING> + <STRING> + str ( self . dir ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dir_x = [ 1 , 0 , - 1 , 0 ] <NEWLINE> dir_y = [ 0 , 1 , 0 , - 1 ] <NEWLINE> <NL> <NL> def solve ( ) : <NEWLINE> <INDENT> X , Y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if X == 0 and Y == 0 : <NEWLINE> <INDENT> return - 1 <NEWLINE> <NL> <DEDENT> stage = [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( Y ) ] <NEWLINE> C = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> costs = [ [ [ float ( <STRING> ) for _ in xrange ( 4 ) ] for _ in xrange ( X ) ] for _ in xrange ( Y ) ] <NEWLINE> <NL> costs [ 0 ] [ 0 ] [ 0 ] = 0 <NEWLINE> queue = [ ] <NEWLINE> <NL> heapq . heappush ( queue , Tuple ( 0 , 0 , 0 , 0 ) ) <NEWLINE> <NL> while len ( queue ) > 0 : <NEWLINE> <NL> <INDENT> current = heapq . heappop ( queue ) <NEWLINE> if costs [ current . y ] [ current . x ] [ current . dir ] < current . cost : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for operation in range ( 4 ) : <NEWLINE> <INDENT> if operation == 0 : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> next_dir = current . dir <NEWLINE> <DEDENT> elif operation == 1 : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> next_dir = ( current . dir + 1 ) % 4 <NEWLINE> <DEDENT> elif operation == 2 : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> next_dir = ( current . dir + 2 ) % 4 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> next_dir = ( current . dir + 3 ) % 4 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> next_x = current . x + dir_x [ next_dir ] <NEWLINE> next_y = current . y + dir_y [ next_dir ] <NEWLINE> next_cost = costs [ current . y ] [ current . x ] [ current . dir ] <NEWLINE> if stage [ current . y ] [ current . x ] != operation : <NEWLINE> <INDENT> next_cost += C [ operation ] <NEWLINE> <DEDENT> if 0 <= next_x < X and 0 <= next_y < Y : <NEWLINE> <INDENT> if costs [ next_y ] [ next_x ] [ next_dir ] > next_cost : <NEWLINE> <INDENT> costs [ next_y ] [ next_x ] [ next_dir ] = next_cost <NEWLINE> data = Tuple ( next_cost , next_y , next_x , next_dir ) <NEWLINE> heapq . heappush ( queue , data ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return min ( costs [ Y - 1 ] [ X - 1 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> result = solve ( ) <NEWLINE> if result < 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> print result <NEWLINE> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> while True : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> S = l [ 0 ] <NEWLINE> p = np . zeros ( S ) <NEWLINE> M = l [ 1 ] <NEWLINE> i = 0 <NEWLINE> N = M <NEWLINE> if M == 0 and S == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> if p [ i ] == M : <NEWLINE> <INDENT> print ( i ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> if N == 0 : <NEWLINE> <INDENT> N = p [ i ] <NEWLINE> p [ i ] = 0 <NEWLINE> i += 1 <NEWLINE> i %= S <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> N -= 1 <NEWLINE> p [ i ] += 1 <NEWLINE> i += 1 <NEWLINE> i %= S <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000000 ) <NEWLINE> <NL> def check ( x , y ) : <NEWLINE> <INDENT> array [ x ] [ y ] = <STRING> <NEWLINE> if array [ x + 1 ] [ y ] == <STRING> : check ( x + 1 , y ) <NEWLINE> if array [ x - 1 ] [ y ] == <STRING> : check ( x - 1 , y ) <NEWLINE> if array [ x ] [ y + 1 ] == <STRING> : check ( x , y + 1 ) <NEWLINE> if array [ x ] [ y - 1 ] == <STRING> : check ( x , y - 1 ) <NEWLINE> if array [ x + 1 ] [ y + 1 ] == <STRING> : check ( x + 1 , y + 1 ) <NEWLINE> if array [ x + 1 ] [ y - 1 ] == <STRING> : check ( x + 1 , y - 1 ) <NEWLINE> if array [ x - 1 ] [ y + 1 ] == <STRING> : check ( x - 1 , y + 1 ) <NEWLINE> if array [ x - 1 ] [ y - 1 ] == <STRING> : check ( x - 1 , y - 1 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == 0 and w == 0 : break <NEWLINE> <NL> array = [ ] <NEWLINE> array . append ( list ( <STRING> * ( 2 + h ) ) ) <NEWLINE> for i in range ( 0 , w ) : array . append ( list ( <STRING> + raw_input ( ) . replace ( <STRING> , <STRING> ) + <STRING> ) ) <NEWLINE> array . append ( list ( <STRING> * ( 2 + h ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 1 , h + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> if array [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> check ( i , j ) <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
import sys <NEWLINE> def dfs ( tiles , W , H , x , y ) : <NEWLINE> <INDENT> tiles [ y ] [ x ] = <STRING> <NEWLINE> for dx , dy in ( ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , - 1 ) , ( 0 , 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) ) : <NEWLINE> <INDENT> if 0 <= x + dx < W and 0 <= y + dy < H and tiles [ y + dy ] [ x + dx ] == <STRING> : <NEWLINE> <INDENT> dfs ( tiles , W , H , x + dx , y + dy ) <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> W , H = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if W == 0 and H == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> tiles = [ [ c for c in input ( ) . split ( ) ] for h in range ( H ) ] <NEWLINE> cnt = 0 <NEWLINE> for h in range ( H ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if tiles [ h ] [ w ] == <STRING> : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> dfs ( tiles , W , H , w , h ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . getrecursionlimit ( 10000 ) <NEWLINE> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 1 << 32 ) <NEWLINE> def f ( x , y ) : <NEWLINE> <INDENT> a [ y ] [ x ] = <STRING> <NEWLINE> for dx , dy in [ [ - 1 , 0 ] , [ 1 , 0 ] , [ 0 , - 1 ] , [ 0 , 1 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] , [ 1 , 1 ] ] : <NEWLINE> <INDENT> dx += x ; dy += y <NEWLINE> if 0 <= dx < w and 0 <= dy < h and a [ dy ] [ dx ] == <STRING> : f ( dx , dy ) <NEWLINE> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : break <NEWLINE> a = [ list ( input ( ) . split ( ) ) for _ in [ 0 ] * h ] ; b = 0 <NEWLINE> for i in range ( w ) : <NEWLINE> <INDENT> for j in range ( h ) : <NEWLINE> <INDENT> if a [ j ] [ i ] == <STRING> : <NEWLINE> <INDENT> b += 1 ; f ( i , j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( b ) <NEWLINE> <DEDENT>
def travel ( here , lb , ub , field , label ) : <NEWLINE> <INDENT> if field [ here [ 1 ] ] [ here [ 0 ] ] == 1 : <NEWLINE> <INDENT> field [ here [ 1 ] ] [ here [ 0 ] ] = label <NEWLINE> if lb [ 0 ] < here [ 0 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] - 1 , here [ 1 ] ) , lb , ub , field , label ) <NEWLINE> if lb [ 1 ] < here [ 1 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] - 1 , here [ 1 ] - 1 ) , lb , ub , field , label ) <NEWLINE> <NL> <DEDENT> <DEDENT> if lb [ 1 ] < here [ 1 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] , here [ 1 ] - 1 ) , lb , ub , field , label ) <NEWLINE> if ub [ 0 ] > here [ 0 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] + 1 , here [ 1 ] - 1 ) , lb , ub , field , label ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ub [ 0 ] > here [ 0 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] + 1 , here [ 1 ] ) , lb , ub , field , label ) <NEWLINE> if ub [ 1 ] > here [ 1 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] + 1 , here [ 1 ] + 1 ) , lb , ub , field , label ) <NEWLINE> <NL> <DEDENT> <DEDENT> if ub [ 1 ] > here [ 1 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] , here [ 1 ] + 1 ) , lb , ub , field , label ) <NEWLINE> if lb [ 0 ] < here [ 0 ] : <NEWLINE> <INDENT> travel ( ( here [ 0 ] - 1 , here [ 1 ] + 1 ) , lb , ub , field , label ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( w , h ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> island = [ ] <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> island . append ( map ( int , raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> label = 1 <NEWLINE> for j in range ( h ) : <NEWLINE> <INDENT> for i in range ( w ) : <NEWLINE> <INDENT> if island [ j ] [ i ] == 1 : <NEWLINE> <INDENT> label += 1 <NEWLINE> travel ( ( i , j ) , ( 0 , 0 ) , ( w - 1 , h - 1 ) , island , label ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print label - 1 <NEWLINE> <DEDENT>
vx = [ 1 , - 1 , 0 , 0 , 1 , 1 , - 1 , - 1 ] <NEWLINE> vy = [ 0 , 0 , 1 , - 1 , 1 , - 1 , 1 , - 1 ] <NEWLINE> <NL> <NL> def dfs ( col , row ) : <NEWLINE> <INDENT> c [ col ] [ row ] = 0 <NEWLINE> for x , y in zip ( vx , vy ) : <NEWLINE> <INDENT> ny = col + y <NEWLINE> nx = row + x <NEWLINE> if nx < 0 or ny < 0 or nx >= w or ny >= h : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if c [ ny ] [ nx ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dfs ( ny , nx ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> c = [ ] <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> c . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> <NL> for col in range ( h ) : <NEWLINE> <INDENT> for row in range ( w ) : <NEWLINE> <INDENT> if c [ col ] [ row ] == 1 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> dfs ( col , row ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print cnt <NEWLINE> <DEDENT>
<NL> def visit ( x , y , area ) : <NEWLINE> <INDENT> move = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 1 ) , ( - 1 , 1 ) , ( - 1 , - 1 ) ] <NEWLINE> for i in move : <NEWLINE> <INDENT> if 0 <= ( x + i [ 0 ] ) < w and 0 <= ( y + i [ 1 ] ) < h and area [ y + i [ 1 ] ] [ x + i [ 0 ] ] == 1 : <NEWLINE> <INDENT> area [ y + i [ 1 ] ] [ x + i [ 0 ] ] = 0 <NEWLINE> visit ( x + i [ 0 ] , y + i [ 1 ] , area ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> area = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> area . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> if area [ i ] [ j ] == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> visit ( j , i , area ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> w , h = 0 , 0 <NEWLINE> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if w == 0 and h == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> solve ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def rec ( y , x , used , TILE ) : <NEWLINE> <INDENT> if ( not ( 0 <= x < W ) ) or ( not ( 0 <= y < H ) ) or ( TILE [ y ] [ x ] == 0 ) or ( used [ y ] [ x ] == 1 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> used [ y ] [ x ] = 1 <NEWLINE> rec ( y - 1 , x - 1 , used , TILE ) <NEWLINE> rec ( y - 1 , x , used , TILE ) <NEWLINE> rec ( y - 1 , x + 1 , used , TILE ) <NEWLINE> rec ( y , x - 1 , used , TILE ) <NEWLINE> rec ( y , x , used , TILE ) <NEWLINE> rec ( y , x + 1 , used , TILE ) <NEWLINE> rec ( y + 1 , x - 1 , used , TILE ) <NEWLINE> rec ( y + 1 , x , used , TILE ) <NEWLINE> rec ( y + 1 , x + 1 , used , TILE ) <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> ( W , H ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> while W != 0 : <NEWLINE> <INDENT> used = [ [ 0 ] * W for i in range ( H ) ] <NEWLINE> TILE = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> TILE . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> Sum = 0 <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> for j in range ( W ) : <NEWLINE> <INDENT> if used [ i ] [ j ] == 0 and TILE [ i ] [ j ] == 1 : <NEWLINE> <INDENT> Sum += rec ( i , j , used , TILE ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print Sum <NEWLINE> <COMMENT> <NL> <NL> ( W , H ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> def fill ( y , x ) : <NEWLINE> <INDENT> global w , h , l <NEWLINE> if 0 <= y < h and 0 <= x + 1 < w and l [ y ] [ x + 1 ] == 1 : <NEWLINE> <INDENT> l [ y ] [ x + 1 ] = 0 <NEWLINE> fill ( y , x + 1 ) <NEWLINE> <DEDENT> if 0 <= y < h and 0 <= x - 1 < w and l [ y ] [ x - 1 ] == 1 : <NEWLINE> <INDENT> l [ y ] [ x - 1 ] = 0 <NEWLINE> fill ( y , x - 1 ) <NEWLINE> <DEDENT> if 0 <= y + 1 < h and 0 <= x < w and l [ y + 1 ] [ x ] == 1 : <NEWLINE> <INDENT> l [ y + 1 ] [ x ] = 0 <NEWLINE> fill ( y + 1 , x ) <NEWLINE> <DEDENT> if 0 <= y - 1 < h and 0 <= x < w and l [ y - 1 ] [ x ] == 1 : <NEWLINE> <INDENT> l [ y - 1 ] [ x ] = 0 <NEWLINE> fill ( y - 1 , x ) <NEWLINE> <NL> <DEDENT> if 0 <= y + 1 < h and 0 <= x + 1 < w and l [ y + 1 ] [ x + 1 ] == 1 : <NEWLINE> <INDENT> l [ y + 1 ] [ x + 1 ] = 0 <NEWLINE> fill ( y + 1 , x + 1 ) <NEWLINE> <DEDENT> if 0 <= y - 1 < h and 0 <= x + 1 < w and l [ y - 1 ] [ x + 1 ] == 1 : <NEWLINE> <INDENT> l [ y - 1 ] [ x + 1 ] = 0 <NEWLINE> fill ( y - 1 , x + 1 ) <NEWLINE> <DEDENT> if 0 <= y + 1 < h and 0 <= x - 1 < w and l [ y + 1 ] [ x - 1 ] == 1 : <NEWLINE> <INDENT> l [ y + 1 ] [ x - 1 ] = 0 <NEWLINE> fill ( y + 1 , x - 1 ) <NEWLINE> <DEDENT> if 0 <= y - 1 < h and 0 <= x - 1 < w and l [ y - 1 ] [ x - 1 ] == 1 : <NEWLINE> <INDENT> l [ y - 1 ] [ x - 1 ] = 0 <NEWLINE> fill ( y - 1 , x - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if not w and not h : break <NEWLINE> l = [ map ( int , input ( ) . split ( ) ) for _ in range ( h ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> cds = [ [ i , j . index ( 1 ) ] for ( i , j ) in enumerate ( l ) if 1 in j ] <NEWLINE> if not cds : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y , x = cds [ 0 ] <NEWLINE> <DEDENT> l [ y ] [ x ] = 0 <NEWLINE> fill ( y , x ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT>
def dfs ( x , y ) : <NEWLINE> <INDENT> C [ y ] [ x ] = 0 <NEWLINE> for dx , dy in zip ( [ 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 ] , [ 0 , 1 , 1 , 1 , 0 , - 1 , - 1 , - 1 ] ) : <NEWLINE> <INDENT> if 0 <= x + dx < w and 0 <= y + dy < h and C [ y + dy ] [ x + dx ] == 1 : <NEWLINE> <INDENT> dfs ( x + dx , y + dy ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if w == h == 0 : break <NEWLINE> C = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( h ) ] <NEWLINE> <NL> ans = 0 <NEWLINE> for y in range ( h ) : <NEWLINE> <INDENT> for x in range ( w ) : <NEWLINE> <INDENT> if C [ y ] [ x ] == 1 : <NEWLINE> <INDENT> dfs ( x , y ) <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> ss = [ S ( ) for _ in range ( n ) ] <NEWLINE> cs = set ( ) <NEWLINE> nz = set ( ) <NEWLINE> for s in ss : <NEWLINE> <INDENT> cs |= set ( [ c for c in s ] ) <NEWLINE> if len ( s ) > 1 : <NEWLINE> <INDENT> nz . add ( s [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> l = len ( cs ) <NEWLINE> ci = { } <NEWLINE> cw = [ 0 ] * l <NEWLINE> for c , i in zip ( cs , range ( l ) ) : <NEWLINE> <INDENT> ci [ c ] = i <NEWLINE> if c in nz : <NEWLINE> <INDENT> nz . add ( i ) <NEWLINE> <DEDENT> <DEDENT> for s in ss [ : - 1 ] : <NEWLINE> <INDENT> w = 1 <NEWLINE> for c in s [ : : - 1 ] : <NEWLINE> <INDENT> cw [ ci [ c ] ] += w <NEWLINE> w *= 10 <NEWLINE> <DEDENT> <DEDENT> w = 1 <NEWLINE> for c in ss [ - 1 ] [ : : - 1 ] : <NEWLINE> <INDENT> cw [ ci [ c ] ] -= w <NEWLINE> w *= 10 <NEWLINE> <DEDENT> r = 0 <NEWLINE> lnz = l - 1 not in nz <NEWLINE> cw1 = cw [ - 1 ] <NEWLINE> for a in itertools . permutations ( range ( 10 ) , l - 1 ) : <NEWLINE> <INDENT> if 0 in a and a . index ( 0 ) in nz : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tw = 0 <NEWLINE> for i in range ( l - 1 ) : <NEWLINE> <INDENT> tw += cw [ i ] * a [ i ] <NEWLINE> <DEDENT> if tw == 0 : <NEWLINE> <INDENT> if cw1 == 0 : <NEWLINE> <INDENT> for i in range ( 1 , 10 ) : <NEWLINE> <INDENT> if i not in a : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if lnz and 0 not in a : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> continue <NEWLINE> <DEDENT> if cw1 == 0 or tw % cw1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> tk = - tw // cw1 <NEWLINE> if 0 < tk < 10 and tk not in a : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> return r <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
from fractions import gcd <NEWLINE> <NL> INF = 2 << 30 <NEWLINE> V = 1002 <NEWLINE> G = [ [ ] for _ in xrange ( V ) ] <NEWLINE> visited = [ False ] * V <NEWLINE> <NL> def add_edge ( fro , to , cap ) : <NEWLINE> <INDENT> G [ fro ] . append ( [ to , cap , len ( G [ to ] ) ] ) <NEWLINE> G [ to ] . append ( [ fro , 0 , len ( G [ fro ] ) - 1 ] ) <NEWLINE> <NL> <DEDENT> def dfs ( v , t , f ) : <NEWLINE> <INDENT> if v == t : <NEWLINE> <INDENT> return f <NEWLINE> <DEDENT> visited [ v ] = True <NEWLINE> for i , ( to , cap , rev ) in enumerate ( ( G [ v ] ) ) : <NEWLINE> <INDENT> if visited [ to ] or cap == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = dfs ( to , t , min ( f , cap ) ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> G [ v ] [ i ] [ 1 ] -= d <NEWLINE> G [ to ] [ rev ] [ 1 ] += d <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def max_flow ( s , t ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> for i in xrange ( V ) : <NEWLINE> <INDENT> visited [ i ] = False <NEWLINE> <DEDENT> f = dfs ( s , t , INF ) <NEWLINE> if f == 0 : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> flow += f <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( m , n ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> V = m + n + 2 <NEWLINE> G = [ [ ] for _ in xrange ( V ) ] <NEWLINE> visited = [ True ] * V <NEWLINE> data = [ ] <NEWLINE> while len ( data ) < n + m : <NEWLINE> <INDENT> data += map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> blue = data [ : m ] <NEWLINE> red = data [ m : ] <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> add_edge ( V - 2 , i , 1 ) <NEWLINE> <DEDENT> for i in xrange ( m , m + n ) : <NEWLINE> <INDENT> add_edge ( i , V - 1 , 1 ) <NEWLINE> <DEDENT> for i , b in enumerate ( blue ) : <NEWLINE> <INDENT> for j , r in enumerate ( red , m ) : <NEWLINE> <INDENT> if gcd ( b , r ) != 1 : <NEWLINE> <INDENT> add_edge ( i , j , 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print max_flow ( V - 2 , V - 1 ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> class Flow ( ) : <NEWLINE> <INDENT> def __init__ ( self , e , N ) : <NEWLINE> <INDENT> self . E = e <NEWLINE> self . N = N <NEWLINE> <NL> <DEDENT> def max_flow ( self , s , t ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> e = self . E <NEWLINE> <NL> def f ( c ) : <NEWLINE> <INDENT> v = self . v <NEWLINE> v [ c ] = 1 <NEWLINE> if c == t : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> for i in range ( self . N ) : <NEWLINE> <INDENT> if v [ i ] == 0 and e [ c ] [ i ] > 0 and f ( i ) > 0 : <NEWLINE> <INDENT> e [ c ] [ i ] -= 1 <NEWLINE> e [ i ] [ c ] += 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> self . v = [ 0 ] * self . N <NEWLINE> if f ( s ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r += 1 <NEWLINE> <NL> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( m , n ) : <NEWLINE> <INDENT> b = LI ( ) <NEWLINE> while len ( b ) < m : <NEWLINE> <INDENT> b += LI ( ) <NEWLINE> <DEDENT> r = LI ( ) <NEWLINE> while len ( r ) < n : <NEWLINE> <INDENT> r += LI ( ) <NEWLINE> <DEDENT> s = m + n + 2 <NEWLINE> e = [ [ 0 ] * s for _ in range ( s ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> e [ 0 ] [ i + 1 ] = 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> e [ m + i + 1 ] [ s - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if fractions . gcd ( b [ i ] , r [ j ] ) > 1 : <NEWLINE> <INDENT> e [ i + 1 ] [ m + j + 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> fl = Flow ( e , s ) <NEWLINE> <NL> return fl . max_flow ( 0 , s - 1 ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> m , n = LI ( ) <NEWLINE> if m == 0 and n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( m , n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> t = [ 0 ] <NEWLINE> y = [ 0 ] <NEWLINE> lst = list ( range ( N ) ) <NEWLINE> for k in lst [ 1 : ] : <NEWLINE> <INDENT> [ x , d ] = input ( ) . slice ( ) <NEWLINE> [ x , d ] = [ int ( x ) , int ( d ) ] <NEWLINE> if d == 0 : <NEWLINE> <INDENT> t = t + [ t [ x ] ] <NEWLINE> y = y + [ y [ x ] - 1 ] <NEWLINE> <DEDENT> if d == 1 : <NEWLINE> <INDENT> t = t + [ t [ x ] - 1 ] <NEWLINE> y = y + [ y [ x ] ] <NEWLINE> <DEDENT> if d == 2 : <NEWLINE> <INDENT> t = t + [ t [ x ] ] <NEWLINE> y = y + [ y [ x ] + 1 ] <NEWLINE> <DEDENT> if d == 3 : <NEWLINE> <INDENT> t = t + [ t [ x ] + 1 ] <NEWLINE> y = y + [ y [ x ] ] <NEWLINE> <DEDENT> <DEDENT> ht = 0 <NEWLINE> lt = 0 <NEWLINE> hy = 0 <NEWLINE> ly = 0 <NEWLINE> for f in range ( N ) : <NEWLINE> <INDENT> if ht < t [ f ] : <NEWLINE> <INDENT> ht += 1 <NEWLINE> <DEDENT> if lt > t [ f ] : <NEWLINE> <INDENT> lt -= 1 <NEWLINE> <DEDENT> if hy < y [ f ] : <NEWLINE> <INDENT> hy += 1 <NEWLINE> <DEDENT> if ly > y [ f ] : <NEWLINE> <INDENT> ly -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( ht - lt + 1 , hy - ly + 1 ) <NEWLINE> <DEDENT>
N = 1000000 <NEWLINE> <NL> N1 = [ i for i in range ( N + 40 ) ] <NEWLINE> N2 = [ i for i in range ( N + 40 ) ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> p = [ n * ( n + 1 ) * ( n + 2 ) // 6 for n in range ( 1 , 200 ) if n * ( n + 1 ) * ( n + 2 ) // 6 < N + 1 ] <NEWLINE> p2 = [ n * ( n + 1 ) * ( n + 2 ) // 6 for n in range ( 1 , 200 ) if n * ( n + 1 ) * ( n + 2 ) // 6 < N + 1 and n * ( n + 1 ) * ( n + 2 ) // 6 % 2 == 1 ] <NEWLINE> <COMMENT> <NL> for p_ in p : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> n = min ( p_ * 5 , N ) <NEWLINE> for j in range ( p_ , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if N1 [ j ] > N1 [ j - p_ ] + 1 : <NEWLINE> <INDENT> N1 [ j ] = N1 [ j - p_ ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> for p_ in p2 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> for j in range ( p_ , N ) : <NEWLINE> <INDENT> if N2 [ j ] > N2 [ j - p_ ] + 1 : <NEWLINE> <INDENT> N2 [ j ] = N2 [ j - p_ ] + 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( N1 [ n ] , N2 [ n ] ) <NEWLINE> <NL> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> rec = list ( range ( 1000000 ) ) <NEWLINE> odd_rec = rec . copy ( ) <NEWLINE> <NL> for i in range ( 2 , 181 ) : <NEWLINE> <INDENT> t = i * ( i + 1 ) * ( i + 2 ) // 6 <NEWLINE> if t % 2 == 0 : <NEWLINE> <INDENT> for i , tpl in enumerate ( zip ( rec [ t : ] , rec ) , start = t ) : <NEWLINE> <INDENT> a , b = tpl <NEWLINE> b += 1 <NEWLINE> if b < a : <NEWLINE> <INDENT> rec [ i ] = b <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> z_rec = zip ( rec [ t : ] , rec , odd_rec [ t : ] , odd_rec ) <NEWLINE> for i , tpl in enumerate ( z_rec , start = t ) : <NEWLINE> <INDENT> a , b , c , d = tpl <NEWLINE> b += 1 <NEWLINE> if b < a : <NEWLINE> <INDENT> rec [ i ] = b <NEWLINE> <DEDENT> d += 1 <NEWLINE> if d < c : <NEWLINE> <INDENT> odd_rec [ i ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> while n : <NEWLINE> <INDENT> print ( rec [ n ] , odd_rec [ n ] ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
import itertools <NEWLINE> <NL> P1 = [ p * ( p + 1 ) * ( p + 2 ) / 6 for p in range ( 1 , 181 ) ] <NEWLINE> P2 = [ p for p in P1 if p % 2 ] <NEWLINE> <NL> maxnum = 1000000 <NEWLINE> <NL> A1 = [ 999999 for x in range ( maxnum + 1 ) ] <NEWLINE> A2 = [ 999999 for x in range ( maxnum + 1 ) ] <NEWLINE> <NL> for X in [ [ P1 , A1 ] , [ P2 , A2 ] ] : <NEWLINE> <INDENT> P = X [ 0 ] <NEWLINE> A = X [ 1 ] <NEWLINE> tmp = P <NEWLINE> bk = 0 <NEWLINE> cnt = 2 <NEWLINE> for p in tmp : <NEWLINE> <INDENT> if p < maxnum : <NEWLINE> <INDENT> A [ p ] = 1 <NEWLINE> bk += 1 <NEWLINE> <DEDENT> <DEDENT> while bk < maxnum : <NEWLINE> <INDENT> tmp2 = [ ] <NEWLINE> for t in tmp : <NEWLINE> <INDENT> for p in P : <NEWLINE> <INDENT> if t + p > maxnum : break <NEWLINE> if A [ t + p ] > cnt : <NEWLINE> <INDENT> A [ t + p ] = cnt <NEWLINE> bk += 1 <NEWLINE> tmp2 . append ( t + p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> tmp = tmp2 [ : ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print A1 [ n ] , A2 [ n ] <NEWLINE> <NL> <DEDENT>
N = int ( raw_input ( ) ) <NEWLINE> D1 = 20 * 5 + 19 * 5 <NEWLINE> D2 = 20 * 10 <NEWLINE> <NL> for i in xrange ( N ) : <NEWLINE> <INDENT> y , m , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> if d != 1 : <NEWLINE> <INDENT> if y % 3 == 0 or m % 2 == 1 : <NEWLINE> <INDENT> last = 20 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> last = 19 <NEWLINE> <DEDENT> ans += last - d + 1 <NEWLINE> d = 1 <NEWLINE> if m < 10 : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y += 1 <NEWLINE> m = 1 <NEWLINE> <DEDENT> <DEDENT> if m != 1 : <NEWLINE> <INDENT> while m < 11 : <NEWLINE> <INDENT> if y % 3 == 0 or m % 2 == 1 : <NEWLINE> <INDENT> ans += 20j avascript : void ( 0 ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += 19 <NEWLINE> <DEDENT> m += 1 <NEWLINE> <DEDENT> m = 1 <NEWLINE> y += 1 <NEWLINE> <DEDENT> while y < 1000 : <NEWLINE> <INDENT> if y % 3 == 0 : <NEWLINE> <INDENT> ans += D2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += D1 <NEWLINE> <DEDENT> y += 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
import sys <NEWLINE> if sys . version_info [ 0 ] >= 3 : raw_input = input <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) ) <NEWLINE> a [ 0 ] -= 1 ; a [ 1 ] -= 1 <NEWLINE> print ( 196471 - a [ 0 ] * 195 - a [ 0 ] / 3 * 5 - a [ 1 ] * 20 + ( a [ 1 ] / 2 if a [ 0 ] % 3 != 2 else 0 ) - a [ 2 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a [ 0 ] -= 1 ; a [ 1 ] -= 1 <NEWLINE> print ( 196471 - a [ 0 ] * 195 - a [ 0 ] / 3 * 5 - a [ 1 ] * 20 + ( a [ 1 ] / 2 if a [ 0 ] % 3 != 2 else 0 ) - a [ 2 ] ) <NEWLINE> <DEDENT>
def datesOfTheYear ( year ) : <NEWLINE> <INDENT> if year % 3 == 0 : <NEWLINE> <INDENT> return 200 <NEWLINE> <DEDENT> return 195 <NEWLINE> <NL> <NL> <DEDENT> def datesOfTheMonth ( year , month ) : <NEWLINE> <INDENT> if year % 3 == 0 : <NEWLINE> <INDENT> return 20 <NEWLINE> <DEDENT> if month % 2 == 0 : <NEWLINE> <INDENT> return 19 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 20 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def datesFromBorn ( birthyear , birthmonth , birthdate ) : <NEWLINE> <INDENT> result = 0 <NEWLINE> for y in range ( birthyear + 1 , 1000 ) : <NEWLINE> <INDENT> result += datesOfTheYear ( y ) <NEWLINE> <DEDENT> for m in range ( birthmonth + 1 , 11 ) : <NEWLINE> <INDENT> result += datesOfTheMonth ( birthyear , m ) <NEWLINE> <DEDENT> result += datesOfTheMonth ( birthyear , birthmonth ) - birthdate + 1 <NEWLINE> return result <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> import fileinput <NEWLINE> <NL> fin = fileinput . input ( ) <NEWLINE> numberofcandidate = int ( fin . next ( ) . sprit ( ) ) <NEWLINE> <NL> for _ in range ( numberofcandidate ) : <NEWLINE> <INDENT> year , month , date = fin . next ( ) . strip ( ) . split ( ) <NEWLINE> print datesFromBorn ( year , month , date ) <NEWLINE> <NL> <DEDENT> sys . exit ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> if sys . version_info [ 0 ] >= 3 : raw_input = input <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> y , m , d = [ int ( e ) for e in raw_input ( ) . split ( ) ] <NEWLINE> y -= 1 ; m -= 1 <NEWLINE> print ( 196471 - y * 195 - y // 3 * 5 - m * 20 + ( m // 2 if y % 3 != 2 else 0 ) - a [ 2 ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> if sys . version_info [ 0 ] >= 3 : raw_input = input <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a [ 0 ] -= 1 ; a [ 1 ] -= 1 <NEWLINE> print ( 196471 - a [ 0 ] * 195 - a [ 0 ] / 3 * 5 - a [ 1 ] * 20 + ( a [ 1 ] / 2 if a [ 0 ] % 3 != 2 else 0 ) - a [ 2 ] ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> N , M , C , s , g = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> es = [ [ ] for i in xrange ( C ) ] <NEWLINE> for i in xrange ( M ) : <NEWLINE> <INDENT> x , y , d , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if not x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> es [ c - 1 ] . append ( ( x - 1 , y - 1 , d ) ) <NEWLINE> <DEDENT> P = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> Q = [ ] ; R = [ ] <NEWLINE> for i in xrange ( C ) : <NEWLINE> <INDENT> Q . append ( [ 0 ] + map ( int , raw_input ( ) . split ( ) ) + [ 10 ** 18 ] ) <NEWLINE> R . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> def calc ( c , z ) : <NEWLINE> <INDENT> p = P [ c ] ; q = Q [ c ] ; r = R [ c ] <NEWLINE> su = i = 0 <NEWLINE> while q [ i + 1 ] < z : <NEWLINE> <INDENT> su += ( q [ i + 1 ] - q [ i ] ) * r [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> return su + ( z - q [ i ] ) * r [ i ] <NEWLINE> <NL> <DEDENT> EA = { } <NEWLINE> INF = 10 ** 18 <NEWLINE> for c in xrange ( C ) : <NEWLINE> <INDENT> E = { ( i , i ) : 0 for i in xrange ( N ) } <NEWLINE> for x , y , d in es [ c ] : <NEWLINE> <INDENT> E [ x , y ] = min ( E . get ( ( x , y ) , INF ) , d ) <NEWLINE> <DEDENT> for k in xrange ( N ) : <NEWLINE> <INDENT> for i in xrange ( N ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , N ) : <NEWLINE> <INDENT> k1 = min ( ( i , k ) , ( k , i ) ) <NEWLINE> k2 = min ( ( k , j ) , ( j , k ) ) <NEWLINE> if k1 in E and k2 in E : <NEWLINE> <INDENT> E [ i , j ] = min ( E . get ( ( i , j ) , INF ) , E [ k1 ] + E [ k2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for ps in E : <NEWLINE> <INDENT> EA [ ps ] = min ( EA . get ( ps , INF ) , calc ( c , E [ ps ] ) ) <NEWLINE> <DEDENT> <DEDENT> for k in xrange ( N ) : <NEWLINE> <INDENT> for i in xrange ( N ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , N ) : <NEWLINE> <INDENT> k1 = min ( ( i , k ) , ( k , i ) ) <NEWLINE> k2 = min ( ( k , j ) , ( j , k ) ) <NEWLINE> if k1 in EA and k2 in EA : <NEWLINE> <INDENT> EA [ i , j ] = min ( EA . get ( ( i , j ) , INF ) , EA [ k1 ] + EA [ k2 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ps = min ( ( s - 1 , g - 1 ) , ( g - 1 , s - 1 ) ) <NEWLINE> print - 1 if ps not in EA else EA [ ps ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> class Dinic : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . g = [ [ ] for i in xrange ( n ) ] <NEWLINE> <DEDENT> def add_edge ( self , fr , to , cap ) : <NEWLINE> <INDENT> self . g [ fr ] . append ( [ to , cap , len ( self . g [ to ] ) ] ) <NEWLINE> self . g [ to ] . append ( [ fr , 0 , len ( self . g [ fr ] ) - 1 ] ) <NEWLINE> <DEDENT> def add_multi_edge ( self , v1 , v2 , cap1 , cap2 ) : <NEWLINE> <INDENT> self . g [ v1 ] . append ( [ v2 , cap1 , len ( self . g [ v2 ] ) ] ) <NEWLINE> self . g [ v2 ] . append ( [ v1 , cap2 , len ( self . g [ v1 ] ) - 1 ] ) <NEWLINE> <DEDENT> def bfs ( self , s ) : <NEWLINE> <INDENT> level = [ - 1 ] * self . n <NEWLINE> deq = deque ( ) <NEWLINE> level [ s ] = 0 <NEWLINE> deq . append ( s ) <NEWLINE> while deq : <NEWLINE> <INDENT> v = deq . popleft ( ) <NEWLINE> for e in self . g [ v ] : <NEWLINE> <INDENT> if e [ 1 ] > 0 and level [ e [ 0 ] ] < 0 : <NEWLINE> <INDENT> level [ e [ 0 ] ] = level [ v ] + 1 <NEWLINE> deq . append ( e [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> self . level = level <NEWLINE> <DEDENT> def dfs ( self , v , t , f ) : <NEWLINE> <INDENT> if v == t : return f <NEWLINE> es = self . g [ v ] <NEWLINE> level = self . level <NEWLINE> for i in xrange ( self . it [ v ] , len ( self . g [ v ] ) ) : <NEWLINE> <INDENT> e = es [ i ] <NEWLINE> if e [ 1 ] > 0 and level [ v ] < level [ e [ 0 ] ] : <NEWLINE> <INDENT> d = self . dfs ( e [ 0 ] , t , min ( f , e [ 1 ] ) ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> e [ 1 ] -= d <NEWLINE> self . g [ e [ 0 ] ] [ e [ 2 ] ] [ 1 ] += d <NEWLINE> self . it [ v ] = i <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> self . it [ v ] = len ( self . g [ v ] ) <NEWLINE> return 0 <NEWLINE> <DEDENT> def max_flow ( self , s , t ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> self . bfs ( s ) <NEWLINE> if self . level [ t ] < 0 : break <NEWLINE> self . it = [ 0 ] * self . n <NEWLINE> while True : <NEWLINE> <INDENT> f = self . dfs ( s , t , 10 ** 9 + 7 ) <NEWLINE> if f > 0 : <NEWLINE> <INDENT> flow += f <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return flow <NEWLINE> <NL> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> R = [ raw_input ( ) for i in xrange ( h ) ] <NEWLINE> <NL> conn = [ [ 0 for i in xrange ( w ) ] for i in xrange ( h ) ] <NEWLINE> <NL> P = [ ] <NEWLINE> Q = [ ] <NEWLINE> dep = 0 <NEWLINE> <NL> for i in xrange ( h - 1 ) : <NEWLINE> <INDENT> for j in xrange ( w - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> first = R [ i ] [ j : j + 2 ] ; second = R [ i + 1 ] [ j : j + 2 ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if ( first == <STRING> and second == <STRING> ) or ( first == <STRING> and second == <STRING> ) : <NEWLINE> <INDENT> k = j <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while k + 1 < w and R [ i ] [ k + 1 ] != <STRING> and R [ i + 1 ] [ k + 1 ] != <STRING> : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> if k + 1 < w and ( ( R [ i ] [ k + 1 ] == <STRING> ) ^ ( R [ i + 1 ] [ k + 1 ] == <STRING> ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> P . append ( ( ( i , j ) , ( i , k ) ) ) <COMMENT> <NEWLINE> conn [ i ] [ j ] += 1 <NEWLINE> conn [ i ] [ k ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if first in [ <STRING> , <STRING> ] and second == <STRING> : <NEWLINE> <INDENT> k = i <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> while k + 1 < h and R [ k + 1 ] [ j ] != <STRING> and R [ k + 1 ] [ j + 1 ] != <STRING> : <NEWLINE> <INDENT> k += 1 <NEWLINE> <DEDENT> if k + 1 < h and ( ( R [ k + 1 ] [ j ] == <STRING> ) ^ ( R [ k + 1 ] [ j + 1 ] == <STRING> ) ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> Q . append ( ( ( i , j ) , ( k , j ) ) ) <COMMENT> <NEWLINE> conn [ i ] [ j ] += 1 <NEWLINE> conn [ k ] [ j ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if first . count ( <STRING> ) + second . count ( <STRING> ) == 3 : <NEWLINE> <INDENT> dep += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> dinic = Dinic ( 2 + len ( P ) + len ( Q ) ) <NEWLINE> <COMMENT> <NL> for i in xrange ( len ( P ) ) : <NEWLINE> <INDENT> dinic . add_edge ( 0 , i + 2 , 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i in xrange ( len ( Q ) ) : <NEWLINE> <INDENT> dinic . add_edge ( len ( P ) + i + 2 , 1 , 1 ) <NEWLINE> <COMMENT> <NL> <DEDENT> for i , p in enumerate ( P ) : <NEWLINE> <INDENT> ( a , b ) , ( a , s ) = p <NEWLINE> for j , q in enumerate ( Q ) : <NEWLINE> <INDENT> ( c , d ) , ( t , d ) = q <NEWLINE> <NL> <COMMENT> <NL> if c <= a <= t and b <= d <= s : <NEWLINE> <INDENT> dinic . add_edge ( i + 2 , len ( P ) + j + 2 , 1 ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print dep - ( len ( P ) + len ( Q ) - dinic . max_flow ( 0 , 1 ) ) + 1 <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> M , T , P , R = map ( int , input ( ) . split ( ) ) <NEWLINE> if not M and not T and not P and not R : break <NEWLINE> d = { i : [ 0 , 0 ] for i in range ( 1 , T + 1 ) } <NEWLINE> wa = [ [ 0 for _ in range ( P ) ] for _ in range ( T ) ] <NEWLINE> for _ in range ( R ) : <NEWLINE> <INDENT> m , t , p , j = map ( int , input ( ) . split ( ) ) <NEWLINE> if j : <NEWLINE> <INDENT> wa [ t - 1 ] [ p - 1 ] += 20 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ t ] [ 0 ] += 1 <NEWLINE> d [ t ] [ 1 ] += ( m + wa [ t - 1 ] [ p - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> rank = sorted ( d . items ( ) , key = lambda x : ( x [ 1 ] [ 0 ] , - x [ 1 ] [ 1 ] ) , reverse = True ) <NEWLINE> f = lambda x : <STRING> . join ( sorted ( x , key = lambda y : int ( y ) , reverse = True ) ) <NEWLINE> l = [ ] <NEWLINE> b = [ ] <NEWLINE> for ( i , j ) in enumerate ( rank ) : <NEWLINE> <INDENT> if i > 0 and rank [ i ] [ 1 ] != rank [ i - 1 ] [ 1 ] : <NEWLINE> <INDENT> l . append ( f ( b ) ) <NEWLINE> b = [ ] <NEWLINE> <DEDENT> b . append ( str ( j [ 0 ] ) ) <NEWLINE> <DEDENT> if b : l . append ( f ( b ) ) <NEWLINE> print <STRING> . join ( l ) <NEWLINE> <NL> <DEDENT>
def solve ( a ) : <NEWLINE> <INDENT> if type ( a [ 0 ] ) is int : <NEWLINE> <INDENT> return sum ( sorted ( a ) [ : len ( a ) / 2 + 1 ] ) / 2 + len ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return sum ( sorted ( solve ( i ) for i in a ) ) [ : len ( a ) / 2 + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( input ( ) ) : <NEWLINE> <INDENT> A = eval ( raw_input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> print solve ( A ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> from collections import deque <NEWLINE> M = 10 ** 6 <NEWLINE> prime = [ 1 ] * ( M + 1 ) <NEWLINE> prime [ 0 ] = prime [ 1 ] = 0 <NEWLINE> for i in xrange ( 2 , int ( sqrt ( M ) ) + 1 ) : <NEWLINE> <INDENT> if prime [ i ] : <NEWLINE> <INDENT> for j in xrange ( i * i , M + 1 , i ) : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> P = { ( 0 , 0 ) : 1 } ; R = [ None , ( 0 , 0 ) ] <NEWLINE> c = 1 ; i = 1 ; p = 1 <NEWLINE> x = y = 0 <NEWLINE> while c < M : <NEWLINE> <INDENT> for j in xrange ( i ) : <NEWLINE> <INDENT> x += p ; c += 1 <NEWLINE> P [ x , y ] = c ; R . append ( ( x , y ) ) <NEWLINE> <DEDENT> for j in xrange ( i ) : <NEWLINE> <INDENT> y -= p ; c += 1 <NEWLINE> P [ x , y ] = c ; R . append ( ( x , y ) ) <NEWLINE> <DEDENT> p = - p <NEWLINE> i += 1 <NEWLINE> <DEDENT> deq = deque ( ) <NEWLINE> R = [ - 1 , 0 , 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m == n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> deq . append ( n ) <NEWLINE> cnts = { n : prime [ n ] } <NEWLINE> used = set ( ) <NEWLINE> while deq : <NEWLINE> <INDENT> v = deq . popleft ( ) <NEWLINE> x , y = R [ v ] <NEWLINE> for dx in R : <NEWLINE> <INDENT> t = P . get ( ( x + dx , y + 1 ) , M + 1 ) <NEWLINE> if t <= m : <NEWLINE> <INDENT> cnts [ t ] = max ( cnts [ v ] + prime [ t ] , cnts . get ( t , 0 ) ) <NEWLINE> if t not in used : <NEWLINE> <INDENT> deq . append ( t ) <NEWLINE> used . add ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> vals = sorted ( ( v , k ) for k , v in cnts . items ( ) if prime [ k ] ) <NEWLINE> print <STRING> % vals [ - 1 ] if vals else <STRING> <NEWLINE> <DEDENT>
def tax ( p , x ) : <NEWLINE> <INDENT> return p * ( 100 + x ) // 100 <NEWLINE> <DEDENT> def solve ( X , Y , S ) : <NEWLINE> <INDENT> for a in range ( 1 , S ) : <NEWLINE> <INDENT> for b in range ( 1 , S - a + 1 ) : <NEWLINE> <INDENT> sum = tax ( a , X ) + tax ( b , X ) <NEWLINE> if sum == S : <NEWLINE> <INDENT> NS = tax ( a , Y ) + tax ( b , Y ) <NEWLINE> if NS > A : <NEWLINE> <INDENT> A = NS <NEWLINE> <DEDENT> <DEDENT> if sum > S : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return A <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> X , Y , S = map ( int , input ( ) . split ( ) ) <NEWLINE> if X == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( solve ( X , Y , S ) ) <NEWLINE> <DEDENT>
def tax ( p , x ) : <NEWLINE> <INDENT> return p * ( 100 + x ) // 100 <COMMENT> <NEWLINE> <NL> <DEDENT> def solve ( X , Y , S ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> oldsum = 0 <NEWLINE> newsum = 0 <NEWLINE> for a in range ( 1 , S ) : <NEWLINE> <INDENT> for b in range ( 1 , S - a + 1 ) : <COMMENT> <NEWLINE> <INDENT> oldsum = tax ( a , X ) + tax ( b , X ) <COMMENT> <NEWLINE> if oldsum == S : <COMMENT> <NEWLINE> <INDENT> newsum = tax ( a , Y ) + tax ( b , Y ) <NEWLINE> if newsum > ans : <NEWLINE> <INDENT> ans = newsum <NEWLINE> <DEDENT> <DEDENT> if oldsum > S : <NEWLINE> <INDENT> break <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> X , Y , S = map ( int , input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( solve ( X , Y , S ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def ri ( ) : return int ( input ( ) ) <NEWLINE> def rli ( ) : return list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def tax ( p , rate ) : <NEWLINE> <INDENT> return math . floor ( p * ( 100 + rate ) / 100 ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> x , y , s = rli ( ) <NEWLINE> while ( x != 0 or y != 0 or s != 0 ) : <NEWLINE> <INDENT> for i in range ( 1 , 1000 ) : <NEWLINE> <INDENT> for j in range ( 1 , 1000 ) : <NEWLINE> <INDENT> if ( tax ( i , x ) + tax ( j , x ) == s ) : <NEWLINE> <INDENT> ans = max ( ans , tax ( i , y ) + tax ( j , y ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> ans = 0 <NEWLINE> x , y , s = rli ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> x , y , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if x == 0 and y == 0 and s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( 1 , s ) : <NEWLINE> <INDENT> for j in range ( 1 , s ) : <NEWLINE> <INDENT> a = i * ( 100 + x ) / 100 ; <NEWLINE> b = j * ( 100 + x ) / 100 ; <NEWLINE> <NL> if a + b != s : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> ans = max ( ans , i * ( 100 + y ) / 100 + j * ( 100 + y ) / 100 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ans <NEWLINE> <NL> <DEDENT>
ans = [ <STRING> ] <NEWLINE> ans . pop ( ) <NEWLINE> s = <STRING> <NEWLINE> w = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> x = [ 0 ] <NEWLINE> x . pop ( ) <NEWLINE> def uni ( seq ) : <NEWLINE> <INDENT> seen = set ( ) <NEWLINE> seen_add = seen . add <NEWLINE> return [ x for x in seq if x not in seen and not seen_add ( x ) ] <NEWLINE> <NL> <DEDENT> def check ( a ) : <NEWLINE> <INDENT> global s <NEWLINE> global w <NEWLINE> n = len ( a ) <NEWLINE> <COMMENT> <NL> for i in range ( 26 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> a = a . replace ( w [ i ] , w [ i - 1 ] , 1 ) ; <NEWLINE> <COMMENT> <NL> <DEDENT> if a == s [ 0 : n ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def foo ( a , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> global ans <NEWLINE> global x <NEWLINE> if n == len ( a ) : <NEWLINE> <INDENT> if check ( a ) : <NEWLINE> <INDENT> ans . append ( a ) <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> sz = len ( a ) <NEWLINE> t = a + s [ sz ] <NEWLINE> if check ( t ) : <NEWLINE> <INDENT> foo ( t , n ) <NEWLINE> <DEDENT> t = a + w [ x [ sz ] + 1 ] <NEWLINE> <COMMENT> <NL> if check ( t ) : <NEWLINE> <COMMENT> <NL> <INDENT> foo ( t , n ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = [ <STRING> ] <NEWLINE> ans . pop ( ) <NEWLINE> x = [ 0 ] <NEWLINE> x . pop ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> for j in range ( 26 ) : <NEWLINE> <INDENT> if w [ j ] == s [ i ] : <NEWLINE> <INDENT> x . append ( j ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> foo ( <STRING> , len ( s ) ) <NEWLINE> ans = uni ( ans ) <NEWLINE> if len ( ans ) <= 10 : <NEWLINE> <INDENT> print len ( ans ) <NEWLINE> for i in range ( len ( ans ) ) : <NEWLINE> <INDENT> print ans [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print len ( ans ) <NEWLINE> for i in range ( 5 ) : <NEWLINE> <INDENT> print ans [ i ] <NEWLINE> <DEDENT> for i in range ( 5 ) : <NEWLINE> <INDENT> print ans [ len ( ans ) - 1 - i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> def dfs ( start , turn = False ) : <NEWLINE> <INDENT> path = deque ( ) <NEWLINE> path . append ( start ) <NEWLINE> <NL> bridge_lengths = deque ( ) <NEWLINE> bridge_lengths . append ( 0 ) <NEWLINE> <NL> unvisited = [ True ] * ( n + 1 ) <NEWLINE> unvisited [ start ] = False <NEWLINE> <NL> rest = core_islands_num - 1 <NEWLINE> diameter = 0 <NEWLINE> end_point = start <NEWLINE> <NL> while True : <NEWLINE> <INDENT> u = path [ - 1 ] <NEWLINE> for i , d in adj_list [ u ] : <NEWLINE> <INDENT> if unvisited [ i ] : <NEWLINE> <INDENT> path . append ( i ) <NEWLINE> unvisited [ i ] = False <NEWLINE> rest -= 1 <NEWLINE> bridge_lengths . append ( d ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> distance = sum ( bridge_lengths ) <NEWLINE> if diameter < distance : <NEWLINE> <INDENT> diameter = distance <NEWLINE> end_point = u <NEWLINE> <DEDENT> if rest == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> path . pop ( ) <NEWLINE> bridge_lengths . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if turn : <NEWLINE> <INDENT> return diameter <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return end_point <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <COMMENT> <NL> file_input = open ( <STRING> , <STRING> ) <COMMENT> <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( file_input . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> p = list ( map ( int , file_input . readline ( ) . split ( ) ) ) <NEWLINE> d = list ( map ( int , file_input . readline ( ) . split ( ) ) ) <NEWLINE> <NL> end_bridges_weight = 0 <NEWLINE> core_islands_num = n <NEWLINE> adj_list = [ [ ] for i in range ( n + 1 ) ] <NEWLINE> s = 1 <NEWLINE> for i1 , i2 , b_l in zip ( range ( 2 , n + 1 ) , p , d ) : <NEWLINE> <INDENT> if i1 not in p [ i1 - 1 : ] : <NEWLINE> <INDENT> end_bridges_weight += b_l <NEWLINE> core_islands_num -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = i1 <NEWLINE> adj_list [ i1 ] . append ( ( i2 , b_l ) ) <NEWLINE> adj_list [ i2 ] . append ( ( i1 , b_l ) ) <NEWLINE> <DEDENT> <DEDENT> if p . count ( 1 ) == 1 : <NEWLINE> <INDENT> del adj_list [ 2 ] [ 0 ] <NEWLINE> end_bridges_weight += d [ 0 ] <NEWLINE> core_islands_num -= 1 <NEWLINE> <NL> <DEDENT> e = dfs ( s ) <NEWLINE> dm = dfs ( e , turn = True ) <NEWLINE> <NL> ans = sum ( d ) * 3 - end_bridges_weight * 2 - dm <NEWLINE> print ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
p = [ 1 ] * 100001 <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> for i in range ( 2 , int ( 100001 ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i : : i ] = [ 0 ] * len ( p [ 2 * i : : i ] ) <NEWLINE> <DEDENT> <DEDENT> p = [ i for i in range ( 100001 ) if p [ i ] ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> m , a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> <NL> aw = ah = 2 <NEWLINE> mx = 4 <NEWLINE> for w in p : <NEWLINE> <INDENT> for h in p : <NEWLINE> <INDENT> if w * h > m : break <NEWLINE> if w * h > mx and 1 >= w * 1.0 / h >= a * 1.0 / b : <NEWLINE> <INDENT> mx = w * h <NEWLINE> aw , ah = w , h <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print aw , ah <NEWLINE> <DEDENT>
import math <NEWLINE> def sieve ( n ) : <NEWLINE> <INDENT> prime = [ 0 , 0 ] <NEWLINE> prime += [ 1 for i in range ( n - 1 ) ] <NEWLINE> ub = math . sqrt ( n ) + 1 <NEWLINE> d = 2 <NEWLINE> while d <= ub : <NEWLINE> <INDENT> if prime [ d ] == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> continue <NEWLINE> <DEDENT> prod = 2 <NEWLINE> while d * prod <= n : <NEWLINE> <INDENT> prime [ d * prod ] = 0 <NEWLINE> prod += 1 <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> return prime <NEWLINE> <DEDENT> prime = sieve ( 1000 ) <NEWLINE> while 1 : <NEWLINE> <INDENT> m , a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( m , a , b ) == ( 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rect_max = ( 0 , 0 , 0 ) <NEWLINE> q = 997 <NEWLINE> while q >= 2 : <NEWLINE> <INDENT> if prime [ q ] == 0 : <NEWLINE> <INDENT> q -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> p = q <NEWLINE> while p * b >= q * a : <NEWLINE> <INDENT> if prime [ p ] == 0 or p * q > m : <NEWLINE> <INDENT> p -= 1 <NEWLINE> continue <NEWLINE> <DEDENT> if rect_max [ 0 ] <= p * q : <NEWLINE> <INDENT> rect_max = ( p * q , p , q ) <NEWLINE> <DEDENT> p -= 1 <NEWLINE> <DEDENT> q -= 1 <NEWLINE> <DEDENT> print rect_max [ 1 ] , rect_max [ 2 ] <NEWLINE> <DEDENT>
import itertools <NEWLINE> while 1 : <NEWLINE> <INDENT> t , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if t == 0 : break <NEWLINE> ans = s if s <= t else 0 <NEWLINE> s = str ( s ) <NEWLINE> nums = [ s ] if ans > 0 else [ ] <NEWLINE> n = len ( s ) <NEWLINE> reject = False <NEWLINE> for split in xrange ( 1 , n ) : <NEWLINE> <INDENT> for cuts in itertools . combinations ( range ( 1 , n ) , split ) : <NEWLINE> <INDENT> cuts = [ 0 ] + list ( cuts ) + [ n ] <NEWLINE> tmp = sum ( int ( s [ i : j ] ) for i , j in zip ( cuts , cuts [ 1 : ] ) ) <NEWLINE> if tmp == ans : reject = True <NEWLINE> elif t >= tmp > ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> nums = [ s [ i : j ] for i , j in zip ( cuts , cuts [ 1 : ] ) ] <NEWLINE> reject = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if reject : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> if len ( nums ) == 0 else ans , <STRING> . join ( nums ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> <NL> class UnionFind ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = list ( range ( n ) ) <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ x ] = self . find ( self . parent [ x ] ) <NEWLINE> return self . parent [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> <NL> if x == y : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . parent [ x ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> n , p1 , p2 = ( int ( s ) for s in input ( ) . split ( ) ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> p = p1 + p2 <NEWLINE> tree = UnionFind ( p * 2 ) <NEWLINE> unions = defaultdict ( list ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> xs , ys , a = input ( ) . split ( ) <NEWLINE> x , y = int ( xs ) - 1 , int ( ys ) - 1 <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> tree . unite ( x , y ) <NEWLINE> tree . unite ( x + p , y + p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . unite ( x , y + p ) <NEWLINE> tree . unite ( x + p , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( p ) : <NEWLINE> <INDENT> unions [ tree . find ( i ) ] . append ( i ) <NEWLINE> <DEDENT> roots = [ ] <NEWLINE> sides = [ ] <NEWLINE> diffs = [ ] <NEWLINE> rest = p1 <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> if i in unions : <NEWLINE> <INDENT> member_len , foelen = len ( unions [ i ] ) , len ( unions [ i + p ] ) <NEWLINE> if memlen == foelen : <NEWLINE> <INDENT> rest = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif memlen < foelen : <NEWLINE> <INDENT> diff = foelen - memlen <NEWLINE> rest -= memlen <NEWLINE> sides . append ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = memlen - foelen <NEWLINE> sides . append ( 1 ) <NEWLINE> rest -= foelen <NEWLINE> <DEDENT> roots . append ( i ) <NEWLINE> diffs . append ( diff ) <NEWLINE> <DEDENT> <DEDENT> if rest < 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> dp = [ [ 1 ] + [ 0 ] * rest for i in range ( len ( roots ) + 1 ) ] <NEWLINE> <NL> for i in reversed ( range ( len ( roots ) ) ) : <NEWLINE> <INDENT> for j in range ( 1 , rest + 1 ) : <NEWLINE> <INDENT> if j < diffs [ i ] : <NEWLINE> <INDENT> if dp [ i + 1 ] [ j ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if dp [ i + 1 ] [ j ] and dp [ i + 1 ] [ j - diffs [ i ] ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = 3 <NEWLINE> <DEDENT> elif dp [ i + 1 ] [ j - diffs [ i ] ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = 2 <NEWLINE> <DEDENT> elif dp [ i + 1 ] [ j ] : <NEWLINE> <INDENT> dp [ i ] [ j ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> divines = [ ] <NEWLINE> for i in range ( len ( roots ) ) : <NEWLINE> <INDENT> if dp [ i ] [ rest ] == 1 : <NEWLINE> <INDENT> divines . extend ( unions [ roots [ i ] + p * sides [ i ] ] ) <NEWLINE> <DEDENT> elif dp [ i ] [ rest ] == 2 : <NEWLINE> <INDENT> divines . extend ( unions [ roots [ i ] + p * ( 1 - sides [ i ] ) ] ) <NEWLINE> rest -= diffs [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> divines . sort ( ) <NEWLINE> for div in divines : <NEWLINE> <INDENT> print ( div + 1 ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
for loop in range ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> manu = raw_input ( ) <NEWLINE> msg = raw_input ( ) <NEWLINE> size = len ( msg ) <NEWLINE> <NL> for s in manu [ : : - 1 ] : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> msg = msg [ - 1 ] + msg [ : - 1 ] <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> msg = msg [ 1 : ] + msg [ 0 ] <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> msg = msg [ size / 2 + size % 2 : ] + msg [ : size / 2 ] <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> msg = msg [ : : - 1 ] <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> for i in range ( len ( msg ) ) : <NEWLINE> <INDENT> if msg [ i ] . isdigit ( ) : <NEWLINE> <INDENT> msg = msg [ : i ] + str ( ( int ( msg [ i ] ) - 1 + 10 ) % 10 ) + msg [ i + 1 : ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> for i in range ( len ( msg ) ) : <NEWLINE> <INDENT> if msg [ i ] . isdigit ( ) : <NEWLINE> <INDENT> msg = msg [ : i ] + str ( ( int ( msg [ i ] ) + 1 ) % 10 ) + msg [ i + 1 : ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print msg <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ub = int ( sqrt ( n ) ) <NEWLINE> square = [ i ** 2 for i in range ( 1 , ub + 1 ) ] <NEWLINE> square_sum = [ [ 0 for i in range ( n ) ] for j in range ( 2 ) ] <NEWLINE> count = 0 <NEWLINE> for k in range ( 1 , ub + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> if square [ k - 1 ] + square [ i - 1 ] <= n : <NEWLINE> <INDENT> square_sum [ 0 ] [ square [ k - 1 ] + square [ i - 1 ] - 1 ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 - square [ k - 1 ] ) : <NEWLINE> <INDENT> if square_sum [ 0 ] [ i - 1 ] >= 1 : <NEWLINE> <INDENT> square_sum [ 1 ] [ i - 1 + square [ k - 1 ] ] += square_sum [ 0 ] [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> count += square_sum [ 1 ] [ n - 1 - square [ k - 1 ] ] <NEWLINE> <DEDENT> print ( 1 if n == ub ** 2 else 0 ) + square_sum [ 0 ] [ n - 1 ] + square_sum [ 1 ] [ n - 1 ] + count <NEWLINE> <DEDENT>
def string_to_complex ( s ) : <NEWLINE> <INDENT> a , b , c , d = map ( int , s . split ( ) ) <NEWLINE> return ( a + b * 1j , c + d * 1j ) <NEWLINE> <NL> <DEDENT> def dot ( c1 , c2 ) : <NEWLINE> <INDENT> return c1 . real * c2 . real + c1 . imag * c2 . imag <NEWLINE> <NL> <DEDENT> def cross ( c1 , c2 ) : <NEWLINE> <INDENT> return c1 . real * c2 . imag - c1 . imag * c2 . real <NEWLINE> <NL> <DEDENT> def cross_point ( p1 , p2 , p3 , p4 ) : <NEWLINE> <INDENT> crs1 = cross ( p2 - p1 , p3 - p1 ) <NEWLINE> crs2 = cross ( p2 - p1 , p4 - p1 ) <NEWLINE> if crs1 == 0 and crs2 == 0 : <NEWLINE> <INDENT> if p1 == p3 or p1 == p4 : <NEWLINE> <INDENT> return p1 <NEWLINE> <DEDENT> elif p2 == p3 or p2 == p4 : <NEWLINE> <INDENT> return p2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> crs3 = cross ( p4 - p3 , p1 - p3 ) <NEWLINE> crs4 = cross ( p4 - p3 , p2 - p3 ) <NEWLINE> if crs1 * crs2 <= 0 and crs3 * crs4 <= 0 : <NEWLINE> <INDENT> base = p4 - p3 <NEWLINE> hypo1 = p1 - p3 <NEWLINE> hypo2 = p2 - p3 <NEWLINE> d1 = abs ( cross ( base , hypo1 ) ) / abs ( base ) <NEWLINE> d2 = abs ( cross ( base , hypo2 ) ) / abs ( base ) <NEWLINE> return p1 + d1 / ( d1 + d2 ) * ( p2 - p1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def contain ( polygon ) : <NEWLINE> <INDENT> flag = False <NEWLINE> for a , b in zip ( polygon [ 0 : ] , polygon [ 1 : ] + [ polygon [ 0 ] ] ) : <NEWLINE> <INDENT> if a . imag > b . imag : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if a . imag <= 0 and b . imag > 0 and cross ( a , b ) > 0 : <NEWLINE> <INDENT> flag = not flag <NEWLINE> <DEDENT> <DEDENT> return flag <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> def dfs_contain ( goal , edges , cross_points ) : <NEWLINE> <INDENT> cur_edge = edges [ - 1 ] <NEWLINE> for next_edge , next_cp in adj_edge [ cur_edge ] : <NEWLINE> <INDENT> if next_edge == goal : <NEWLINE> <INDENT> if contain ( cross_points + [ next_cp ] ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> elif next_edge not in edges and unchecked [ next_edge ] and DP [ next_edge ] : <NEWLINE> <INDENT> edges . append ( next_edge ) <NEWLINE> cross_points . append ( next_cp ) <NEWLINE> if dfs_contain ( goal , edges , cross_points ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> e = edges . pop ( ) <NEWLINE> DP [ e ] = False <NEWLINE> cross_points . pop ( ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> file_input = stdin . readlines ( ) <NEWLINE> <NL> from itertools import combinations <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( lines [ 0 ] ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> edges = enumerate ( map ( string_to_complex , lines [ 1 : 1 + n ] ) ) <NEWLINE> adj_edge = [ [ ] for i in range ( n ) ] <NEWLINE> <NL> for e1 , e2 in combinations ( edges , 2 ) : <NEWLINE> <INDENT> n1 , t1 = e1 <NEWLINE> n2 , t2 = e2 <NEWLINE> cp = cross_point ( * t1 , * t2 ) <NEWLINE> if cp : <NEWLINE> <INDENT> adj_edge [ n1 ] . append ( ( n2 , cp ) ) <NEWLINE> adj_edge [ n2 ] . append ( ( n1 , cp ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> for i , ae in enumerate ( adj_edge ) : <NEWLINE> <INDENT> if len ( ae ) == 1 : <NEWLINE> <INDENT> ne , cp = ae . pop ( ) <NEWLINE> adj_edge [ ne ] . remove ( ( i , cp ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> <NL> <DEDENT> <DEDENT> unchecked = [ True ] * n <NEWLINE> <NL> for e in range ( n ) : <NEWLINE> <INDENT> unchecked [ e ] = False <NEWLINE> DP = [ True ] * n <NEWLINE> if dfs_contain ( e , [ e ] , [ ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> del lines [ : 1 + n ] <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
r = 100001 <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> for i in range ( int ( r ** 0.5 ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i : : i ] = [ 0 for x in range ( 2 * i , r , i ) ] <NEWLINE> <DEDENT> <DEDENT> prime = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if p [ i ] : prime . append ( i ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ans = 0 <NEWLINE> i = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> s = 0 <NEWLINE> j = i <NEWLINE> while 1 : <NEWLINE> <INDENT> s += prime [ j ] <NEWLINE> if s >= n : <NEWLINE> <INDENT> if s == n : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> j += 1 <NEWLINE> <DEDENT> i += 1 <NEWLINE> if i > n : break <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
r = 10000 <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = p [ 1 ] = 0 <NEWLINE> for i in range ( int ( r ** 0.5 ) ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i : : i ] = [ 0 for x in range ( 2 * i , r , i ) ] <NEWLINE> <DEDENT> <DEDENT> prime = [ ] <NEWLINE> for i in range ( r ) : <NEWLINE> <INDENT> if p [ i ] : prime . append ( i ) <NEWLINE> <NL> <DEDENT> def solve ( n , k , i ) : <NEWLINE> <INDENT> if k == 0 : return 1 if n == 0 else 0 <NEWLINE> if n - k * prime [ i ] < 0 : return 0 <NEWLINE> return solve ( n - prime [ i ] , k - 1 , i + 1 ) + solve ( n , k , i + 1 ) <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if k * prime [ i ] > n : break <NEWLINE> ans += solve ( n - prime [ i ] , k - 1 , i + 1 ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
for i in range ( 2 , 1201 ) : <NEWLINE> <INDENT> for j in range ( 2 , int ( i ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if not i % j : break <NEWLINE> <DEDENT> else : p += [ i ] <NEWLINE> <DEDENT> dp = [ [ 0 ] * 1200 for _ in range ( 15 ) ] <NEWLINE> dp [ 0 ] [ 0 ] = 1 <NEWLINE> for x , y in enumerate ( p ) : <NEWLINE> <INDENT> for i in range ( min ( x + 1 , 14 ) , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( p [ x ] , 1200 ) : <NEWLINE> <INDENT> dp [ i ] [ j ] += dp [ i - 1 ] [ j - y ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> print ( dp [ k ] [ n ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> class Main ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> prime = self . sieve ( 1299709 ) <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if prime [ n ] : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lower = upper = n <NEWLINE> while not prime [ lower ] : <NEWLINE> <INDENT> lower -= 1 <NEWLINE> <DEDENT> while not prime [ upper ] : <NEWLINE> <INDENT> upper += 1 <NEWLINE> <DEDENT> print upper - lower <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def sieve ( self , n ) : <NEWLINE> <INDENT> f = [ True for i in xrange ( n + 1 ) ] <NEWLINE> f [ 0 ] = False <NEWLINE> f [ 1 ] = False <NEWLINE> i = 2 <NEWLINE> while i * i <= n : <NEWLINE> <INDENT> if f [ i ] : <NEWLINE> <INDENT> j = 2 <NEWLINE> while i * j <= n : <NEWLINE> <INDENT> f [ i * j ] = False <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return f <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m = Main ( ) <NEWLINE> m . solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> while True : <NEWLINE> <INDENT> ( n , w ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <NL> vcnt = [ 0 ] * 10 <NEWLINE> vr = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = int ( raw_input ( ) ) <NEWLINE> if v / w > vr : <NEWLINE> <INDENT> vr = v / w <NEWLINE> <DEDENT> vcnt [ v / w ] += 1 <NEWLINE> <NL> <DEDENT> vmax = max ( vcnt ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> ans += ( ( vr - i ) / float ( vr ) ) * ( vcnt [ i ] / float ( vmax ) ) <NEWLINE> <NL> <DEDENT> print ans + 0.01 <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> src = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> highest = max ( src ) <NEWLINE> bands = highest // W + 1 <NEWLINE> hist = [ 0 for i in range ( bands ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> hist [ src [ i ] // W ] += 1 <NEWLINE> <DEDENT> ans = maxn = 0 <NEWLINE> for i , n in enumerate ( hist ) : <NEWLINE> <INDENT> ans += n * ( bands - 1 - i ) <NEWLINE> maxn = max ( n , maxn ) <NEWLINE> <DEDENT> print ( ans * / maxn / ( bands - 1 ) + 0.01 ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> v = [ 0 ] * 10 <NEWLINE> m = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( raw_input ( ) ) / w <NEWLINE> v [ p ] += 1 <NEWLINE> m = max ( m , p ) <NEWLINE> <DEDENT> ans = 0.01 <NEWLINE> for i in range ( 10 ) : <NEWLINE> <INDENT> ans += ( v [ i ] * 1.0 / max ( v ) ) * ( 1 - i * 1.0 / m ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == w == 0 : break <NEWLINE> L = [ 0 ] * ( w + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = input ( ) <NEWLINE> L [ v / w ] += 1 <NEWLINE> <DEDENT> maxh = max ( L ) <NEWLINE> r = n - 1 <NEWLINE> while r > 0 and L [ r ] == 0 : <NEWLINE> <INDENT> r -= 1 <NEWLINE> <DEDENT> ink = 0.01 <NEWLINE> for i in range ( r + 1 ) : <NEWLINE> <INDENT> if r < > 0 : <NEWLINE> <INDENT> ink += float ( r - i ) / r * float ( L [ i ] ) / maxh <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ink += L [ i ] <NEWLINE> <DEDENT> <DEDENT> print ink <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lst = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = input ( ) <NEWLINE> num /= w <NEWLINE> lst . append ( num ) <NEWLINE> <NL> <DEDENT> ans = 0.0 <NEWLINE> cnt = [ 0 for i in range ( 100 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = max_num - lst [ i ] <NEWLINE> ans += num <NEWLINE> cnt [ num ] += 1 <NEWLINE> <NL> <DEDENT> print ans / max ( lst ) / max ( cnt ) + 0.01 <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> V = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> heappush ( V , int ( input ( ) ) ) <NEWLINE> maxV = V [ - 1 ] <NEWLINE> <NL> <DEDENT> histnum = maxV // w <NEWLINE> hist = [ ] <NEWLINE> for i in range ( histnum + 1 ) : <NEWLINE> <INDENT> hist . append ( [ ] ) <NEWLINE> <DEDENT> vl = len ( V ) <NEWLINE> for i in range ( vl ) : <NEWLINE> <INDENT> v = heappop ( V ) <NEWLINE> hist [ v // w ] . append ( v ) <NEWLINE> <NL> <DEDENT> highest = 0 <NEWLINE> for i in range ( len ( hist ) ) : <NEWLINE> <INDENT> highest = max ( highest , len ( hist [ i ] ) ) <NEWLINE> <DEDENT> ink = 0 <NEWLINE> for i in range ( len ( hist ) ) : <NEWLINE> <INDENT> ink += ( 1 - i / histnum ) * ( len ( hist [ i ] ) / highest ) <NEWLINE> <DEDENT> print ( ink ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ab = [ raw_input ( ) . split ( ) for i in xrange ( n ) ] <NEWLINE> s = raw_input ( ) <NEWLINE> g = raw_input ( ) <NEWLINE> que = [ [ s , 0 ] ] <NEWLINE> while que : <NEWLINE> <INDENT> c , i = que . pop ( 0 ) <NEWLINE> if c == g : <NEWLINE> <INDENT> print i <NEWLINE> break <NEWLINE> <DEDENT> for a , b in ab : <NEWLINE> <INDENT> cc = c . replace ( a , b ) <NEWLINE> if len ( cc ) > len ( g ) : continue <NEWLINE> que . append ( [ cc , i + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print - 1 <NEWLINE> <DEDENT> <DEDENT>
// C + + 11 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> using namespace std ; <NEWLINE> <NL> inline long long GetTSC ( ) { <NEWLINE> <INDENT> long long lo , hi ; <NEWLINE> asm volatile ( <STRING> : <STRING> ( lo ) , <STRING> ( hi ) ) ; <NEWLINE> return lo + ( hi << 32 ) ; <NEWLINE> <DEDENT> } <NEWLINE> inline double GetSeconds ( ) { <NEWLINE> <INDENT> return GetTSC ( ) / 2.8e9 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> const long inf = pow ( 10 , 15 ) ; <NEWLINE> int di [ ] = { - 1 , 0 , 1 , 0 } ; <NEWLINE> int dj [ ] = { 0 , 1 , 0 , - 1 } ; <NEWLINE> tuple < int , int > q [ 50 * 50 * 50 * 50 ] ; <NEWLINE> <NL> void solve ( ) { <NEWLINE> <INDENT> double starttime = GetSeconds ( ) ; <NEWLINE> while ( 1 ) { <NEWLINE> <INDENT> int w , h ; <NEWLINE> cin >> w >> h ; <NEWLINE> // cerr << w << <STRING> << h << endl ; <NEWLINE> if ( w == 0 & & h == 0 ) break ; <NEWLINE> int lp , ls , rp , rs ; <NEWLINE> bool lb [ 2500 ] = { } ; <NEWLINE> bool rb [ 2500 ] = { } ; <NEWLINE> bool f [ 2500 ] [ 2500 ] = { } ; <NEWLINE> for ( int i = 0 ; i < h ; i + + ) { <NEWLINE> <INDENT> string s ; <NEWLINE> cin >> s ; <NEWLINE> for ( int j = 0 ; j < w ; j + + ) { <NEWLINE> <INDENT> if ( s [ j ] == <STRING> ) lb [ i * w + j ] = 1 ; <NEWLINE> if ( s [ j ] == <STRING> ) lp = i * w + j ; <NEWLINE> if ( s [ j ] == <STRING> ) ls = i * w + j ; <NEWLINE> <DEDENT> } <NEWLINE> cin >> s ; <NEWLINE> for ( int j = 0 ; j < w ; j + + ) { <NEWLINE> <INDENT> if ( s [ j ] == <STRING> ) rb [ i * w + j ] = 1 ; <NEWLINE> if ( s [ j ] == <STRING> ) rp = i * w + j ; <NEWLINE> if ( s [ j ] == <STRING> ) rs = i * w + j ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> f [ ls ] [ rs ] = 1 ; <NEWLINE> int qi = 0 ; <NEWLINE> int qe = 1 ; <NEWLINE> q [ 0 ] = make_tuple ( ls , rs ) ; <NEWLINE> bool ff = 0 ; <NEWLINE> while ( qi < qe ) { <NEWLINE> <INDENT> int lt = get < 0 > ( q [ qi ] ) ; <NEWLINE> int rt = get < 1 > ( q [ qi ] ) ; <NEWLINE> int li = lt / w ; <NEWLINE> int lj = lt % w ; <NEWLINE> int ri = rt / w ; <NEWLINE> int rj = rt % w ; <NEWLINE> qi + + ; <NEWLINE> // cerr << <STRING> << qi << <STRING> << qe << <STRING> << li << <STRING> << lj << <STRING> << ri << <STRING> << rj << endl ; <NEWLINE> for ( int i = 0 ; i < 4 ; i + + ) { <NEWLINE> <INDENT> int nli = li + di [ i ] ; <NEWLINE> int nlj = lj + dj [ i ] ; <NEWLINE> int nri = ri + di [ i ] ; <NEWLINE> int nrj = rj - dj [ i ] ; <NEWLINE> if ( nli < 0 | | nli >= h | | nlj < 0 | | nlj >= w | | lb [ nli * w + nlj ] ) { <NEWLINE> <INDENT> nli = li ; <NEWLINE> nlj = lj ; <NEWLINE> <DEDENT> } <NEWLINE> if ( nri < 0 | | nri >= h | | nrj < 0 | | nrj >= w | | rb [ nri * w + nrj ] ) { <NEWLINE> <INDENT> nri = ri ; <NEWLINE> nrj = rj ; <NEWLINE> <DEDENT> } <NEWLINE> int nlt = nli * w + nlj ; <NEWLINE> int nrt = nri * w + nrj ; <NEWLINE> if ( nlt == lp & & nrt == rp ) { <NEWLINE> <INDENT> ff = 1 ; <NEWLINE> break ; <NEWLINE> <DEDENT> } <NEWLINE> if ( nlt == lp | | nrt == rp ) continue ; <NEWLINE> if ( f [ nlt ] [ nrt ] ) continue ; <NEWLINE> f [ nlt ] [ nrt ] = 1 ; <NEWLINE> q [ qe + + ] = make_tuple ( nlt , nrt ) ; <NEWLINE> <DEDENT> } <NEWLINE> if ( ff ) break ; <NEWLINE> <DEDENT> } <NEWLINE> if ( ff ) { <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> cout << <STRING> << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> // cerr << <STRING> << GetSeconds ( ) - starttime << endl ; <NEWLINE> <NL> return ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> solve ( ) ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> <NL>
while True : <NEWLINE> <INDENT> m , n = ( int ( s ) for s in raw_input ( ) . split ( ) ) <NEWLINE> if not m : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> objs = [ int ( raw_input ( ) , 2 ) for i in range ( n ) ] <NEWLINE> dp = [ [ 0 ] * ( 1 << m ) for i in range ( 1 << m ) ] <NEWLINE> bits = [ 1 << i for i in range ( m ) ] <NEWLINE> <NL> for mask in reversed ( range ( 1 << m ) ) : <NEWLINE> <INDENT> s = Counter ( obj & mask for obj in objs ) <NEWLINE> for mask0 , value in s . items ( ) : <NEWLINE> <INDENT> if value > 1 : <NEWLINE> <INDENT> dp [ mask ] [ mask0 ] = min ( max ( dp [ mask | b ] [ mask0 ] , <NEWLINE> <INDENT> dp [ mask | b ] [ mask0 | b ] ) + 1 <NEWLINE> for b in bits if not b & mask ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print dp [ 0 ] [ 0 ] <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> ans = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> group , name = raw_input ( ) . split ( <STRING> ) <NEWLINE> if i == 0 : first = group <NEWLINE> ans [ group ] = set ( name [ : - 1 ] . split ( <STRING> ) ) <NEWLINE> while 1 : <NEWLINE> <INDENT> for key in ans : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for key1 in ans : <NEWLINE> <INDENT> if key in ans [ key1 ] : <NEWLINE> <INDENT> ans [ key1 ] |= ans [ key ] <NEWLINE> ans [ key1 ] . discard ( key ) <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> del ans [ key ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : break <NEWLINE> <DEDENT> <DEDENT> print len ( ans [ first ] ) <NEWLINE> <DEDENT>
def dfs ( dg , gs , ms , v ) : <NEWLINE> <INDENT> me = ms [ v ] <NEWLINE> for i in xrange ( len ( me ) ) : <NEWLINE> <INDENT> if me [ i ] in dg : <NEWLINE> <INDENT> ret = dfs ( dg , gs , ms , gs . index ( me [ i ] ) ) <NEWLINE> for e in ret : <NEWLINE> <INDENT> if e not in dg [ gs [ v ] ] : <NEWLINE> <INDENT> dg [ gs [ v ] ] . append ( e ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if me [ i ] not in dg [ gs [ v ] ] : <NEWLINE> <INDENT> dg [ gs [ v ] ] . append ( me [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return dg [ gs [ v ] ] <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if not n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> gs = [ ] ; ms = [ ] <NEWLINE> dg = { } <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> g , m = raw_input ( ) . split ( <STRING> ) <NEWLINE> gs . append ( g ) ; ms . append ( m [ : - 1 ] . split ( <STRING> ) ) <NEWLINE> dg [ g ] = [ ] <NEWLINE> <NL> <DEDENT> dfs ( dg , gs , ms , 0 ) <NEWLINE> print len ( dg [ gs [ 0 ] ] ) <NEWLINE> <DEDENT>
from django . template . defaultfilters import first <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> first_group_menbers = set ( input ( ) [ : - 1 ] . split ( <STRING> ) [ 1 ] . split ( <STRING> ) ) <NEWLINE> <NL> d = { } <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> group , members = input ( ) [ : - 1 ] . split ( <STRING> ) <NEWLINE> d [ group ] = set ( members . split ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for group , members in d . items ( ) : <NEWLINE> <INDENT> if group in first_group_menbers : <NEWLINE> <INDENT> first_group_menbers . remove ( group ) <NEWLINE> for m in members : <NEWLINE> <INDENT> first_group_menbers . add ( m ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( len ( first_group_menbers ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> status = { } <NEWLINE> god_st = 0 <NEWLINE> res = { } <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> s = raw_input ( ) . split ( ) <NEWLINE> <COMMENT> <NL> h , m = map ( int , s [ 1 ] . split ( <STRING> ) ) <NEWLINE> mi = 60 * h + m <NEWLINE> st = s [ 2 ] == <STRING> <NEWLINE> ID = s [ 3 ] <NEWLINE> <NL> if ID == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> if st == 1 : <NEWLINE> <INDENT> god_st = mi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in status : <NEWLINE> <INDENT> if k != ID and status [ k ] != - 1 : <NEWLINE> <INDENT> res [ k ] = res . get ( k , 0 ) + ( mi - max ( god_st , status [ k ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if st == 1 : <NEWLINE> <INDENT> status [ ID ] = mi <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> status [ ID ] = - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print max ( res . values ( ) ) <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> exist = set ( [ ] ) <NEWLINE> enter = [ 0 ] * 1000 <NEWLINE> bless = [ 0 ] * 1000 <NEWLINE> for loop in xrange ( n ) : <NEWLINE> <INDENT> md , hm , io , p = raw_input ( ) . split ( ) <NEWLINE> h , m = map ( int , hm . split ( <STRING> ) ) <NEWLINE> t = 60 * h + m <NEWLINE> p = int ( p ) <NEWLINE> if io == <STRING> : <NEWLINE> <INDENT> time [ p ] = t <NEWLINE> exist . add ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> exist . remove ( p ) <NEWLINE> if p == 0 : <NEWLINE> <INDENT> for i in exist : bless [ i ] += t - max ( enter [ p ] , enter [ i ] ) <NEWLINE> <DEDENT> elif 0 in exist : <NEWLINE> <INDENT> bless [ p ] += t - max ( enter [ 0 ] , enter [ p ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print max ( bless ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> def _kosa ( a1 , a2 , b1 , b2 ) : <NEWLINE> <INDENT> x1 , y1 , _ = a1 <NEWLINE> x2 , y2 , _ = a2 <NEWLINE> x3 , y3 , _ = b1 <NEWLINE> x4 , y4 , _ = b2 <NEWLINE> <NL> tc = ( x1 - x2 ) * ( y3 - y1 ) + ( y1 - y2 ) * ( x1 - x3 ) <NEWLINE> td = ( x1 - x2 ) * ( y4 - y1 ) + ( y1 - y2 ) * ( x1 - x4 ) <NEWLINE> return tc * td < 0 <NEWLINE> <NL> <DEDENT> def kosa ( a1 , a2 , b1 , b2 ) : <NEWLINE> <INDENT> return _kosa ( a1 , a2 , b1 , b2 ) and _kosa ( b1 , b2 , a1 , a2 ) <NEWLINE> <NL> <NL> <DEDENT> def distance ( x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> return math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE> <NL> <DEDENT> def distance3 ( p1 , p2 , p3 ) : <NEWLINE> <INDENT> x1 , y1 , _ = p1 <NEWLINE> x2 , y2 , _ = p2 <NEWLINE> x3 , y3 , _ = p3 <NEWLINE> <NL> ax = x2 - x1 <NEWLINE> ay = y2 - y1 <NEWLINE> bx = x3 - x1 <NEWLINE> by = y3 - y1 <NEWLINE> <NL> r = ( ax * bx + ay * by ) / ( ax * ax + ay * ay ) <NEWLINE> if r <= 0 : <NEWLINE> <INDENT> return distance ( x1 , y1 , x3 , y3 ) <NEWLINE> <DEDENT> if r >= 1 : <NEWLINE> <INDENT> return distance ( x2 , y2 , x3 , y3 ) <NEWLINE> <DEDENT> return distance ( x1 + r * ax , y1 + r * ay , x3 , y3 ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> def f ( n ) : <NEWLINE> <INDENT> a = [ S ( ) for _ in range ( n ) ] <NEWLINE> b = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> f = True <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ i ] in a [ j ] : <NEWLINE> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> b . append ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> a = b <NEWLINE> n = len ( b ) <NEWLINE> d = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ai = a [ i ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> aj = a [ j ] <NEWLINE> for k in range ( 1 , min ( len ( ai ) , len ( aj ) ) ) : <NEWLINE> <INDENT> if ai [ - k : ] == aj [ : k ] : <NEWLINE> <INDENT> d [ i ] [ j ] = k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> fm = { } <NEWLINE> def _f ( aa ) : <NEWLINE> <INDENT> mc = 0 <NEWLINE> mi = mj = - 1 <NEWLINE> l = len ( aa ) <NEWLINE> aa . sort ( ) <NEWLINE> key = tuple ( map ( tuple , aa ) ) <NEWLINE> if key in fm : <NEWLINE> <INDENT> return fm [ key ] <NEWLINE> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> ai = aa [ i ] [ 1 ] <NEWLINE> for j in range ( l ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> aj = aa [ j ] [ 0 ] <NEWLINE> t = d [ ai ] [ aj ] <NEWLINE> if mc < t : <NEWLINE> <INDENT> mc = t <NEWLINE> mi = i <NEWLINE> mj = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if mc == 0 : <NEWLINE> <INDENT> fm [ key ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> ami = aa [ mi ] <NEWLINE> amj = aa [ mj ] <NEWLINE> ta = [ aa [ i ] for i in range ( l ) if i != mi and i != mj ] <NEWLINE> tm = mc + _f ( ta + [ [ ami [ 0 ] , amj [ 1 ] ] ] ) <NEWLINE> if d [ amj [ 1 ] ] [ ami [ 0 ] ] > 0 : <NEWLINE> <INDENT> tt = d [ amj [ 1 ] ] [ ami [ 0 ] ] + _f ( ta + [ [ amj [ 0 ] , ami [ 1 ] ] ] ) <NEWLINE> if tm < tt : <NEWLINE> <INDENT> tm = tt <NEWLINE> <DEDENT> <DEDENT> for i in range ( l ) : <NEWLINE> <INDENT> if i == mi or i == mj : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> ai = aa [ i ] [ 0 ] <NEWLINE> if d [ ami [ 1 ] ] [ ai ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( l ) : <NEWLINE> <INDENT> if j == mi or j == mj or i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> aj = aa [ j ] [ 1 ] <NEWLINE> if d [ aj ] [ amj [ 0 ] ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if d [ ami [ 1 ] ] [ ai ] + d [ aj ] [ amj [ 0 ] ] <= mc : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> b = [ aa [ ii ] for ii in range ( l ) if ii not in [ mi , mj , i , j ] ] <NEWLINE> tt = d [ ami [ 1 ] ] [ ai ] + d [ aj ] [ amj [ 0 ] ] + _f ( b + [ [ ami [ 0 ] , aa [ i ] [ 1 ] ] , [ aa [ j ] [ 0 ] , amj [ 1 ] ] ] ) <NEWLINE> if tm < tt : <NEWLINE> <INDENT> tm = tt <NEWLINE> <DEDENT> <DEDENT> <DEDENT> fm [ key ] = tm <NEWLINE> return tm <NEWLINE> <NL> <DEDENT> fr = _f ( [ [ i , i ] for i in range ( n ) ] ) <NEWLINE> return sum ( map ( len , a ) ) - fr <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = I ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rr . append ( f ( n ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> dup = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> si = S [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> sj = S [ j ] <NEWLINE> if si . find ( sj ) + 1 : <NEWLINE> <INDENT> dup [ j ] = 1 <NEWLINE> <DEDENT> if sj . find ( si ) + 1 : <NEWLINE> <INDENT> dup [ i ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> S = [ S [ i ] for i in range ( n ) if not dup [ i ] ] <NEWLINE> n -= sum ( dup ) <NEWLINE> <NL> P = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> D = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> si = S [ i ] <NEWLINE> l = len ( si ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> sj = S [ j ] <NEWLINE> pos = l <NEWLINE> for k in range ( l ) : <NEWLINE> <INDENT> if sj . startswith ( si [ k : ] ) : <NEWLINE> <INDENT> pos = k <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> P [ i ] [ j ] = len ( sj ) - ( l - pos ) <NEWLINE> D [ i ] [ j ] = l - pos <NEWLINE> <NL> <DEDENT> <DEDENT> Q = [ [ ] for i in range ( 300 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Q [ len ( S [ i ] ) ] . append ( ( 1 << i , i , 0 ) ) <NEWLINE> <DEDENT> ALL = 2 ** n - 1 <NEWLINE> up = sum ( map ( len , S ) ) <NEWLINE> border = up <NEWLINE> memo = { ( 1 << i , i ) : len ( S [ i ] ) for i in range ( n ) } <NEWLINE> l = 0 <NEWLINE> while l < border : <NEWLINE> <INDENT> for state , i , d in Q [ l ] : <NEWLINE> <INDENT> if memo [ state , i ] < l : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( state >> j ) & 1 < 1 : <NEWLINE> <INDENT> ncost = l + P [ i ] [ j ] <NEWLINE> nstate = state | ( 1 << j ) <NEWLINE> if ( nstate , j ) not in memo or ncost < memo [ nstate , j ] : <NEWLINE> <INDENT> border = min ( border , up - d - D [ i ] [ j ] ) <NEWLINE> if ncost <= border : <NEWLINE> <INDENT> memo [ nstate , j ] = ncost <NEWLINE> Q [ ncost ] . append ( ( nstate , j , d + D [ i ] [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> l += 1 <NEWLINE> <DEDENT> print ( border ) <NEWLINE> <DEDENT>
class WeightedUnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . par = [ i for i in range ( n + 1 ) ] <NEWLINE> self . rank = [ 0 ] * ( n + 1 ) <NEWLINE> self . weight = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . par [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . weight [ x ] += self . weight [ self . par [ x ] ] <NEWLINE> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def weighting ( self , x ) : <NEWLINE> <INDENT> self . find ( x ) <NEWLINE> return self . weight [ x ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def union ( self , x , y , w ) : <NEWLINE> <INDENT> w -= self . weighting ( x ) <NEWLINE> w += self . weighting ( y ) <NEWLINE> x = self . find ( x ) <NEWLINE> y = self . find ( y ) <NEWLINE> <NL> if self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> self . weight [ y ] = w <NEWLINE> self . par [ y ] = w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . weight [ y ] = - w <NEWLINE> self . par [ y ] = x <NEWLINE> if self . rank [ x ] == self . rank [ y ] : <NEWLINE> <INDENT> self . rank [ x ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def diff ( self , x , y ) : <NEWLINE> <INDENT> return self . weighting ( x ) - self . weighting ( y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> N , M = 1 , 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( N == 0 ) & ( M == 0 ) : <NEWLINE> <INDENT> quit ( ) <NEWLINE> <DEDENT> info = [ list ( input ( ) . split ( ) ) for i in range ( M ) ] <NEWLINE> wuf = WeightedUnionFind ( N ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if info [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> wuf . union ( int ( info [ i ] [ 1 ] ) , int ( info [ i ] [ 2 ] ) , int ( info [ i ] [ 3 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if wuf . same ( int ( info [ i ] [ 1 ] ) , int ( info [ i ] [ 2 ] ) ) : <NEWLINE> <INDENT> print ( wuf . diff ( int ( info [ i ] [ 1 ] ) , int ( info [ i ] [ 2 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , k , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( n , k , s ) == ( 0 , 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp = [ [ 0 for i in range ( s ) ] for j in range ( k ) ] <NEWLINE> for x in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( k - 1 ) : <NEWLINE> <INDENT> for i in range ( s - x ) : <NEWLINE> <INDENT> if dp [ j + 1 ] [ i ] >= 1 : <NEWLINE> <INDENT> dp [ j ] [ i + x ] += dp [ j + 1 ] [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dp [ k - 1 ] [ x - 1 ] = 1 <NEWLINE> <DEDENT> print dp [ 0 ] [ s - 1 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import itertools as it <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> S1 = raw_input ( ) <NEWLINE> S2 = raw_input ( ) <NEWLINE> <NL> m = { } <NEWLINE> <NL> for i in range ( len ( S1 ) ) : <NEWLINE> <INDENT> lst = [ 0 for j in range ( 26 ) ] <NEWLINE> for j in range ( i , len ( S1 ) ) : <NEWLINE> <INDENT> lst [ ( ord ( S1 [ j ] ) - ord ( <STRING> ) ) ] += 1 <NEWLINE> m [ tuple ( lst ) ] = j - i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> <NL> for i in range ( len ( S2 ) ) : <NEWLINE> <INDENT> lst = [ 0 for j in range ( 26 ) ] <NEWLINE> for j in range ( i , len ( S2 ) ) : <NEWLINE> <INDENT> lst [ ( ord ( S2 [ j ] ) - ord ( <STRING> ) ) ] += 1 <NEWLINE> t = tuple ( lst ) <NEWLINE> if t in m : <NEWLINE> <INDENT> ans = max ( ans , m [ t ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE>
import math <NEWLINE> def comb ( x , y ) : <NEWLINE> <INDENT> return factorial ( x ) // factorial ( x - y ) // factorial ( y ) <NEWLINE> <NL> <DEDENT> w , h , ax , ay , bx , by = map ( int , input ( ) . split ( ) ) <NEWLINE> dx = min ( w - abs ( ax - bx ) , abs ( ax - bx ) ) <NEWLINE> dy = min ( h - abs ( ay - by ) , abs ( ay - by ) ) <NEWLINE> ans = 1 <NEWLINE> if dx * 2 == w : ans *= 2 <NEWLINE> if dy * 2 == h : ans *= 2 <NEWLINE> ans *= comb ( dx + dy , dx ) <NEWLINE> print ( ans % 100000007 ) <NEWLINE>
<INDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> hl = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> hl . append ( int ( input ( ) ) ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> i = 0 <NEWLINE> ans = 1 <NEWLINE> <NL> <STRING> <NEWLINE> <NL> for i , h in enumerate ( hl ) : <COMMENT> <NEWLINE> <INDENT> d = i // 4 <NEWLINE> a = h - d <NEWLINE> if a < 0 : <NEWLINE> <INDENT> a = 0 <NEWLINE> <DEDENT> ans += a <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a , b , c , d , e = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> na , nb , nc = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> v = [ 0 ] * ( na + nb + nc ) <NEWLINE> for i in range ( na ) : <NEWLINE> <INDENT> v [ i ] = a <NEWLINE> <DEDENT> for i in range ( nb ) : <NEWLINE> <INDENT> v [ i + na ] = b <NEWLINE> <DEDENT> for i in range ( nc ) : <NEWLINE> <INDENT> v [ i + na + nb ] = c <NEWLINE> <DEDENT> t = na + nb + nc <NEWLINE> ans = na * a + nb * b + nc * c <NEWLINE> if t < d : <NEWLINE> <INDENT> if ans > d * e : <NEWLINE> <INDENT> ans = d * e <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> for i in range ( d ) : <NEWLINE> <INDENT> tmp += v [ len ( v ) - 1 - i ] <NEWLINE> <DEDENT> if tmp >= d * e : <NEWLINE> <INDENT> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> if e < v [ i ] : <NEWLINE> <INDENT> v [ i ] = e <NEWLINE> <DEDENT> <DEDENT> for i in range ( d ) : <NEWLINE> <INDENT> v [ len ( v ) - 1 - i ] = e <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> ans += v [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> mv = [ [ - 1 , - 1 , - 1 ] , [ - 1 , - 1 , 0 ] , [ - 1 , - 1 , 1 ] , [ - 1 , 0 , - 1 ] , [ - 1 , 0 , 0 ] , [ - 1 , 0 , 1 ] , [ - 1 , 1 , - 1 ] , [ - 1 , 1 , 0 ] , [ - 1 , 1 , 1 ] , <NEWLINE> <INDENT> [ 0 , - 1 , - 1 ] , [ 0 , - 1 , 0 ] , [ 0 , - 1 , 1 ] , [ 0 , 0 , - 1 ] , [ 0 , 0 , 1 ] , [ 0 , 1 , - 1 ] , [ 0 , 1 , 0 ] , [ 0 , 1 , 1 ] , <NEWLINE> [ 1 , - 1 , - 1 ] , [ 1 , - 1 , 0 ] , [ 1 , - 1 , 1 ] , [ 1 , 0 , - 1 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 1 ] , [ 1 , 1 , - 1 ] , [ 1 , 1 , 0 ] , [ 1 , 1 , 1 ] ] <NEWLINE> <NL> <DEDENT> cno = 0 <NEWLINE> arr = [ [ [ [ 0 for x in range ( 5 ) ] for y in range ( 5 ) ] for z in range ( 5 ) ] for k in range ( 2 ) ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> for z in range ( 5 ) : <NEWLINE> <INDENT> if z > 0 : input ( ) <NEWLINE> for y in range ( 5 ) : arr [ 0 ] [ z ] [ y ] = list ( map ( int , input ( ) ) ) <NEWLINE> <DEDENT> a , b = [ 0 ] * 27 , [ 0 ] * 27 <NEWLINE> ts = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for t in ts [ 1 : ] : a [ t ] = 1 <NEWLINE> ts = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for t in ts [ 1 : ] : b [ t ] = 1 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> for z in range ( 5 ) : <NEWLINE> <INDENT> for y in range ( 5 ) : <NEWLINE> <INDENT> for x in range ( 5 ) : <NEWLINE> <INDENT> s = 0 ; <NEWLINE> for i in range ( 26 ) : <NEWLINE> <INDENT> xx , yy , zz = x + mv [ i ] [ 0 ] , y + mv [ i ] [ 1 ] , z + mv [ i ] [ 2 ] <NEWLINE> if xx >= 0 and xx < 5 and yy >= 0 and yy < 5 and zz >= 0 and zz < 5 : <NEWLINE> <INDENT> s += arr [ j & 1 ] [ zz ] [ yy ] [ xx ] & 1 <NEWLINE> <DEDENT> <DEDENT> if arr [ j & 1 ] [ z ] [ y ] [ x ] & 1 : arr [ 1 - ( j & 1 ) ] [ z ] [ y ] [ x ] = b [ s ] <NEWLINE> else : arr [ 1 - ( j & 1 ) ] [ z ] [ y ] [ x ] = a [ s ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if cno : print ( ) <NEWLINE> cno += 1 <NEWLINE> print ( <STRING> , cno , <STRING> , sep = <STRING> ) <NEWLINE> for z in range ( 5 ) : <NEWLINE> <INDENT> if z > 0 : print ( ) <NEWLINE> for y in range ( 5 ) : print ( * arr [ n & 1 ] [ z ] [ y ] , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if not line : break <NEWLINE> data . append ( line ) <NEWLINE> <DEDENT> for answer in proc ( data ) : <NEWLINE> <INDENT> print answer <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def proc ( data ) : <NEWLINE> <INDENT> return [ passwd for passwd in data if is_hitofude ( passwd ) ] <NEWLINE> <NL> <DEDENT> def is_hitofude ( text ) : <NEWLINE> <INDENT> for first , second in get_pair ( text ) : <NEWLINE> <INDENT> if second == <STRING> : break <NEWLINE> if not _can_slide ( first , second ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def get_pair ( text ) : <NEWLINE> <INDENT> pair_list = list ( text ) <NEWLINE> pair_list . reverse ( ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if 2 <= len ( pair_list ) : <NEWLINE> <INDENT> yield ( pair_list . pop ( ) , pair_list [ - 1 ] ) <NEWLINE> <DEDENT> elif 1 == len ( pair_list ) : <NEWLINE> <INDENT> yield ( pair_list . pop ( ) , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> matrix = [ <STRING> , <NEWLINE> <INDENT> <STRING> , <NEWLINE> <STRING> ] <NEWLINE> <DEDENT> pair = [ ] <NEWLINE> for y , row in enumerate ( matrix ) : <NEWLINE> <INDENT> for x , base in enumerate ( row ) : <NEWLINE> <INDENT> if x + 1 < len ( row ) : pair . append ( ( base , row [ x + 1 ] ) ) <COMMENT> <NEWLINE> if 0 <= x - 1 : pair . append ( ( base , row [ x - 1 ] ) ) <COMMENT> <NEWLINE> if y + 1 < 3 : pair . append ( ( base , matrix [ y + 1 ] [ x ] ) ) <COMMENT> <NEWLINE> if 0 <= y - 1 : pair . append ( ( base , matrix [ y - 1 ] [ x ] ) ) <COMMENT> <NEWLINE> <NL> <DEDENT> <DEDENT> def _can_slide ( first , second ) : <NEWLINE> <INDENT> return ( first , second ) in pair <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ref = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> for i in range ( 1000 ) : <NEWLINE> <INDENT> p = raw_input ( ) <NEWLINE> for i in range ( len ( p ) - 1 ) : <NEWLINE> <INDENT> if p [ i + 1 ] not in ref [ p [ i ] ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print p <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> phrases = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> word = input ( ) . strip ( ) <NEWLINE> phrases . append ( word ) <NEWLINE> <NL> <DEDENT> PHRASE_LEN = [ 5 , 7 , 5 , 7 , 7 ] <NEWLINE> found_flag = False <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> acc_len = 0 <NEWLINE> phrase_idx = 0 <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> acc_len += len ( phrases [ j ] ) <NEWLINE> <NL> if acc_len == PHRASE_LEN [ phrase_idx ] : <NEWLINE> <INDENT> if phrase_idx == ( len ( PHRASE_LEN ) - 1 ) : <NEWLINE> <INDENT> found_flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> acc_len = 0 <NEWLINE> phrase_idx += 1 <NEWLINE> <DEDENT> elif acc_len > PHRASE_LEN [ phrase_idx ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if found_flag : <NEWLINE> <INDENT> print ( i + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT> ~ <NEWLINE> ~ <NEWLINE> ~ <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> li = [ input ( ) for i in range ( n ) ] <NEWLINE> index = 0 <NEWLINE> def pls ( depth ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> global index <NEWLINE> while len ( li [ index ] ) > depth and li [ index ] [ depth - 1 ] == <STRING> : <NEWLINE> <INDENT> if ( not li [ index ] [ depth ] == <STRING> ) and ( not li [ index ] [ depth ] == <STRING> ) : <NEWLINE> <INDENT> k += int ( li [ index ] [ depth ] ) <NEWLINE> if not index == n - 1 : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> <DEDENT> elif li [ index ] [ depth ] == <STRING> : <NEWLINE> <INDENT> index += 1 <NEWLINE> k += pls ( depth + 1 ) <NEWLINE> <DEDENT> elif li [ index ] [ depth ] == <STRING> : <NEWLINE> <INDENT> index += 1 <NEWLINE> k += prd ( depth + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> <DEDENT> def prd ( depth ) : <NEWLINE> <INDENT> k = 1 <NEWLINE> global index <NEWLINE> while len ( li [ index ] ) > depth and li [ index ] [ depth - 1 ] == <STRING> : <NEWLINE> <INDENT> if ( not li [ index ] [ depth ] == <STRING> ) and ( not li [ index ] [ depth ] == <STRING> ) : <NEWLINE> <INDENT> k *= int ( li [ index ] [ depth ] ) <NEWLINE> if not index == n - 1 : <NEWLINE> <INDENT> index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> <DEDENT> elif li [ index ] [ depth ] == <STRING> : <NEWLINE> <INDENT> index += 1 <NEWLINE> k *= pls ( depth + 1 ) <NEWLINE> <DEDENT> elif li [ index ] [ depth ] == <STRING> : <NEWLINE> <INDENT> index += 1 <NEWLINE> k *= prd ( depth + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return k <NEWLINE> <DEDENT> <DEDENT> if li [ 0 ] == <STRING> : <NEWLINE> <INDENT> index += 1 <NEWLINE> print ( pls ( 1 ) ) <NEWLINE> <DEDENT> elif li [ 0 ] == <STRING> : <NEWLINE> <INDENT> index += 1 <NEWLINE> print ( prd ( 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> a = [ input ( ) for _ in range ( n ) ] <NEWLINE> while True : <NEWLINE> <INDENT> if len ( a ) == 1 : break <NEWLINE> c = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if a [ i ] . count ( <STRING> ) > c : <NEWLINE> <INDENT> c = a [ i ] . count ( <STRING> ) <NEWLINE> s = i <NEWLINE> <DEDENT> <DEDENT> e = s <NEWLINE> while e < len ( a ) and a [ e ] . count ( <STRING> ) == a [ s ] . count ( <STRING> ) : <NEWLINE> <INDENT> e += 1 <NEWLINE> <DEDENT> k = a [ s - 1 ] . replace ( <STRING> , <STRING> ) <NEWLINE> b = [ a [ i ] for i in range ( s , e ) ] <NEWLINE> for i in range ( len ( b ) ) : <NEWLINE> <INDENT> b [ i ] = int ( b [ i ] . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT> if k == <STRING> : <NEWLINE> <INDENT> a [ s ] = <STRING> * a [ s ] . count ( <STRING> ) + str ( sum ( b ) ) <NEWLINE> del a [ s + 1 : e ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = 1 <NEWLINE> for i in b : <NEWLINE> <INDENT> m *= i <NEWLINE> <DEDENT> a [ s ] = <STRING> * a [ s ] . count ( <STRING> ) + str ( m ) <NEWLINE> del a [ s + 1 : e ] <NEWLINE> <DEDENT> <DEDENT> print ( a [ 0 ] ) <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = raw_input ( ) <NEWLINE> Q = set ( ) <NEWLINE> lock = 0 <NEWLINE> P = [ ] <NEWLINE> for c in s : <NEWLINE> <INDENT> if c is <STRING> : <NEWLINE> <INDENT> lock = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = ( lock , 1 << int ( c ) ) <NEWLINE> P . append ( v ) <NEWLINE> Q . add ( v ) <NEWLINE> lock |= 1 << int ( c ) <NEWLINE> <DEDENT> <DEDENT> i = 0 ; ok = 1 <NEWLINE> while i < len ( P ) and ok : <NEWLINE> <INDENT> lock1 , t1 = P [ i ] <NEWLINE> if lock1 & t1 == t1 : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> for j in xrange ( i ) : <NEWLINE> <INDENT> lock2 , t2 = P [ j ] <NEWLINE> if lock1 & lock2 == 0 and t1 & lock2 == t1 : <NEWLINE> <INDENT> if t2 & lock1 == t2 : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> v = ( lock1 | lock2 , t2 ) <NEWLINE> if v not in Q : <NEWLINE> <INDENT> P . append ( v ) <NEWLINE> Q . add ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print <STRING> * ok or <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 1000 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> j = a [ i + 1 ] - a [ i ] <NEWLINE> if j < ans : <NEWLINE> <INDENT> ans = j <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
flg = True <NEWLINE> while flg : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> flg = False <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = list ( ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( 0 , n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> l . append ( abs ( a [ i ] - a [ j ] ) ) <NEWLINE> <DEDENT> <DEDENT> if l == [ ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( min ( l ) ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> MAX = 7400000 <NEWLINE> prime = [ 1 ] * MAX <NEWLINE> prime [ 0 ] = prime [ 1 ] = 0 <NEWLINE> res = [ ] <NEWLINE> sq = int ( math . sqrt ( MAX ) ) <NEWLINE> for i in xrange ( 2 , sq + 1 ) : <NEWLINE> <INDENT> q = len ( res ) <NEWLINE> if prime [ i ] : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> for j in xrange ( i * i , MAX , i ) : <NEWLINE> <INDENT> prime [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> prime [ i ] = q <NEWLINE> <DEDENT> for i in xrange ( sq + 1 , MAX ) : <NEWLINE> <INDENT> q = len ( res ) <NEWLINE> if prime [ i ] : <NEWLINE> <INDENT> res . append ( i ) <NEWLINE> <DEDENT> prime [ i ] = q <NEWLINE> <NL> <DEDENT> def solve ( m , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> sat = [ 0 ] * ( m * m ) <NEWLINE> for i in xrange ( m , m * m ) : <NEWLINE> <INDENT> if not sat [ i ] : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> n -= 1 <NEWLINE> for j in xrange ( i , m * m , i ) : <NEWLINE> <INDENT> sat [ j ] = 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> idx = prime [ m * m ] <NEWLINE> print m * m , res [ idx ] <NEWLINE> return res [ idx + n ] <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> m , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print solve ( m , n ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> while 1 : <NEWLINE> <INDENT> n , k , s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> ps = [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( n ) ] <NEWLINE> <NL> G = [ [ ] for i in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> xi , yi , zi = ps [ i ] <NEWLINE> for j in xrange ( i + 1 , n ) : <NEWLINE> <INDENT> if i == j : continue <NEWLINE> xj , yj , zj = ps [ j ] <NEWLINE> <NL> dx = abs ( xi - xj ) <NEWLINE> dy = abs ( yi - yj ) <NEWLINE> dz = abs ( zi - zj ) <NEWLINE> <NL> if dx < s and dy < s and dz < s : <NEWLINE> <INDENT> cost = 2 * ( ( s - dx ) * ( s - dy ) + ( s - dy ) * ( s - dz ) + ( s - dz ) * ( s - dx ) ) <NEWLINE> G [ i ] . append ( ( j , cost ) ) <NEWLINE> G [ j ] . append ( ( i , cost ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = - 1 <NEWLINE> leaf = set ( ) <NEWLINE> used = [ 0 ] * n <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if len ( G [ i ] ) == 0 : <NEWLINE> <INDENT> if k == 1 : <NEWLINE> <INDENT> ans = 0 <NEWLINE> <DEDENT> used [ i ] = 1 <NEWLINE> <DEDENT> elif len ( G [ i ] ) == 1 : <NEWLINE> <INDENT> leaf . add ( i ) <NEWLINE> <DEDENT> <DEDENT> for v in leaf : <NEWLINE> <INDENT> if used [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ v ] = 1 <NEWLINE> prev = t = None <NEWLINE> deq = deque ( ) <NEWLINE> su = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if prev is not None and len ( G [ v ] ) == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for t , cost in G [ v ] : <NEWLINE> <INDENT> if t == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ t ] = 1 <NEWLINE> if len ( deq ) < k - 1 : <NEWLINE> <INDENT> deq . append ( cost ) <NEWLINE> su += cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> su -= deq . popleft ( ) <NEWLINE> deq . append ( cost ) <NEWLINE> su += cost <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if len ( deq ) == k - 1 : <NEWLINE> <INDENT> ans = max ( ans , su ) <NEWLINE> <DEDENT> v , prev = t , v <NEWLINE> <DEDENT> <DEDENT> for v in xrange ( n ) : <NEWLINE> <INDENT> if used [ v ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> prev = t = None <NEWLINE> used [ v ] = 1 <NEWLINE> u = set ( [ v ] ) <NEWLINE> while used [ v ] < 3 : <NEWLINE> <INDENT> for t , cost in G [ v ] : <NEWLINE> <INDENT> if t == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> used [ t ] += 1 <NEWLINE> u . add ( t ) <NEWLINE> break <NEWLINE> <DEDENT> v , prev = t , v <NEWLINE> <DEDENT> cont = k if len ( u ) == k else k - 1 <NEWLINE> prev = t = None <NEWLINE> deq = deque ( ) ; su = 0 <NEWLINE> for i in xrange ( 2 * len ( u ) ) : <NEWLINE> <INDENT> for t , cost in G [ v ] : <NEWLINE> <INDENT> if t == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if len ( deq ) < cont : <NEWLINE> <INDENT> deq . append ( cost ) <NEWLINE> su += cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> su -= deq . popleft ( ) <NEWLINE> su += cost <NEWLINE> deq . append ( cost ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if len ( deq ) == cont : <NEWLINE> <INDENT> ans = max ( ans , su ) <NEWLINE> <DEDENT> v , prev = t , v <NEWLINE> <NL> <DEDENT> <DEDENT> if ans == - 1 : <NEWLINE> <INDENT> print - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 6 * k * s * s - ans <NEWLINE> <DEDENT> <DEDENT>
<NL> while true : <NEWLINE> <INDENT> ( n , m ) = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> is = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> best = max [ is [ i ] + is [ j ] if not ( i == j ) and is [ i ] + is [ j ] <= k else - 1 for i in range ( 0 : n ) for j in range ( 0 : n ) ] <NEWLINE> if ( best < 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( best ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = sorted ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> index = bisect . bisect_left ( a , m ) - 1 <NEWLINE> if index <= 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( index , 0 , - 1 ) : <NEWLINE> <INDENT> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] + a [ j ] <= m : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] + a [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
maxs = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> max = - 1 <NEWLINE> <NL> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = b [ 0 ] <NEWLINE> m = b [ 1 ] <NEWLINE> if ( n == 0 and m == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> sum = a [ i ] + a [ j ] <NEWLINE> if ( sum > max and sum = < m ) : <NEWLINE> <INDENT> max = sum <NEWLINE> <DEDENT> <DEDENT> <DEDENT> maxs . append ( max ) <NEWLINE> <NL> <DEDENT> for i in maxs : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<NL> A = map ( int , input ( ) . split ( ) ) <NEWLINE> n = int ( A [ 0 ] ) <NEWLINE> m = int ( A [ 1 ] ) <NEWLINE> <NL> <NL> max = [ ] <NEWLINE> k = 0 <NEWLINE> while n > 0 and m > 0 : <NEWLINE> <INDENT> B = [ 0 for i in range ( n ) ] <NEWLINE> B = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B [ i ] = int ( B [ i ] ) <NEWLINE> <DEDENT> ma = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> x = B [ i ] + B [ j ] <NEWLINE> if ma < x and x <= m : <NEWLINE> <INDENT> ma = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> max . append ( ma ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> n = int ( A [ 0 ] ) <NEWLINE> m = int ( A [ 1 ] ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> if max [ i ] > 0 : <NEWLINE> <INDENT> print ( max [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
s = [ ] <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> max = 0 <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> for i in range ( len ( l ) ) : <NEWLINE> <INDENT> for j in range ( len ( l ) ) : <NEWLINE> <INDENT> if max < l [ i ] + l [ j ] and i != j and m >= l [ i ] + l [ j ] : <NEWLINE> <INDENT> max = l [ i ] + l [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if max == 0 : <NEWLINE> <INDENT> s += [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += [ max ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for x in s : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <NL> <DEDENT>
A = [ 0 for i in range ( 2 ) ] <NEWLINE> A = ( int , input ( ) . split ( ) ) <NEWLINE> n = A [ 0 ] <NEWLINE> m = A [ 1 ] <NEWLINE> max = [ ] <NEWLINE> k = 0 <NEWLINE> <NL> while n > 0 and m > 0 : <NEWLINE> <INDENT> B = [ 0 for i in range ( n ) ] <NEWLINE> B = input ( ) . split ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B [ i ] = int ( B [ i ] ) <NEWLINE> <DEDENT> ma = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> x = B [ i ] + B [ j ] <NEWLINE> if ma < x and x <= m : <NEWLINE> <INDENT> ma = x <NEWLINE> <DEDENT> <DEDENT> <DEDENT> max . append ( ma ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> n = int ( A [ 0 ] ) <NEWLINE> m = int ( A [ 1 ] ) <NEWLINE> k += 1 <NEWLINE> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> if max [ i ] > 0 : <NEWLINE> <INDENT> print ( max [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if n == 0 and m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> a = [ int ( raw_input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> ans = - 1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ i ] + a [ j ] <= m : <NEWLINE> <INDENT> ans = max ( ans , a [ i ] + a [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print <STRING> if ans == - 1 else ans <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> s1 = input ( ) . split ( <STRING> ) <NEWLINE> if s1 == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s2 = input ( ) . split ( <STRING> ) <NEWLINE> <NL> cnt1 = 0 <NEWLINE> cnt2 = 0 <NEWLINE> i = 0 <NEWLINE> <NL> if len ( s1 ) != len ( s2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while i < len ( s1 ) : <NEWLINE> <INDENT> if s1 [ i ] == s2 [ i ] : <NEWLINE> <INDENT> cnt1 += 1 <NEWLINE> <DEDENT> elif s1 [ i ] != s2 [ i ] and i % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif s1 [ i ] != s2 [ i ] and i % 2 != 0 : <NEWLINE> <INDENT> cnt2 += 1 <NEWLINE> if cnt2 > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if cnt2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if cnt1 == len ( s1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
s = [ ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> l1 = list ( input ( ) . split ( ) ) <NEWLINE> if l1 == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l2 = list ( input ( ) . split ( ) ) <NEWLINE> <NL> if l1 == l2 : <NEWLINE> <INDENT> s += [ <STRING> ] <NEWLINE> <DEDENT> elif len ( set ( l1 + l2 ) ) == 1 : <NEWLINE> <INDENT> s += [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += [ <STRING> ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
while ( 1 ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if ( a == <STRING> ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = input ( ) <NEWLINE> n = len ( a ) <NEWLINE> m = len ( b ) <NEWLINE> l = 0 ; <NEWLINE> flag = 0 <NEWLINE> idx_dif = 0 <NEWLINE> error_cou = 0 <NEWLINE> <NL> while ( 1 ) : <NEWLINE> <INDENT> if ( l >= n - 1 or l + idx_dif >= m - 1 ) : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <NL> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> for i in range ( l , n ) : <NEWLINE> <INDENT> if ( a [ i ] == <STRING> ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( i + idx_dif < m ) : <NEWLINE> <INDENT> if ( a [ l : i ] == b [ l + idx_dif : i + idx_dif ] ) : <NEWLINE> <INDENT> l = i + 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> elif ( i == n - 1 ) : <NEWLINE> <INDENT> if ( a [ l : i ] != b [ l + idx_dif : m - 1 ] ) : <NEWLINE> <INDENT> flag = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = n - 1 <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> if ( flag != 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> elif ( flag == 1 ) : <NEWLINE> <INDENT> for i in range ( l , n ) : <NEWLINE> <INDENT> if ( a [ i ] == <STRING> ) : <NEWLINE> <INDENT> for j in range ( l + idx_dif , m ) : <NEWLINE> <INDENT> if ( b [ j ] == <STRING> ) : <NEWLINE> <INDENT> if ( a [ l : i ] != b [ l + idx_dif : j ] ) : <NEWLINE> <INDENT> error_cou += 1 <NEWLINE> <DEDENT> idx_dif = j - i <NEWLINE> l = i + 1 <NEWLINE> flag = 0 <NEWLINE> break <NEWLINE> <DEDENT> if ( j == m - 1 ) : <NEWLINE> <INDENT> flag = 2 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( flag != 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( flag == 2 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( l >= n - 1 or l + idx_dif >= m - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if ( error_cou >= 2 or flag == 2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( error_cou == 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( error_cou == 0 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> while ( True ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> tmp = 0 <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> aL = len ( a ) <NEWLINE> b = input ( ) . split ( <STRING> ) <NEWLINE> bL = len ( b ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if aL != bL : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( True ) : <NEWLINE> <INDENT> if a [ i ] != b [ i ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> elif i > aL - 2 : <NEWLINE> <INDENT> if tmp == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> elif a [ i + 1 ] != b [ i + 1 ] : <NEWLINE> <INDENT> if tmp == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> else : tmp = 1 <NEWLINE> <DEDENT> i += 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> s1 = input ( ) . split ( <STRING> ) <NEWLINE> if s1 [ 0 ] == <STRING> : break <NEWLINE> s2 = input ( ) . split ( <STRING> ) <NEWLINE> <NL> jdg = 1 <NEWLINE> cnt_d = <NEWLINE> <NL> if len ( s1 ) != len ( s2 ) : print ( <STRING> ) <NEWLINE> else : <NEWLINE> <INDENT> l = len ( s1 ) <NEWLINE> i = 0 <NEWLINE> while i < l : <NEWLINE> <INDENT> if s1 [ i ] != s2 [ i ] : <NEWLINE> <INDENT> cnt_d += 1 <NEWLINE> if cnt_d == 1 and i % 2 == 1 : <NEWLINE> <INDENT> jdg = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> jdg = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if jdg == 1 and cnt_d == 1 : print ( <STRING> ) <NEWLINE> elif jdg == 0 or cnt_d > 1 : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> list1 = input ( ) . split ( <STRING> ) <NEWLINE> if list1 [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> list2 = input ( ) . split ( <STRING> ) <NEWLINE> <NL> c1 = 0 <NEWLINE> c2 = 0 <NEWLINE> flag = 0 <NEWLINE> <NL> if len ( list1 ) != len ( list2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 0 <NEWLINE> while i < len ( list1 ) : <NEWLINE> <INDENT> if list1 [ i ] == list2 [ i ] : <NEWLINE> <INDENT> c1 += 1 <NEWLINE> <DEDENT> elif i % 2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c2 += 1 <NEWLINE> if c2 > 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if flag == 0 and t2 == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if c1 == len ( list1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> s1 = input ( ) . split ( <STRING> ) <NEWLINE> if s1 is <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s2 = input ( ) . split ( <STRING> ) <NEWLINE> if len ( s1 ) != len ( s2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <DEDENT> r = [ 0 ] * 2 <NEWLINE> for i in range ( len ( s1 ) ) : <NEWLINE> <INDENT> if s1 [ i ] != s2 [ i ] : <NEWLINE> <INDENT> r [ i % 2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> if [ 0 , 1 ] < r : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( [ <STRING> , <STRING> ] [ r [ 1 ] ] ) <NEWLINE> <DEDENT> <DEDENT>
results = [ ] <NEWLINE> while 1 : <NEWLINE> <INDENT> a = input ( ) . split ( <STRING> ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = input ( ) . split ( <STRING> ) <NEWLINE> count1 = 0 <NEWLINE> count2 = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if ( i % 2 == 1 ) : <NEWLINE> <INDENT> for ( k , l ) in zip ( a [ i ] , b [ i ] ) : <NEWLINE> <INDENT> if ( k != l ) : <NEWLINE> <INDENT> count1 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for k , l in zip ( a [ i ] , b [ i ] ) : <NEWLINE> <INDENT> if ( k != l ) : <NEWLINE> <INDENT> count2 += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( a ) != len ( b ) : <NEWLINE> <INDENT> results . append ( 2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if count1 == 0 and count2 == 0 : <NEWLINE> <INDENT> results . append ( 0 ) <NEWLINE> <DEDENT> elif count1 == 1 and count2 == 0 : <NEWLINE> <INDENT> results . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> results . append ( 2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in results : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if i == 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> d , w = map ( int , input ( ) . split ( ) ) <NEWLINE> if d == w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> E = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( d ) ] <NEWLINE> a = 0 <NEWLINE> for x2 in range ( d ) : <NEWLINE> <INDENT> for y2 in range ( w ) : <NEWLINE> <INDENT> for x1 in range ( x2 - 1 ) : <NEWLINE> <INDENT> for y1 in range ( y2 - 1 ) : <NEWLINE> <INDENT> co = 10 ** 18 <NEWLINE> for x in range ( x1 , x2 + 1 ) : <NEWLINE> <INDENT> co = min ( co , E [ x ] [ y1 ] , E [ x ] [ y2 ] ) <NEWLINE> <DEDENT> for y in range ( y1 , y2 + 1 ) : <NEWLINE> <INDENT> co = min ( co , E [ x1 ] [ y ] , E [ x2 ] [ y ] ) <NEWLINE> <DEDENT> ci = cnt = 0 <NEWLINE> for x in range ( x1 + 1 , x2 ) : <NEWLINE> <INDENT> for y in range ( y1 + 1 , y2 ) : <NEWLINE> <INDENT> ci = max ( ci , E [ x ] [ y ] ) <NEWLINE> cnt += E [ x ] [ y ] <NEWLINE> <DEDENT> <DEDENT> if ci < co : <NEWLINE> <INDENT> a = max ( ans , ( x2 - x1 - 1 ) * ( y2 - y1 - 1 ) * co - cnt ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> total = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> total += i <NEWLINE> <NL> <DEDENT> hei = total / n <NEWLINE> <NL> count = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> if i <= hei : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
while True : <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> & <COMMENT> <NEWLINE> <INDENT> if flag : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gems = [ ] <NEWLINE> okflag = 0 <NEWLINE> loc = [ 10 , 10 ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> [ gemx , gemy ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> gems . append ( [ gemx , gemy ] ) <NEWLINE> <DEDENT> M = int ( raw_input ( ) ) <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> com = raw_input ( ) . split ( ) <NEWLINE> com [ 1 ] = int ( com [ 1 ] ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> for j in range ( com [ 1 ] ) : <NEWLINE> <INDENT> loc [ 1 ] = loc [ 1 ] + 1 <NEWLINE> if loc in gems : <NEWLINE> <INDENT> gems . remove ( loc ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> for j in range ( com [ 1 ] ) : <NEWLINE> <INDENT> loc [ 1 ] = loc [ 1 ] - 1 <NEWLINE> if loc in gems : <NEWLINE> <INDENT> gems . remove ( loc ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> for j in range ( com [ 1 ] ) : <NEWLINE> <INDENT> loc [ 0 ] = loc [ 0 ] + 1 <NEWLINE> if loc in gems : <NEWLINE> <INDENT> gems . remove ( loc ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( com [ 1 ] ) : <NEWLINE> <INDENT> loc [ 0 ] = loc [ 0 ] - 1 <NEWLINE> if loc in gems : <NEWLINE> <INDENT> gems . remove ( loc ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if len ( gems ) == 0 : <NEWLINE> <INDENT> okflag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if okflag : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> p = [ 10 , 10 ] <NEWLINE> l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for d , s in [ input ( ) . split ( ) for _ in range ( int ( input ( ) ) ) ] : <NEWLINE> <INDENT> for _ in range ( s ) : <NEWLINE> <INDENT> if d == <STRING> : <NEWLINE> <INDENT> p [ 1 ] += 1 <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> p [ 0 ] += 1 <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> p [ 0 ] -= 1 <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> p [ 1 ] -= 1 <NEWLINE> <DEDENT> if p in l : <NEWLINE> <INDENT> l . remove ( p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( l ) == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N , M , A = map ( int , input ( ) . split ( ) ) <NEWLINE> amd = [ { } for i in range ( 1001 ) ] <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> h , p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> amd [ h ] [ p ] = q <NEWLINE> amd [ h ] [ q ] = p <NEWLINE> <DEDENT> raw_input ( ) <COMMENT> <NEWLINE> <NL> now = A <NEWLINE> for d in reversed ( amd ) : <NEWLINE> <INDENT> if now in d : <NEWLINE> <INDENT> now = d [ now ] <NEWLINE> <DEDENT> <DEDENT> print ( now ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m , a = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == m == a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> A = [ [ 0 ] * 1002 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m + 1 ) : <NEWLINE> <INDENT> h , p , q = map ( int , input ( ) . split ( ) ) <NEWLINE> A [ p ] [ 1001 - h ] = q <NEWLINE> A [ q ] [ 1001 - h ] = p <NEWLINE> <NL> <DEDENT> for i in range ( 1001 ) : <NEWLINE> <INDENT> if A [ a ] [ i ] == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = A [ a ] [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n , m , a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == m == a == 0 : break <NEWLINE> lst = [ 0 ] * n <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> lst [ i ] = i <NEWLINE> <DEDENT> ms = { } <NEWLINE> for _ in xrange ( n ) : <NEWLINE> <INDENT> h , p , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if h not in ms : <NEWLINE> <INDENT> ms [ h ] = { } <NEWLINE> <DEDENT> ms [ h ] [ p ] = q <NEWLINE> <DEDENT> for i , v in sorted ( ms . items ( ) ) : <NEWLINE> <INDENT> for k , l in v . items ( ) : <NEWLINE> <INDENT> tmp = lst [ k - 1 ] <NEWLINE> lst [ k - 1 ] = lst [ l - 1 ] <NEWLINE> lst [ l - 1 ] = tmp <NEWLINE> <DEDENT> <DEDENT> print lst [ a - 1 ] + 1 <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if num == [ 0 , 0 , 0 ] : break <NEWLINE> hrz = [ 0 for i in range ( num [ 1 ] ) ] <NEWLINE> for i in range ( num [ 1 ] ) : <NEWLINE> <INDENT> hrz [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> lct = [ 1001 , num [ 2 ] ] <NEWLINE> while lct [ 0 ] != 1 : <NEWLINE> <INDENT> pps = [ 0 , 0 ] <NEWLINE> for i in range ( num [ 1 ] ) : <NEWLINE> <INDENT> if pps [ 0 ] < hrz [ i ] [ 0 ] < lct [ 0 ] : <NEWLINE> <INDENT> if hrz [ i ] [ 1 ] == lct [ 1 ] : <NEWLINE> <INDENT> pps = [ hrz [ i ] [ 0 ] , hrz [ i ] [ 2 ] ] <NEWLINE> <DEDENT> elif hrz [ i ] [ 2 ] == lct [ 1 ] : <NEWLINE> <INDENT> pps = [ hrz [ i ] [ 0 ] , hrz [ i ] [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> lct = pps <NEWLINE> <DEDENT> print lct [ 1 ] <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> [ n , m , a ] = input ( ) . split ( ) <NEWLINE> if [ n , m , a ] == [ <STRING> , <STRING> , <STRING> ] : break <NEWLINE> [ n , m , a ] = [ int ( n ) , int ( m ) , int ( a ) ] <NEWLINE> yokobo = { } <NEWLINE> for k in range ( m ) : <NEWLINE> <INDENT> [ h , p , q ] = input ( ) . sprit ( ) <NEWLINE> yokobo [ h , p ] = [ int ( q ) ] <NEWLINE> yokobo [ h , q ] = [ int ( p ) ] <NEWLINE> <DEDENT> move = 1000 <NEWLINE> while move > 0 : <NEWLINE> <INDENT> a = yokobo [ move , a ] <NEWLINE> move = move - 1 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> ( n , m , a ) = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( n , m , a ) == ( 0 , 0 , 0 ) : break <NEWLINE> <NL> bars = [ ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> ( h , p , q ) = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> bars . append ( ( h , p , q ) ) <NEWLINE> <NL> <DEDENT> x = a <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> next_bar = max ( [ b for b in bars if b [ 1 ] == x or b [ 2 ] == x ] ) <NEWLINE> x = next_bar [ 2 ] if next_bar [ 1 ] == x else next_bar [ 1 ] <NEWLINE> y = next_bar [ 0 ] <NEWLINE> map ( lambda b : bars . remove ( b ) , [ b for b in bars if b [ 0 ] >= y ] ) <NEWLINE> if bars == [ ] : break <NEWLINE> <DEDENT> print x <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m , a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 and a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> now = a <NEWLINE> amida = [ [ ] for i in range ( 1000 ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> h , p , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> amida [ h ] . append ( ( p , q ) ) <NEWLINE> <NL> <DEDENT> for height in range ( 1000 - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> lines = amida [ height ] <NEWLINE> for l in lines : <NEWLINE> <INDENT> if l [ 0 ] == now : <NEWLINE> <INDENT> now = l [ 1 ] <NEWLINE> <DEDENT> elif l [ 1 ] == now : <NEWLINE> <INDENT> now = l [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print now <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> class Main ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> n , m , a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 and m == 0 and a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> adj = [ [ ] for i in range ( m ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> h , p , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> adj [ h ] . append ( ( p , q ) ) <NEWLINE> <NL> <DEDENT> for e in reversed ( adj ) : <NEWLINE> <INDENT> for p , q in e : <NEWLINE> <INDENT> if p == a : <NEWLINE> <INDENT> a = q <NEWLINE> <DEDENT> elif q == a : <NEWLINE> <INDENT> a = p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print a <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m = Main ( ) <NEWLINE> m . solve ( ) <NEWLINE> <DEDENT>
from itertools import permutations <NEWLINE> for t in xrange ( input ( ) ) : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ list ( raw_input ( ) ) for i in xrange ( h ) ] <NEWLINE> xmin = { } ; xmax = { } <NEWLINE> ymin = { } ; ymax = { } <NEWLINE> obj = set ( ) <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> for j in xrange ( w ) : <NEWLINE> <INDENT> c = A [ i ] [ j ] <NEWLINE> if c == <STRING> : continue <NEWLINE> xmin [ c ] = min ( xmin . get ( c , 99 ) , j ) <NEWLINE> xmax [ c ] = max ( xmax . get ( c , - 1 ) , j ) <NEWLINE> ymin [ c ] = min ( ymin . get ( c , 99 ) , i ) <NEWLINE> ymax [ c ] = max ( ymax . get ( c , - 1 ) , i ) <NEWLINE> obj . add ( c ) <NEWLINE> <DEDENT> <DEDENT> if not obj : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> ok = 1 <NEWLINE> for q in obj : <NEWLINE> <INDENT> for i in xrange ( ymin [ q ] , ymax [ q ] + 1 ) : <NEWLINE> <INDENT> for j in xrange ( xmin [ q ] , xmax [ q ] + 1 ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == <STRING> : <NEWLINE> <INDENT> ok = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not ok : break <NEWLINE> <DEDENT> if not ok : break <NEWLINE> <DEDENT> if not ok : <NEWLINE> <INDENT> print <STRING> <NEWLINE> continue <NEWLINE> <DEDENT> for p in permutations ( obj ) : <NEWLINE> <INDENT> valid = [ [ 1 ] * w for i in xrange ( h ) ] <NEWLINE> ok = 1 <NEWLINE> for q in p : <NEWLINE> <INDENT> for i in xrange ( ymin [ q ] , ymax [ q ] + 1 ) : <NEWLINE> <INDENT> for j in xrange ( xmin [ q ] , xmax [ q ] + 1 ) : <NEWLINE> <INDENT> if A [ i ] [ j ] != q and not valid [ i ] [ j ] : <NEWLINE> <INDENT> ok = 0 <NEWLINE> break <NEWLINE> <DEDENT> elif A [ i ] [ j ] == q : <NEWLINE> <INDENT> valid [ i ] [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> if not ok : break <NEWLINE> <DEDENT> if not ok : break <NEWLINE> <DEDENT> if ok : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = raw_input ( ) <NEWLINE> <NL> def keitai ( n1 , n2 ) : <NEWLINE> <INDENT> li1 = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> li2 = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> li3 = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> li4 = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> li5 = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> li6 = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> li7 = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> li8 = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> li9 = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> li = [ li1 , li2 , li3 , li4 , li5 , li6 , li7 , li8 , li9 ] <NEWLINE> lis = li [ n1 - 1 ] <NEWLINE> n2 = n2 % len ( lis ) <NEWLINE> a = lis [ n2 - 1 ] <NEWLINE> return a <NEWLINE> <NL> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> a = str ( raw_input ( ) ) <NEWLINE> num = 0 <NEWLINE> string = <STRING> <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> if int ( a [ i ] ) == 0 : <NEWLINE> <INDENT> string = string + keitai ( b , num ) <NEWLINE> num = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = num + 1 <NEWLINE> b = int ( a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print string <NEWLINE> <DEDENT>
d = { 1 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } , <NEWLINE> <INDENT> 2 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } , <NEWLINE> 3 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } , <NEWLINE> 4 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } , <NEWLINE> 5 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } , <NEWLINE> 6 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } , <NEWLINE> 7 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> } , <NEWLINE> 8 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> } , <NEWLINE> 9 : { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> } <NEWLINE> <DEDENT> } <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mes = raw_input ( ) <NEWLINE> mes = mes . split ( <STRING> ) <NEWLINE> mes = filter ( lambda x : len ( x ) > 0 , mes ) <NEWLINE> l = [ ] <NEWLINE> for e in mes : <NEWLINE> <INDENT> l . append ( [ e [ 0 ] , len ( e ) ] ) <NEWLINE> <DEDENT> res = <STRING> <NEWLINE> for e in l : <NEWLINE> <INDENT> i = int ( e [ 0 ] ) <NEWLINE> if ( i == 1 ) : <NEWLINE> <INDENT> if e [ 1 ] > 5 : x = e [ 1 ] % 5 <NEWLINE> else : x = e [ 1 ] <NEWLINE> <DEDENT> elif ( i == 7 or i == 9 ) : <NEWLINE> <INDENT> if e [ 1 ] > 4 : x = e [ 1 ] % 4 <NEWLINE> else : x = e [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if e [ 1 ] > 3 : x = e [ 1 ] % 3 <NEWLINE> else : x = e [ 1 ] <NEWLINE> res = res + d [ i ] [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> print res <NEWLINE> <DEDENT>
from itertools import cycle as c <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tt = input ( ) <NEWLINE> l = [ ] <NEWLINE> t = <STRING> <NEWLINE> for ( i , j ) in enumerate ( tt ) : <NEWLINE> <INDENT> ct = int ( j ) <NEWLINE> if ct == 0 or i == 0 : <NEWLINE> <INDENT> if i != 0 : <NEWLINE> <INDENT> l . extend ( [ t ] ) <NEWLINE> t = <STRING> <NEWLINE> <DEDENT> kk = [ c ( [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> <INDENT> c ( [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> c ( [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> c ( [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> c ( [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> c ( [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> c ( [ <STRING> , <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> c ( [ <STRING> , <STRING> , <STRING> ] ) , <NEWLINE> c ( [ <STRING> , <STRING> , <STRING> , <STRING> ] ) ] <NEWLINE> <DEDENT> <DEDENT> if ct != 0 : <NEWLINE> <INDENT> t = kk [ ct - 1 ] . next ( ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> from itertools import groupby <NEWLINE> <NL> a = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for i in input ( ) : <NEWLINE> <INDENT> b = [ [ i for i in j ] for i , j in groupby ( raw_input ( ) ) ] <NEWLINE> c = [ ] <NEWLINE> d = <STRING> <NEWLINE> for i in b : <NEWLINE> <INDENT> index = int ( i [ 0 ] ) <NEWLINE> s = a [ index ] [ ( len ( i ) ) % len ( a [ index ] ) - 1 ] <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> d = d + <STRING> . join ( c ) <NEWLINE> c = [ ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c . append ( s ) <NEWLINE> <DEDENT> <DEDENT> if d != <STRING> : <NEWLINE> <INDENT> print d <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> d = [ ] <NEWLINE> d . append ( [ ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> ] ) <NEWLINE> d . append ( [ <STRING> , <STRING> , <STRING> , <STRING> ] ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> nn = input ( ) <NEWLINE> output = <STRING> <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for n in nn : <NEWLINE> <INDENT> n = int ( n ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> output += d [ b ] [ c ] <NEWLINE> c = 0 <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
K = <STRING> <NEWLINE> A = <STRING> <NEWLINE> D = <STRING> <NEWLINE> G = <STRING> <NEWLINE> J = <STRING> <NEWLINE> M = <STRING> <NEWLINE> P = <STRING> <NEWLINE> T = <STRING> <NEWLINE> W = <STRING> <NEWLINE> L = [ <STRING> , K , A , D , G , J , M , P , T , W ] <NEWLINE> <NL> <NL> while 1 : <NEWLINE> <INDENT> S = [ ] <NEWLINE> n = input ( ) <NEWLINE> if not <STRING> in n : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = n . split ( <STRING> ) <NEWLINE> for ns in n : <NEWLINE> <INDENT> if ns == <STRING> : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> i = len ( ns ) % len ( L [ int ( ns [ 0 ] ) ] ) <NEWLINE> S += [ [ L [ int ( ns [ 0 ] ) ] , i - 1 ] ] <NEWLINE> <DEDENT> for s in S : <NEWLINE> <INDENT> print ( s [ 0 ] [ s [ 1 ] ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> di = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> , 7 : <STRING> , 8 : <STRING> , 9 : <STRING> } <NEWLINE> while True : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> count = 0 <NEWLINE> le = 999 <NEWLINE> fl = False <NEWLINE> for letter in a : <NEWLINE> <INDENT> if ( letter == <STRING> ) : <NEWLINE> <INDENT> if ( le == 999 ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout . write ( di [ le ] [ ( count - 1 ) % len ( di [ le ] ) ] ) <NEWLINE> count = 0 <NEWLINE> le = 999 <NEWLINE> fl = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> le = int ( letter ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> if ( fl ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> from __future__ import print_function <NEWLINE> <NL> p = [ 10 , 50 , 100 , 500 ] <NEWLINE> <NL> first = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if not first : <NEWLINE> <INDENT> print ( ) <NEWLINE> first = False <NEWLINE> <NL> <DEDENT> m = [ int ( _ ) for _ in raw_input ( ) . split ( ) ] <NEWLINE> <NL> s = sum ( pi * mi for pi , mi in zip ( p , m ) ) <NEWLINE> r = s - n <NEWLINE> for i in xrange ( 3 , - 1 , - 1 ) : <NEWLINE> <INDENT> pi = p [ i ] <NEWLINE> ni = r / pi <NEWLINE> m [ i ] -= ni <NEWLINE> r -= ni * pi <NEWLINE> <NL> <DEDENT> for pi , mi in zip ( p , m ) : <NEWLINE> <INDENT> if mi > 0 : <NEWLINE> <INDENT> print ( pi , mi ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
second = False <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if second : print <STRING> <NEWLINE> second = True <NEWLINE> s = input ( ) <NEWLINE> if s == 0 : break <NEWLINE> ls = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> have = { } <NEWLINE> <NL> have [ 10 ] , have [ 50 ] , have [ 100 ] , have [ 500 ] = ls <NEWLINE> have_c = sum ( ls ) <NEWLINE> <NL> ans = { } <NEWLINE> ans_c = 1 << 30 <NEWLINE> <NL> for i10 in range ( have [ 10 ] + 1 ) : <NEWLINE> <INDENT> for i50 in range ( have [ 50 ] + 1 ) : <NEWLINE> <INDENT> for i100 in range ( have [ 100 ] + 1 ) : <NEWLINE> <INDENT> for i500 in range ( have [ 500 ] + 1 ) : <NEWLINE> <INDENT> pay = i10 * 10 + i50 * 50 + i100 * 100 + i500 * 500 <NEWLINE> if pay < s : continue <NEWLINE> pay_c = i10 + i50 + i100 + i500 <NEWLINE> change = pay - s <NEWLINE> change_c = change / 500 <NEWLINE> change %= 500 <NEWLINE> change_c += change / 100 <NEWLINE> change %= 100 <NEWLINE> change_c += change / 50 <NEWLINE> change %= 50 <NEWLINE> change_c += change / 10 <NEWLINE> t_c = have_c - pay_c + change_c <NEWLINE> if ans_c > t_c : <NEWLINE> <INDENT> ans [ 10 ] , ans [ 50 ] , ans [ 100 ] , ans [ 500 ] = i10 , i50 , i100 , i500 <NEWLINE> ans_c = t_c <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans [ 10 ] is not 0 : print 10 , ans [ 10 ] <NEWLINE> if ans [ 50 ] is not 0 : print 50 , ans [ 50 ] <NEWLINE> if ans [ 100 ] is not 0 : print 100 , ans [ 100 ] <NEWLINE> if ans [ 500 ] is not 0 : print 500 , ans [ 500 ] <NEWLINE> <DEDENT>
from itertools import product <NEWLINE> L = [ 10 , 50 , 100 , 500 ] <NEWLINE> <NL> def solve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> ans = [ [ 20 ] * 4 , [ 20 ] * 4 ] <NEWLINE> for c in product ( * [ range ( N [ i ] + 1 ) for i in xrange ( 4 ) ] ) : <NEWLINE> <COMMENT> <NL> <INDENT> r = calc ( c ) <NEWLINE> <COMMENT> <NL> if check ( c , r ) : <NEWLINE> <INDENT> ans = min ( [ r , c ] , ans , key = lambda x : sum ( x [ 0 ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> return ans [ 1 ] <NEWLINE> <NL> <DEDENT> def calc ( N ) : <NEWLINE> <INDENT> r = sum ( L [ i ] * N [ i ] for i in xrange ( 4 ) ) - M <NEWLINE> <COMMENT> <NL> if r < 0 : <NEWLINE> <INDENT> return [ - 1 ] * 4 <NEWLINE> <DEDENT> ret = [ 0 ] * 4 <NEWLINE> for i in xrange ( 3 , - 1 , - 1 ) : <NEWLINE> <INDENT> ret [ i ] += r / L [ i ] <NEWLINE> r -= ret [ i ] * L [ i ] <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def check ( N1 , N2 ) : <NEWLINE> <INDENT> if N2 [ 0 ] == - 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for c1 , c2 in zip ( N1 , N2 ) : <NEWLINE> <INDENT> if c1 > 0 and c2 > 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> M = int ( raw_input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> N = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i , n in zip ( L , solve ( ) ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print i , n <NEWLINE> <DEDENT> M = int ( raw_input ( ) ) <NEWLINE> if M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
coins = [ 10 , 50 , 100 , 500 ] <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> cost = int ( raw_input ( ) ) <NEWLINE> if cost == 0 : break <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> num = sum ( c ) <NEWLINE> <NL> mn = num <NEWLINE> ans = [ 0 , 0 , 0 , 0 ] <NEWLINE> for i in range ( c [ 0 ] + 1 ) : <NEWLINE> <INDENT> for j in range ( c [ 1 ] + 1 ) : <NEWLINE> <INDENT> for k in range ( c [ 2 ] + 1 ) : <NEWLINE> <INDENT> for l in range ( c [ 3 ] + 1 ) : <NEWLINE> <INDENT> pay = 10 * i + 50 * j + 100 * k + 500 * l <NEWLINE> change = pay - cost <NEWLINE> if change < 0 : continue <NEWLINE> <NL> tmp = [ 0 , 0 , 0 , 0 ] <NEWLINE> for m in range ( 3 , - 1 , - 1 ) : <NEWLINE> <INDENT> while change - coins [ m ] >= 0 : <NEWLINE> <INDENT> change -= coins [ m ] <NEWLINE> tmp [ m ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for c1 , c2 in zip ( [ i , j , k , l ] , tmp ) : <NEWLINE> <INDENT> if c1 > 0 and c2 > 0 : break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if num - ( i + j + k + l ) + sum ( tmp ) < mn : <NEWLINE> <INDENT> mn = num - ( i + j + k + l ) + sum ( tmp ) <NEWLINE> ans = [ i , j , k , l ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for ci , ki in zip ( coins , ans ) : <NEWLINE> <INDENT> if ki == 0 : continue <NEWLINE> print ci , ki <NEWLINE> <DEDENT> print <NEWLINE> <DEDENT>
def opt_change ( n ) : <NEWLINE> <INDENT> change = [ 0 , 0 , 0 , 0 ] <NEWLINE> purse = ( 10 , 50 , 100 , 500 ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> change [ 3 - i ] = n / purse [ 3 - i ] <NEWLINE> n = n % purse [ 3 - i ] <NEWLINE> <DEDENT> return change <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> price = int ( raw_input ( ) ) <NEWLINE> if price == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> purse_num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> purse = [ 10 , 50 , 100 , 500 ] <NEWLINE> own = sum ( [ purse [ i ] * purse_num [ i ] for i in range ( 4 ) ] ) <NEWLINE> result = opt_change ( own - price ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> num = 0 if purse_num [ i ] <= result [ i ] else ( purse_num [ i ] - result [ i ] ) <NEWLINE> if num != 0 : <NEWLINE> <INDENT> print purse [ i ] , num <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> m = int ( raw_input ( ) ) <NEWLINE> if m == 0 : break <NEWLINE> cm = [ 10 , 50 , 100 , 500 ] <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> mintn = 81 <NEWLINE> fc = [ 0 for i in xrange ( 4 ) ] <NEWLINE> mc = [ 0 for i in xrange ( 4 ) ] <NEWLINE> t = 0 <NEWLINE> for i in xrange ( 4 ) : <NEWLINE> <INDENT> t += c [ i ] * cm [ i ] <NEWLINE> ch = t - m <NEWLINE> <DEDENT> for i in xrange ( 3 , - 1 , - 1 ) : <NEWLINE> <INDENT> while ( ch >= cm [ i ] ) : <NEWLINE> <INDENT> ch -= cm [ i ] <NEWLINE> mc [ i ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( 4 ) : <NEWLINE> <INDENT> fc [ i ] = c [ i ] - mc [ i ] <NEWLINE> if fc [ i ] < 0 : fc [ i ] = 0 <NEWLINE> <DEDENT> for i in xrange ( 4 ) : <NEWLINE> <INDENT> if fc [ i ] != 0 : print <STRING> % ( cm [ i ] , fc [ i ] ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
coins = [ 10 , 50 , 100 , 500 ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> P = int ( raw_input ( ) ) <NEWLINE> if P == 0 : break <NEWLINE> else : print <STRING> <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rest = - P <NEWLINE> for i in xrange ( len ( coins ) ) : <NEWLINE> <INDENT> rest += coins [ i ] * c [ i ] <NEWLINE> <DEDENT> k = [ 0 ] * len ( coins ) <NEWLINE> for i in xrange ( len ( coins ) ) : <NEWLINE> <INDENT> idx = len ( coins ) - 1 - i <NEWLINE> k [ idx ] = c [ idx ] - ( rest / coins [ idx ] ) <NEWLINE> rest -= coins [ idx ] * ( c [ idx ] - k [ idx ] ) <NEWLINE> <DEDENT> for i in xrange ( len ( coins ) ) : <NEWLINE> <INDENT> if k [ i ] > 0 : <NEWLINE> <INDENT> print <STRING> % ( coins [ i ] , k [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> y10 , y50 , y100 , y500 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> Sum = 10 * y10 + 50 * y50 + y100 * 100 + y500 * 500 <NEWLINE> <NL> while Sum - 500 >= n : <NEWLINE> <INDENT> Sum -= 500 <NEWLINE> y500 -= 1 <NEWLINE> <DEDENT> while Sum - 100 >= n : <NEWLINE> <INDENT> Sum -= 100 <NEWLINE> y100 -= 1 <NEWLINE> <DEDENT> while Sum - 50 >= n : <NEWLINE> <INDENT> Sum -= 50 <NEWLINE> y50 -= 1 <NEWLINE> <DEDENT> while Sum - 10 >= n : <NEWLINE> <INDENT> Sum -= 10 <NEWLINE> y10 -= 1 <NEWLINE> <NL> <DEDENT> if y10 > 0 : <NEWLINE> <INDENT> print 10 , y10 <NEWLINE> <DEDENT> if y50 > 0 : <NEWLINE> <INDENT> print 50 , y50 <NEWLINE> <DEDENT> if y100 > 0 : <NEWLINE> <INDENT> print 100 , y100 <NEWLINE> <DEDENT> if y500 > 0 : <NEWLINE> <INDENT> print 500 , y500 <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> def back_oturigation ( fee , coin_values , coin_nums ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> coin_values = np . array ( coin_values ) <NEWLINE> coin_nums = np . array ( coin_nums ) <NEWLINE> all = np . dot ( coin_values , coin_nums ) <NEWLINE> oturi = int ( all - fee ) <NEWLINE> <NL> use_coins = [ 0 ] * len ( coin_values ) <NEWLINE> no_use_coins = [ 0 ] * len ( coin_values ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( coin_values ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> no_use_coins [ i ] = int ( oturi / coin_values [ i ] ) <NEWLINE> oturi = oturi - ( coin_values [ i ] * no_use_coins [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 0 , len ( use_coins ) , 1 ) : <NEWLINE> <INDENT> use_coins [ i ] = coin_nums [ i ] - no_use_coins [ i ] <NEWLINE> if use_coins [ i ] > 0 : <NEWLINE> <INDENT> print ( str ( coin_values [ i ] ) + <STRING> + str ( use_coins [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> first = True <NEWLINE> while ( True ) : <NEWLINE> <INDENT> total_fee = int ( input ( <STRING> ) ) <NEWLINE> if total_fee == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if first : <NEWLINE> <INDENT> first = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> coins = input ( <STRING> ) <NEWLINE> coins = coins . split ( <STRING> ) <COMMENT> <NEWLINE> coins = [ int ( coin ) for coin in coins ] <NEWLINE> coin_values = [ 10 , 50 , 100 , 500 ] <NEWLINE> back_oturigation ( total_fee , coin_values , coins ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def change ( val ) : <NEWLINE> <INDENT> v500 = val / 500 <NEWLINE> v100 = ( val - v500 ) / 100 <NEWLINE> v50 = ( val % 100 ) / 50 <NEWLINE> v10 = ( val % 50 ) / 10 <NEWLINE> return v10 + v50 + v100 + v500 <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> if cnt > 0 : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> ( c10 , c50 , c100 , c500 ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> Min = 1000000 <NEWLINE> a10 = 0 <NEWLINE> a50 = 0 <NEWLINE> a100 = 0 <NEWLINE> a500 = 0 <NEWLINE> for i1 in range ( c10 + 1 ) : <NEWLINE> <INDENT> for i2 in range ( c50 + 1 ) : <NEWLINE> <INDENT> for i3 in range ( c100 + 1 ) : <NEWLINE> <INDENT> for i4 in range ( c500 + 1 ) : <NEWLINE> <INDENT> Sumc = i1 + i2 + i3 + i4 <NEWLINE> Sumv = i1 * 10 + i2 * 50 + i3 * 100 + i4 * 500 <NEWLINE> if Sumv >= n : <NEWLINE> <INDENT> Re = change ( Sumv - n ) <NEWLINE> if Min > Re - Sumc : <NEWLINE> <INDENT> Min = Re - Sumc <NEWLINE> a10 = i1 <NEWLINE> a50 = i2 <NEWLINE> a100 = i3 <NEWLINE> a500 = i4 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if a10 > 0 : <NEWLINE> <INDENT> print 10 , a10 <NEWLINE> <DEDENT> if a50 > 0 : <NEWLINE> <INDENT> print 50 , a50 <NEWLINE> <DEDENT> if a100 > 0 : <NEWLINE> <INDENT> print 100 , a100 <NEWLINE> <DEDENT> if a500 > 0 : <NEWLINE> <INDENT> print 500 , a500 <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if ( n == 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> d = [ ] <NEWLINE> digit = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in a [ 1 : ] : <NEWLINE> <INDENT> digit . add ( j ) <NEWLINE> <DEDENT> d . append ( a [ 1 : ] ) <NEWLINE> <DEDENT> paper = [ set ( ) for i in range ( n ) ] <NEWLINE> ans = 31 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> paper [ i ] . add ( i ) <NEWLINE> <DEDENT> for i in digit : <NEWLINE> <INDENT> for j in range ( len ( d ) ) : <NEWLINE> <INDENT> if i in d [ j ] : <NEWLINE> <INDENT> for k in range ( j , len ( d ) ) : <NEWLINE> <INDENT> if i in d [ k ] : <NEWLINE> <INDENT> for l in paper [ k ] : <NEWLINE> <INDENT> paper [ j ] . add ( l ) <NEWLINE> <DEDENT> for l in paper [ j ] : <NEWLINE> <INDENT> paper [ k ] . add ( l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for j in range ( len ( d ) ) : <NEWLINE> <INDENT> if ( len ( paper [ j ] ) == n ) : <NEWLINE> <INDENT> ans = min ( ans , i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ( ans != 31 ) : <NEWLINE> <INDENT> print ans <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print - 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
from math import sqrt <NEWLINE> <NL> while True : <NEWLINE> <INDENT> e = int ( raw_input ( ) ) <NEWLINE> if e == 0 : break <NEWLINE> <NL> ans = e <NEWLINE> <NL> for z in range ( e ) : <NEWLINE> <INDENT> if z ** 3 > e : break <NEWLINE> y = int ( sqrt ( e - z ** 3 ) ) <NEWLINE> x = e - y ** 2 - z ** 3 <NEWLINE> ans = min ( ans , x + y + z ) <NEWLINE> <NL> <DEDENT> print ans <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> e = ans = input ( ) <NEWLINE> if e == 0 : break <NEWLINE> for z in range ( e ) : <NEWLINE> <INDENT> z3 = z ** 3 <NEWLINE> if z3 > e : break <NEWLINE> y = int ( ( e - z3 ) ** 0.5 ) <NEWLINE> ans = min ( ans , e + y + z - y ** 2 - z3 ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> class Main ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> e = input ( ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = float ( <STRING> ) <NEWLINE> for z in range ( 101 ) : <NEWLINE> <INDENT> tmp = e - z ** 3 <NEWLINE> if tmp < 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for y in range ( 1001 ) : <NEWLINE> <INDENT> x = e - z ** 3 - y ** 2 <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> m = min ( m , x + y + z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print m <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m = Main ( ) <NEWLINE> m . solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> from math import sqrt <NEWLINE> <NL> while True : <NEWLINE> <INDENT> e = int ( input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans = 10 ** 9 <NEWLINE> for z in range ( e ) : <NEWLINE> <INDENT> if z > e : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> y = int ( sqrt ( e - z ** 3 ) ) <NEWLINE> x = e - y ** 2 - z ** 3 <NEWLINE> ans = min ( ans , x + y + i ) <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT>
from math import sqrt <NEWLINE> <NL> while True : <NEWLINE> <INDENT> e = int ( raw_input ( ) ) <NEWLINE> <NL> if e == 0 : break <NEWLINE> <NL> x , y , z , ans = 0 , 0 , 0 , e <NEWLINE> <NL> for z in range ( e ) : <NEWLINE> <INDENT> if z ** 3 > e : break <NEWLINE> y = int ( sqrt ( e - z ** 3 ) ) <NEWLINE> x = e - y ** 2 - z ** 3 <NEWLINE> ans = min ( ans , x + y + z ) <NEWLINE> <NL> <DEDENT> print ans <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> e = int ( input ( ) ) <NEWLINE> while e > 0 : <NEWLINE> <INDENT> z = 0 <NEWLINE> while z ** 3 <= e <NEWLINE> <INDENT> z += 1 <NEWLINE> <DEDENT> z -= 1 <NEWLINE> e -= z ** 3 <NEWLINE> y = 0 <NEWLINE> while y * y <= e : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> y -= 1 <NEWLINE> e -= y * y <NEWLINE> e += y + z <NEWLINE> print ( e ) <NEWLINE> e = int ( input ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def yis ( z ) : <NEWLINE> <INDENT> for i in range ( 1000 ) : <NEWLINE> <INDENT> if i * i > e - z * z * z : <NEWLINE> <INDENT> y = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return y <NEWLINE> <NL> <NL> <DEDENT> while True : <NEWLINE> <INDENT> e = int ( raw_input ( ) ) <NEWLINE> y = 0 <NEWLINE> z = 0 <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( 100 ) : <NEWLINE> <INDENT> if i * i * i > e : <NEWLINE> <INDENT> z = i - 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> n = z <NEWLINE> m = e <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> y = yis ( z ) <NEWLINE> m = min ( m , e - y * y - z * z * z + y + z ) <NEWLINE> z = z - 1 <NEWLINE> <DEDENT> print m <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> e = input ( ) <NEWLINE> if e == 0 : break <NEWLINE> ans = 3 * e <NEWLINE> for z in range ( e + 1 ) : <NEWLINE> <INDENT> z3 = z ** 3 <NEWLINE> if z3 > e : break <NEWLINE> for y in range ( e + 1 ) : <NEWLINE> <INDENT> x = e - y ** 2 - z3 <NEWLINE> if x >= 0 : <NEWLINE> <INDENT> ans = min ( ans , x + y + z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
import math <NEWLINE> targ = int ( input ( ) ) <NEWLINE> y , z = 0 , 0 <NEWLINE> while True : <NEWLINE> <INDENT> minans = float ( <STRING> ) <NEWLINE> for n in range ( math . ceil ( targ ** ( 1 / 3 ) ) + 1 ) : <NEWLINE> <INDENT> if minans == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = int ( math . sqrt ( targ - n ** 3 ) ) <NEWLINE> if ( n ** 3 ) + ( m ** 2 ) > targ : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if minans > targ - ( n ** 3 + m ** 2 ) + n + m : <NEWLINE> <INDENT> minans = targ - ( n ** 3 + m ** 2 ) + n + m <NEWLINE> <DEDENT> <DEDENT> if minans != float ( <STRING> ) : <NEWLINE> <INDENT> print ( minans ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( y + z ) <NEWLINE> <DEDENT> targ = int ( input ( ) ) <NEWLINE> if targ == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> while 1 : <NEWLINE> <INDENT> e = int ( raw_input ( ) ) <NEWLINE> if e == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> z = 0 <NEWLINE> m = e <NEWLINE> while math . pow ( z , 3 ) <= e : <NEWLINE> <INDENT> y = 0 <NEWLINE> while y ** 2 <= e - math . pow ( z , 3 ) : <NEWLINE> <INDENT> m = min ( e + y + z - y ** 2 - math . pow ( z , 3 ) , m ) <NEWLINE> y += 1 <NEWLINE> <DEDENT> z += 1 <NEWLINE> <DEDENT> print int ( m ) <NEWLINE> <DEDENT> quit ( ) <NEWLINE>
m = 24 * 60 * 60 <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if not n : break <NEWLINE> cnt = 1 <NEWLINE> t = [ 0 for i in xrange ( 24 * 60 * 60 ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> a = raw_input ( ) . split ( ) <NEWLINE> h , m , s = [ 0 , 0 ] , [ 0 , 0 ] , [ 0 , 0 ] <NEWLINE> for i in xrange ( 2 ) : <NEWLINE> <INDENT> h [ i ] , m [ i ] , s [ i ] = map ( int , a [ i ] . split ( <STRING> ) ) <NEWLINE> <DEDENT> t1 = h [ 0 ] * 60 ** 2 + m [ 0 ] * 60 + s [ 0 ] <NEWLINE> t2 = h [ 1 ] * 60 ** 2 + m [ 1 ] * 60 + s [ 1 ] <NEWLINE> for i in xrange ( t1 , t2 ) : <NEWLINE> <INDENT> t [ i ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in xrange ( 24 * 60 * 60 ) : <NEWLINE> <INDENT> cnt = max ( t [ i ] , cnt ) <NEWLINE> <NL> <DEDENT> print cnt <NEWLINE> <DEDENT>
def to_sec ( a ) : <NEWLINE> <INDENT> h , m , s = map ( int , a . split ( <STRING> ) ) <NEWLINE> return 3600 * h + 60 * m + s <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> used = [ 0 ] * 84401 <NEWLINE> for loop in range ( n ) : <NEWLINE> <INDENT> a , b = raw_input ( ) . split ( ) <NEWLINE> a , b = to_sec ( a ) , to_sec ( b ) <NEWLINE> used [ a ] += 1 <NEWLINE> used [ b ] -= 1 <NEWLINE> <DEDENT> for i in range ( 1 , 84400 ) : <NEWLINE> <INDENT> used [ i ] += used [ i - 1 ] <NEWLINE> <DEDENT> print max ( used ) <NEWLINE> <DEDENT>
import sys <NEWLINE> from collections import Counter <NEWLINE> <NL> sys . set_coroutine_wrapper ( 2500 ) <NEWLINE> <NL> <NL> def paint ( field , i , j , b , f , moves = { ( - 1 , 0 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( 0 , - 1 ) } ) : <NEWLINE> <INDENT> fij = field [ i ] [ j ] <NEWLINE> if fij & f : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if fij & 4 and not fij & b : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> field [ i ] [ j ] |= b | f <NEWLINE> for di , dj in moves : <NEWLINE> <INDENT> ni = i + di <NEWLINE> nj = j + dj <NEWLINE> if nj < 0 or w <= nj or ni < 0 or h <= ni : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> paint ( field , ni , nj , b , f ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> buf = [ ] <NEWLINE> chardict = { <STRING> : 0 , <STRING> : 5 , <STRING> : 6 } <NEWLINE> while True : <NEWLINE> <INDENT> w , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if w == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> field = [ ] <NEWLINE> init_w , init_b = 0 , 0 <NEWLINE> for _ in range ( h ) : <NEWLINE> <INDENT> line = input ( ) . strip ( ) <NEWLINE> init_w += line . count ( <STRING> ) <NEWLINE> init_b += line . count ( <STRING> ) <NEWLINE> field . append ( [ chardict [ c ] for c in line ] ) <NEWLINE> <DEDENT> for i in range ( h ) : <NEWLINE> <INDENT> for j in range ( w ) : <NEWLINE> <INDENT> fij = field [ i ] [ j ] <NEWLINE> if fij & 4 and not fij & 24 : <NEWLINE> <INDENT> paint ( field , i , j , fij & 3 , ( fij & 3 ) << 3 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> result = Counter ( b & 3 for row in field for b in row ) <NEWLINE> print ( result [ 2 ] - init_b , result [ 1 ] - init_w ) <NEWLINE> <DEDENT>
class Area : <NEWLINE> <INDENT> def __init__ ( self , m , x , y ) : <NEWLINE> <INDENT> self . m = m <NEWLINE> self . f_W = False <NEWLINE> self . f_B = False <NEWLINE> self . side = 0 <NEWLINE> self . count = 0 <NEWLINE> self . standardx = x <NEWLINE> self . standardy = y <NEWLINE> self . check ( x , y ) <NEWLINE> self . getSide ( ) <NEWLINE> <NL> <DEDENT> def check ( self , x , y ) : <NEWLINE> <INDENT> if ( y < 0 or y >= len ( m ) or x < 0 or x >= len ( m [ 0 ] ) ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> c = self . m [ y ] [ x ] <NEWLINE> if ( c != 0 ) : <NEWLINE> <INDENT> if ( c == 1 ) : <NEWLINE> <INDENT> self . f_B = True <NEWLINE> <DEDENT> if ( c == 2 ) : <NEWLINE> <INDENT> self . f_W = True <NEWLINE> <DEDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( c == 0 ) : <NEWLINE> <INDENT> self . m [ y ] [ x ] = 3 <NEWLINE> self . count += 1 <NEWLINE> self . check ( x - 1 , y ) <NEWLINE> self . check ( x + 1 , y ) <NEWLINE> self . check ( x , y - 1 ) <NEWLINE> self . check ( x , y + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def getSide ( self ) : <NEWLINE> <INDENT> if ( self . f_B and self . f_W ) : <NEWLINE> <INDENT> self . side = 0 <NEWLINE> <DEDENT> elif ( self . f_B ) : <NEWLINE> <INDENT> self . side = 1 <NEWLINE> <DEDENT> elif ( self . f_W ) : <NEWLINE> <INDENT> self . side = 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . side = 0 <NEWLINE> <DEDENT> return self . side <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( not w ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = [ ] <NEWLINE> for i in range ( h ) : <NEWLINE> <INDENT> m . append ( [ ] ) <NEWLINE> l = raw_input ( ) <NEWLINE> for ii in range ( w ) : <NEWLINE> <INDENT> dic = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 } <NEWLINE> m [ i ] . append ( dic [ l [ ii ] ] ) <NEWLINE> <DEDENT> <DEDENT> B = 0 <NEWLINE> W = 0 <NEWLINE> for i , l in enumerate ( m ) : <NEWLINE> <INDENT> for ii , c in enumerate ( l ) : <NEWLINE> <INDENT> if ( c == 0 ) : <NEWLINE> <INDENT> a = Area ( m , ii , i ) <NEWLINE> if ( a . getSide ( ) == 1 ) : <NEWLINE> <INDENT> B += a . count <NEWLINE> <DEDENT> elif ( a . getSide ( ) == 2 ) : <NEWLINE> <INDENT> W += a . count <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print B , W <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from itertools import accumulate <NEWLINE> <NL> buf = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n , m = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> hs = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> ws = [ int ( input ( ) ) for _ in range ( m ) ] <NEWLINE> ha = accumulate ( hs ) <NEWLINE> wa = accumulate ( ws ) <NEWLINE> hd = defaultdict ( int ) <NEWLINE> wd = defaultdict ( int ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> hd [ ha [ j ] - ha [ i ] ] += 1 <NEWLINE> wd [ wa [ j ] - wa [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for h , cnt in hd . items ( ) : <NEWLINE> <INDENT> if h in wd : <NEWLINE> <INDENT> ans += cnt * wd [ h ] <NEWLINE> <DEDENT> <DEDENT> buf . append ( ans ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , buf ) ) ) <NEWLINE>
while ( 1 ) : <NEWLINE> <INDENT> [ N , M ] = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> H = [ ] <NEWLINE> W = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> H . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> W . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> S = 0 <NEWLINE> for top in range ( N ) : <NEWLINE> <INDENT> for left in range ( M ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> w = 0 <NEWLINE> right = left <NEWLINE> for bottom in range ( top , N ) : <NEWLINE> <INDENT> h = h + H [ bottom ] <NEWLINE> while w < h and right < M : <NEWLINE> <INDENT> w = w + W [ right ] <NEWLINE> right = right + 1 <NEWLINE> <DEDENT> if w == h : <NEWLINE> <INDENT> S = S + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print S <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> ws , hs , w , h = defaultdict ( lambda : 0 ) , defaultdict ( lambda : 0 ) , [ ] , [ ] <NEWLINE> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n | m == 0 : break <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> t = s = input ( ) <NEWLINE> ws [ s ] += 1 <NEWLINE> for pw in reversed ( w ) : <NEWLINE> <INDENT> s += pw <NEWLINE> ws [ s ] += 1 <NEWLINE> <DEDENT> w . append ( t ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> t = s = input ( ) <NEWLINE> hs [ s ] += 1 <NEWLINE> for pw in reversed ( h ) : <NEWLINE> <INDENT> s += pw <NEWLINE> hs [ s ] += 1 <NEWLINE> <DEDENT> h . append ( t ) <NEWLINE> <NL> <DEDENT> ans = 0 <NEWLINE> for w , wn in ws . iteritems ( ) : <NEWLINE> <INDENT> for h , hn in hs . iteritems ( ) : <NEWLINE> <INDENT> if w == h : <NEWLINE> <INDENT> ans += wn * hn <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> h = [ int ( raw_input ( ) ) for _ in range ( N ) ] <NEWLINE> w = [ int ( raw_input ( ) ) for _ in range ( M ) ] <NEWLINE> ans = 0 <NEWLINE> H , W = h [ : ] , w [ : ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> s = h [ i ] <NEWLINE> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> s += h [ j ] <NEWLINE> H . append ( s ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> s = w [ i ] <NEWLINE> for j in range ( i + 1 , M ) : <NEWLINE> <INDENT> s += w [ j ] <NEWLINE> W . append ( s ) <NEWLINE> <DEDENT> <DEDENT> for hi in H : <NEWLINE> <INDENT> for wi in W : <NEWLINE> <INDENT> if hi == wi : ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 and M == 0 : break <NEWLINE> h = [ input ( ) for _ in range ( N ) ] <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> h [ i + 1 ] += h [ i ] <NEWLINE> <DEDENT> w = [ input ( ) for _ in range ( M ) ] <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> w [ i + 1 ] += w [ i ] <NEWLINE> <DEDENT> h = [ 0 ] + h <NEWLINE> w = [ 0 ] + w <NEWLINE> hl = [ 0 ] * ( 1000 * 1000 + 1 ) <NEWLINE> wl = [ 0 ] * ( 1000 * 1000 + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N + 1 ) : <NEWLINE> <INDENT> hl [ h [ j ] - h [ i ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> for j in range ( i + 1 , M + 1 ) : <NEWLINE> <INDENT> wl [ w [ j ] - w [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i , j in zip ( hl , wl ) : <NEWLINE> <INDENT> ans += i * j <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
from math import log <NEWLINE> class SegmentTree : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . tree = [ 0 for i in range ( 2 * N - 1 ) ] <NEWLINE> <NL> <DEDENT> def update ( self , i , x ) : <NEWLINE> <INDENT> node = i + self . N - 1 <NEWLINE> self . tree [ node ] += x <NEWLINE> while node > 0 : <NEWLINE> <INDENT> node = ( node - 1 ) / 2 <NEWLINE> self . tree [ node ] += x <NEWLINE> <NL> <DEDENT> <DEDENT> def sum ( self , here , l , r , hl , hr ) : <COMMENT> <NEWLINE> <INDENT> if here >= self . N - 1 or l == hl and r == hr : <NEWLINE> <INDENT> return self . tree [ here ] <NEWLINE> <DEDENT> midle = ( hl + hr + 1 ) / 2 <COMMENT> <NEWLINE> result = 0 <NEWLINE> if l < midle : <NEWLINE> <INDENT> result += self . sum ( 2 * here + 1 , l , min ( r , midle - 1 ) , hl , midle - 1 ) <NEWLINE> <DEDENT> if r >= midle : <NEWLINE> <INDENT> result += self . sum ( 2 * here + 2 , max ( l , midle ) , r , midle , hr ) <NEWLINE> <DEDENT> return result <NEWLINE> <DEDENT> <DEDENT> while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( n , m ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Lon_idx = log ( n , 2 ) <NEWLINE> Lat_idx = log ( m , 2 ) <NEWLINE> LonN = 2 ** ( int ( Lon_idx ) if Lon_idx . is_integer ( ) else ( int ( Lon_idx ) + 1 ) ) <NEWLINE> LatN = 2 ** ( int ( Lat_idx ) if Lat_idx . is_integer ( ) else ( int ( Lat_idx ) + 1 ) ) <NEWLINE> LonST = SegmentTree ( LonN ) <NEWLINE> LatST = SegmentTree ( LatN ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> LonST . update ( i , int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 0 , m ) : <NEWLINE> <INDENT> LatST . update ( i , int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> Lon = [ 0 for i in range ( n * 1000 + 1 ) ] <NEWLINE> Lat = [ 0 for i in range ( m * 1000 + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for j in range ( n + 1 - i ) : <NEWLINE> <INDENT> Lon [ LonST . sum ( 0 , j , j + i - 1 , 0 , LonN - 1 ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( m + 1 - i ) : <NEWLINE> <INDENT> Lat [ LatST . sum ( 0 , j , j + i - 1 , 0 , LatN - 1 ) ] += 1 <NEWLINE> <DEDENT> <DEDENT> max_width = min ( LonST . tree [ 0 ] , LatST . tree [ 0 ] ) <NEWLINE> print sum ( [ Lon [ i ] * Lat [ i ] for i in range ( 1 , max_width + 1 ) ] ) <NEWLINE> <DEDENT>
import collections <NEWLINE> cnt1 = collections . Counter ( ) <NEWLINE> cnt2 = collections . Counter ( ) <NEWLINE> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> ll = [ 0 ] * 1500 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ll [ j ] += x <NEWLINE> cnt1 [ ll [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> ll [ j ] += x <NEWLINE> cnt2 [ ll [ j ] ] += 1 <NEWLINE> <DEDENT> <DEDENT> sets = set ( cnt1 . keys ( ) . cnt2 . keys ( ) ) <NEWLINE> ans = 0 <NEWLINE> for s in sets : <NEWLINE> <INDENT> ans += cnt1 [ s ] * cnt2 [ s ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE>
while True : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( n , m ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dp = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> dp = sorted ( dp , key = lambda kv : kv [ 1 ] , reverse = True ) <NEWLINE> r = 0 <NEWLINE> for d , p in dp : <NEWLINE> <INDENT> if m >= d : <NEWLINE> <INDENT> m -= d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r += p * ( d - m ) <NEWLINE> m = 0 <NEWLINE> <DEDENT> <DEDENT> print ( r <NEWLINE> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> l1 = list ( map ( input ( ) . split ( ) ) ) <NEWLINE> l1 = l1 [ : : - 1 ] <NEWLINE> l . append ( l1 ) <NEWLINE> <DEDENT> l = sorted ( l ) <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s += l [ i ] [ 0 ] * l [ i ] [ 1 ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if m - l [ i ] [ 1 ] >= 0 : <NEWLINE> <INDENT> s -= l [ i ] [ 0 ] * l [ i ] [ 1 ] <NEWLINE> m -= l [ i ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s -= l [ i ] [ 0 ] * m <NEWLINE> <DEDENT> <DEDENT> print ( s ) <NEWLINE>
da = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> k = [ [ 0 for i in range ( 2 ) ] for j in range ( 10001 ) ] <NEWLINE> i = 0 <NEWLINE> su = 0 <NEWLINE> j = 0 <NEWLINE> <NL> while da [ 0 ] != 0 and da [ 1 ] != 0 : <NEWLINE> <INDENT> i = 0 <NEWLINE> su = 0 <NEWLINE> j = 0 <NEWLINE> for i in range ( da [ 0 ] ) : <NEWLINE> <INDENT> k [ i ] [ 0 ] , k [ i ] [ 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> su += k [ i ] [ 0 ] * k [ i ] [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> sorted ( k , key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> while da [ 1 ] > 0 and j != i + 1 : <NEWLINE> <INDENT> if da [ 1 ] >= k [ j ] [ 0 ] and j != i <NEWLINE> <INDENT> su -= k [ j ] [ 0 ] * k [ j ] [ 1 ] <NEWLINE> da [ 1 ] -= k [ j ] [ 0 ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> elif j == i + 1 : <NEWLINE> <INDENT> da [ 1 ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> su -= da [ 1 ] * k [ j ] [ 1 ] <NEWLINE> da [ 1 ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( su ) <NEWLINE> <NL> da = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if da [ 0 ] == 0 and da [ 1 ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k = [ [ 0 for i in range ( 2 ) ] for j in range ( 10001 ) ] <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if N == M == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = [ ] <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> L . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> L = sorted ( L , key = lambda x : x [ 1 ] ) <NEWLINE> L . reverse ( ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> if M > 0 : <NEWLINE> <INDENT> if M - L [ i ] [ 0 ] >= 0 : <NEWLINE> M -= L [ i ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += ( L [ i ] [ 0 ] - M ) * L [ i ] [ 1 ] <NEWLINE> M = 0 <NEWLINE> else : <NEWLINE> ans += L [ i ] [ 0 ] * L [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if [ N , M ] == [ 0 , 0 ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> L = [ ] <NEWLINE> S = 0 <COMMENT> <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> l . reverse ( ) <COMMENT> <NEWLINE> L . append ( l ) <NEWLINE> S = S + l [ 0 ] * l [ 1 ] <NEWLINE> <DEDENT> L . sort ( ) <NEWLINE> j = N <NEWLINE> while M > 0 : <NEWLINE> <INDENT> if M >= L [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> S = S - L [ j ] [ 0 ] * L [ j ] [ 1 ] <NEWLINE> M = M - L [ j ] [ 1 ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = S - L [ j ] [ 0 ] * M <NEWLINE> M = M - L [ j ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> print ( S ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> INF = 10 ** 20 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n , m , l , k , a , h = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if l != 0 : <NEWLINE> <INDENT> sisetu = list ( map ( int , input ( ) . split ( ) ) ) + [ a , h ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> input ( ) <NEWLINE> sisetu = [ a , h ] <NEWLINE> <NL> <DEDENT> costs = [ [ INF ] * n for _ in range ( n ) ] <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> x , y , t = map ( int , input ( ) . split ( ) ) <NEWLINE> costs [ x ] [ y ] = t <NEWLINE> costs [ y ] [ x ] = t <NEWLINE> <DEDENT> for k in range ( n ) : <NEWLINE> <INDENT> costsk = costs [ k ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> costsi = costs [ i ] <NEWLINE> costsik = costsi [ k ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> costsij = costsi [ j ] <NEWLINE> costsikj = costsik + costsk [ j ] <NEWLINE> if costsij > costsikj : <NEWLINE> <INDENT> costsi [ j ] = costsikj <NEWLINE> costs [ j ] [ i ] = costsikj <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> edges = [ [ ] for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if i in sisetu and j in sisetu and costs [ i ] [ j ] <= m : <NEWLINE> <INDENT> edges [ i ] . append ( ( costs [ i ] [ j ] , j ) ) <NEWLINE> edges [ j ] . append ( ( costs [ i ] [ j ] , i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> que = [ ] <NEWLINE> heappush ( que , ( 0 , a ) ) <NEWLINE> cost = [ INF ] * n <NEWLINE> cost [ a ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> total , node = heappop ( que ) <NEWLINE> for dist , to in edges [ node ] : <NEWLINE> <INDENT> if total + dist < cost [ to ] : <NEWLINE> <INDENT> cost [ to ] = total + dist <NEWLINE> heappush ( que , ( total + dist , to ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if cost [ h ] == INF : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost [ h ] + max ( 0 , ( cost [ h ] - m ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from heapq import heappush , heappop <NEWLINE> while 1 : <NEWLINE> <INDENT> N , M , L , K , A , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> F = [ 0 ] * N <NEWLINE> if L > 0 : <NEWLINE> <INDENT> for e in map ( int , raw_input ( ) . split ( ) ) : <NEWLINE> <INDENT> F [ e ] = 1 <NEWLINE> <DEDENT> <DEDENT> G = [ [ ] for i in xrange ( N ) ] <NEWLINE> for i in xrange ( K ) : <NEWLINE> <INDENT> x , y , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> G [ x ] . append ( ( y , t ) ) <NEWLINE> G [ y ] . append ( ( x , t ) ) <NEWLINE> <DEDENT> dist = [ [ 10 ** 18 ] * ( M + 1 ) for i in xrange ( N ) ] <NEWLINE> dist [ A ] [ M ] = 0 <NEWLINE> que = [ ( 0 , A , M ) ] <NEWLINE> while que : <NEWLINE> <INDENT> cost , v , rest = heappop ( que ) <NEWLINE> if dist [ v ] [ rest ] < cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if F [ v ] and rest < M and cost + 1 < dist [ v ] [ rest + 1 ] : <NEWLINE> <INDENT> dist [ v ] [ rest + 1 ] = cost + 1 <NEWLINE> heappush ( que , ( cost + 1 , v , rest + 1 ) ) <NEWLINE> <DEDENT> for t , co in G [ v ] : <NEWLINE> <INDENT> if rest >= co and cost + co < dist [ t ] [ rest - co ] : <NEWLINE> <INDENT> dist [ t ] [ rest - co ] = cost + co <NEWLINE> heappush ( que , ( cost + co , t , rest - co ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ans = min ( dist [ H ] ) <NEWLINE> print <STRING> if ans > 10 ** 17 else ans <NEWLINE> <DEDENT>
import sys <NEWLINE> import heapq <NEWLINE> <NL> class Dijkstra ( object ) : <NEWLINE> <INDENT> def dijkstra ( self , adj , start , goal = None ) : <NEWLINE> <INDENT> num = len ( adj ) <NEWLINE> dist = [ sys . maxint ] * num <NEWLINE> prev = [ sys . maxint ] * num <NEWLINE> dist [ start ] = 0 <NEWLINE> q = [ ] <NEWLINE> heapq . heappush ( q , ( 0 , start ) ) <NEWLINE> <NL> while len ( q ) != 0 : <NEWLINE> <INDENT> prov_cost , src = heapq . heappop ( q ) <NEWLINE> if dist [ src ] < prov_cost : continue <NEWLINE> for dest in range ( num ) : <NEWLINE> <INDENT> cost = adj [ src ] [ dest ] <NEWLINE> if cost != sys . maxint and dist [ dest ] > dist [ src ] + cost : <NEWLINE> <INDENT> dist [ dest ] = dist [ src ] + cost <NEWLINE> heapq . heappush ( q , ( dist [ dest ] , dest ) ) <NEWLINE> prev [ dest ] = src <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if goal is not None : <NEWLINE> <INDENT> return self . get_path ( goal , prev ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dist <NEWLINE> <NL> <DEDENT> <DEDENT> def get_path ( self , goal , prev ) : <NEWLINE> <INDENT> path = [ goal ] <NEWLINE> dest = goal <NEWLINE> while prev [ dest ] != sys . maxint : <NEWLINE> <INDENT> path . append ( prev [ dest ] ) <NEWLINE> dest = prev [ dest ] <NEWLINE> <DEDENT> return list ( reversed ( path ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> while True : <NEWLINE> <INDENT> N , M , L , K , A , H = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> <COMMENT> <NL> Ls = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> edge = [ [ sys . maxint ] * ( N * ( M + 1 ) ) for _ in xrange ( N * ( M + 1 ) ) ] <NEWLINE> for l in Ls : <NEWLINE> <INDENT> for i in xrange ( M ) : <NEWLINE> <INDENT> edge [ l * ( M + 1 ) + i ] [ l * ( M + 1 ) + i + 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for _ in xrange ( K ) : <NEWLINE> <INDENT> s , g , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in xrange ( c , M + 1 ) : <NEWLINE> <INDENT> edge [ s * ( M + 1 ) + i ] [ g * ( M + 1 ) + i - c ] = c <NEWLINE> edge [ g * ( M + 1 ) + i ] [ s * ( M + 1 ) + i - c ] = c <NEWLINE> <DEDENT> <DEDENT> cost = Dijkstra ( ) . dijkstra ( edge , A * ( M + 1 ) + M ) <NEWLINE> minCost = sys . maxint <NEWLINE> for i in xrange ( M + 1 ) : <NEWLINE> <INDENT> minCost = min ( minCost , cost [ H * ( M + 1 ) + i ] ) <NEWLINE> <DEDENT> if minCost == sys . maxint : print <STRING> <NEWLINE> else : print minCost <NEWLINE> <DEDENT>
import sys <NEWLINE> sys . setrecursionlimit ( 10000 ) <NEWLINE> <NL> def checkloop ( pdict , product , inroute ) : <NEWLINE> <INDENT> inroute . append ( product ) <NEWLINE> if pdict [ product ] [ 1 ] == product : <NEWLINE> <INDENT> return ( False , product ) <NEWLINE> <DEDENT> elif pdict [ product ] [ 1 ] in inroute : <NEWLINE> <INDENT> return ( True , pdict [ product ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return checkloop ( pdict , pdict [ product ] [ 1 ] , inroute ) <NEWLINE> <NL> <DEDENT> <DEDENT> def daysopen ( pdict , product , made , notsearched ) : <NEWLINE> <INDENT> if pdict [ product ] [ 1 ] in made : <NEWLINE> <INDENT> made . append ( product ) <NEWLINE> notsearched . remove ( product ) <NEWLINE> return pdict [ product ] [ 2 ] <NEWLINE> <DEDENT> if pdict [ product ] [ 1 ] == product : <NEWLINE> <INDENT> made . append ( product ) <NEWLINE> notsearched . remove ( product ) <NEWLINE> return pdict [ product ] [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> made . append ( product ) <NEWLINE> notsearched . remove ( product ) <NEWLINE> return daysopen ( pdict , pdict [ product ] [ 1 ] , made , notsearched ) + pdict [ product ] [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def daysloop ( pdict , product , made , notsearched , inloop ) : <NEWLINE> <INDENT> inloop . append ( product ) <NEWLINE> if pdict [ product ] [ 1 ] in inloop : <NEWLINE> <INDENT> smallestdifference = 100000 <NEWLINE> smallestdifferenceitem = <STRING> <NEWLINE> for item in inloop : <NEWLINE> <INDENT> if smallestdifference > pdict [ item ] [ 0 ] - pdict [ item ] [ 2 ] : <NEWLINE> <INDENT> smallestdifference = pdict [ item ] [ 0 ] - pdict [ item ] [ 2 ] <NEWLINE> smallestdifferenceitem = item <NEWLINE> <COMMENT> <NL> <DEDENT> days = pdict [ smallestdifferenceitem ] [ 0 ] <NEWLINE> made . append ( smallestdifferenceitem ) <NEWLINE> notsearched . remove ( smallestdifferenceitem ) <NEWLINE> inloop . remove ( smallestdifferenceitem ) <NEWLINE> for item in inloop : <NEWLINE> <INDENT> made . append ( item ) <NEWLINE> notsearched . remove ( item ) <NEWLINE> days = days + pdict [ item ] [ 2 ] <NEWLINE> <DEDENT> return days <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return daysloop ( pdict , pdict [ product ] [ 1 ] , made , notsearched , inloop ) <NEWLINE> <NL> <DEDENT> <DEDENT> while ( 1 ) : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pdict = { } <NEWLINE> notsearched = [ ] <NEWLINE> notcomplete = 1 <NEWLINE> made = [ ] <NEWLINE> days = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> indat = raw_input ( ) . split ( ) <NEWLINE> pdict [ indat [ 0 ] ] = ( int ( indat [ 1 ] ) , indat [ 2 ] , int ( indat [ 3 ] ) ) <COMMENT> <NEWLINE> notsearched . append ( indat [ 0 ] ) <NEWLINE> <DEDENT> while len ( notsearched ) != 0 : <NEWLINE> <COMMENT> <NL> <INDENT> inroute = [ ] <NEWLINE> product = notsearched [ 0 ] <NEWLINE> <COMMENT> <NL> if pdict [ product ] [ 1 ] in made : <NEWLINE> <INDENT> days = days + pdict [ product ] [ 2 ] <NEWLINE> made . append ( product ) <NEWLINE> notsearched . remove ( product ) <NEWLINE> <DEDENT> elif checkloop ( pdict , product , inroute ) [ 0 ] : <NEWLINE> <INDENT> inloop = [ ] <NEWLINE> days = days + daysloop ( pdict , product , made , notsearched , inloop ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> days = days + daysopen ( pdict , product , made , notsearched ) <NEWLINE> <DEDENT> <DEDENT> print days <NEWLINE> <DEDENT> <DEDENT>
def prime ( a ) : <NEWLINE> <INDENT> prime = [ ] <NEWLINE> for p in range ( 2 , a ) : <NEWLINE> <INDENT> if a % p == 0 : <NEWLINE> <INDENT> prime . append ( p ) <NEWLINE> while a % p == 0 : <NEWLINE> <INDENT> a /= p <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> def keynumber ( prime ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( len ( prime ) - 1 ) : <NEWLINE> <INDENT> sum += prime [ i ] <NEWLINE> <DEDENT> key = prime [ - 1 ] - sum <NEWLINE> return key <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> ab = raw_input ( ) . split ( ) <NEWLINE> a = int ( ab [ 0 ] ) <NEWLINE> b = int ( ab [ 1 ] ) <NEWLINE> if a == 0 and b == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> pa = prime ( a ) <NEWLINE> pb = prime ( b ) <NEWLINE> ka = keynumber ( pa ) <NEWLINE> kb = keynumber ( pb ) <NEWLINE> if ka > kb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def toBinary ( block ) : <NEWLINE> <INDENT> return [ sum ( 1 << i for i , bb in enumerate ( b ) if bb == <STRING> ) for b in block ] <NEWLINE> <NL> <DEDENT> def toStr ( bfield ) : <NEWLINE> <INDENT> return [ <STRING> . join ( <STRING> if f & ( 1 << i ) == 0 else <STRING> for i in xrange ( W ) ) for f in bfield ] <NEWLINE> <NL> <DEDENT> def rotated ( block ) : <NEWLINE> <INDENT> return map ( lambda x : <STRING> . join ( x ) , zip ( * [ b [ : ] for b in block ] ) ) [ : : - 1 ] <NEWLINE> <NL> <DEDENT> def striped ( block ) : <NEWLINE> <INDENT> ret = [ b [ : ] for b in block ] <NEWLINE> while ret [ - 1 ] == <STRING> * len ( ret [ 0 ] ) : <NEWLINE> <INDENT> ret . pop ( - 1 ) <NEWLINE> <DEDENT> while ret [ 0 ] == <STRING> * len ( ret [ 0 ] ) : <NEWLINE> <INDENT> ret . pop ( 0 ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def canPut ( x , y ) : <NEWLINE> <INDENT> if not ( 0 < x + w <= W or 0 < y + h <= H ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for f , b in zip ( bfield [ y : y + h ] , bblock ) : <NEWLINE> <INDENT> if ( f & ( b << x ) ) != 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def puted ( x , y ) : <NEWLINE> <INDENT> ret = bfield [ : ] <NEWLINE> for i , b in zip ( xrange ( y , y + h ) , bblock ) : <NEWLINE> <INDENT> ret [ i ] = ret [ i ] | ( b << x ) <NEWLINE> <DEDENT> print <STRING> . join ( toStr ( ret ) ) , <STRING> <NEWLINE> return ret <NEWLINE> <NL> <DEDENT> def count ( bfield ) : <NEWLINE> <INDENT> return sum ( 1 for f in bfield if f == ( 1 << W ) - 1 ) <NEWLINE> <NL> <DEDENT> for _ in xrange ( input ( ) ) : <NEWLINE> <INDENT> block = striped ( rotated ( striped ( [ raw_input ( ) for _ in xrange ( map ( int , raw_input ( ) . split ( ) ) [ 0 ] ) ] ) ) ) <NEWLINE> h , w = len ( block ) , len ( block [ 0 ] ) <NEWLINE> H , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> field = [ raw_input ( ) for _ in xrange ( H ) ] <NEWLINE> bfield = toBinary ( field ) <NEWLINE> FLAG = False <NEWLINE> ans = 0 <NEWLINE> for _ in xrange ( 4 ) : <NEWLINE> <INDENT> block = rotated ( block ) <NEWLINE> h , w = w , h <NEWLINE> bblock = toBinary ( block ) <NEWLINE> for y in xrange ( 0 , H - h + 1 ) : <NEWLINE> <INDENT> for x in xrange ( 0 , W - w + 1 ) : <NEWLINE> <INDENT> if canPut ( x , y ) : <NEWLINE> <INDENT> FLAG = True <NEWLINE> ans = max ( ans , count ( puted ( x , y ) ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ans if FLAG else - 1 <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> c = int ( raw_input ( ) ) <NEWLINE> for i in range ( c ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> data = map ( int , raw_input ( ) ) <NEWLINE> u , d = 0 , 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> if data [ i + 1 ] - data [ i ] > u : <NEWLINE> <INDENT> u = data [ i + 1 ] - data [ i ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if data [ i + 1 ] - data [ i ] > d : <NEWLINE> <INDENT> d = data [ i + 1 ] - data [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print u , d <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
t = int ( input ( ) ) <NEWLINE> for _ in range ( t ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> h = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> maxv = 0 , minv = 0 <NEWLINE> for i in range ( len ( h ) - 1 ) : <NEWLINE> <INDENT> maxv = max ( maxv , h [ i + 1 ] - h [ i ] ) <NEWLINE> minv = max ( minv , h [ i ] - h [ i + 1 ] ) <NEWLINE> <DEDENT> print ( maxv , minv ) <NEWLINE> <DEDENT>
def f ( p ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> if p <= 5 : return ans <NEWLINE> for n in range ( 1 , int ( p / 2 ) + 1 ) : <NEWLINE> <INDENT> if p % n == 0 : ans += n <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> m = f ( n ) <NEWLINE> if n == m : print ( <STRING> ) <NEWLINE> else : print ( <STRING> if n > m else <STRING> ) <NEWLINE> <DEDENT>
import itertools as it <NEWLINE> <NL> T = input ( ) <NEWLINE> <NL> def goodset ( a , b , c ) : <NEWLINE> <INDENT> return ( a == b and b == c ) or ( a + 1 == b and b + 1 == c ) <NEWLINE> <NL> <DEDENT> def win ( c ) : <NEWLINE> <INDENT> return goodset ( c [ 0 ] , c [ 1 ] , c [ 2 ] ) and goodset ( c [ 3 ] , c [ 4 ] , c [ 5 ] ) and goodset ( c [ 6 ] , c [ 7 ] , c [ 8 ] ) <NEWLINE> <NL> <DEDENT> for i in range ( T ) : <NEWLINE> <INDENT> cards = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> color = raw_input ( ) . split ( ) <NEWLINE> for j in range ( 9 ) : <NEWLINE> <INDENT> if color [ j ] == <STRING> : <NEWLINE> <INDENT> cards [ j ] += 100 <NEWLINE> <DEDENT> elif color [ j ] == <STRING> : <NEWLINE> <INDENT> cards [ j ] += 200 <NEWLINE> <DEDENT> <DEDENT> w = 0 <NEWLINE> for p in it . permutations ( range ( 9 ) ) : <NEWLINE> <INDENT> c = [ cards [ p [ j ] ] for j in range ( 9 ) ] <NEWLINE> if win ( c ) : <NEWLINE> <INDENT> w = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print w <NEWLINE> <DEDENT>
a = [ ] <NEWLINE> M = int ( input ( ) ) <NEWLINE> for i in range ( M * 2 ) : <NEWLINE> <INDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> a . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( [ i for i in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( M ) : <NEWLINE> <INDENT> data = a [ i * 2 : ( i + 1 ) * 2 ] <NEWLINE> data_df = pd . DataFrame ( data ) <NEWLINE> data_df = data_df . sort_values ( 1 , axis = 1 ) <COMMENT> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> rgb_count = 0 <NEWLINE> value_count = 0 <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> data3 = data_df . iloc [ : , 3 * j : 3 * ( j + 1 ) ] . sort_values ( 0 , axis = 1 ) <NEWLINE> r = ( data3 . iloc [ : , 0 ] [ 0 ] + data3 . iloc [ : , 2 ] [ 0 ] ) / data3 . iloc [ : , 1 ] [ 0 ] <NEWLINE> if data3 . iloc [ : , 0 ] [ 1 ] == data3 . iloc [ : , 1 ] [ 1 ] == data3 . iloc [ : , 2 ] [ 1 ] : <NEWLINE> <INDENT> rgb_count += 1 <NEWLINE> <DEDENT> if r == 2 : <NEWLINE> <INDENT> value_count += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> if ( value_count == 3 and rgb_count == 3 ) : <COMMENT> <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( data_df . iloc [ : , 0 ] [ 0 ] != 8 and data_df . iloc [ : , 1 ] [ 0 ] != 9 and data_df . iloc [ : , 3 ] [ 0 ] != 1 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> WINNING_HANDS = [ <NEWLINE> <INDENT> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <NEWLINE> <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> <NEWLINE> ] <NEWLINE> <NL> <DEDENT> num_of_datasets = int ( sys . stdin . readline ( ) . strip ( <STRING> ) ) <NEWLINE> datasets = [ { <STRING> : [ ] , <STRING> : [ ] , <STRING> : [ ] } for _ in range ( num_of_datasets ) ] <NEWLINE> results = list ( ) <NEWLINE> <NL> for dataset in range ( num_of_datasets ) : <NEWLINE> <INDENT> n_set = [ num for num in sys . stdin . readline ( ) . strip ( <STRING> ) . split ( ) ] <NEWLINE> c_set = [ colour for colour in sys . stdin . readline ( ) . strip ( <STRING> ) . split ( ) ] <NEWLINE> for idx , colour in enumerate ( c_set ) : <NEWLINE> <INDENT> if colour == <STRING> : <NEWLINE> <INDENT> datasets [ dataset ] [ <STRING> ] . append ( n_set [ idx ] ) <NEWLINE> <DEDENT> elif colour == <STRING> : <NEWLINE> <INDENT> datasets [ dataset ] [ <STRING> ] . append ( n_set [ idx ] ) <NEWLINE> <DEDENT> elif colour == <STRING> : <NEWLINE> <INDENT> datasets [ dataset ] [ <STRING> ] . append ( n_set [ idx ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> match_count = int ( ) <NEWLINE> <NL> for rgb_key in datasets [ dataset ] : <NEWLINE> <INDENT> nums = sorted ( datasets [ dataset ] [ rgb_key ] ) <NEWLINE> <NL> for hand in WINNING_HANDS : <NEWLINE> <INDENT> while hand [ 0 ] in nums and hand [ 1 ] in nums and hand [ 2 ] in nums : <NEWLINE> <INDENT> tmp = nums . copy ( ) <NEWLINE> if hand [ 0 ] in tmp : <NEWLINE> <INDENT> if hand [ 1 ] in tmp : <NEWLINE> <INDENT> if hand [ 2 ] in tmp : <NEWLINE> <INDENT> match_count += 1 <NEWLINE> nums = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if match_count == 3 : <NEWLINE> <INDENT> results . append ( 1 ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if dataset < num_of_datasets - 1 and match_count != 3 : <NEWLINE> <INDENT> results . append ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> for result in results : <NEWLINE> <INDENT> print ( result ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
dx = [ - 1 , 0 , 1 , 0 ] <NEWLINE> dy = [ 0 , - 1 , 0 , 1 ] <NEWLINE> tanks = map ( ord , <STRING> ) <NEWLINE> flat = ord ( <STRING> ) <NEWLINE> brick = ord ( <STRING> ) <NEWLINE> iron = ord ( <STRING> ) <NEWLINE> water = ord ( <STRING> ) <NEWLINE> <NL> for t in xrange ( input ( ) ) : <NEWLINE> <INDENT> h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = [ map ( ord , raw_input ( ) ) for i in xrange ( h ) ] <NEWLINE> n = input ( ) <NEWLINE> s = raw_input ( ) <NEWLINE> x , y = 0 , 0 <NEWLINE> d = 0 <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> for j in xrange ( w ) : <NEWLINE> <INDENT> if m [ i ] [ j ] in tanks : <NEWLINE> <INDENT> x = j <NEWLINE> y = i <NEWLINE> d = tanks . index ( m [ i ] [ j ] ) <NEWLINE> m [ i ] [ j ] = flat <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for comm in s : <NEWLINE> <INDENT> if comm == <STRING> : <NEWLINE> <INDENT> d = 1 <NEWLINE> if y > 0 and m [ y - 1 ] [ x ] == flat : <NEWLINE> <INDENT> y -= 1 <NEWLINE> <DEDENT> <DEDENT> elif comm == <STRING> : <NEWLINE> <INDENT> d = 3 <NEWLINE> if y < h - 1 and m [ y + 1 ] [ x ] == flat : <NEWLINE> <INDENT> y += 1 <NEWLINE> <DEDENT> <DEDENT> elif comm == <STRING> : <NEWLINE> <INDENT> d = 0 <NEWLINE> if x > 0 and m [ y ] [ x - 1 ] == flat : <NEWLINE> <INDENT> x -= 1 <NEWLINE> <DEDENT> <DEDENT> elif comm == <STRING> : <NEWLINE> <INDENT> d = 2 <NEWLINE> if x < w - 1 and m [ y ] [ x + 1 ] == flat : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> nx = x + dx [ d ] <NEWLINE> ny = y + dy [ d ] <NEWLINE> while 0 <= nx <= w - 1 and 0 <= ny <= h - 1 : <NEWLINE> <INDENT> obj = m [ ny ] [ nx ] <NEWLINE> if obj == brick : <NEWLINE> <INDENT> m [ ny ] [ nx ] = flat <NEWLINE> break <NEWLINE> <DEDENT> elif obj == iron : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> nx += dx [ d ] <NEWLINE> ny += dy [ d ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> m [ y ] [ x ] = tanks [ d ] <NEWLINE> for i in xrange ( h ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( chr , m [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> N , K = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> X = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <NEWLINE> L = [ X [ i + 1 ] - X [ i ] for i in range ( 0 , N - 1 ) ] <NEWLINE> L . sort ( ) <NEWLINE> s = 0 <NEWLINE> for i in range ( 0 , N - K ) : <NEWLINE> <INDENT> s = s + L [ i ] <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
t = int ( input ( ) ) <NEWLINE> for j in range ( t ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l1 = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> l1 . append ( l [ i + 1 ] - l [ i ] ) <NEWLINE> <DEDENT> l1 = sorted ( l1 ) <NEWLINE> for i in range ( k - 1 ) : <NEWLINE> <INDENT> del l1 [ - 1 ] <NEWLINE> <DEDENT> s = 0 <NEWLINE> for i in l1 : <NEWLINE> <INDENT> s += i <NEWLINE> <DEDENT> print ( s ) <NEWLINE> <DEDENT>
N , K = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> X = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> X . sort ( reverse = True ) <NEWLINE> print ( X ) <NEWLINE> Y = [ ] <NEWLINE> for i in range ( len ( X ) - 1 ) : <NEWLINE> <INDENT> Y . append ( X [ i ] - X [ i + 1 ] ) <NEWLINE> <DEDENT> Y . sort ( reverse = True ) <NEWLINE> del Y [ : K - 1 ] <NEWLINE> print ( Y ) <NEWLINE> a = 0 <NEWLINE> for i in range ( len ( Y ) ) : <NEWLINE> <INDENT> a = a + Y [ i ] <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
def croad ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> else : <NEWLINE> <INDENT> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> y . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <DEDENT> y . sort ( ) <NEWLINE> y . reverse ( ) <NEWLINE> while k > 1 and len ( y ) > 0 : <NEWLINE> <INDENT> y . pop ( 0 ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> print ( sum ( y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = int ( input ( ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> croad ( ) <NEWLINE> <DEDENT>
def f ( n , k , x ) : <NEWLINE> <INDENT> dis = [ x [ i + 1 ] - x [ i ] for i in range ( n - 1 ) ] <COMMENT> <NEWLINE> dis . sort ( ) <COMMENT> <NEWLINE> return sum ( dis [ : n - k ] ) <COMMENT> <NEWLINE> <NL> <DEDENT> t = int ( input ( ) ) <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> L = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n <= k : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = [ ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> A . append ( L [ i ] - L [ i - 1 ] ) <NEWLINE> <DEDENT> A . sort ( ) <NEWLINE> A . reverse ( ) <NEWLINE> S = L [ n - 1 ] - L [ 0 ] <NEWLINE> for l in range ( k - 1 ) : <NEWLINE> <INDENT> S -= A [ l ] <NEWLINE> <DEDENT> print ( S ) <NEWLINE> <DEDENT> <DEDENT>
def croad ( ) : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = [ ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> y . append ( x [ i + 1 ] - x [ i ] ) <NEWLINE> <DEDENT> y . sort ( ) <NEWLINE> y . reverse ( ) <NEWLINE> while k > 1 : <NEWLINE> <INDENT> y . pop ( 0 ) <NEWLINE> k -= 1 <NEWLINE> <DEDENT> print ( sum ( y ) ) <NEWLINE> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> croad ( ) <NEWLINE> <DEDENT>
trial = int ( input ( ) ) <NEWLINE> for t in range ( trial ) : <NEWLINE> <INDENT> housecnt , elec = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> house = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> maxlist = [ ] <NEWLINE> for h in range ( housecnt - 1 ) : <NEWLINE> <INDENT> maxlist . append ( house [ h + 1 ] - house [ h ] ) <NEWLINE> <DEDENT> maxlist . sort ( ) <NEWLINE> for p in range ( min ( housecnt , elec - 1 ) ) : <NEWLINE> <INDENT> maxlist . pop ( ) <NEWLINE> <DEDENT> print ( sum ( maxlist ) ) <NEWLINE> <DEDENT>
f = lambda A , x , B , C : ( A * x + B ) % C <NEWLINE> while 1 : <NEWLINE> <INDENT> N , A , B , C , X = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if not N and not A and not B and not C and not X : break <NEWLINE> Y = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> T = X <NEWLINE> c = [ [ ] for _ in range ( N ) ] <NEWLINE> <NL> sl = 0 <NEWLINE> for i in range ( 10005 ) : <NEWLINE> <INDENT> if T == Y [ sl ] : <NEWLINE> <INDENT> sl += 1 <NEWLINE> if sl == N : break <NEWLINE> <DEDENT> T = f ( A , T , B , C ) <NEWLINE> <DEDENT> if i > 10000 : i = - 1 <NEWLINE> print ( i ) <NEWLINE> <NL> <DEDENT>
while True : <NEWLINE> <INDENT> N , A , B , C , X = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == A == B == C == X == 0 : break <NEWLINE> sum = 0 <NEWLINE> Z = 0 <NEWLINE> Y = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> if ( X in Y ) == True : <NEWLINE> <INDENT> Y . remove ( X ) <NEWLINE> <DEDENT> while Z == 0 : <NEWLINE> <INDENT> if sum == 10000 : <NEWLINE> <INDENT> sum = - 2 <NEWLINE> Z = 1 <NEWLINE> <DEDENT> sum += 1 <NEWLINE> X = ( A * X + B ) % C <NEWLINE> if X == Y [ 0 ] : <NEWLINE> <INDENT> Y . pop ( 0 ) <NEWLINE> if len ( Y ) == 0 : <NEWLINE> <INDENT> Z = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print sum <NEWLINE> <DEDENT>
null <NEWLINE>
import math <NEWLINE> def sieve ( n ) : <NEWLINE> <INDENT> prime = [ 0 , 0 ] <NEWLINE> prime += [ 1 for i in range ( n - 1 ) ] <NEWLINE> ub = math . sqrt ( n ) + 1 <NEWLINE> d = 2 <NEWLINE> while d <= ub : <NEWLINE> <INDENT> if prime [ d ] == 0 : <NEWLINE> <INDENT> d += 1 <NEWLINE> continue <NEWLINE> <DEDENT> prod = 2 <NEWLINE> while d * prod <= n : <NEWLINE> <INDENT> prime [ d * prod ] = 0 <NEWLINE> prod += 1 <NEWLINE> <DEDENT> d += 1 <NEWLINE> <DEDENT> return prime <NEWLINE> <DEDENT> prime = sieve ( 2 * 10 ** 5 ) <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> N , P = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ( N , P ) == ( 0 , 0 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> prime_ub = P <NEWLINE> prime_list = [ ] <NEWLINE> prime_num = 0 <NEWLINE> inc = N + 1 <NEWLINE> while prime_num < prime_ub : <NEWLINE> <INDENT> if prime [ inc ] == 1 : <NEWLINE> <INDENT> prime_num += 1 <NEWLINE> prime_list . append ( inc ) <NEWLINE> <DEDENT> inc += 1 <NEWLINE> <DEDENT> sum_list = [ ] <NEWLINE> for i in range ( prime_num ) : <NEWLINE> <INDENT> sum_list += [ prime_list [ i ] + p for p in prime_list [ i : ] ] <NEWLINE> <DEDENT> sum_list . sort ( ) <NEWLINE> print sum_list [ P - 1 ] <NEWLINE> <DEDENT>
import math <NEWLINE> M = 256 <NEWLINE> while 1 : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> H = 1e10 <NEWLINE> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for S in range ( 16 ) : <NEWLINE> <INDENT> for A in range ( 16 ) : <NEWLINE> <INDENT> for C in range ( 16 ) : <NEWLINE> <INDENT> R = S <NEWLINE> O = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> R = ( A * R + C ) % M <NEWLINE> O [ i ] = ( l [ i ] + R ) % M <NEWLINE> <DEDENT> X = [ O . count ( i ) for i in set ( O ) ] <NEWLINE> tmp = - sum ( float ( x ) / N * math . log ( float ( x ) / N , 2 ) for x in X ) <NEWLINE> if tmp < H : <NEWLINE> <INDENT> H = tmp <NEWLINE> ans = [ S , A , C ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , ans ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import itertools as it <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> S = reversed ( raw_input ( ) ) <NEWLINE> if S == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = [ 1 ] + [ 0 for i in range ( 10 ) ] <NEWLINE> diff = ans = 0 <NEWLINE> even = 1 <NEWLINE> for c in S : <NEWLINE> <INDENT> num = int ( c ) <NEWLINE> diff += num * even <NEWLINE> diff %= 11 <NEWLINE> if num != 0 : <NEWLINE> <INDENT> ans += m [ diff ] <NEWLINE> <DEDENT> m [ diff ] += 1 <NEWLINE> even *= - 1 <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import itertools as it <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> def fact ( num ) : <NEWLINE> <INDENT> if num <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return fact ( num - 1 ) + 1 <NEWLINE> <NL> <DEDENT> print fact ( 200000 ) <NEWLINE>
trial = int ( input ( ) ) <NEWLINE> <NL> for t in range ( trial ) : <NEWLINE> <INDENT> targ = [ int ( n ) for n in f . readline ( ) . split ( <STRING> ) ] <NEWLINE> root = [ [ 0 for n in range ( targ [ 0 ] + 1 ) ] for m in range ( targ [ 1 ] + 1 ) ] <NEWLINE> matanum = int ( f . readline ( ) ) <NEWLINE> for m in range ( matanum ) : <NEWLINE> <INDENT> matax , matay , secx , secy = ( int ( n ) for n in f . readline ( ) . split ( <STRING> ) ) <NEWLINE> if matax == secx : <NEWLINE> <INDENT> root [ max ( matay , secy ) ] [ matax ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ matay ] [ max ( secx , matax ) ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for yaxis in range ( targ [ 1 ] + 1 ) : <NEWLINE> <INDENT> for xaxis in range ( targ [ 0 ] + 1 ) : <NEWLINE> <INDENT> if xaxis == 0 : <NEWLINE> <INDENT> if root [ yaxis ] [ xaxis ] == <STRING> : <NEWLINE> <INDENT> root [ yaxis ] [ xaxis ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if yaxis == 0 : <NEWLINE> <INDENT> root [ 0 ] [ 0 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ yaxis ] [ xaxis ] = root [ yaxis - 1 ] [ xaxis ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif yaxis == 0 : <NEWLINE> <INDENT> if root [ yaxis ] [ xaxis ] == <STRING> : <NEWLINE> <INDENT> root [ yaxis ] [ xaxis ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ yaxis ] [ xaxis ] = root [ yaxis ] [ xaxis - 1 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if root [ yaxis ] [ xaxis ] == <STRING> : <NEWLINE> <INDENT> root [ yaxis ] [ xaxis ] = root [ yaxis ] [ xaxis - 1 ] <NEWLINE> <DEDENT> elif root [ yaxis ] [ xaxis ] == <STRING> : <NEWLINE> <INDENT> root [ yaxis ] [ xaxis ] = root [ yaxis - 1 ] [ xaxis ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root [ yaxis ] [ xaxis ] = root [ yaxis - 1 ] [ xaxis ] + root [ yaxis ] [ xaxis - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if root [ targ [ 1 ] ] [ targ [ 0 ] ] == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( root [ targ [ 1 ] ] [ targ [ 0 ] ] ) <NEWLINE> <DEDENT> <DEDENT>
m = { <STRING> : 24 , <STRING> : 21 , <STRING> : 18 , <STRING> : 15 , <STRING> : 12 , <STRING> : 9 , <STRING> : 6 , <STRING> : 3 , <STRING> : 2 , <STRING> : 1 , <STRING> : - 1 , <STRING> : - 2 , <STRING> : - 3 , <STRING> : - 6 , <STRING> : - 9 , <STRING> : - 12 , <STRING> : - 15 , <STRING> : - 18 , <STRING> : - 21 , <STRING> : - 24 } <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> v , * b = input ( ) . split ( ) <NEWLINE> if len ( b ) == 2 : <NEWLINE> <INDENT> k , b = b [ 0 ] , b [ 1 ] <NEWLINE> a = m [ k ] <NEWLINE> <DEDENT> else : b = b [ 0 ] ; a = 0 <NEWLINE> s = 0 <NEWLINE> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> if v [ i ] in <STRING> : <NEWLINE> <INDENT> s = len ( v ) - i <NEWLINE> if <STRING> in v [ i + 1 : ] : s -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> x = float ( v ) <NEWLINE> while x < 1 : <NEWLINE> <INDENT> x *= 10 <NEWLINE> a -= 1 <NEWLINE> <DEDENT> while x >= 10 : <NEWLINE> <INDENT> x /= 10 <NEWLINE> a += 1 <NEWLINE> <DEDENT> while 1 : <NEWLINE> <INDENT> if v [ 0 ] in <STRING> : <NEWLINE> <INDENT> if len ( v ) != 1 : <NEWLINE> <INDENT> v = v [ 0 ] + <STRING> + v [ 1 : ] <NEWLINE> if <STRING> in v [ 2 : ] : <NEWLINE> <INDENT> a = 2 + v [ 2 : ] . index ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if not n : break <NEWLINE> t = 0 <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> o = n // i <NEWLINE> t += ( i - 1 ) <NEWLINE> p = n - ( i * o - t ) <NEWLINE> if o + p // i + 1 - i < 1 : break <NEWLINE> if p % i == 0 : cnt += 1 <NEWLINE> <DEDENT> print cnt <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if n == a == b == 0 : break <NEWLINE> c = 0 ; d = [ 1 ] * ( n + 1 ) <NEWLINE> for x in range ( a ) : <NEWLINE> <INDENT> for i in range ( x * b , n + 1 , a ) : d [ i ] = 0 <NEWLINE> <DEDENT> print ( sum ( d ) ) <NEWLINE> <DEDENT>
card_table = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 , <STRING> : 5 , <STRING> : 6 , <STRING> : 7 , <STRING> : 8 , <STRING> : 9 , <STRING> : 10 , <STRING> : 11 , <STRING> : 12 } <NEWLINE> suit_table = { <STRING> : 0 , <STRING> : 1 , <STRING> : 2 , <STRING> : 3 } <NEWLINE> <NL> <NL> def get_numlist ( cards ) : <NEWLINE> <INDENT> numlist = [ ] <NEWLINE> for card in cards : <NEWLINE> <INDENT> numlist . append ( card [ 0 ] ) <NEWLINE> <DEDENT> return numlist <NEWLINE> <NL> <NL> <DEDENT> def is_royal ( cards ) : <NEWLINE> <INDENT> numlist = get_numlist ( cards ) <NEWLINE> if set ( numlist ) == set ( [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def is_fourcard ( cards ) : <NEWLINE> <INDENT> numlist = get_numlist ( cards ) <NEWLINE> if numlist . count ( numlist [ 0 ] ) == 4 or numlist . count ( numlist [ 1 ] ) == 4 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def is_fullhouse ( cards ) : <NEWLINE> <INDENT> numlist = get_numlist ( cards ) <NEWLINE> if len ( set ( numlist ) ) == 2 : <NEWLINE> <INDENT> for num in numlist : <NEWLINE> <INDENT> if numlist . count ( num ) == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def is_flash ( cards ) : <NEWLINE> <INDENT> suitlist = [ ] <NEWLINE> for card in cards : <NEWLINE> <INDENT> suitlist . append ( card [ 1 ] ) <NEWLINE> <DEDENT> if len ( set ( suitlist ) ) == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def is_straight ( cards ) : <NEWLINE> <INDENT> numlist = get_numlist ( cards ) <NEWLINE> if len ( set ( numlist ) ) == 5 : <NEWLINE> <INDENT> index_list = [ ] <NEWLINE> for num in numlist : <NEWLINE> <INDENT> index_list . append ( card_table [ num ] ) <NEWLINE> <DEDENT> index_list . sort ( ) <NEWLINE> if index_list == range ( index_list [ 0 ] , index_list [ 4 ] + 1 ) or index_list == [ 0 , 9 , 10 , 11 , 12 ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def is_threecard ( cards ) : <NEWLINE> <INDENT> numlist = get_numlist ( cards ) <NEWLINE> for num in numlist : <NEWLINE> <INDENT> if numlist . count ( num ) == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def is_twopair ( cards ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> numlist = get_numlist ( cards ) <NEWLINE> for num in set ( numlist ) : <NEWLINE> <INDENT> if numlist . count ( num ) == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> if count == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def is_onepair ( cards ) : <NEWLINE> <INDENT> numlist = get_numlist ( cards ) <NEWLINE> for num in numlist : <NEWLINE> <INDENT> if numlist . count ( num ) == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> def get_hand ( cards , rate ) : <NEWLINE> <INDENT> if is_flash ( cards ) and is_straight ( cards ) : <NEWLINE> <INDENT> if is_royal ( cards ) : <NEWLINE> <INDENT> return rate [ 8 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return rate [ 7 ] <NEWLINE> <DEDENT> <DEDENT> if is_fourcard ( cards ) : <NEWLINE> <INDENT> return rate [ 6 ] <NEWLINE> <DEDENT> if is_fullhouse ( cards ) : <NEWLINE> <INDENT> return rate [ 5 ] <NEWLINE> <DEDENT> if is_flash ( cards ) : <NEWLINE> <INDENT> return rate [ 4 ] <NEWLINE> <DEDENT> if is_straight ( cards ) : <NEWLINE> <INDENT> return rate [ 3 ] <NEWLINE> <DEDENT> if is_threecard ( cards ) : <NEWLINE> <INDENT> return rate [ 2 ] <NEWLINE> <DEDENT> if is_twopair ( cards ) : <NEWLINE> <INDENT> return rate [ 1 ] <NEWLINE> <DEDENT> if is_onepair ( cards ) : <NEWLINE> <INDENT> return rate [ 0 ] <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> def sum_bps ( cards , bps ) : <NEWLINE> <INDENT> bp = 0 <NEWLINE> for card in cards : <NEWLINE> <INDENT> num = card_table [ card [ 0 ] ] <NEWLINE> suit = suit_table [ card [ 1 ] ] <NEWLINE> bp += bps [ suit ] [ num ] <NEWLINE> <DEDENT> return bp <NEWLINE> <NL> <DEDENT> first_flag = False <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> input_num = int ( raw_input ( ) ) <NEWLINE> if not first_flag : <NEWLINE> <INDENT> print <NEWLINE> <DEDENT> bps = [ ] <NEWLINE> for count in range ( 4 ) : <NEWLINE> <INDENT> i = raw_input ( ) <NEWLINE> bps . append ( map ( int , i . split ( ) ) ) <NEWLINE> <DEDENT> i = raw_input ( ) <NEWLINE> rate = map ( int , i . split ( ) ) <NEWLINE> for count in range ( input_num ) : <NEWLINE> <INDENT> i = raw_input ( ) <NEWLINE> cards = i . split ( ) <NEWLINE> hand_rate = get_hand ( cards , rate ) <NEWLINE> bp = sum_bps ( cards , bps ) <NEWLINE> print hand_rate * bp <NEWLINE> <DEDENT> first_flag = True <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
while ( 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> W = [ [ ] for i in range ( 3 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> name = raw_input ( ) <NEWLINE> inp = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = inp [ 0 ] <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> W [ i ] . append ( [ c , inp [ 1 + i ] ] ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> W [ i ] . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> DP = [ [ 0 for x in range ( M + 1 ) ] for y in range ( N ) ] <NEWLINE> <NL> for t in range ( M + 1 ) : <NEWLINE> <INDENT> ci = W [ i ] [ 0 ] [ 0 ] * t <NEWLINE> if ci <= M : <NEWLINE> <INDENT> DP [ 0 ] [ ci ] = W [ i ] [ 0 ] [ 1 ] * t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for y in range ( 1 , N ) : <NEWLINE> <INDENT> for x in range ( M + 1 ) : <NEWLINE> <INDENT> for t in range ( M ) : <NEWLINE> <INDENT> ci = W [ i ] [ y ] [ 0 ] * t <NEWLINE> if ci <= x : <NEWLINE> <INDENT> DP [ y ] [ x ] = max ( DP [ y ] [ x ] , DP [ y - 1 ] [ x - ci ] + W [ i ] [ y ] [ 1 ] * t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> ans = max ( ans , max ( DP [ - 1 ] ) ) <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT>
import copy <NEWLINE> <NL> def can_empty ( A ) : <NEWLINE> <INDENT> while 1 : <NEWLINE> <COMMENT> <NL> <INDENT> for w in xrange ( W ) : <NEWLINE> <INDENT> seq = ( <STRING> . join ( A [ h ] [ w ] for h in xrange ( H ) ) ) . replace ( <STRING> , <STRING> ) <NEWLINE> seq += <STRING> * ( H - len ( seq ) ) <NEWLINE> for h in xrange ( H ) : <NEWLINE> <INDENT> A [ h ] [ w ] = seq [ h ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> B = [ [ 0 ] * W for _ in xrange ( H ) ] <NEWLINE> for h in xrange ( H ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> for w in xrange ( 1 , W ) : <NEWLINE> <INDENT> if A [ h ] [ w ] == A [ h ] [ w - 1 ] : cnt += 1 <NEWLINE> elif cnt >= n and A [ h ] [ w - 1 ] : <NEWLINE> <INDENT> for wi in xrange ( w - cnt , w ) : B [ h ] [ wi ] = 1 <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= n and A [ h ] [ W - 1 ] != <STRING> : <NEWLINE> <INDENT> for wi in xrange ( W - cnt , W ) : B [ h ] [ wi ] = 1 <NEWLINE> <DEDENT> <DEDENT> for w in xrange ( W ) : <NEWLINE> <INDENT> cnt = 1 <NEWLINE> for h in xrange ( 1 , H ) : <NEWLINE> <INDENT> if A [ h ] [ w ] == A [ h - 1 ] [ w ] : cnt += 1 <NEWLINE> elif cnt >= n and A [ h - 1 ] [ w ] : <NEWLINE> <INDENT> for hi in xrange ( h - cnt , h ) : B [ hi ] [ w ] = 1 <NEWLINE> cnt = 1 <NEWLINE> <DEDENT> <DEDENT> if cnt >= n and A [ H - 1 ] [ w ] != <STRING> : <NEWLINE> <INDENT> for hi in xrange ( H - cnt , H ) : B [ hi ] [ w ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> banish = False <NEWLINE> for h in xrange ( H ) : <NEWLINE> <INDENT> for w in xrange ( W ) : <NEWLINE> <INDENT> if B [ h ] [ w ] : <NEWLINE> <INDENT> A [ h ] [ w ] = <STRING> <NEWLINE> banish = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if not banish : return False <NEWLINE> if A == goal : return True <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> H , W , n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> _A = [ list ( raw_input ( ) ) for _ in xrange ( H ) ] [ : : - 1 ] <NEWLINE> goal = [ [ <STRING> ] * W for _ in xrange ( H ) ] <NEWLINE> ans = False <NEWLINE> for h in xrange ( H ) : <NEWLINE> <INDENT> A = copy . deepcopy ( _A ) <NEWLINE> for w in xrange ( W ) : <NEWLINE> <INDENT> if w < W - 1 : <NEWLINE> <INDENT> if A [ h ] [ w ] == A [ h ] [ w + 1 ] : continue <NEWLINE> A [ h ] [ w ] , A [ h ] [ w + 1 ] = A [ h ] [ w + 1 ] , A [ h ] [ w ] <NEWLINE> if can_empty ( A ) : <NEWLINE> <INDENT> ans = True <NEWLINE> break <NEWLINE> <DEDENT> A [ h ] [ w ] , A [ h ] [ w + 1 ] = A [ h ] [ w + 1 ] , A [ h ] [ w ] <NEWLINE> <DEDENT> <DEDENT> if ans : break <NEWLINE> <DEDENT> print <STRING> if ans else <STRING> <NEWLINE>
while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> E , B , Y = [ ] , [ ] , [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> era , base , year = raw_input ( ) . split ( ) <NEWLINE> E . append ( era ) <NEWLINE> B . append ( int ( base ) ) <NEWLINE> Y . append ( int ( year ) ) <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> year = int ( raw_input ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if Y [ j ] - B [ j ] < year <= Y [ j ] : <NEWLINE> <INDENT> print E [ i ] , year - Y [ j ] + B [ j ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 998244353 <NEWLINE> dd = [ ( 0 , - 1 ) , ( 1 , 0 ) , ( 0 , 1 ) , ( - 1 , 0 ) ] <NEWLINE> ddn = [ ( 0 , - 1 ) , ( 1 , - 1 ) , ( 1 , 0 ) , ( 1 , 1 ) , ( 0 , 1 ) , ( - 1 , - 1 ) , ( - 1 , 0 ) , ( - 1 , 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> l = True <NEWLINE> lr = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> c = s [ i ] <NEWLINE> p = s [ i - 1 ] <NEWLINE> cl = int ( c ) % 3 <NEWLINE> if cl == 0 : <NEWLINE> <INDENT> cl = 3 <NEWLINE> <DEDENT> pl = int ( p ) % 3 <NEWLINE> if pl == 0 : <NEWLINE> <INDENT> pl = 3 <NEWLINE> <NL> <DEDENT> if l and cl > pl : <NEWLINE> <INDENT> lr += 1 <NEWLINE> <DEDENT> elif not l and cl < pl : <NEWLINE> <INDENT> lr += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = not l <NEWLINE> <DEDENT> <DEDENT> l = False <NEWLINE> tr = 0 <NEWLINE> for i in range ( 1 , len ( s ) ) : <NEWLINE> <INDENT> c = s [ i ] <NEWLINE> p = s [ i - 1 ] <NEWLINE> cl = int ( c ) % 3 <NEWLINE> if cl == 0 : <NEWLINE> <INDENT> cl = 3 <NEWLINE> <DEDENT> pl = int ( p ) % 3 <NEWLINE> if pl == 0 : <NEWLINE> <INDENT> pl = 3 <NEWLINE> <NL> <DEDENT> if l and cl > pl : <NEWLINE> <INDENT> tr += 1 <NEWLINE> <DEDENT> elif not l and cl < pl : <NEWLINE> <INDENT> tr += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = not l <NEWLINE> <NL> <DEDENT> <DEDENT> rr . append ( min ( lr , tr ) ) <NEWLINE> <NL> <DEDENT> return <STRING> . join ( map ( str , rr ) ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> s = raw_input ( ) ; <NEWLINE> <NL> k = u = p = c = 0 ; <NEWLINE> for a in s : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> k += 1 ; <NEWLINE> <DEDENT> if a == <STRING> : <NEWLINE> <INDENT> u += 1 ; <NEWLINE> <DEDENT> if a == <STRING> : <NEWLINE> <INDENT> p += 1 ; <NEWLINE> <DEDENT> if a == <STRING> : <NEWLINE> <INDENT> c += 1 ; <NEWLINE> <NL> <DEDENT> <DEDENT> print min ( k , u , p , c ) ; <NEWLINE>
p = [ 1 ] * 1000001 <NEWLINE> for i in range ( 2 , 1001 ) : <NEWLINE> <INDENT> if p [ i ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( 2 , 1000000 / i + 1 ) : <NEWLINE> <INDENT> p [ i * j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> t = int ( raw_input ( ) ) <NEWLINE> for i in range ( t ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> res = n * ( n - 1 ) / 2 + 2 <NEWLINE> for j in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> if p [ j ] == 1 : <NEWLINE> <INDENT> res -= ( n / j - 1 ) * ( j - 1 ) <NEWLINE> <DEDENT> <DEDENT> print res <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> data = [ map ( float , raw_input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> maxV = 0.0 <NEWLINE> for comb in itertools . permutations ( range ( N ) , M ) : <NEWLINE> <INDENT> dist = 0.0 <NEWLINE> for i in range ( M - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , M ) : <NEWLINE> <INDENT> t = comb [ i ] <NEWLINE> s = comb [ j ] <NEWLINE> dist += pow ( data [ t ] [ 0 ] - data [ s ] [ 0 ] , 2 ) + pow ( data [ t ] [ 1 ] - data [ s ] [ 1 ] , 2 ) + pow ( data [ t ] [ 2 ] - data [ s ] [ 2 ] , 2 ) <NEWLINE> <DEDENT> <DEDENT> maxV = max ( maxV , dist ) <NEWLINE> <DEDENT> print maxV <NEWLINE>
<COMMENT> <NL> <NL> from collections import deque <NEWLINE> import itertools as it <NEWLINE> import sys <NEWLINE> <NL> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> N , M , L = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def fact ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> return fact ( n - 1 ) * n <NEWLINE> <DEDENT> MC = [ ] <NEWLINE> for i in range ( M + 1 ) : <NEWLINE> <INDENT> MC . append ( fact ( M ) / fact ( i ) / fact ( M - i ) ) <NEWLINE> <NL> <DEDENT> p_lst = [ ] <NEWLINE> P_val = [ ] <NEWLINE> P_sum = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> P , T , V = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p_lst . append ( ( T , V ) ) <NEWLINE> PP = [ ] <NEWLINE> for k in range ( M + 1 ) : <NEWLINE> <INDENT> PP . append ( MC [ k ] * ( P ** k ) * ( ( 100 - P ) ** ( M - k ) ) ) <NEWLINE> <DEDENT> P_val . append ( list ( PP ) ) <NEWLINE> for k in range ( M , 0 , - 1 ) : <NEWLINE> <INDENT> PP [ k - 1 ] += PP [ k ] <NEWLINE> <DEDENT> P_sum . append ( PP ) <NEWLINE> <NL> <DEDENT> def comp ( p1 , p2 , k1 , k2 ) : <NEWLINE> <INDENT> T1 , V1 = p1 <NEWLINE> T2 , V2 = p2 <NEWLINE> return L * ( V2 - V1 ) < V1 * V2 * ( k2 * T2 - k1 * T1 ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> index_lst = [ 0 for j in range ( N ) ] <NEWLINE> for k1 in range ( M + 1 ) : <NEWLINE> <INDENT> ret = P_val [ i ] [ k1 ] <NEWLINE> for j in range ( N ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag = True <NEWLINE> while True : <NEWLINE> <INDENT> k2 = index_lst [ j ] <NEWLINE> if k2 > M : <NEWLINE> <INDENT> ret *= 0 <NEWLINE> break <NEWLINE> <DEDENT> if comp ( p_lst [ i ] , p_lst [ j ] , k1 , k2 ) : <NEWLINE> <INDENT> ret *= P_sum [ j ] [ k2 ] <NEWLINE> break <NEWLINE> <DEDENT> index_lst [ j ] += 1 <NEWLINE> <DEDENT> <DEDENT> ans += ret <NEWLINE> <DEDENT> ans = float ( ans ) / 100 ** ( N * M ) <NEWLINE> print ans <NEWLINE> <NL> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> L = [ 0 ] * n <NEWLINE> D = [ 0 ] * n <NEWLINE> for man in xrange ( n ) : <NEWLINE> <INDENT> m , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> L [ man ] = l <NEWLINE> t = 0 <NEWLINE> for date in xrange ( m ) : <NEWLINE> <INDENT> s , e = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> t ^= ( ( 1 << ( e - 6 ) ) - 1 ) ^ ( ( 1 << ( s - 6 ) ) - 1 ) <NEWLINE> <DEDENT> D [ man ] = t <NEWLINE> <DEDENT> dp = [ [ 0 ] * ( 1 << 17 ) for i in xrange ( n ) ] <NEWLINE> dp [ 0 ] [ D [ 0 ] ] = L [ 0 ] <NEWLINE> for i in xrange ( 1 , n ) : <NEWLINE> <INDENT> for bit in xrange ( 1 << 17 ) : <NEWLINE> <INDENT> if dp [ i - 1 ] [ bit ] and bit & D [ i ] == 0 : <NEWLINE> <INDENT> dp [ i ] [ bit | D [ i ] ] = max ( dp [ i ] [ bit | D [ i ] ] , dp [ i - 1 ] [ bit ] + L [ i ] ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] [ D [ i ] ] = max ( dp [ i ] [ D [ i ] ] , L [ i ] ) <NEWLINE> <DEDENT> print max ( max ( dp [ i ] ) for i in xrange ( n ) ) <NEWLINE> <DEDENT>
inf = 10 ** 9 <NEWLINE> N = int ( raw_input ( ) ) <NEWLINE> p = [ int ( raw_input ( ) ) for i in xrange ( N ) ] <NEWLINE> to = [ i for i in xrange ( N ) ] <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> if to [ i ] != i : continue <NEWLINE> seq = set ( [ ] ) <NEWLINE> while 1 : <NEWLINE> <INDENT> if to [ i ] != i : <NEWLINE> <INDENT> for j in seq : to [ j ] = to [ i ] <NEWLINE> <DEDENT> elif i in seq : <NEWLINE> <INDENT> for j in seq : to [ j ] = - 1 <NEWLINE> break <NEWLINE> <DEDENT> elif p [ i ] == 0 : <NEWLINE> <INDENT> for j in seq : to [ j ] = i <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> seq . add ( i ) <NEWLINE> i += p [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dp = [ inf ] * N <NEWLINE> dp [ 0 ] = 0 <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> if dp [ i ] == inf : continue <NEWLINE> for j in xrange ( i + 1 , min ( N , i + 7 ) ) : <NEWLINE> <INDENT> if to [ j ] < j : continue <NEWLINE> dp [ to [ j ] ] = min ( dp [ to [ j ] ] , dp [ i ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> print dp [ N - 1 ] <NEWLINE>
import Queue , sys <NEWLINE> INF = 10 ** 9 + 7 <NEWLINE> n = input ( ) <NEWLINE> p = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> p . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> dist = [ 10 ** 7 ] * n <NEWLINE> calc = [ - 1 ] * n <NEWLINE> used = [ False ] * n <NEWLINE> que = Queue . PriorityQueue ( ) <NEWLINE> que . put ( ( 0 , 0 ) ) <NEWLINE> dist [ 0 ] = 0 <NEWLINE> sys . setrecursionlimit ( 10 ** 5 + 7 ) <NEWLINE> def dfs ( pos , calc , used , f ) : <NEWLINE> <INDENT> if p [ pos ] == 0 : <NEWLINE> <INDENT> return pos <NEWLINE> <DEDENT> if calc [ pos ] != - 1 : <NEWLINE> <INDENT> return calc [ pos ] <NEWLINE> <DEDENT> if used [ pos ] : <NEWLINE> <INDENT> return INF <NEWLINE> <DEDENT> used [ pos ] = True <NEWLINE> calc [ pos ] = dfs ( pos + p [ pos ] , calc , used , p [ pos ] ) <NEWLINE> used [ pos ] = False <NEWLINE> return calc [ pos ] <NEWLINE> <DEDENT> while not que . empty ( ) : <NEWLINE> <INDENT> co , v = que . get ( ) <NEWLINE> if dist [ v ] < co : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for k in xrange ( 1 , 7 ) : <NEWLINE> <INDENT> go = v + k <NEWLINE> if go >= n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if p [ go ] != 0 : <NEWLINE> <INDENT> if calc [ go ] == - 1 : <NEWLINE> <INDENT> dfs ( go , calc , used , 0 ) <NEWLINE> <DEDENT> if calc [ go ] == INF : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> go = calc [ go ] <NEWLINE> <DEDENT> if go == n - 1 : <NEWLINE> <INDENT> print dist [ v ] + 1 <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> if dist [ v ] + 1 < dist [ go ] : <NEWLINE> <INDENT> dist [ go ] = dist [ v ] + 1 <NEWLINE> que . put ( ( dist [ go ] , go ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def fact ( n ) : <NEWLINE> <INDENT> return 1 if n == 0 else n * fact ( n - 1 ) <NEWLINE> <NL> <DEDENT> S = raw_input ( ) <NEWLINE> l , s = len ( S ) , set ( list ( S ) ) <NEWLINE> lens = len ( s ) <NEWLINE> d = [ S . count ( i ) for i in s ] <NEWLINE> if l % 2 == 0 : <NEWLINE> <INDENT> for i in range ( lens ) : <NEWLINE> <INDENT> if d [ i ] % 2 == 1 : <NEWLINE> <INDENT> print 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> denomi = 1 <NEWLINE> for i in range ( lens ) : <NEWLINE> <INDENT> denomi *= fact ( d [ i ] / 2 ) <NEWLINE> <DEDENT> print fact ( l / 2 ) / denomi <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> if sum ( [ d [ i ] % 2 for i in range ( lens ) ] ) != 1 : <NEWLINE> <INDENT> print 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> denomi = 1 <NEWLINE> for i in range ( lens ) : <NEWLINE> <INDENT> denomi *= fact ( d [ i ] / 2 ) if d [ i ] % 2 == 0 else fact ( ( d [ i ] - 1 ) / 2 ) <NEWLINE> <DEDENT> print fact ( ( l - 1 ) / 2 ) / denomi <NEWLINE> <DEDENT> <DEDENT>
a = raw_input ( ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) <NEWLINE> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ i ] == a [ i + 1 ] : <NEWLINE> <INDENT> if len ( a [ : i + 1 ] ) >= len ( a [ i + 1 : ] ) : <NEWLINE> <INDENT> ans = a [ : i + 1 ] [ - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = a [ i + 1 : ] [ - 1 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> if ans == <STRING> else <STRING> <NEWLINE>
<COMMENT> <NL> <NL> S = raw_input ( ) <NEWLINE> <NL> def func ( lst ) : <NEWLINE> <INDENT> if type ( lst ) == type ( 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if len ( lst ) > 2 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> ret = True <NEWLINE> for l in lst : <NEWLINE> <INDENT> ret = ( ret or func ( l ) ) <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> S = S . replace ( <STRING> , <STRING> ) <NEWLINE> <NL> try : <NEWLINE> <INDENT> exec ( <STRING> + S ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print <STRING> <NEWLINE> exit ( ) <NEWLINE> <DEDENT> if func ( piyo ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT>
k = int ( raw_input ( ) ) <NEWLINE> <NL> <NL> l , r = 0 , k <NEWLINE> while ( r - l ) > 1 : <NEWLINE> <INDENT> m = ( l + r ) / 2 <NEWLINE> if ( m * ( m + 1 ) ) < k : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r = m <NEWLINE> <NL> <DEDENT> <DEDENT> b = l <NEWLINE> <NL> <COMMENT> <NL> ad = k - ( b * ( b + 1 ) ) <NEWLINE> <NL> d = ( ( ad - 1 ) % ( b + 1 ) ) + 1 <NEWLINE> <NL> <COMMENT> <NL> x = 2 * b + 1 <NEWLINE> y = 1 <NEWLINE> if ( ad - d ) > 0 : <NEWLINE> <INDENT> x += 1 <NEWLINE> <NL> <DEDENT> if d <= ( b + 1 + 1 ) / 2 : <NEWLINE> <INDENT> dd = d * 2 - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dz = ( b + 1 - d ) <NEWLINE> dd = dz * 2 + 2 <NEWLINE> <NL> <DEDENT> x -= ( dd - 1 ) <NEWLINE> y += ( dd - 1 ) <NEWLINE> <NL> <NL> def mul ( a , b ) : <NEWLINE> <INDENT> res = [ [ 0 , 0 ] , [ 0 , 0 ] ] <NEWLINE> p , q , r = 2 , 2 , 2 <NEWLINE> for s in xrange ( p ) : <NEWLINE> <INDENT> for t in xrange ( q ) : <NEWLINE> <INDENT> res [ s ] [ t ] = 0 <NEWLINE> for u in xrange ( r ) : <NEWLINE> <INDENT> y = a [ s ] [ u ] * b [ u ] [ t ] <NEWLINE> res [ s ] [ t ] += y <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def fib ( x ) : <NEWLINE> <INDENT> bt = [ [ 1 , 1 ] , [ 1 , 0 ] ] <NEWLINE> r = [ [ 1 , 1 ] , [ 1 , 0 ] ] <NEWLINE> while x > 0 : <NEWLINE> <INDENT> if x % 2 != 0 : <NEWLINE> <INDENT> r = mul ( r , bt ) <NEWLINE> <DEDENT> bt = mul ( bt , bt ) <NEWLINE> x /= 2 <NEWLINE> <NL> <DEDENT> return r [ 0 ] [ 0 ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> ans = fib ( x - 1 ) * fib ( y - 1 ) <NEWLINE> print ans <NEWLINE>
c = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <NEWLINE> <INDENT> <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> <DEDENT> m = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> s = input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( 0 , len ( s ) , 2 ) : <NEWLINE> <INDENT> if com == <STRING> : ans += <STRING> <NEWLINE> else : ans += c [ com [ 0 ] ] + m [ com [ 1 ] ] <NEWLINE> <DEDENT> print ( ans ) <NEWLINE>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> j = 0 <NEWLINE> while n >= 10 : <NEWLINE> <INDENT> m_max = 0 <NEWLINE> for k in range ( 1 , int ( log10 ( n ) ) + 1 ) : <NEWLINE> <INDENT> m = ( n // ( 10 ** k ) ) * ( n % ( 10 ** k ) ) <NEWLINE> if m >= m_max : <NEWLINE> <INDENT> m_max = m <NEWLINE> <DEDENT> <DEDENT> n = m_max <NEWLINE> j += 1 <NEWLINE> <DEDENT> print ( j ) <NEWLINE> <DEDENT>
for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> j = 0 <NEWLINE> while n >= 10 : <NEWLINE> <INDENT> L = [ ( n // ( 10 ** k ) ) * ( n % ( 10 ** k ) ) <NEWLINE> <INDENT> for k in range ( 1 , int ( log10 ( n ) ) + 1 ) ] <NEWLINE> <DEDENT> n = max ( L ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> print ( j ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> xy = sorted ( [ map ( int , raw_input ( ) . split ( ) ) + [ i ] for i in range ( n ) ] ) <NEWLINE> yx = sorted ( xy , key = lambda x : x [ 1 ] ) <NEWLINE> X = [ i [ 0 ] for i in xy ] <NEWLINE> Y = [ i [ 1 ] for i in yx ] <NEWLINE> xy = [ str ( i [ 0 ] ) + <STRING> + str ( i [ 1 ] ) + <STRING> + str ( i [ 2 ] ) for i in xy ] <NEWLINE> yx = [ str ( i [ 0 ] ) + <STRING> + str ( i [ 1 ] ) + <STRING> + str ( i [ 2 ] ) for i in yx ] <NEWLINE> ans = { } <NEWLINE> for xi in range ( n ) : <NEWLINE> <INDENT> for xj in range ( xi , n + 1 ) : <NEWLINE> <INDENT> for yi in range ( n ) : <NEWLINE> <INDENT> for yj in range ( yi , n + 1 ) : <NEWLINE> <INDENT> ans [ str ( xi ) + <STRING> + str ( xj ) + <STRING> + str ( yi ) + <STRING> + str ( yj ) ] = len ( set ( xy [ xi : xj ] ) & set ( yx [ yi : yj ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x1 = bisect . bisect_left ( X , x1 ) <NEWLINE> y1 = bisect . bisect_left ( Y , y1 ) <NEWLINE> x2 = bisect . bisect_right ( X , x2 ) <NEWLINE> y2 = bisect . bisect_right ( Y , y2 ) <NEWLINE> try : print ans [ str ( x1 ) + <STRING> + str ( x2 ) + <STRING> + str ( y1 ) + <STRING> + str ( y2 ) ] <NEWLINE> except : print 0 <NEWLINE> <DEDENT>
now = False <NEWLINE> lst = [ ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> for k in range ( N ) : <NEWLINE> <INDENT> lst = lst . append ( input ( ) ) <NEWLINE> <DEDENT> M = int ( input ( ) ) <NEWLINE> for t in range ( M ) : <NEWLINE> <INDENT> ID = input ( ) <NEWLINE> if ID in lst : <NEWLINE> <INDENT> now = not ( now ) <NEWLINE> if now : <NEWLINE> <INDENT> print ( <STRING> , ID ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , ID ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , ID ) <NEWLINE> <DEDENT> <DEDENT>
n = int ) input ( ) ) <NEWLINE> xs = [ ] <NEWLINE> for i in range ( n ) : xs . append ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> flag = 1 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s in xs : <NEWLINE> <INDENT> print ( <STRING> if flag == 1 else <STRING> , <STRING> , s ) <NEWLINE> flag ^= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , s ) <NEWLINE> <DEDENT> <DEDENT>
<NL> <INDENT> N = int ( input ( ) ) <NEWLINE> a = 0 <NEWLINE> lst = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> lst . append ( str ( raw_input ( ) ) ) <NEWLINE> <DEDENT> M = int ( input ( ) ) <NEWLINE> for j in range ( M ) : <NEWLINE> <INDENT> T = str ( raw_input ( ) ) <NEWLINE> if ( T in lst ) == True : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> a = 1 <NEWLINE> print <STRING> + T <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = 0 <NEWLINE> print <STRING> + T <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + T <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = LI ( ) <NEWLINE> a = LI ( ) <NEWLINE> p = LI ( ) <NEWLINE> fm = { } <NEWLINE> def f ( k ) : <NEWLINE> <INDENT> if k in fm : <NEWLINE> <INDENT> return fm [ k ] <NEWLINE> <DEDENT> g = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if k & ( 1 << i ) : <NEWLINE> <INDENT> g *= a [ i ] // fractions . gcd ( g , a [ i ] ) <NEWLINE> <DEDENT> <DEDENT> fm [ k ] = m // g <NEWLINE> return fm [ k ] <NEWLINE> <NL> <DEDENT> r = 0 <NEWLINE> for k in range ( 1 , 1 << n ) : <NEWLINE> <INDENT> t = [ ] <NEWLINE> b = 1.0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if k & ( 1 << i ) : <NEWLINE> <INDENT> t . append ( 1 << i ) <NEWLINE> b *= p [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b *= 100 - p [ i ] <NEWLINE> <DEDENT> b /= 100 <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> tl = len ( t ) <NEWLINE> for l in range ( 1 , 1 << tl ) : <NEWLINE> <INDENT> o = 0 <NEWLINE> lc = 0 <NEWLINE> for j in range ( tl ) : <NEWLINE> <INDENT> if l & ( 1 << j ) : <NEWLINE> <INDENT> o |= t [ j ] <NEWLINE> lc += 1 <NEWLINE> <DEDENT> <DEDENT> if lc % 2 == 1 : <NEWLINE> <INDENT> c += f ( o ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c -= f ( o ) <NEWLINE> <DEDENT> <DEDENT> r += b * c <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> return <STRING> . format ( r ) <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> mind = n <NEWLINE> for i in range ( max ( 0 , n - 20 ) , min ( 10001 , n + 20 ) ) : <NEWLINE> <INDENT> if i == int ( str ( i ) [ : : - 1 ] ) and abs ( n - i ) < mind : <NEWLINE> <INDENT> mind = abs ( n - i ) <NEWLINE> ans = i <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
S = [ ] <NEWLINE> for i in range ( input ( ) ) : <NEWLINE> <INDENT> p , x = raw_input ( ) . split ( ) <NEWLINE> S += [ p ] * int ( x ) <NEWLINE> <DEDENT> i = 0 <NEWLINE> while i < len ( S ) - 1 : <NEWLINE> <INDENT> if S [ i ] + S [ i + 1 ] == <STRING> : <NEWLINE> <INDENT> del S [ i + 1 ] <NEWLINE> del S [ i ] <NEWLINE> i = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> print <STRING> if len ( S ) == 0 else <STRING> <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import os <NEWLINE> import sys <NEWLINE> import itertools <NEWLINE> import math <NEWLINE> from collections import Counter , defaultdict <NEWLINE> <NL> class Main ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . chars = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = raw_input ( ) <NEWLINE> ans = <STRING> <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> ans += self . chars [ self . chars . index ( s [ i ] ) - k [ i % len ( k ) ] ] <NEWLINE> <DEDENT> print ans <NEWLINE> <DEDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> m = Main ( ) <NEWLINE> m . solve ( ) <NEWLINE> <DEDENT>
station = <STRING> <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = raw_input ( ) <NEWLINE> print <STRING> . join ( station [ station . find ( s [ i ] ) - k [ i % n ] ] for i in xrange ( len ( s ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> station = <STRING> <NEWLINE> for c in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> station += chr ( c ) <NEWLINE> <DEDENT> for c in range ( ord ( <STRING> ) , ord ( <STRING> ) + 1 ) : <NEWLINE> <INDENT> station += chr ( c ) <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> l = sys . stdin . readline ( ) <NEWLINE> l = map ( lambda x : int ( x ) , l . split ( ) ) <NEWLINE> <NL> s = sys . stdin . readline ( ) . rstrip ( ) <NEWLINE> res = <STRING> <NEWLINE> for i , x in enumerate ( s ) : <NEWLINE> <INDENT> index = ord ( x ) - ( ord ( <STRING> ) if x . islower ( ) else ord ( <STRING> ) + 26 ) - l [ i % len ( l ) ] <NEWLINE> res += station [ index ] <NEWLINE> <DEDENT> print res <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
p = raw_input ( ) <NEWLINE> if len ( p ) < 6 or islower ( p ) or isupper ( p ) or isdigit ( p ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
graph = [ ] <NEWLINE> <NL> def init ( ) : <NEWLINE> <INDENT> global graph <NEWLINE> graph = [ [ False ] * 26 + [ True ] for _ in xrange ( 27 ) ] <NEWLINE> graph [ 26 ] [ 26 ] = False <NEWLINE> <NL> <DEDENT> def atoi ( c ) : <COMMENT> <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> return 26 <NEWLINE> <DEDENT> return ord ( c ) - ord ( <STRING> ) <NEWLINE> <NL> <DEDENT> def make_graph ( L ) : <NEWLINE> <INDENT> global graph <NEWLINE> tmp = [ ] <NEWLINE> while <STRING> in L : <NEWLINE> <INDENT> L . remove ( <STRING> ) <NEWLINE> <DEDENT> for s1 , s2 in zip ( L , L [ 1 : ] ) : <NEWLINE> <INDENT> if s1 [ 0 ] == s2 [ 0 ] : <NEWLINE> <INDENT> tmp += [ s1 [ 1 : ] , s2 [ 1 : ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if not tmp == [ ] : <NEWLINE> <INDENT> make_graph ( tmp ) <NEWLINE> <DEDENT> tmp = [ ] <NEWLINE> graph [ atoi ( s2 [ 0 ] ) ] [ atoi ( s1 [ 0 ] ) ] = True <NEWLINE> <DEDENT> <DEDENT> if not tmp == [ ] : <NEWLINE> <INDENT> make_graph ( tmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> def check ( start ) : <NEWLINE> <INDENT> stack = set ( [ start ] ) <NEWLINE> visited = [ False ] * 27 <NEWLINE> while len ( stack ) != 0 : <NEWLINE> <INDENT> cur = stack . pop ( ) <NEWLINE> visited [ cur ] = True <NEWLINE> if graph [ cur ] [ start ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in xrange ( 27 ) : <NEWLINE> <INDENT> if graph [ cur ] [ i ] and not visited [ i ] : <NEWLINE> <INDENT> stack . add ( i ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> L = [ raw_input ( ) + <STRING> for _ in xrange ( n ) ] <NEWLINE> init ( ) <NEWLINE> make_graph ( L ) <NEWLINE> for i in xrange ( 27 ) : <NEWLINE> <INDENT> if not check ( i ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def add_edge ( node , adj_lst , adj_rev , s1 , s2 ) : <NEWLINE> <INDENT> ind = 0 <NEWLINE> max_len = min ( len ( s1 ) , len ( s2 ) ) <NEWLINE> while ind < max_len and s1 [ ind ] == s2 [ ind ] : <NEWLINE> <INDENT> ind += 1 <NEWLINE> <DEDENT> if ind == max_len : <NEWLINE> <INDENT> if max_len < len ( s1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> c1 = ord ( s1 [ ind ] ) - ord ( <STRING> ) <NEWLINE> c2 = ord ( s2 [ ind ] ) - ord ( <STRING> ) <NEWLINE> adj_lst [ c1 ] . add ( c2 ) <NEWLINE> adj_rev [ c2 ] . add ( c1 ) <NEWLINE> node . add ( c1 ) <NEWLINE> node . add ( c2 ) <NEWLINE> return False <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> lst = [ input ( ) for _ in range ( n ) ] <NEWLINE> node = set ( ) <NEWLINE> adj_lst = [ set ( ) for _ in range ( 26 ) ] <NEWLINE> adj_rev = [ set ( ) for _ in range ( 26 ) ] <NEWLINE> blank_flag = False <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> blank_flag = blank_flag or add_edge ( node , adj_lst , adj_rev , lst [ i ] , lst [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = [ ] <NEWLINE> visited = [ False ] * 26 <NEWLINE> cycle_flag = False <NEWLINE> <NL> def visit ( n ) : <NEWLINE> <INDENT> global cycle_flag <NEWLINE> if cycle_flag : return <NEWLINE> if visited [ n ] == 2 : <NEWLINE> <INDENT> cycle_flag = True <NEWLINE> <DEDENT> elif visited [ n ] == 0 : <NEWLINE> <INDENT> visited [ n ] = 2 <NEWLINE> for to in adj_lst [ n ] : <NEWLINE> <INDENT> visit ( to ) <NEWLINE> <DEDENT> visited [ n ] = 1 <NEWLINE> L . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> L = [ ] <NEWLINE> for n in node : <NEWLINE> <INDENT> visit ( n ) <NEWLINE> <DEDENT> if cycle_flag or blank_flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
nq = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n = nq [ 0 ] <NEWLINE> q = nq [ 1 ] <NEWLINE> <NL> yn = [ [ 1 , <STRING> ] ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> yn . append ( raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> y = 1 <NEWLINE> k = 0 <NEWLINE> while y <= q : <NEWLINE> <INDENT> k += 1 <NEWLINE> y = int ( yn [ k ] [ 0 ] ) <NEWLINE> <NL> <DEDENT> print yn [ k - 1 ] [ 1 ] <NEWLINE>
data = [ [ 1 , <STRING> ] <NEWLINE> <NL> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> data . append ( [ a , b ] ) <NEWLINE> <NL> <DEDENT> for i in data : <NEWLINE> <INDENT> if i [ 0 ] > q : <NEWLINE> <INDENT> print i [ 1 ] <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <DEDENT> f = [ s for input ( ) . split ( ) ] <NEWLINE> pm = <STRING> <NEWLINE> cnt = 0 <NEWLINE> for m in f : <NEWLINE> <INDENT> if m [ 1 ] == pm : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> pm = m [ 1 ] <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> if s == <STRING> : break <NEWLINE> while True : <NEWLINE> <INDENT> if s . find ( <STRING> ) == - 1 and s . find ( <STRING> ) == - 1 : <NEWLINE> <INDENT> index = s . rfind ( <STRING> ) <NEWLINE> if index == - 1 : break <NEWLINE> e = s . find ( <STRING> , index , len ( s ) ) <NEWLINE> s = s [ : index ] + s [ index + 1 : e ] [ : : - 1 ] + s [ e + 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> index = s . find ( <STRING> ) <NEWLINE> if index == - 1 : <NEWLINE> <INDENT> index = s . find ( <STRING> ) <NEWLINE> <DEDENT> if s . find ( <STRING> ) != - 1 <NEWLINE> <INDENT> index = min ( index , s . find ( <STRING> ) ) <NEWLINE> <DEDENT> e = index <NEWLINE> f = 0 <NEWLINE> while s [ e ] == <STRING> or s [ e ] == <STRING> : <NEWLINE> <INDENT> f += [ - 1 , 1 ] [ s [ e ] == <STRING> ] <NEWLINE> e += 1 <NEWLINE> <DEDENT> r = s [ e ] <NEWLINE> if r != <STRING> : <NEWLINE> <INDENT> r = chr ( ( ord ( r ) - ord ( <STRING> ) + f ) % 26 + ord ( <STRING> ) ) <NEWLINE> <DEDENT> s = s [ : index ] + r + s [ e + 1 : ] <NEWLINE> <DEDENT> <DEDENT> print ( s . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
ref = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> N , M , Q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> <NL> corr = [ set ( range ( N ) ) for _ in range ( M ) ] <NEWLINE> s = [ <STRING> ] * N <NEWLINE> for loop in xrange ( Q ) : <NEWLINE> <INDENT> S , B = raw_input ( ) . split ( ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> : s [ i ] = { <STRING> : <STRING> , <STRING> : <STRING> } [ s [ i ] ] <NEWLINE> <DEDENT> on = set ( [ i for i in range ( N ) if s [ i ] == <STRING> ] ) <NEWLINE> off = set ( range ( N ) ) - on <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> if B [ i ] == <STRING> : corr [ i ] &= on <NEWLINE> else : corr [ i ] &= off <NEWLINE> <DEDENT> <DEDENT> ans = [ ref [ list ( i ) [ 0 ] ] if len ( i ) == 1 else <STRING> for i in corr ] <NEWLINE> print <STRING> . join ( ans ) <NEWLINE> <DEDENT>
ref = <STRING> <NEWLINE> while 1 : <NEWLINE> <INDENT> N , M , Q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if N == 0 : break <NEWLINE> sn = set ( range ( N ) ) <NEWLINE> corr = [ set ( range ( N ) ) for _ in range ( M ) ] <NEWLINE> s = [ 0 ] * N <NEWLINE> for loop in xrange ( Q ) : <NEWLINE> <INDENT> S , B = raw_input ( ) . split ( ) <NEWLINE> s = [ 1 - s [ i ] if S [ i ] == <STRING> else s [ i ] for i in range ( N ) ] <NEWLINE> on = set ( [ i for i in range ( N ) if s [ i ] ] ) <NEWLINE> off = sn - on <NEWLINE> for i in range ( M ) : <NEWLINE> <INDENT> corr [ i ] &= on if B [ i ] == <STRING> else off <NEWLINE> <DEDENT> <DEDENT> ans = [ ref [ list ( i ) [ 0 ] ] if len ( i ) == 1 else <STRING> for i in corr ] <NEWLINE> print <STRING> . join ( ans ) <NEWLINE> <DEDENT>
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools <NEWLINE> <NL> sys . setrecursionlimit ( 10 ** 7 ) <NEWLINE> inf = 10 ** 20 <NEWLINE> eps = 1.0 / 10 ** 10 <NEWLINE> mod = 10 ** 9 + 7 <NEWLINE> dd = [ ( - 1 , 0 ) , ( 0 , 1 ) , ( 1 , 0 ) , ( 0 , - 1 ) ] <NEWLINE> ddn = [ ( - 1 , 0 ) , ( - 1 , 1 ) , ( 0 , 1 ) , ( 1 , 1 ) , ( 1 , 0 ) , ( 1 , - 1 ) , ( 0 , - 1 ) , ( - 1 , - 1 ) ] <NEWLINE> <NL> def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> def LS ( ) : return sys . stdin . readline ( ) . split ( ) <NEWLINE> def I ( ) : return int ( sys . stdin . readline ( ) ) <NEWLINE> def F ( ) : return float ( sys . stdin . readline ( ) ) <NEWLINE> def S ( ) : return input ( ) <NEWLINE> def pf ( s ) : return print ( s , flush = True ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> rr = [ ] <NEWLINE> <NL> tt = [ <NEWLINE> <INDENT> [ 3 , 0 , 2 , 5 , 6 , 4 , 1 ] , <NEWLINE> [ 0 , 7 , 9 , 2 , 3 , 1 , 8 ] , <NEWLINE> [ 2 , 9 , 11 , 13 , 5 , 3 , 0 ] , <NEWLINE> [ 5 , 2 , 13 , 15 , 17 , 6 , 3 ] , <NEWLINE> [ 6 , 3 , 5 , 17 , 18 , 16 , 4 ] , <NEWLINE> [ 4 , 1 , 3 , 6 , 16 , 14 , 12 ] , <NEWLINE> [ 1 , 8 , 0 , 3 , 4 , 12 , 10 ] <NEWLINE> <DEDENT> ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = S ( ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> fil = int ( s [ : : - 1 ] , 2 ) <NEWLINE> ii = [ 2 ** i for i in range ( 128 ) ] <NEWLINE> m = { } <NEWLINE> def u ( a ) : <NEWLINE> <INDENT> key = tuple ( a ) <NEWLINE> if key in m : <NEWLINE> <INDENT> return m [ key ] <NEWLINE> <DEDENT> t = 0 <NEWLINE> for i in range ( 7 ) : <NEWLINE> <INDENT> if a [ i ] : <NEWLINE> <INDENT> t |= ii [ tt [ 0 ] [ i ] ] <NEWLINE> <DEDENT> <DEDENT> if fil & ii [ t ] : <NEWLINE> <INDENT> m [ key ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> m [ key ] = 0 <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> f = True <NEWLINE> for k in range ( ii [ 19 ] ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a = [ 1 if k & ii [ i ] else 0 for i in range ( 19 ) ] <NEWLINE> b = [ u ( list ( map ( lambda x : a [ x ] , ta ) ) ) for ta in tt ] <NEWLINE> if u ( b ) != b [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> f = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if f : <NEWLINE> <INDENT> rr . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rr . append ( <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> return <STRING> . join ( rr ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> print ( main ( ) ) <NEWLINE> <NL>
W = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in xrange ( W ) : <NEWLINE> <INDENT> if A [ i ] <= 0 : continue <NEWLINE> lout = A [ i ] <NEWLINE> if 0 in A [ : i ] : <NEWLINE> <INDENT> for j in xrange ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif A [ j ] < 0 : <NEWLINE> <INDENT> lout = max ( 0 , min ( lout , j - i - A [ j ] ) ) <NEWLINE> if lout == 0 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> lout = 0 <NEWLINE> <DEDENT> rout = A [ i ] <NEWLINE> if 0 in A [ i + 1 : ] : <NEWLINE> <INDENT> for j in xrange ( i + 1 , W + 1 ) : <NEWLINE> <INDENT> if A [ j ] == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif A [ j ] < 0 : <NEWLINE> <INDENT> rout = max ( 0 , min ( rout , i - j - A [ j ] ) ) <NEWLINE> if rout == 0 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> rout = 0 <NEWLINE> <DEDENT> ans += max ( lout , rout ) <NEWLINE> <DEDENT> print ans <NEWLINE>
def take2 ( i ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> yield next ( i ) , next ( i ) <NEWLINE> <DEDENT> <DEDENT> def main ( f ) : <NEWLINE> <INDENT> _ = int ( f . readline ( ) ) <NEWLINE> xyuv = [ [ x + y * 1j for x , y in take2 ( map ( int , line . split ( ) ) ) ] for line in f ] <NEWLINE> <NL> print ( solve ( xyuv ) ) <NEWLINE> <DEDENT> def is_all_same_attime ( xyuv ) : <NEWLINE> <INDENT> xy0 , uv0 = xyuv [ 0 ] <NEWLINE> for i in range ( len ( xyuv ) ) : <NEWLINE> <INDENT> if xyuv [ 0 ] == xyuv [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> xyi , uvi = xyuv [ i ] <NEWLINE> <NL> t = get_cross_time ( xy0 - xyi , uv0 - uvi ) <NEWLINE> <NL> if t is None or t < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> p0 = xy0 + uv0 * t <NEWLINE> for j in range ( i + 1 , len ( xyuv ) ) : <NEWLINE> <INDENT> xyj , uvj = xyuv [ j ] <NEWLINE> pj = xyj + uvj * t <NEWLINE> if is_zero ( pj - p0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> return False <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> def get_cross_time ( xy , uv ) : <NEWLINE> <INDENT> denominator = uv . real - uv . imag <NEWLINE> return ( xy . imag - xy . real ) / denominator if denominator else None <NEWLINE> <NL> <DEDENT> def is_all_same ( xyuv ) : <NEWLINE> <INDENT> for xyuvi in xyuv : <NEWLINE> <INDENT> if xyuvi != xyuv [ 0 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_zero ( a ) : <NEWLINE> <INDENT> return abs ( a ) < 0.00001 <NEWLINE> <NL> <DEDENT> def get_t ( xy1 , uv1 , xy2 , uv2 ) : <NEWLINE> <INDENT> a = uv1 . real * uv2 . imag - uv1 . imag * uv2 . real <NEWLINE> b = xy1 . real * uv2 . imag - xy1 . imag * uv2 . real + uv1 . real * xy2 . imag - uv1 . imag * xy2 . real <NEWLINE> c = xy1 . real * xy2 . imag - xy1 . imag * xy2 . real <NEWLINE> if a : <NEWLINE> <INDENT> d = b * b - 4 * a * c <NEWLINE> if d < 0 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> elif d == 0 : <NEWLINE> <INDENT> return [ - b / ( 2 * a ) ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = d ** 0.5 / ( 2 * a ) <NEWLINE> b /= 2 * a <NEWLINE> return [ - b + d , - b - d ] <NEWLINE> <DEDENT> <DEDENT> if b : <NEWLINE> <INDENT> return [ - c / b ] <NEWLINE> <DEDENT> if not c : <NEWLINE> <INDENT> global always_lined_point <NEWLINE> always_lined_point += 1 <NEWLINE> <DEDENT> return [ ] <NEWLINE> <NL> <DEDENT> from itertools import combinations <NEWLINE> from itertools import groupby <NEWLINE> from collections import Counter <NEWLINE> def solve ( xyuv ) : <NEWLINE> <INDENT> global always_lined_point <NEWLINE> if len ( xyuv ) <= 2 or is_all_same ( xyuv ) or is_all_same_attime ( xyuv ) : <NEWLINE> <INDENT> return len ( xyuv ) <NEWLINE> <DEDENT> max_ij = 0 <NEWLINE> for i , j in combinations ( range ( len ( xyuv ) ) , 2 ) : <NEWLINE> <INDENT> if xyuv [ i ] == xyuv [ j ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> xyi , uvi = xyuv [ i ] <NEWLINE> xyj , uvj = xyuv [ j ] <NEWLINE> <NL> always_lined_point = 0 <NEWLINE> t = [ ] <NEWLINE> for indeces in ( range ( i ) , range ( i + 1 , j ) , range ( j + 1 , len ( xyuv ) ) ) : <NEWLINE> <INDENT> for k in indeces : <NEWLINE> <INDENT> xyk , uvk = xyuv [ k ] <NEWLINE> t . extend ( get_t ( xyi - xyk , uvi - uvk , xyj - xyk , uvj - uvk ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = [ ti for ti in t if 0 <= ti ] <COMMENT> <NEWLINE> t = [ round ( ti , 10 ) for ti in t ] <COMMENT> <NEWLINE> t = Counter ( t ) <NEWLINE> <NL> group_lengths = [ ] <NEWLINE> for k , c in t . most_common ( 2 ) : <NEWLINE> <INDENT> group_length = 1 if is_zero ( xyi + uvi * k ) else c <NEWLINE> group_lengths . append ( group_length ) <NEWLINE> <NL> <DEDENT> max_ij = max ( max_ij , max ( group_lengths ) + always_lined_point + 2 ) <NEWLINE> <DEDENT> return max_ij <NEWLINE> <NL> <DEDENT> import sys <NEWLINE> f = sys . stdin <NEWLINE> <NL> main ( f ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimi ( 9999 ) <NEWLINE> def dfs ( i , z ) : <NEWLINE> <INDENT> print <STRING> * z + name [ i ] <NEWLINE> for j in child [ i ] : <NEWLINE> <INDENT> dfs ( j , z + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> name = [ ] <NEWLINE> child = [ [ ] for i in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> k = int ( raw_input ( ) ) <NEWLINE> m = raw_input ( ) <NEWLINE> name . append ( m ) <NEWLINE> if k == 0 : continue <NEWLINE> child [ k - 1 ] . append ( i ) <NEWLINE> <NL> <DEDENT> dfs ( 0 , 0 ) <NEWLINE>
import math <NEWLINE> d = float ( raw_input ( ) ) <NEWLINE> res = math . sqrt ( 2 ) * d <NEWLINE> for x in xrange ( 1 , 11 ) : <NEWLINE> <INDENT> if x * x <= d * d <= x * 2 + 1 : <NEWLINE> <INDENT> ans = max ( ans , d + 1.0 ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> % ans <NEWLINE>
from itertools import count <NEWLINE> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g = set ( ) <NEWLINE> for n in count ( 0 ) : <NEWLINE> <INDENT> p = ( c + 60 * n ) // ( a + b ) <NEWLINE> print ( a + b ) * p , c + 60 * n , ( a + b ) * p + a <NEWLINE> if ( ( a + b ) * p - ( c + 60 * n ) , ( c + 60 * n ) - ( ( a + b ) * p + a ) ) in g : <NEWLINE> <INDENT> n = - 1 <NEWLINE> break <NEWLINE> <DEDENT> if ( a + b ) * p <= c + 60 * n <= ( a + b ) * p + a : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d = ( a + b ) * p - ( c + 60 * n ) <NEWLINE> e = ( c + 60 * n ) - ( ( a + b ) * p + a ) <NEWLINE> g . add ( ( d , e ) ) <NEWLINE> <DEDENT> <DEDENT> if n >= 0 : <NEWLINE> <INDENT> print ( c + 60 * n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( n ) <NEWLINE> <NL> <DEDENT>
<NL> a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> canArrive = False <NEWLINE> i = 0 <NEWLINE> now = 0 <NEWLINE> while True : <NEWLINE> <INDENT> if now % 60 <= c and c <= ( now + a ) % 60 : <NEWLINE> <INDENT> canArrive = True <NEWLINE> break <NEWLINE> <COMMENT> <NL> <DEDENT> now += ( a + b ) <NEWLINE> <COMMENT> <NL> <DEDENT> if canArrive : <NEWLINE> <INDENT> print c + 60 * ( now // 60 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print - 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <NEWLINE> <DEDENT>
<NL> def a2c ( name ) : <NEWLINE> <INDENT> c = name [ 0 ] <NEWLINE> boin = [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> for b in name : <NEWLINE> <INDENT> if i , b in enumerate ( boin [ : - 1 ] ) : <NEWLINE> <INDENT> c += name [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> names = [ ] <NEWLINE> length = - 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> tmp = a2c ( raw_input ( ) ) <NEWLINE> names . append ( tmp ) <NEWLINE> length = max ( length , len ( tmp ) ) <NEWLINE> <NL> <DEDENT> names = set ( names ) <NEWLINE> if len ( names ) != n : <NEWLINE> <INDENT> print - 1 <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for i in xrange ( 1 , length ) : <NEWLINE> <INDENT> s = set ( [ name [ : i ] for name in names ] ) <NEWLINE> if len ( set ) == n : <NEWLINE> <INDENT> print i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> b = [ ] <NEWLINE> for j in range ( len ( s ) ) : <NEWLINE> <INDENT> if j < 1 or s [ j - 1 ] in <STRING> : <NEWLINE> <INDENT> b . append ( s [ j ] ) <NEWLINE> <DEDENT> <DEDENT> S . append ( b ) <NEWLINE> <DEDENT> ans = 0 <NEWLINE> S . sort ( ) <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> A = S [ i ] ; B = S [ i + 1 ] <NEWLINE> if A == B : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> res = min ( len ( A ) , len ( B ) ) <NEWLINE> for j in range ( res ) : <NEWLINE> <INDENT> if A [ j ] != B [ j ] : <NEWLINE> <INDENT> res = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> ans = max ( ans , res + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ans ) <NEWLINE> <DEDENT> <DEDENT>
s = raw_input ( ) <NEWLINE> p = <STRING> <NEWLINE> used = set ( ) <NEWLINE> <NL> while s != p : <NEWLINE> <INDENT> idx = 0 <NEWLINE> c = [ 0 ] * 3 <NEWLINE> while idx < len ( s ) : <NEWLINE> <INDENT> if idx + 3 <= len ( s ) and s [ idx : idx + 3 ] == p : <NEWLINE> <INDENT> idx += 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ p . index ( s [ idx ] ) ] += 1 <NEWLINE> idx += 1 <NEWLINE> <DEDENT> <DEDENT> if sum ( e == 0 for e in c ) != 1 or sum ( c ) == s : <NEWLINE> <INDENT> print <STRING> <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> s = s . replace ( <STRING> , p [ [ i for i in [ 0 , 1 , 2 ] if c [ i ] == 0 ] [ 0 ] ] ) <NEWLINE> <DEDENT> print <STRING> <NEWLINE>
<COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> S = raw_input ( ) <NEWLINE> c = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if len ( S ) <= 3 : <NEWLINE> <INDENT> print <STRING> if S == <STRING> else <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> T = S . strip ( ) . split ( <STRING> ) <NEWLINE> P = <STRING> . join ( T ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in c : <NEWLINE> <INDENT> if x in P : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = x . join ( T ) <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( t ) == 1 or cnt != 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> S = raw_input ( ) <NEWLINE> c = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if S == <STRING> : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> T = S . strip ( ) . split ( <STRING> ) <NEWLINE> P = <STRING> . join ( T ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for x in c : <NEWLINE> <INDENT> if x in P : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = x . join ( T ) <NEWLINE> <NL> <DEDENT> <DEDENT> if cnt != 2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lst = [ ] <NEWLINE> b = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = str ( raw_input ( ) ) <NEWLINE> lst . append ( s ) <NEWLINE> if s == <STRING> : <NEWLINE> <INDENT> if ( <STRING> in lst ) == True : <NEWLINE> <INDENT> lst . remove ( <STRING> ) <NEWLINE> lst . remove ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if b != 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( lst ) != 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
l = [ int ( input ( ) ) for _ in range ( int ( input ( ) ) ) ] <NEWLINE> s = [ ] <NEWLINE> <NL> isno = False <NEWLINE> for i in l : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> s . append ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> _ = s . pop ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> isno = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if not isno and not s : print ( <STRING> ) <NEWLINE> elif not isno and s : print ( <STRING> ) <NEWLINE> <NL>
a = int ( input ( ) ) <NEWLINE> <NL> aa = 0 <NEWLINE> <NL> un = 0 <NEWLINE> <NL> p = 0 <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> if k == <STRING> : <NEWLINE> <INDENT> aa += 1 <NEWLINE> <DEDENT> elif k == <STRING> : <NEWLINE> <INDENT> un += 1 <NEWLINE> <DEDENT> if un > aa : <NEWLINE> <INDENT> p = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if aa > un : <NEWLINE> <INDENT> p = 1 <NEWLINE> <NL> <DEDENT> if p = 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> d = 0 <NEWLINE> k = 0 <NEWLINE> su = 0 <NEWLINE> <NL> for i in range ( a [ 2 ] ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> su = max ( su , k ) <NEWLINE> if b [ d ] = i + 1 : <NEWLINE> <INDENT> k = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( su ) <NEWLINE> <NL> <NL>
while 1 : <NEWLINE> <INDENT> r , w , c , a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if r == w == c == a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> b = 0 <NEWLINE> sum = 0 <NEWLINE> if r % c == 0 : <NEWLINE> <INDENT> if r / c >= w : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> <DEDENT> while b == 0 : <NEWLINE> <INDENT> sum += 1 <NEWLINE> r += a <NEWLINE> if r % c == 0 : <NEWLINE> <INDENT> if r / c >= w : <NEWLINE> <INDENT> b = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print sum <NEWLINE> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> <NL> while a != [ <STRING> , <STRING> ] : <NEWLINE> <INDENT> recomend = [ 0 for _ in range ( int ( a [ 1 ] ) ) ] <NEWLINE> for i in range ( int ( a [ 0 ] ) ) : <NEWLINE> <INDENT> b = input ( ) . split ( <STRING> ) <NEWLINE> if recomend [ int ( b [ 0 ] ) - 1 ] < int ( b [ 1 ] ) : <NEWLINE> <INDENT> recomend [ int ( b [ 0 ] ) - 1 ] = int ( b [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( recomend ) ) <NEWLINE> a = input ( ) . split ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def calc ( l , n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> if a [ l ] and a [ l + 1 ] : return [ 0 , True ] <NEWLINE> if a [ l ] or a [ l + 1 ] : return [ 0 , False ] <NEWLINE> return [ 1 , False ] <NEWLINE> <DEDENT> m = n >> 1 <NEWLINE> c1 , f1 = calc ( l , m ) <NEWLINE> c2 , f2 = calc ( l + m , m ) <NEWLINE> if f1 and f2 : return [ c1 + c2 , True ] <NEWLINE> if f1 or f2 : return [ c1 + c2 , False ] <NEWLINE> return [ c1 + c2 + 1 , False ] <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> if M == 0 : print ( N - 1 ) <NEWLINE> else : <NEWLINE> <INDENT> a = [ False ] * 256 <NEWLINE> for i in range ( M ) : a [ int ( input ( ) ) ] = True <NEWLINE> print ( calc ( 0 , N ) [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> t , d , l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rest = ans = 0 <NEWLINE> for i in xrange ( t ) : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> if l <= x : <NEWLINE> <INDENT> rest = d <NEWLINE> <DEDENT> elif rest : <NEWLINE> <INDENT> rest -= 1 <NEWLINE> <DEDENT> if rest and i < t - 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
while 1 : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n == m == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> left = - 1 ; right = max ( S ) + 2 <NEWLINE> def check ( mid ) : <NEWLINE> <INDENT> if 1 + mid <= S [ 0 ] : <NEWLINE> <INDENT> return 10 ** 9 <NEWLINE> <DEDENT> cnt = 0 ; l = 1 <NEWLINE> target = S [ n - 1 ] - mid <NEWLINE> for i in xrange ( n - 1 ) : <NEWLINE> <INDENT> assert S [ i ] < l + mid <NEWLINE> while l <= S [ i ] and cnt <= m and l <= target : <NEWLINE> <INDENT> l += max ( 1 , mid - ( S [ i ] - l ) ) <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> if l + mid <= S [ i + 1 ] and cnt <= m and l <= target : <NEWLINE> <INDENT> l += max ( 1 , mid - ( l - S [ i ] ) ) <NEWLINE> cnt += 1 <NEWLINE> <NL> if l <= S [ i + 1 ] - mid and l <= target : <NEWLINE> <INDENT> cnt += min ( S [ i + 1 ] - mid , target ) - l + 1 <NEWLINE> l = min ( S [ i + 1 ] - mid , target ) + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <DEDENT> while left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if m <= check ( mid ) : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> <DEDENT> if 10 ** 8 < check ( left ) : <NEWLINE> <INDENT> print - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print right <NEWLINE> <DEDENT> <DEDENT>
asd = raw_input ( ) <NEWLINE> asdd = asd . split ( ) <NEWLINE> n = int ( asdd [ 0 ] ) <NEWLINE> if n == 1 : <NEWLINE> <INDENT> print m + 1 % 1000000007 <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> m = int ( asdd [ 1 ] ) <NEWLINE> x = ( m + 1 ) / ( n - 1 ) <NEWLINE> print ( 2 * ( ( m + 1 ) * x - x * ( n - 1 ) * ( x + 1 ) / 2 ) + m + 1 ) % 1000000007 <NEWLINE>
while True : <NEWLINE> <INDENT> a = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if a [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif int ( a [ 1 ] ) <= 30 : <NEWLINE> <INDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT> elif int ( a [ 1 ] ) == 31 and int ( a [ 2 ] ) <= 4 : <NEWLINE> <INDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ 0 ] = <STRING> <NEWLINE> s = int ( a [ 1 ] ) <NEWLINE> s -= 30 <NEWLINE> a [ 1 ] = str ( s ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = 0 <NEWLINE> for j in a : <NEWLINE> <INDENT> if a % 2 == 0 : <NEWLINE> <INDENT> r += 1 <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
n , m , c = map ( int , input ( ) . split ( ) ) <NEWLINE> l = ( 0 , ) + tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = [ 0 ] * ( c + 1 ) <NEWLINE> w = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> w . sort ( key = lambda x : x [ 1 ] , reverse = True ) <NEWLINE> v = 0 <NEWLINE> p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ w [ i ] [ 0 ] ] : <NEWLINE> <INDENT> l [ w [ i ] [ 0 ] ] -= 1 <NEWLINE> v += w [ i ] [ 1 ] <NEWLINE> p += 1 <NEWLINE> if p == m : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( v ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> def fib ( N ) : <NEWLINE> <INDENT> if N in [ 0 , 1 ] : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fib ( N - 1 ) + fib ( N - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print fib ( n ) <NEWLINE>
memo = [ 1 , 1 ] <NEWLINE> <NL> def fib ( n ) : <NEWLINE> <INDENT> if ( n in memo ) : <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> ans = fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> memo . append ( ans ) <NEWLINE> return ans <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( fib ( n ) ) <NEWLINE>
def fibonacci ( n ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> F [ n ] = 1 <NEWLINE> return F [ n ] <NEWLINE> <DEDENT> if F [ n ] is not None : <NEWLINE> <INDENT> return F [ n ] <NEWLINE> <DEDENT> F [ n ] = fibonacci ( n - 1 ) + fibonacci ( n - 2 ) <NEWLINE> return F [ n ] <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> F = [ None ] * n <NEWLINE> print ( fibonacci ( n ) ) <NEWLINE>
f = [ 1 , 1 ] <NEWLINE> for _ in [ 0 ] * 43 : f += [ f ( - 2 ) + f ( - 1 ) ] <NEWLINE> print ( f [ int ( input ( ) ) ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> first = 1 <NEWLINE> second = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> second , first = first + second , second <NEWLINE> <DEDENT> print ( val ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> F = [ ] <NEWLINE> F . append ( 1 ) <NEWLINE> F . append ( 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> F . append ( F [ i - 1 ] + F [ i - 2 ] ) <NEWLINE> print ( F [ i ] ) <NEWLINE> <NL> <DEDENT> print ( F [ n ] ) <NEWLINE> <DEDENT>
_fib = [ None ] * 44 <NEWLINE> _fib [ 0 ] = 1 <NEWLINE> _fib [ 1 ] = 1 <NEWLINE> <NL> def fib ( n ) : <NEWLINE> <INDENT> if _fib [ n ] is None : <NEWLINE> <INDENT> _fib [ n ] = fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <DEDENT> return _fib [ n ] <NEWLINE> <NL> <DEDENT> _n = int ( raw_input ( ) ) <NEWLINE> print ( fib ( _n ) ) <NEWLINE>
memo = { } <NEWLINE> <NL> def fib_memo ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return n <NEWLINE> <DEDENT> if n in memo : <COMMENT> <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> memo [ n ] = fib_memo ( n - 1 ) + fib_memo ( n - 2 ) <NEWLINE> return memo [ n ] <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> print fib_memo ( n ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> dp = [ 1 , 1 ] <NEWLINE> <NL> for i in range ( 50 ) : <NEWLINE> <INDENT> dp += dp [ - 1 ] + dp [ - 2 ] <NEWLINE> <NL> <DEDENT> print dp [ n ] <NEWLINE> <NL>
cache = [ ] <NEWLINE> <NL> def fib ( x ) : <NEWLINE> <INDENT> if x in cache : <NEWLINE> <INDENT> return cache [ x ] <NEWLINE> <DEDENT> elif x == 0 or x == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = fib ( x - 1 ) + fib ( x - 2 ) <NEWLINE> cache [ x ] = v <NEWLINE> return v <NEWLINE> <NL> <DEDENT> <DEDENT> x = input ( ) <NEWLINE> print fib ( x ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def main ( n ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> lst . append ( 1 ) <NEWLINE> lst . append ( 1 ) <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> lst [ i ] = lst [ i - 1 ] + lst [ i - 2 ] <NEWLINE> <DEDENT> return lst [ n ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> print ( main ( n ) ) <NEWLINE> <DEDENT>
def memolize ( f ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> <NL> def helper ( x ) : <NEWLINE> <INDENT> if x not in cache : <NEWLINE> <INDENT> cache [ x ] = f ( x ) <NEWLINE> return cache [ x ] <NEWLINE> <DEDENT> <DEDENT> return helper <NEWLINE> <NL> <DEDENT> @ memolize <NEWLINE> def fib ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> return fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( fib ( n ) ) <NEWLINE> <NL>
def fib ( n ) : <NEWLINE> <INDENT> if F [ n ] != 0 : <NEWLINE> <INDENT> return F [ n ] <NEWLINE> <DEDENT> elif n == 0 or n == 1 : <NEWLINE> <INDENT> F [ n ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> F [ n ] = fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <NL> <DEDENT> return F [ n ] <NEWLINE> <NL> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> F = [ 45 ] <NEWLINE> print fib ( n ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def dp ( n ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> return dp ( n - 1 ) + dp ( n - 2 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> print dp ( n ) <NEWLINE> <DEDENT>
answer_list = [ 1 , 1 ] + [ None ] * 43 <NEWLINE> <NL> def fib ( num ) : <NEWLINE> <INDENT> ans = answer_list [ num ] <NEWLINE> if ans : <NEWLINE> <INDENT> return ans <NEWLINE> <DEDENT> ans = fib ( num - 1 ) + fib ( num - 2 ) <NEWLINE> answer_list [ num ] = ans <NEWLINE> return ans <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ) <NEWLINE> <NL> print ( fib ( n ) ) <NEWLINE>
def fibo ( n ) : <NEWLINE> <INDENT> S = [ 1 , 1 ] <NEWLINE> s = 1 <NEWLINE> if n > 1 : <NEWLINE> <INDENT> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> S . append ( S [ i - 1 ] + S [ i - 2 ] ) <NEWLINE> s = S [ i ] <NEWLINE> <DEDENT> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> print ( fibo ( n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = b , a + b <NEWLINE> <NL> <NL> <DEDENT> print ( a ) <NEWLINE>
def fib ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print fib ( int ( input ( ) ) ) <NEWLINE>
<COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> def _fibonacci ( n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return _fibonacci ( n - 1 ) + _fibonacci ( n - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( raw_input ( ) ) <NEWLINE> return _fibonacci ( N ) <NEWLINE> <NL> <NL> <DEDENT> print main ( ) <NEWLINE>
def memoize ( f ) : <NEWLINE> <INDENT> cache = { } <NEWLINE> def helper ( x ) : <NEWLINE> <INDENT> if x not in cache : <NEWLINE> <INDENT> cache [ x ] = f ( x ) <NEWLINE> <DEDENT> return cache [ x ] <NEWLINE> <DEDENT> return helper <NEWLINE> <NL> <DEDENT> @ memoize <NEWLINE> def fib ( n ) : <NEWLINE> <INDENT> if n in ( 0 , 1 ) : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return fib ( n - 1 ) + fib ( n - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> pritn ( fib ( int ( input ( ) ) ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> F = [ 1 , 1 ] + [ 0 for i in range ( 44 ) ] <NEWLINE> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] <NEWLINE> <DEDENT> print ( fib [ n ] ) <NEWLINE>
def dynamic ( n ) : <NEWLINE> <INDENT> if n == 0 or n == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if F [ n ] != 0 : <NEWLINE> <INDENT> return F [ n ] <NEWLINE> <DEDENT> F [ n ] = dynamic ( n - 1 ) + dynamic ( n - 2 ) <NEWLINE> return F [ n ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> print ( dynamic ( n ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> fib = [ 1 , 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] <NEWLINE> <DEDENT> print ( fib [ n ] ) <NEWLINE>
memo = { } <NEWLINE> <NL> def fib_memo ( n ) : <NEWLINE> <INDENT> if n <= 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if n in memo : <COMMENT> <NEWLINE> <INDENT> return memo [ n ] <NEWLINE> <DEDENT> memo [ n ] = fib_memo ( n - 1 ) + fib_memo ( n - 2 ) <NEWLINE> return memo [ n ] <NEWLINE> <NL> <DEDENT> x = int ( raw_input ( ) ) <NEWLINE> <NL> print fib_memo ( x ) <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> <NL> c = [ 0 ] * ( n + 1 ) <NEWLINE> c [ 0 ] , c [ 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> c [ i ] = int ( input ( ) . split ( ) [ 1 ] ) <NEWLINE> <NL> <DEDENT> dp = [ [ sys . maxsize ] * ( n + 1 ) for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ i ] = 0 <NEWLINE> <NL> <DEDENT> for l in range ( 2 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( 1 , n - l + 2 ) : <NEWLINE> <INDENT> j = i + l - 1 : <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] + c [ i - 1 ] * [ k ] * c [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ 1 ] [ n ] ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> def scalar ( n ) : <NEWLINE> <INDENT> m = [ [ 0 for i in range ( len ( n ) ) ] for j in range ( len ( n ) ) ] <NEWLINE> <NL> for l in range ( 2 , len ( n ) + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( n ) - l + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = min ( m [ i ] [ k ] + m [ k + 1 ] [ j ] + M [ i ] [ 0 ] * M [ k ] [ 1 ] * M [ j ] [ 1 ] for k in range ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print m [ 0 ] [ len ( n ) - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> M . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> scalar ( M ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> p = [ 0 for i in range ( 0 , 101 ) ] <NEWLINE> m = [ 0 for i in range ( 0 , 101 ) ] for j in range ( 0 , 101 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p [ n - 1 ] , p [ n ] = map ( int , raw_input . split ( ) ) <NEWLINE> <NL> <DEDENT> for k in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , n - k + 2 ) : <NEWLINE> <INDENT> j = i + k - 1 <NEWLINE> m [ i ] [ j ] = float ( <STRING> ) <NEWLINE> for l in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ l ] + m [ l + 1 ] [ j ] + p [ i - 1 ] * p [ l ] * p [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print m [ 1 ] [ n ] <NEWLINE>
def mcm ( M ) : <NEWLINE> <INDENT> n = len ( M ) <NEWLINE> m = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> for l in range ( 2 , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n - l + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> def cost ( i , k , j ) : <NEWLINE> <INDENT> return m [ i ] [ k ] + m [ k + 1 ] [ j ] + M [ i ] [ 0 ] * M [ k ] [ 1 ] * M [ j ] [ 1 ] <NEWLINE> <DEDENT> m [ i ] [ j ] = min ( cost ( i , k , j ) for k in range ( i , j - 1 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return m [ 0 ] [ n - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> M . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print mcm ( M ) <NEWLINE>
INF = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> for i , a in enumerate ( sys . stdin ) : <NEWLINE> <INDENT> a = list ( map ( int , a . split ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> A . extend ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A . append ( a [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> C = [ [ INF ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> C [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n - j + 1 ) : <NEWLINE> <INDENT> for k in range ( i + 1 , i + j + 1 ) : <NEWLINE> <INDENT> cost = C [ i ] [ k - 1 ] + C [ k ] [ i + j ] + A [ i ] * A [ k ] * A [ i + j + 1 ] <NEWLINE> if cost < C [ i ] [ i + j ] : <NEWLINE> <INDENT> C [ i ] [ i + j ] = cost <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( C [ 1 ] [ n ] ) <NEWLINE>
n = input ( ) <NEWLINE> r = [ 0 for row in range ( 100 ) ] <NEWLINE> c = [ 0 for row in range ( 100 ) ] <NEWLINE> m = [ [ 0 for col in range ( n ) ] for row in range ( n ) ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> p [ i ] , p [ i + 1 ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for l in range ( 2 , n ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = 100000000000 <NEWLINE> for k in range ( j - 1 ) : <NEWLINE> <INDENT> if m [ i ] [ j ] > m [ i ] [ k ] + m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * [ j ] : <NEWLINE> <INDENT> m [ i ] [ j ] = m [ i ] [ k ] + m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print m [ 1 ] [ n ] <NEWLINE>
<COMMENT> <NL> def chain ( p , n ) : <NEWLINE> <INDENT> m = { } <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> m [ i ] = { i : 0 } <NEWLINE> <NL> <DEDENT> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , n - l + 2 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = float ( <STRING> ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m [ 1 ] [ n ] ) <NEWLINE> <NL> <DEDENT> def __name__ == <STRING> : <NEWLINE> <INDENT> p = { } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> st = input ( ) <NEWLINE> w = st . split ( ) <NEWLINE> p [ i - 1 ] = int ( w [ 0 ] ) <NEWLINE> p [ i ] = int ( w [ 1 ] ) <NEWLINE> <DEDENT> chain ( p , n ) <NEWLINE> <DEDENT>
def matrixChainMultiplication ( p ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( p ) - 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> cost = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> for numOfMatrices in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , n - numOfMatrices + 2 ) : <NEWLINE> <INDENT> j = i + numOfMatrices - 1 <NEWLINE> cost [ i ] [ j ] = float ( <STRING> ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> cost [ i ] [ j ] = min ( cost [ i ] [ j ] , cost [ i ] [ k ] + cost [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m [ 1 ] [ n ] ) <NEWLINE> <NL> <DEDENT> p = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> listed_input = input ( ) . split ( ) <NEWLINE> p . append ( int ( listed_input [ 0 ] ) ) <NEWLINE> <DEDENT> p . append ( int ( listed_input [ 1 ] ) ) <NEWLINE> <NL> matrixChainMultiplication ( p ) <NEWLINE>
def solve ( a ) : <NEWLINE> <INDENT> n = len ( a ) <NEWLINE> cost = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for length in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , n - length + 1 ) : <NEWLINE> <INDENT> k = i + length - 1 <NEWLINE> def f ( i , j , k ) : <NEWLINE> <INDENT> return cost [ i ] [ j - 1 ] + cost [ j ] [ k ] + M [ i ] [ 0 ] * M [ j - 1 ] [ 1 ] * M [ k ] [ 1 ] <NEWLINE> <DEDENT> cost [ i ] [ k ] = min ( [ f ( i , j , k ) for j in range ( i + 1 , k + 1 ) ] ) <NEWLINE> <DEDENT> <DEDENT> return cost [ 0 ] [ n - 1 ] <NEWLINE> <NL> <DEDENT> n = raw_input ( ) <NEWLINE> M = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> M . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print solve ( M ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = list ( range ( n + 2 ) ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p [ i ] , p [ n + 1 ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> table = [ [ 0 ] * ( n + 1 ) for i in range ( n + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( 1 , n ) : <COMMENT> <NEWLINE> <INDENT> table [ i ] [ i + 1 ] = p [ i ] * p [ i + 1 ] * p [ i + 2 ] <NEWLINE> <NL> <NL> <DEDENT> for k in range ( 3 , n + 1 ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( 1 , n + 2 - k ) : <COMMENT> <NEWLINE> <INDENT> j = i + k - 1 <COMMENT> <NEWLINE> <NL> table [ i ] [ j ] = float ( <STRING> ) <NEWLINE> <NL> for x in range ( i , j + 1 ) : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> cost = table [ i ] [ x ] + table [ x + 1 ] [ j ] + p [ i ] * p [ x + 1 ] * p [ j + 1 ] <NEWLINE> table [ i ] [ j ] = min ( table [ i ] [ j ] , cost ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( table [ 1 ] [ n ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> p = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> <NL> m = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( n - k + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = float ( <STRING> ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i ] [ 0 ] * p [ k ] [ 1 ] * p [ j ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( m [ 0 ] [ n - 1 ] ) <NEWLINE>
def edit_distance ( M ) : <NEWLINE> <INDENT> n = len ( M ) <NEWLINE> A = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , n - l + 1 ) : <NEWLINE> <INDENT> k = i + l - 1 <NEWLINE> def f ( i , j , k ) : <NEWLINE> <INDENT> return A [ i ] [ j ] + A [ j + 1 ] [ k ] + M [ i ] [ 0 ] * M [ j ] [ 1 ] * M [ k ] [ 1 ] <NEWLINE> <DEDENT> A [ i ] [ k ] = min ( f ( i , j , k ) for j in range ( i , k ) ) <NEWLINE> <DEDENT> <DEDENT> return A [ 0 ] [ n - 1 ] <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> M = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> M . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print edit_distace ( M ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> <NL> <NL> m = [ [ 0 ] * ( N + 1 ) for i in range ( N + 1 ) ] <NEWLINE> <NL> p = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> p [ i ] , dummy = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> p . append ( dummy ) <NEWLINE> <NL> for l in range ( 2 , N + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , N - l + 2 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = float ( <STRING> ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print <STRING> , m [ 1 ] [ N ] <NEWLINE>
def matrix ( n ) : <NEWLINE> <INDENT> x = [ [ 0 for i in range ( n ) ] for j in range ( n ) ) ] <NEWLINE> for l in range ( 2 , len ( n ) + 1 ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( n ) - l + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> x [ i ] [ j ] = min ( x [ i ] [ k ] + x [ k + 1 ] [ j ] + X [ i ] [ 0 ] * X [ k ] [ 1 ] * X [ j ] [ 1 ] for k in range ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print x [ 0 ] [ len ( n ) - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> X = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> X . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> matrix ( X ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> p = [ 0 for i in range ( 0 , 101 ) ] <NEWLINE> m = [ [ 0 for i in range ( 0 , 101 ) ] for j in range ( 0 , 101 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> p [ i - 1 ] , p [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , n - l + 2 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = float ( <STRING> ) <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print m [ 1 ] [ n ] <NEWLINE>
if <STRING> == __name__ : s ( ) <NEWLINE> def s ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) + 1 <NEWLINE> e = [ input ( ) . split ( ) for _ in [ 0 ] * ~ - n ] <NEWLINE> p = [ int ( e [ 0 ] [ 0 ] ) ] + list ( int ( x [ 1 ] ) for x in e ) <NEWLINE> m = [ [ 0 ] * n for _ in [ 0 ] * n ] <NEWLINE> for l in range ( 2 , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n - l + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 ; m [ i ] [ j ] = 1e6 <NEWLINE> for k in range ( i , j ) : m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print ( m [ 1 ] [ n - 1 ] ) <NEWLINE> <DEDENT>
INF = float ( <STRING> ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> m = [ [ 0 ] * ( n + 1 ) for _ in range ( n + 1 ) ] <NEWLINE> li = [ list ( map ( int , a . split ( ) ) ) for a in sys . stdin ] <NEWLINE> z = ( li [ 0 ] [ 0 ] , ) + list ( zip ( * li ) ) [ 1 ] <NEWLINE> for l in range ( 1 , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n - l + 1 ) : <NEWLINE> <INDENT> j = i + l <NEWLINE> m [ i ] [ j ] = INF <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + z [ i - 1 ] * z [ k ] * z [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( m [ 1 ] [ n ] ) <NEWLINE> <NL>
def cost ( i , k , j ) : <NEWLINE> <INDENT> return m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i ] [ 0 ] * p [ k ] [ 1 ] * p [ j ] [ 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> M = [ ] <NEWLINE> m = [ [ 0 for i in xrange ( n ) ] for j in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> M . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> M_long = len ( M ) <NEWLINE> for l in xrange ( 2 , M_long + 1 ) : <NEWLINE> <INDENT> for i in xrange ( 0 , M_long - l + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = min ( cost ( i , k , j ) for k in xrange ( i , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print m [ 0 ] [ M_long - 1 ] <NEWLINE>
N = input ( ) <NEWLINE> M = [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( N ) ] <NEWLINE> cache = { } <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> cache [ ( i , i + 1 ) ] = 0 <NEWLINE> <DEDENT> def dfs ( left , right ) : <COMMENT> <NEWLINE> <INDENT> if ( left , right ) in cache : <NEWLINE> <INDENT> return cache [ ( left , right ) ] <NEWLINE> <DEDENT> min_cost = float ( <STRING> ) <NEWLINE> for mid in xrange ( left + 1 , right ) : <NEWLINE> <INDENT> tmp = M [ left ] [ 0 ] * M [ mid - 1 ] [ 1 ] * M [ right - 1 ] [ 1 ] <NEWLINE> tmp += dfs ( left , mid ) <NEWLINE> tmp += dfs ( mid , right ) <NEWLINE> if min_cost > tmp : <NEWLINE> <INDENT> min_cost = tmp <NEWLINE> <DEDENT> <DEDENT> return min_cost <NEWLINE> <DEDENT> print dfs ( 0 , len ( M ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> INF = 10 ** 9 <NEWLINE> P = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = map ( int , input ( ) . split ( ) ) <NEWLINE> P . append ( ) <NEWLINE> <DEDENT> m = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> for l in range ( 2 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( n - l + 1 ) : <NEWLINE> <INDENT> j = i + l - 1 <NEWLINE> m [ i ] [ j ] = INF <NEWLINE> for k in range ( i , j ) : <NEWLINE> <INDENT> m [ i ] [ j ] = min ( m [ i ] [ j ] , m [ i ] [ k ] + m [ k + 1 ] [ j ] + P [ i - 1 ] [ 0 ] * P [ k ] [ 1 ] * P [ j ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( m [ 0 ] [ n - 1 ] ) <NEWLINE>
i = input <NEWLINE> for _ in [ 0 ] * int ( i ( ) ) : <NEWLINE> <INDENT> X , z = i ( ) , [ ] <NEWLINE> for y in i ( ) : <NEWLINE> <INDENT> s = i = 0 <NEWLINE> for k in z : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t < 1 : break <NEWLINE> if t < k : z [ i ] = t <NEWLINE> s = k ; i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t : z += [ t ] <NEWLINE> <DEDENT> <DEDENT> print ( len ( z ) ) <NEWLINE> <DEDENT>
def lcs ( X , Y ) : <NEWLINE> <INDENT> m = len ( X ) + 1 <NEWLINE> n = len ( Y ) + 1 <NEWLINE> c = [ [ 0 ] * n for _ in xrange ( m ) ] <NEWLINE> X = <STRING> + X <NEWLINE> Y = <STRING> + Y <NEWLINE> maxl = 0 <NEWLINE> for i in xrange ( 1 , m ) : <NEWLINE> <INDENT> for j in xrange ( 1 , n ) : <NEWLINE> <INDENT> if X [ i ] == Y [ j ] : <NEWLINE> <INDENT> c [ i ] [ j ] = c [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> c [ i ] [ j ] = max ( c [ i ] [ j - 1 ] , c [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> maxl = max ( maxl , c [ i ] [ j ] ) <NEWLINE> <DEDENT> print maxl <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> q = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> X = raw_input ( ) <NEWLINE> Y = raw_input ( ) <NEWLINE> lcs ( X , Y ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def LCS ( ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> y = raw_input ( ) <NEWLINE> i , j = len ( x ) , len ( y ) <NEWLINE> <NL> dsp = [ [ 0 for col in xrange ( j + 1 ) ] for row in xrange ( i + 1 ) ] <NEWLINE> for i in xrange ( 1 , i + 1 ) : <NEWLINE> <INDENT> for j in xrange ( 1 , j + 1 ) : <NEWLINE> <INDENT> if x [ i - 1 ] == y [ j - 1 ] : <NEWLINE> <INDENT> dsp [ i ] [ j ] = dsp [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dsp [ i ] [ j ] = max ( dsp [ i - 1 ] [ j ] , dsp [ i ] [ j - 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print dsp [ - 1 ] [ - 1 ] <NEWLINE> <NL> <DEDENT> q = input ( ) <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> LCS ( ) <NEWLINE> <DEDENT>
ascii_letters = <STRING> <NEWLINE> <NL> def llcs ( x , y ) : <NEWLINE> <INDENT> pm = dict ( ( zip ( ascii_letters , [ 0 ] * 52 ) ) ) <NEWLINE> for c in pm : <NEWLINE> <INDENT> for i , xc in enumerate ( x ) : <NEWLINE> <INDENT> if c == xc : <NEWLINE> <INDENT> pm [ c ] |= ( 1 << i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> V = ( 1 << len ( x ) ) - 1 <NEWLINE> <NL> for yc in y : <NEWLINE> <INDENT> V = ( ( V + ( V & pm [ yc ] ) ) | ( V & ~ pm [ yc ] ) ) <NEWLINE> <NL> <DEDENT> ans = bin ( V ) [ - len ( x ) : ] . count ( <STRING> ) <NEWLINE> <NL> return ans <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> <NL> def solve ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> file_input = open ( <STRING> , <STRING> ) <NEWLINE> q = int ( file_input . readline ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s1 = file_input . readline ( ) . rstrip ( ) <NEWLINE> s2 = file_input . readline ( ) . rstrip ( ) <NEWLINE> print ( llcs ( s1 , s2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> solve ( ) <NEWLINE>
def lcs_better ( X , Y ) : <NEWLINE> <INDENT> costs = [ 0 ] <NEWLINE> for c in Y : <NEWLINE> <INDENT> for i in range ( len ( costs ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = X . find ( c , costs [ i ] ) <NEWLINE> if tmp + 1 : <NEWLINE> <INDENT> if i + 1 < len ( costs ) : <NEWLINE> <INDENT> costs [ i + 1 ] = min ( costs [ i + 1 ] , tmp + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> costs . append ( tmp + 1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return len ( costs ) - 1 <NEWLINE> <NL> <NL> <DEDENT> def answer ( X , Y ) : <NEWLINE> <INDENT> m , n = len ( X ) , len ( Y ) <NEWLINE> C = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if X [ i - 1 ] == Y [ j - 1 ] : <NEWLINE> <INDENT> C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ i ] [ j ] = max ( C [ i ] [ j - 1 ] , C [ i - 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return C [ m ] [ n ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> X = list ( input ( ) ) <NEWLINE> Y = list ( input ( ) ) <NEWLINE> print ( lcs_better ( X , Y ) ) <NEWLINE> <DEDENT> <DEDENT>
q = int ( input ( ) ) <NEWLINE> <NL> def Longest_Common ( q ) : <NEWLINE> <INDENT> X = raw_input ( ) <NEWLINE> Y = raw_input ( ) <NEWLINE> dp = [ [ 0 for i in range ( len ( X ) ) ] for j in range ( len ( Y ) ) ] <COMMENT> <NEWLINE> <NL> for j in range ( len ( Y ) ) : <NEWLINE> <INDENT> if Y [ j ] == X [ 0 ] : <NEWLINE> <INDENT> dp [ j ] [ 0 ] += 1 <NEWLINE> <DEDENT> if ( j + 1 <= len ( Y ) - 1 ) : <NEWLINE> <INDENT> dp [ j + 1 ] [ 0 ] = dp [ j ] [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( X ) ) : <NEWLINE> <INDENT> if X [ i ] == Y [ 0 ] : <NEWLINE> <INDENT> dp [ 0 ] [ i ] += 1 <NEWLINE> <DEDENT> if ( i + 1 <= len ( X ) - 1 ) : <NEWLINE> <INDENT> dp [ 0 ] [ i + 1 ] = dp [ 0 ] [ i + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , len ( X ) ) : <NEWLINE> <INDENT> for j in range ( 1 , len ( Y ) ) : <NEWLINE> <INDENT> if X [ i ] == Y [ j ] : dp [ j ] [ i ] = max ( dp [ j - 1 ] [ i - 1 ] , dp [ j - 1 ] [ i ] , dp [ j ] [ i - 1 ] ) + 1 <NEWLINE> else : dp [ j ] [ i ] = max ( dp [ j - 1 ] [ i - 1 ] , dp [ j - 1 ] [ i ] , dp [ j ] [ i - 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print dp [ len ( Y ) - 1 ] [ len ( X ) - 1 ] <NEWLINE> <NL> if ( q == 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Longest_Common ( q - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> Longest_Common ( q ) <NEWLINE>
def ask ( X , Y ) : <NEWLINE> <INDENT> cost = [ 0 ] <NEWLINE> for j in Y : <NEWLINE> <INDENT> for i in range ( len ( cost ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> a = X . find ( c , cost [ i ] ) + 1 <NEWLINE> if a : <NEWLINE> <INDENT> if i + 1 < len ( cost ) : <NEWLINE> <INDENT> cost [ i + 1 ] = min ( cost [ i + 1 ] , a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost . append ( a ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return len ( cost ) - 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> Z = [ ] <NEWLINE> for p in range ( q ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> z = ask ( X , Y ) <NEWLINE> Z . append ( z ) <NEWLINE> <NL> <DEDENT> for p in range ( q ) : <NEWLINE> <INDENT> print ( Z [ p ] ) <NEWLINE> <NL> <DEDENT>
def lcs_size ( ) : <NEWLINE> <INDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> a = len ( X ) <NEWLINE> b = len ( Y ) <NEWLINE> z2 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> ch = X [ i ] <NEWLINE> z1 = z2 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if ch == Y [ j ] : <NEWLINE> <INDENT> z2 [ j + 1 ] = z1 [ j ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z2 [ j + 1 ] = z2 [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return z2 [ - 1 ] <NEWLINE> <NL> <DEDENT> q = input ( ) <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> print lcs_size ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = int ( stdin . readline ( ) ) <NEWLINE> <NL> c = [ range ( 1001 ) for _ in xrange ( 1001 ) ] <NEWLINE> <NL> for _ in xrange ( num ) : <NEWLINE> <INDENT> x = stdin . readline ( ) . rstrip ( ) <NEWLINE> y = stdin . readline ( ) . rstrip ( ) <NEWLINE> <NL> m = len ( x ) <NEWLINE> n = len ( y ) <NEWLINE> <NL> for i in xrange ( m + 1 ) : <NEWLINE> <INDENT> row = c [ i ] <NEWLINE> for j in xrange ( n + 1 ) : <NEWLINE> <INDENT> row [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> cim1 = c [ 0 ] <NEWLINE> for i , xi in enumerate ( x , start = 1 ) : <NEWLINE> <INDENT> ci = c [ i ] <NEWLINE> for j , yj in enumerate ( y , start = 1 ) : <NEWLINE> <INDENT> if xi == yj : <NEWLINE> <INDENT> ci [ j ] = cim1 [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif cim1 [ j ] >= ci [ j - 1 ] : <NEWLINE> <INDENT> ci [ j ] = cim1 [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ci [ j ] = ci [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> cim1 = ci <NEWLINE> <NL> <DEDENT> print ( ci [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def Ics ( x , y ) : <NEWLINE> <INDENT> a = len ( x ) <NEWLINE> b = len ( y ) <NEWLINE> c1 = [ 0 ] * ( b + 1 ) <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> d = x [ i ] <NEWLINE> c2 = c1 [ : ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if d == y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> q = int ( input ( ) . rstrip ( ) ) <NEWLINE> r = [ ] <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> r . append ( Ics ( s1 , s2 ) ) <NEWLINE> <NL> <DEDENT> print ( * r , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = [ 0 for i in range ( n ) ] <NEWLINE> y = [ 0 for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] = input ( ) <NEWLINE> y [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> X = list ( x [ i ] ) <NEWLINE> Y = list ( y [ i ] ) <NEWLINE> a = [ int ( 0 ) for i in range ( len ( X ) ) ] <NEWLINE> for j in range ( len ( X ) ) : <NEWLINE> <INDENT> b = - 1 <NEWLINE> for l in range ( j , len ( X ) ) : <NEWLINE> <INDENT> for k in range ( len ( Y ) ) : <NEWLINE> <INDENT> if X [ l ] == Y [ k ] and b < k : <NEWLINE> <INDENT> b = k <NEWLINE> a [ j ] += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ( a ) ) <NEWLINE> <DEDENT> a = [ 0 for i in range ( n ) ] a = [ 0 for i in range ( n ) ] <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> X = raw_input ( ) <NEWLINE> Y = raw_input ( ) <NEWLINE> a = len ( X ) <NEWLINE> b = len ( Y ) <NEWLINE> c1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> c2 = c1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if X [ i ] == Y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> print solve ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> <NL> def lcs ( ) : <NEWLINE> <INDENT> s1 = raw_input ( ) <NEWLINE> s2 = raw_input ( ) <NEWLINE> la , lb = len ( s1 ) , len ( s2 ) <NEWLINE> dp1 = [ 0 for _ in range ( lb + 1 ) ] <NEWLINE> <NL> for i in range ( la ) : <NEWLINE> <INDENT> dp2 = dp1 + [ ] <NEWLINE> for j in range ( lb ) : <NEWLINE> <INDENT> if s1 [ i ] == s2 [ j ] : <NEWLINE> <INDENT> dp1 [ j + 1 ] = dp2 [ j ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp1 [ j + 1 ] = dp1 [ j ] if dp1 [ j ] > dp2 [ j + 1 ] else dp2 [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dp1 [ - 1 ] <NEWLINE> <NL> <DEDENT> tc = int ( raw_input ( ) ) <NEWLINE> for _ in range ( tc ) : <NEWLINE> <INDENT> print ( lcs ( ) ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> y = raw_input ( ) <NEWLINE> <NL> a , b = len ( x ) , len ( y ) <NEWLINE> x1 = [ 0 for k in range ( b + 1 ) ] <NEWLINE> for i in xrange ( a ) : <NEWLINE> <INDENT> e1 = x [ i ] <NEWLINE> x2 = x1 + <STRING> <NEWLINE> for j in xrange ( b ) : <NEWLINE> <INDENT> if e1 == y [ j ] : <NEWLINE> <INDENT> x1 [ j + 1 ] = x2 [ j ] + 1 <NEWLINE> <DEDENT> elif x1 [ j + 1 ] < x1 [ j ] : <NEWLINE> <INDENT> x1 [ j + 1 ] = x1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i2 in range ( n ) : <NEWLINE> <INDENT> print solve ( ) <NEWLINE> <DEDENT>
<NL> def f ( x , y ) : <NEWLINE> <INDENT> list = [ 0 ] <NEWLINE> for z in y : <NEWLINE> <INDENT> for i in range ( len ( list ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> tmp = x . find ( z , list [ i ] ) + 1 <NEWLINE> if tmp : <NEWLINE> <INDENT> if i + 1 < len ( list ) : <NEWLINE> <INDENT> list [ i + 1 ] = min ( list [ i + 1 ] , tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( tmp ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return len ( list ) - 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> print ( f ( x , y ) ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> X = raw_input ( ) <NEWLINE> Y = raw_input ( ) <NEWLINE> print lcs ( X , Y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def lcs ( X , Y ) : <NEWLINE> <INDENT> m = len ( X ) <NEWLINE> n = len ( Y ) <NEWLINE> c = [ [ 0 ] for i in xrange ( m + 1 ) ] <NEWLINE> c [ 0 ] += [ 0 ] * n <NEWLINE> <NL> for i in xrange ( m ) : <NEWLINE> <INDENT> for j in xrange ( n ) : <NEWLINE> <INDENT> if X [ i ] == Y [ j ] : <NEWLINE> <INDENT> c [ i + 1 ] . append ( c [ i ] [ j ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if c [ i ] [ j + 1 ] >= c [ i + 1 ] [ j ] : <NEWLINE> <INDENT> c [ i + 1 ] . append ( c [ i ] [ j + 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ i + 1 ] . append ( c [ i + 1 ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return c [ m ] [ n ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> seq1 = raw_input ( ) <NEWLINE> seq2 = raw_input ( ) <NEWLINE> a , b = len ( seq1 ) , len ( seq2 ) <NEWLINE> x1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> <INDENT> for i in range ( a ) : <NEWLINE> <INDENT> e1 = seq1 [ i ] <NEWLINE> x2 = x1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == seq2 [ j ] : <NEWLINE> <INDENT> x1 [ j + 1 ] = x2 [ j ] + 1 <NEWLINE> <DEDENT> elif x1 [ j + 1 ] < x1 [ j ] : <NEWLINE> <INDENT> x1 [ j + 1 ] = x1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x1 [ - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> for i2 in range ( n ) : <NEWLINE> <INDENT> print solve ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> from __future__ import division <NEWLINE> from sys import stdin , maxint <NEWLINE> <NL> def lcs ( s1 , s2 ) : <NEWLINE> <INDENT> la , lb = len ( s1 ) , len ( s2 ) <NEWLINE> dp1 = [ 0 for _ in range ( lb + 1 ) ] <NEWLINE> <NL> for i in xrange ( 1 , la + 1 ) : <NEWLINE> <INDENT> dp2 = dp1 [ 0 : ] <NEWLINE> for j in xrange ( 1 , lb + 1 ) : <NEWLINE> <INDENT> if s1 [ i - 1 ] == s2 [ j - 1 ] : <NEWLINE> <INDENT> dp1 [ j ] = dp2 [ j - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp1 [ j ] = max ( dp1 [ j - 1 ] , dp2 [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dp1 [ - 1 ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> tc = int ( stdin . readline ( ) ) <NEWLINE> for _ in range ( tc ) : <NEWLINE> <INDENT> sa = stdin . readline ( ) . strip ( ) <NEWLINE> sb = stdin . readline ( ) . strip ( ) <NEWLINE> print ( lcs ( sa , sb ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def longestcommonsubsequence ( ) : <NEWLINE> <INDENT> seq1 = raw_input ( ) <NEWLINE> seq2 = raw_input ( ) <NEWLINE> <NL> a , b = len ( seq1 ) , len ( seq2 ) <NEWLINE> x1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = seq1 [ i ] <NEWLINE> x2 = x1 + [ ] <NEWLINE> <COMMENT> <NL> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == seq2 [ j ] : <NEWLINE> <INDENT> x1 [ j + 1 ] = x2 [ j ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 [ j + 1 ] = max ( x1 [ j + 1 ] , x1 [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i2 in range ( n ) : <NEWLINE> <NL> <INDENT> print longestcommonsubsequence ( ) <NEWLINE> <DEDENT>
<NL> <INDENT> e = input <NEWLINE> a = <STRING> <NEWLINE> for _ in [ 0 ] * int ( e ( ) ) : <NEWLINE> <INDENT> X , z = e ( ) , [ ] <NEWLINE> for y in e ( ) : <NEWLINE> <INDENT> s = i = 0 <NEWLINE> for k in z : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t < 1 : break <NEWLINE> if t < k : z [ i ] = t <NEWLINE> s = k ; i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t : z += [ t ] <NEWLINE> <DEDENT> <DEDENT> a += <STRING> <NEWLINE> <DEDENT> print ( a [ 1 : ] <NEWLINE> <DEDENT>
def solve ( ) : <NEWLINE> <INDENT> seq1 = raw_input ( ) <NEWLINE> seq2 = raw_input ( ) <NEWLINE> <NL> x , y = len ( seq1 ) , len ( seq2 ) <NEWLINE> a1 = [ 0 for i in range ( y + 1 ) ] <NEWLINE> for i in range ( x ) : <NEWLINE> <INDENT> e1 = seq1 [ i ] <NEWLINE> a2 = a1 + [ ] <NEWLINE> for j in range ( y ) : <NEWLINE> <INDENT> if e1 == seq2 [ j ] : <NEWLINE> <INDENT> a1 [ j + 1 ] = a2 [ j ] + 1 <NEWLINE> <DEDENT> elif a1 [ j + 1 ] < a1 [ j ] : <NEWLINE> <INDENT> a1 [ j + 1 ] = a1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return a1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = imput ( ) <NEWLINE> for i2 in range ( n ) : <NEWLINE> <INDENT> print solve ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def findLCS ( X , Y ) : <NEWLINE> <INDENT> C = [ [ 0 for i in range ( 1001 ) ] for j in range ( 1001 ) ] <NEWLINE> X , Y = <STRING> + X , <STRING> + Y <NEWLINE> m , n , maxl = len ( X ) , len ( Y ) , 0 <NEWLINE> <NL> for i in range ( 1 , m ) : <NEWLINE> <INDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if X [ i ] == Y [ j ] : <NEWLINE> <INDENT> C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> C [ i ] [ j ] = max ( C [ i - 1 ] [ j ] , C [ i ] [ j - 1 ] ) <NEWLINE> <DEDENT> maxl = max ( maxl , C [ i ] [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return maxl <NEWLINE> <NL> <DEDENT> lines = sys . stdin . readlines ( ) <NEWLINE> N = int ( lines [ 0 ] ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> X = lines [ 2 * i + 1 ] . strip ( ) <NEWLINE> Y = lines [ 2 * i + 2 ] . strip ( ) <NEWLINE> print findLCS ( X , Y ) <NEWLINE> <DEDENT>
def LCS ( ) : <NEWLINE> <INDENT> X = raw_input ( ) <NEWLINE> Y = raw_input ( ) <NEWLINE> <NL> a , b = len ( X ) , len ( Y ) <NEWLINE> c1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = X [ i ] <NEWLINE> c2 = c1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == Y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print LCS ( ) <NEWLINE> <DEDENT>
def longest ( ) : <NEWLINE> <INDENT> moji1 = raw_input ( ) <NEWLINE> moji2 = raw_input ( ) <NEWLINE> <NL> a , b = len ( seq1 ) , len ( seq2 ) <NEWLINE> x1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> e1 = moji1 [ i ] <NEWLINE> x2 = x1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == moji2 [ j ] : <NEWLINE> <INDENT> x1 [ j + 1 ] = x2 [ j ] + 1 <NEWLINE> <DEDENT> elif x1 [ j + 1 ] < x1 [ j ] : <NEWLINE> <INDENT> x1 [ j + 1 ] = x1 [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return x1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print longest ( ) <NEWLINE> <DEDENT>
def Ics ( X , Y ) : <NEWLINE> <INDENT> m = len ( X ) <NEWLINE> n = len ( Y ) <NEWLINE> c1 = [ 0 ] * ( n + 1 ) <NEWLINE> c2 = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> d = X [ i ] <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( d == Y [ j ] ) : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif ( c1 [ j + 1 ] < c1 [ j ] ) : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> return ( c1 [ - 1 ] ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) . rstrip ( ) ) <NEWLINE> t = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s1 = input ( ) . rstrip ( ) <NEWLINE> s2 = input ( ) . rstrip ( ) <NEWLINE> t . append ( Ics ( s1 , s2 ) ) <NEWLINE> <DEDENT> print ( * t , sep = <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> for k in xrange ( n ) : <NEWLINE> <INDENT> str1 = raw_input ( ) <NEWLINE> str2 = raw_input ( ) <NEWLINE> <NL> after = [ 0 ] * ( len ( str2 ) + 1 ) <NEWLINE> <NL> for i in xrange ( 1 , len ( str1 ) + 1 ) : <NEWLINE> <INDENT> before = after + [ ] <NEWLINE> for j in xrange ( 1 , len ( str2 ) + 1 ) : <NEWLINE> <INDENT> if str1 [ i - 1 ] == str2 [ j - 1 ] : <NEWLINE> <INDENT> after [ j ] = before [ j - 1 ] + 1 <NEWLINE> <DEDENT> elif after [ j - 1 ] > before [ j ] : <NEWLINE> <INDENT> after [ j ] = after [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print after [ j ] <NEWLINE> <DEDENT>
def solve_lcs ( ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> y = raw_input ( ) <NEWLINE> <NL> a = len ( x ) <NEWLINE> y = len ( y ) <NEWLINE> c1 = [ 0 for i in range ( b + 1 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> e1 = x [ i ] <NEWLINE> c2 = c1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if e1 == y [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c2 [ j ] + 1 <NEWLINE> <DEDENT> elif c1 [ j + 1 ] < c1 [ j ] : <NEWLINE> <INDENT> c1 [ j + 1 ] = c1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c1 [ - 1 ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> for i2 in range ( n ) : <NEWLINE> <INDENT> print solve_lcs ( ) <NEWLINE> <DEDENT>
def edit_distance ( ) : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> t = raw_input ( ) <NEWLINE> a = len ( s ) <NEWLINE> b = len ( t ) <NEWLINE> x = [ 0 for i in range ( b + 1 ) ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> q = s [ i ] <NEWLINE> x2 = x1 + [ ] <NEWLINE> for j in range ( b ) : <NEWLINE> <INDENT> if ( q == t [ j ] ) : <NEWLINE> <INDENT> x [ j + 1 ] = x2 [ j ] + 1 <NEWLINE> <DEDENT> elif ( x [ j + 1 ] < x [ j ] ) : <NEWLINE> <INDENT> x [ j + 1 ] = x2 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x [ - 1 ] <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> for i2 in range ( n ) : <NEWLINE> <INDENT> print edit_distance ( ) <NEWLINE> <DEDENT>
q = int ( input ( ) ) <NEWLINE> <NL> def lcss ( x , y ) : <NEWLINE> <NL> <INDENT> lcs = [ 0 ] * ( len ( x ) + 1 ) <NEWLINE> for i in range ( len ( y ) ) : <NEWLINE> <INDENT> w1 = y [ i ] <NEWLINE> lcs_2 = lcs [ : ] <NEWLINE> for j in range ( len ( x ) ) : <NEWLINE> <INDENT> if x [ j ] == w1 : <NEWLINE> <INDENT> lcs [ j + 1 ] = lcs_2 [ j ] + 1 <NEWLINE> <DEDENT> elif lcs [ j + 1 ] < lcs [ j ] : <NEWLINE> <INDENT> lcs [ j + 1 ] = lcs [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return lcs [ - 1 ] <NEWLINE> <NL> <DEDENT> ret = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> ret . append ( lcss ( ) ) <NEWLINE> <DEDENT> print ( * ret , sep = <STRING> ) <NEWLINE>
def solve ( ) : <NEWLINE> <INDENT> x = raw_input ( ) <NEWLINE> y = raw_input ( ) <NEWLINE> a , b = len ( x ) , len ( y ) <NEWLINE> <NL> dsp1 = [ 0 for i in xrange ( b + 1 ) ] <NEWLINE> for i in xrange ( a ) : <NEWLINE> <INDENT> dsp2 = dsp1 + [ ] <NEWLINE> for j in xrange ( b ) : <NEWLINE> <INDENT> if x [ i ] == y [ j ] : <NEWLINE> dsp1 [ j + 1 ] = dsp2 [ j ] + 1 <NEWLINE> <DEDENT> elif dsp1 [ j + 1 ] < dsp1 [ j ] : <NEWLINE> <INDENT> dsp1 [ j + 1 ] = dsp1 [ j ] <NEWLINE> <DEDENT> <DEDENT> print max ( dsp1 ) <NEWLINE> <NL> n = input ( ) <NEWLINE> for a in xrange ( n ) : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT> <DEDENT>
a = [ ] <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> X , z = input ( ) , [ ] <NEWLINE> for y in input ( ) : <NEWLINE> <INDENT> s = i = 0 <NEWLINE> for k in z : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t < 1 : break <NEWLINE> if t < k : z [ i ] = t <NEWLINE> s = k ; i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = X . find ( y , s ) + 1 <NEWLINE> if t : z += [ t ] <NEWLINE> <DEDENT> <DEDENT> a += [ len ( z ) ] <NEWLINE> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
def main ( ) : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> adj = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = tmp [ 0 ] <NEWLINE> u = u - 1 <NEWLINE> k = tmp [ 1 ] <NEWLINE> v = tmp [ 2 : ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> adj [ u ] [ v [ j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> print ( <STRING> . join ( list ( map ( str , adj [ i ] ) ) ) ) <NEWLINE> <NL> for i in adj : <NEWLINE> print ( * i ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> v = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = l [ 0 ] <NEWLINE> k = l [ 1 ] <NEWLINE> for j in l [ 2 : ] : <NEWLINE> <INDENT> v [ i - 1 ] [ j - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( v [ i ] [ j ] + <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> arr = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> l = raw_input ( ) . split ( ) <NEWLINE> if ( int ( l [ 1 ] ) >= 1 ) : <NEWLINE> <INDENT> x = int ( l [ 0 ] ) <NEWLINE> y = int ( l [ 1 ] ) <NEWLINE> p = len ( l ) <NEWLINE> d = 0 <NEWLINE> while ( 2 + d < p ) : <NEWLINE> <INDENT> z = int ( l [ 2 + d ] ) <NEWLINE> arr [ x - 1 ] [ z - 1 ] = 1 <NEWLINE> d = d + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( arr ) <NEWLINE>
<COMMENT> <NL> n = int ( raw_input ( ) ) <NEWLINE> <COMMENT> <NL> x = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> seq = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> tmp = seq [ 0 ] - 1 <NEWLINE> n2 = seq [ 1 ] <NEWLINE> if n2 != 0 : <NEWLINE> <INDENT> for e in seq [ 2 : ] : <NEWLINE> <INDENT> x [ tmp ] [ e - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , x [ i ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) ; <NEWLINE> G = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> list = [ int ( m ) for m in input ( ) . split ( ) ] <NEWLINE> u = list [ 0 ] <NEWLINE> k = list [ 1 ] <NEWLINE> for j in range ( 2 , len ( list ) ) : <NEWLINE> <INDENT> v = list [ j ] <NEWLINE> G [ u - 1 ] [ v - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> print ( G [ i ] [ j ] , end = <STRING> ) <NEWLINE> if j != len ( g [ i ] ) - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( v [ 1 ] ) : <NEWLINE> <INDENT> a [ u - 1 ] [ v [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( * a [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> <NL> class Graph : <NEWLINE> <INDENT> def __init__ ( self , nodes = { } ) : <NEWLINE> <INDENT> self . nodes = nodes <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> G = Graph ( ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> numList = line . split ( ) <NEWLINE> G . nodes [ int ( numList [ 0 ] ) ] = list ( map ( int , numList [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> for node in range ( n ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> for adj in range ( n ) : <NEWLINE> <INDENT> if adj + 1 != n : <NEWLINE> <INDENT> out += <STRING> if adj + 1 in G . nodes [ node ] else <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> out += <STRING> if adj + 1 in G . nodes [ node ] else <STRING> <NEWLINE> <DEDENT> <DEDENT> print ( out ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> for _ in [ 0 ] * N : <NEWLINE> <INDENT> r = [ 0 ] * N <NEWLINE> for i in input ( ) . split ( ) [ 2 : ] : a [ int ( i ) - 1 ] = 1 <NEWLINE> print ( * a ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> g = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> <NL> while n : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> column_g = g [ l [ 0 ] - 1 ] <NEWLINE> for i in l [ 2 : ] : <NEWLINE> <INDENT> column_g [ i - 1 ] = 1 <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <DEDENT> for v in column_g : <NEWLINE> <INDENT> print ( * v ) <NEWLINE> <DEDENT>
v_num = int ( input ( ) ) <NEWLINE> adjacent = [ [ 0 for n in range ( v_num ) ] for m in range ( v_num ) ] <NEWLINE> for _ in range ( v_num ) : <NEWLINE> <INDENT> inp = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> for i in inp [ 2 : ] : <NEWLINE> <INDENT> adjacent [ inp [ 0 ] - 1 ] [ i - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> for i in range ( v_num ) : <NEWLINE> <INDENT> print ( * adjacent [ i ] ) <NEWLINE> <DEDENT>
N = int ( raw_input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = [ 0 ] * N <NEWLINE> <NL> <DEDENT> for line in sys . stdin : <NEWLINE> <INDENT> values = line . split ( ) <NEWLINE> u = int ( values [ 0 ] ) - 1 <NEWLINE> k = int ( values [ 1 ] ) <NEWLINE> nodes = values [ 2 : ] <NEWLINE> for i in range ( int ( k ) ) : <NEWLINE> <INDENT> v = int ( nodes [ i ] ) - 1 <NEWLINE> A [ u ] [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> print <STRING> . join ( [ str ( x ) for x in A [ i ] ] ) <NEWLINE> <DEDENT>
def dfs ( n ) : <NEWLINE> <INDENT> global t <NEWLINE> S [ n ] = t <NEWLINE> DP [ n ] = 1 <NEWLINE> for i in A [ n ] [ 2 : ] : <NEWLINE> <INDENT> if not DP [ i ] : <NEWLINE> <INDENT> t += 1 <NEWLINE> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> t += 1 <NEWLINE> F [ n ] = t <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> d = deque ( ) <NEWLINE> A = [ 0 ] * ( n + 1 ) <NEWLINE> S = [ 0 ] * ( n + 1 ) <NEWLINE> F = [ 0 ] * ( n + 1 ) <NEWLINE> DP = [ 0 ] * ( n + 1 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i + 1 ] = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <DEDENT> t = 1 <NEWLINE> dfs ( 1 ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> tmp = <STRING> . format ( i , S [ i ] , F [ i ] ) <NEWLINE> print ( tmp ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> d = [ 0 for i in range ( n ) ] <NEWLINE> f = [ 0 for i in range ( n ) ] <NEWLINE> a = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> st = [ 0 for i in range ( n ) ] <NEWLINE> time = [ 0 ] <NEWLINE> G = [ 0 for i in range ( n ) ] <NEWLINE> <NL> def dfs_visit ( s ) : <NEWLINE> <INDENT> st [ s ] = 1 <NEWLINE> time [ 0 ] += 1 <NEWLINE> d [ s ] = time [ 0 ] <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> if a [ s ] [ k ] == 1 and st [ k ] == 0 : <NEWLINE> <INDENT> dfs_visit ( k ) <NEWLINE> <DEDENT> <DEDENT> time [ 0 ] += 1 <NEWLINE> f [ s ] = time [ 0 ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for s in range ( n ) : <NEWLINE> <INDENT> if st [ s ] == 0 : <NEWLINE> <INDENT> def_visit ( s ) <NEWLINE> <DEDENT> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> print ( s + 1 , d [ s ] , f [ s ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> a [ G [ 0 ] - 1 ] [ G [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE> <NL> <NL>
def depth ( s , time ) : <NEWLINE> <INDENT> time += 1 <NEWLINE> flag [ s ] = 1 <NEWLINE> d [ s ] = t <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if G [ s ] [ i ] == 1 : <NEWLINE> <INDENT> if flag [ i ] == 0 : <NEWLINE> <INDENT> depth ( i , time ) <NEWLINE> t = f [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> f [ s ] = time + 1 <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> G = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> d = [ 0 for i in range ( n + 1 ) ] <NEWLINE> f = [ 0 for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( v [ 1 ] ) : <NEWLINE> <INDENT> G [ v [ 0 ] ] [ v [ 2 + j ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> flag = [ 0 for i in range ( n + 1 ) ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if flag [ i ] == 0 : <NEWLINE> <INDENT> depth ( i , max ( f ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( d [ i ] ) + <STRING> + str ( f [ i ] ) ) <NEWLINE> <DEDENT>
def dfs ( u , node_info , matrix ) : <NEWLINE> <COMMENT> <NL> <INDENT> colors = [ 0 ] * len ( matrix ) <NEWLINE> detect_time = [ 0 ] * len ( matrix ) <NEWLINE> finished_time = [ 0 ] * len ( matrix ) <NEWLINE> time = 1 <NEWLINE> stack = list ( ) <NEWLINE> stack . append ( u ) <NEWLINE> colors [ u ] = 1 <NEWLINE> detect_time [ u ] = time <NEWLINE> while len ( stack ) : <NEWLINE> <INDENT> for i , val in enumerate ( matrix [ u ] ) : <NEWLINE> <INDENT> if val == 1 and colors [ i ] == 0 : <NEWLINE> <INDENT> time += 1 <NEWLINE> stack . append ( i ) <NEWLINE> colors [ i ] = 1 <NEWLINE> detect_time [ i ] = time <NEWLINE> u = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> time += 1 <NEWLINE> e = stack . pop ( ) <NEWLINE> colors [ e ] = 2 <NEWLINE> finished_time [ e ] = time <NEWLINE> if len ( stack ) : <NEWLINE> <INDENT> u = stack [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( len ( matrix ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i + 1 , detect_time [ i ] , finished_time [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> matrix = [ [ 0 ] * N for _ in range ( N ) ] <NEWLINE> color = [ 0 ] * N <NEWLINE> for i in matrix : <NEWLINE> <INDENT> node_info = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> node_i = node_info [ 0 ] - 1 <NEWLINE> if not node_info [ 1 ] == 0 : <NEWLINE> <INDENT> for i in node_info [ 2 : ] : <NEWLINE> <INDENT> matrix [ node_i ] [ i - 1 ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for line in matrix : <NEWLINE> dfs ( 0 , None , matrix ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> global time <NEWLINE> time = 0 <NEWLINE> <NL> def dfs ( graph , start , state , discover , finish ) : <NEWLINE> <NL> <INDENT> state [ start - 1 ] = 1 <NEWLINE> global time <NEWLINE> time = time + 1 <NEWLINE> discover [ start - 1 ] = time <NEWLINE> <COMMENT> <NL> <NL> neighbours = sorted ( graph [ start ] ) <NEWLINE> <NL> for neighbour in neighbours : <NEWLINE> <INDENT> if state [ neighbour - 1 ] == 0 : <NEWLINE> <INDENT> dfs ( graph , neighbour , state , discover , finish ) <NEWLINE> <NL> <DEDENT> <DEDENT> state [ start - 1 ] = 2 <NEWLINE> time = time + 1 <NEWLINE> finish [ start - 1 ] = time <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> d = [ 0 ] * 6 <NEWLINE> f = [ 0 ] * 6 <NEWLINE> <NL> <COMMENT> <NL> n = int ( stdin . readline ( ) ) <NEWLINE> <NL> g = { } <NEWLINE> <NL> d = [ - 1 ] * n <NEWLINE> <NL> all_vertex = [ ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> entry = [ int ( s ) for s in stdin . readline ( ) . split ( ) [ 2 : ] ] <NEWLINE> g [ i + 1 ] = entry <NEWLINE> all_vertex . append ( i + 1 ) <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> state = [ 0 ] * n <NEWLINE> <NL> for node in all_vertex : <NEWLINE> <INDENT> if state [ node - 1 ] == 0 : <NEWLINE> <INDENT> dfs ( g , node , state , d , f ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> print str ( i + 1 ) + <STRING> + str ( d [ i ] ) + <STRING> + str ( f [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def dfs_recursive ( u ) : <NEWLINE> <INDENT> global time <NEWLINE> color [ u ] = <STRING> <NEWLINE> arrive [ u ] = time <NEWLINE> time += 1 <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if adjMat [ u ] [ v ] == 1 and color [ v ] == <STRING> : <NEWLINE> <INDENT> dfs_recursive ( v ) <NEWLINE> <DEDENT> <DEDENT> color [ u ] = <STRING> <NEWLINE> finish [ u ] = time <NEWLINE> time += 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> adjMat = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> color = [ <STRING> ] * n <NEWLINE> arrive = [ 0 ] * n <NEWLINE> finish = [ 0 ] * n <NEWLINE> time = 1 <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> adj = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = adj [ 0 ] <NEWLINE> v = adj [ 2 : ] <NEWLINE> for j in v : <NEWLINE> <INDENT> adjMat [ i - 1 ] [ j - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for root in range ( n ) : <NEWLINE> <INDENT> if color [ root ] == <STRING> : <NEWLINE> <INDENT> dfs ( root ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> out += <STRING> . format ( i + 1 , arrive [ i ] , finish [ i ] ) <NEWLINE> print ( out ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def dfs ( i , t , l , a , b ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> a [ i ] = t <NEWLINE> for j in l [ i ] : <NEWLINE> <INDENT> if not a [ j - 1 ] : <NEWLINE> <INDENT> t = dfs ( j - 1 , t , l , a , b ) <NEWLINE> <DEDENT> <DEDENT> t += 1 <NEWLINE> b [ i ] = t <NEWLINE> return t <NEWLINE> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> l = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( s ) for s in sys . stdin . readline ( ) . split ( ) [ 2 : ] <NEWLINE> l . append ( x ) <NEWLINE> <DEDENT> a = [ 0 ] * n <NEWLINE> b = [ 0 ] * n <NEWLINE> t = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if not a [ i ] : <NEWLINE> <INDENT> tm = dfs ( i , t , l , a , b ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> print i + 1 , a [ i ] , b [ i ] <NEWLINE> <DEDENT>
class Color ( Enum ) : <NEWLINE> <INDENT> WHITE = auto ( ) <COMMENT> <NEWLINE> GRAY = auto ( ) <COMMENT> <NEWLINE> BLACK = auto ( ) <COMMENT> <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> d = [ 0 for i in range ( n ) ] <NEWLINE> f = [ 0 for i in range ( n ) ] <NEWLINE> <NL> colors = [ ] <COMMENT> <NEWLINE> A = [ [ 0 for j in range ( n ) ] for i in range ( n ) ] <COMMENT> <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> arr = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> u , k , v = arr [ 0 ] , arr [ 1 ] , arr [ 2 : ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> A [ u - 1 ] [ v [ j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> time = 0 <NEWLINE> def dfs_init ( ) : <NEWLINE> <INDENT> global colors <NEWLINE> colors = [ Color . WHITE for i in range ( n ) ] <NEWLINE> dfs ( 0 ) <NEWLINE> <NL> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> global time <NEWLINE> colors [ u ] = Color . GRAY <NEWLINE> time += 1 <NEWLINE> d [ u ] = time <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if A [ u ] [ v ] == 1 and colors [ v ] == Color . WHITE : <NEWLINE> <INDENT> dfs ( v ) <NEWLINE> <DEDENT> <DEDENT> colors [ u ] = Color . BLACK <NEWLINE> time += 1 <NEWLINE> f [ u ] = time <NEWLINE> <NL> <DEDENT> dfs_init ( ) <NEWLINE> for u in range ( n ) : <NEWLINE> <INDENT> if colors [ u ] == Color . WHITE : <NEWLINE> <INDENT> dfs ( u ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i + 1 , d [ i ] , f [ i ] ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> d = [ 0 for i in range ( n ) ] <NEWLINE> f = [ 0 for i in range ( n ) ] <NEWLINE> X = [ 0 for i in range ( n ) ] <NEWLINE> M = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> color = [ 0 for i in range ( n ) ] <NEWLINE> t = 0 <NEWLINE> <NL> def DFS_v ( u ) : <NEWLINE> <INDENT> color [ u ] = 1 <NEWLINE> t += 1 <NEWLINE> d [ u ] = t <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if M [ u ] [ v ] == 1 and color [ v ] == 0 : <NEWLINE> <INDENT> DFS_v ( v ) <NEWLINE> <DEDENT> <DEDENT> color [ u ] = 2 <NEWLINE> t += 1 <NEWLINE> f [ u ] = t <NEWLINE> <NL> <DEDENT> def DFS ( ) : <NEWLINE> <INDENT> for u in range ( n ) : <NEWLINE> <INDENT> if color [ u ] == 0 : <NEWLINE> <INDENT> DFS_v ( u ) <NEWLINE> <DEDENT> <DEDENT> for u in range ( n ) : <NEWLINE> <INDENT> print <STRING> % ( u + 1 , d [ u ] , f [ u ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> X = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( X [ 1 ] ) : <NEWLINE> <INDENT> M [ X [ 0 ] - 1 ] [ X [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( ) <NEWLINE>
<NL> <COMMENT> <NL> <NL> def DFS ( n = 1 , A = [ 0 ] , i = 0 , d = [ 0 ] , f = [ 0 ] , time = 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == 1 and d [ j ] == 0 : <NEWLINE> <INDENT> time = time + 1 <NEWLINE> d [ j ] = time <NEWLINE> time = DFS ( n , A , j , d , f , time ) <NEWLINE> <DEDENT> <DEDENT> time = time + 1 <NEWLINE> f [ i ] = time <NEWLINE> return time <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = [ 0 ] * n <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> value = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> u = value [ 0 ] - 1 <NEWLINE> k = value [ 1 ] <NEWLINE> nodes = value [ 2 : ] <NEWLINE> for i in range ( k ) : <NEWLINE> <INDENT> v = nodes [ i ] - 1 <NEWLINE> A [ u ] [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ 0 ] * n <NEWLINE> f = [ 0 ] * n <NEWLINE> <NL> time = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> time = time + 1 <NEWLINE> d [ i ] = time <NEWLINE> time = DFS ( n , A , i , d , f , time ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( str ( i + 1 ) + <STRING> + str ( d [ i ] ) + <STRING> + str ( f [ i ] ) ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> d = [ 0 for i in range ( n ) ] <NEWLINE> f = [ 0 for i in range ( n ) ] <NEWLINE> G = [ 0 for i in range ( n ) ] <NEWLINE> v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> st = [ 0 for i in range ( n ) ] <NEWLINE> tm = [ 0 ] <NEWLINE> <NL> def DFS_visit ( s ) : <NEWLINE> <INDENT> st [ s ] = 1 <NEWLINE> tm [ 0 ] += 1 <NEWLINE> d [ s ] = tm [ 0 ] <NEWLINE> for e in range ( n ) : <NEWLINE> <INDENT> if v [ s ] [ e ] == 1 and st [ e ] == 0 : <NEWLINE> <INDENT> DFS_visit ( e ) <NEWLINE> <DEDENT> <DEDENT> st [ s ] == 2 <NEWLINE> tm [ 0 ] += 1 <NEWLINE> f [ s ] = tm [ 0 ] <NEWLINE> <NL> <DEDENT> def DFS ( ) : <NEWLINE> <INDENT> for s in range ( n ) : <NEWLINE> <INDENT> if st [ s ] == 0 : <NEWLINE> <INDENT> DFS_visit ( s ) <NEWLINE> <DEDENT> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> print <STRING> . format ( s + 1 , d [ s ] , f [ s ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> v [ G [ 0 ] - 1 ] [ G [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( ) <NEWLINE>
j = 1 <NEWLINE> def dfs ( graph , start , result , visited = None ) : <NEWLINE> <INDENT> global j <NEWLINE> if visited == None : <NEWLINE> <INDENT> visited = [ ] <NEWLINE> <DEDENT> visited . append ( start ) <NEWLINE> result [ start ] [ 1 ] = j <NEWLINE> for next in graph [ start ] [ 2 : ] : <NEWLINE> <INDENT> if next in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> j += 1 <NEWLINE> dfs ( graph , next , result , visited ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j += 1 <NEWLINE> result [ start ] [ 2 ] = j <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> g = [ [ ] ] <NEWLINE> r = [ [ i , 0 , 0 ] for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> g . append ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT> dfs ( g , 1 , r ) <NEWLINE> for i in range ( 1 : n + 1 ) <NEWLINE> <INDENT> print ( * r [ i ] ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> d = [ 0 for i in range ( n ) ] <NEWLINE> f = [ 0 for i in range ( n ) ] <NEWLINE> G = [ 0 for i in range ( n ) ] <NEWLINE> M = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> col = [ 0 for i in range ( n ) ] <NEWLINE> t = [ 0 ] <NEWLINE> <NL> def DFS_visit ( u ) : <NEWLINE> <INDENT> col [ u ] = 1 <NEWLINE> t [ 0 ] += 1 <NEWLINE> d [ u ] = t [ 0 ] <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if M [ u ] [ v ] == 1 and col [ v ] == 0 : <NEWLINE> <INDENT> DFS_visit ( v ) <NEWLINE> <DEDENT> <DEDENT> col [ u ] = 2 <NEWLINE> t [ 0 ] += 1 <NEWLINE> f [ u ] = t [ 0 ] <NEWLINE> <NL> <DEDENT> def DFS ( ) : <NEWLINE> <INDENT> for u in range ( n ) : <NEWLINE> <INDENT> if col [ u ] == 0 : <NEWLINE> <INDENT> DFS_visit ( u ) <NEWLINE> <DEDENT> <DEDENT> for u in range ( n ) : <NEWLINE> <INDENT> print <STRING> . format ( s + 1 , d [ s ] , f [ s ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> X = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( X [ 1 ] ) : <NEWLINE> <INDENT> M [ X [ 0 ] - 1 ] [ X [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> DFS ( ) <NEWLINE>
import sys <NEWLINE> <NL> d_num = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> graph_list = [ ] <NEWLINE> <NL> for _ in range ( 0 , d_num ) : <NEWLINE> <INDENT> array = sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> if len ( array ) > 2 : <NEWLINE> <INDENT> graph_list . append ( [ ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> graph_list . append ( [ int ( array [ i ] ) for i in range ( 2 , len ( array ) ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> t = 1 <NEWLINE> result = [ [ ] for _ in range ( 0 , d_num ) ] <NEWLINE> searched_list = [ ] <NEWLINE> stack = [ ] <NEWLINE> <NL> stack . append ( 0 ) <NEWLINE> while sorted ( searched_list ) != range ( 0 , d_num ) : <NEWLINE> <INDENT> if len ( stack ) == 0 : <NEWLINE> <INDENT> stack . append ( filter ( lambda x : x not in searched_list , range ( 0 , d_num ) ) [ 0 ] ) <NEWLINE> <DEDENT> node = stack [ - 1 ] <NEWLINE> searched_list . append ( node ) <NEWLINE> children = filter ( lambda x : x not in searched_list , graph_list [ node ] ) <NEWLINE> if len ( child ) == 0 : <NEWLINE> <INDENT> next_node = children [ 0 ] <NEWLINE> result [ next_node ] . append ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> result [ node ] . append ( t ) <NEWLINE> <DEDENT> t += 1 <NEWLINE> <NL> <DEDENT> s = <STRING> <NEWLINE> <NL> for i in range ( 0 , len ( result ) ) : <NEWLINE> <INDENT> print str ( i + 1 ) + <STRING> + str ( result [ i ] [ 0 ] + 1 ) + <STRING> + str ( result [ i ] [ 1 ] + 1 ) <NEWLINE> <DEDENT>
def dfs ( u ) : <NEWLINE> <INDENT> global dfs_color , d , f , t <NEWLINE> color [ u ] = GRAY <NEWLINE> d [ u ] += t <NEWLINE> t += 1 <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if ( M [ u ] [ v ] == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( color [ v ] == WHITE ) : <NEWLINE> <INDENT> dfs ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> color [ u ] = BLACK <NEWLINE> f [ u ] = t <NEWLINE> t += 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> M = [ [ for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( tmp [ 1 ] ) : <NEWLINE> <INDENT> M [ tmp [ 0 ] - 1 ] [ tmp [ j + 2 ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> color = [ WHITE for i in range ( n ) ] <NEWLINE> d , f = [ 0 for i in range ( n ) ] <NEWLINE> t = 1 <NEWLINE> <NL> for u in range ( n ) : <NEWLINE> <INDENT> if ( color [ u ] == WHITE ) : <NEWLINE> <INDENT> dfs ( u ) <NEWLINE> <DEDENT> <DEDENT> for u in range ( n ) : <NEWLINE> <INDENT> print ( str ( u + 1 ) , str ( d [ u ] ) , str ( f [ u ] ) , sep = <STRING> ) <NEWLINE> <DEDENT>
<NL> <COMMENT> <NL> <NL> def DFS ( n = 1 , i = 0 , time = 1 ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == 1 and d [ j ] == 0 : <NEWLINE> <INDENT> time = time + 1 <NEWLINE> d [ j ] = time <NEWLINE> time = DFS ( n , j , time ) <NEWLINE> <DEDENT> <DEDENT> time = time + 1 <NEWLINE> f [ i ] = time <NEWLINE> return time <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = [ 0 ] * n <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> value = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> u = value [ 0 ] - 1 <NEWLINE> k = value [ 1 ] <NEWLINE> nodes = value [ 2 : ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = nodes [ j ] - 1 <NEWLINE> A [ u ] [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ 0 ] * n <NEWLINE> f = [ 0 ] * n <NEWLINE> <NL> time = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == 0 : <NEWLINE> <INDENT> time = time + 1 <NEWLINE> d [ i ] = time <NEWLINE> time = DFS ( n , i , time ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( str ( i + 1 ) + <STRING> + str ( d [ i ] ) + <STRING> + str ( f [ i ] ) ) <NEWLINE> <DEDENT>
N = 100 <NEWLINE> <NL> M = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] <NEWLINE> color = [ 0 for i in range ( N ) ] <NEWLINE> d = [ 0 for i in range ( N ) ] <NEWLINE> f = [ 0 for i in range ( N ) ] <NEWLINE> tt = 0 <NEWLINE> <NL> <COMMENT> <NL> def dfs_visit ( u ) : <NEWLINE> <INDENT> color [ u ] = 1 <NEWLINE> tt = tt + 1 <NEWLINE> d [ u ] = tt <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> if M [ u ] [ v ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if color [ v ] == 0 : <NEWLINE> <INDENT> dfs_visit ( v ) <NEWLINE> <DEDENT> <DEDENT> color [ u ] = 2 <NEWLINE> tt = tt + 1 <NEWLINE> f [ u ] = tt <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def dfs ( ) : <NEWLINE> <INDENT> for u in range ( n ) : <NEWLINE> <INDENT> color [ u ] = 0 <NEWLINE> <DEDENT> tt = 0 <NEWLINE> <NL> for u in range ( n ) : <NEWLINE> <INDENT> if color [ u ] == 0 : <NEWLINE> <INDENT> dfs_visit ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> for u in range ( n ) : <NEWLINE> <INDENT> print <STRING> % ( u + 1 , d [ u ] , f [ u ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> M [ i ] [ j ] = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> Num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> u = Num [ 0 ] <NEWLINE> k = Num [ 1 ] <NEWLINE> u = u - 1 <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = Num [ j ] <NEWLINE> v = v - 1 <NEWLINE> M [ u ] [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> d = [ 0 for i in range ( n ) ] <NEWLINE> f = [ 0 for i in range ( n ) ] <NEWLINE> a = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> st = [ 0 for i in range ( n ) ] <NEWLINE> time = [ 0 ] <NEWLINE> g = [ 0 for i in range ( n ) ] <NEWLINE> <NL> <NL> def dfs_visit ( s ) : <NEWLINE> <INDENT> st [ s ] = 1 <NEWLINE> time [ 0 ] += 1 <NEWLINE> d [ s ] = time [ 0 ] <NEWLINE> <NL> for k in range ( n ) : <NEWLINE> <INDENT> if a [ s ] [ k ] == 1 and st [ k ] == 0 : <NEWLINE> <INDENT> dfs_visit ( k ) <NEWLINE> <DEDENT> <DEDENT> st [ s ] == 2 <NEWLINE> time [ 0 ] += 1 <NEWLINE> f [ s ] = time [ 0 ] <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for s in range ( n ) : <NEWLINE> <INDENT> if st [ s ] == 0 : <NEWLINE> <INDENT> dfs_visit ( s ) <NEWLINE> <DEDENT> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> print <STRING> . format ( s + 1 , d [ s ] , f [ s ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> g = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> a [ g [ 0 ] - 1 ] [ G [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ [ 0 ] * n for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = v [ 0 ] <NEWLINE> k = v [ 1 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> a [ u - 1 ] [ v [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ 0 ] * n <NEWLINE> f = [ 0 ] * n <NEWLINE> isDiscovered = [ False ] * n <NEWLINE> time_stamp = 0 <NEWLINE> <NL> def dfs ( x ) : <NEWLINE> <INDENT> global time_stamp <NEWLINE> isDiscovered [ x ] = True <NEWLINE> time_stamp = time_stamp + 1 <NEWLINE> d [ x ] = time_stamp <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if a [ x ] [ i ] == 1 and isDiscovered [ i ] == False : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <DEDENT> <DEDENT> time_stamp = time_stamp + 1 <NEWLINE> f [ x ] = time_stamp <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if isDiscovered [ i ] == False : <NEWLINE> <INDENT> dfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in rane ( n ) : <NEWLINE> <INDENT> print ( i + 1 , d [ i ] , f [ i ] ) <NEWLINE> <DEDENT>
n = 0 <NEWLINE> m = input ( ) <NEWLINE> c = [ 0 for i in xrange ( m ) ] <NEWLINE> t = [ 0 for i in xrange ( m ) ] <NEWLINE> <NL> <NL> def d ( u ) : <NEWLINE> <INDENT> global n <NEWLINE> if ts [ u ] : return <NEWLINE> n = n + 1 <NEWLINE> ts [ u ] = [ u + 1 , n ] <NEWLINE> for i in c [ u ] : d ( i - 1 ) <NEWLINE> n = n + 1 <NEWLINE> ts [ u ] [ 2 : ] = [ n ] <NEWLINE> <NL> <DEDENT> def dfs ( ) : <NEWLINE> <INDENT> for i in range ( m ) : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c [ l [ 0 ] - 1 ] = l [ 2 : ] <NEWLINE> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> d ( i ) <NEWLINE> print <STRING> . join ( map ( str , ts [ i ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> dfs ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> E = [ input ( ) . split ( ) [ 2 : ] for _ in range ( N ) ] <NEWLINE> Q = [ 0 ] <NEWLINE> L = [ 0 ] + [ - 1 ] * N <NEWLINE> flag = [ 1 ] + [ 0 ] * N <NEWLINE> def func ( ide ) : <NEWLINE> <INDENT> global Q <NEWLINE> for i in E [ ide ] : <NEWLINE> <INDENT> i = int ( i ) - 1 <NEWLINE> if frag [ i ] != 1 : frag [ i ] = 1 ; L [ i ] = L [ ide ] + 1 ; Q . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while Q : top = Q . pop ( 0 ) ; func ( top ) <NEWLINE> <NL> for i in range ( N ) : print ( i + 1 , int ( L [ i ] ) ) <NEWLINE> <NL>
m = [ [ 0 for _ in range ( n + 1 ) ] for _ in range ( n + 1 ) ] <NEWLINE> mm = [ [ ] for _ in range ( n + 1 ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> u , k , l = tmp [ 0 ] , tmp [ 1 ] , tmp [ 2 : ] <NEWLINE> mm [ u ] += tmp [ 2 : ] <NEWLINE> for x in l : <NEWLINE> <INDENT> m [ u ] [ x ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dp = [ float ( <STRING> ) for _ in range ( n + 1 ) ] <NEWLINE> queue = [ 1 ] <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> t = queue . pop ( 0 ) <NEWLINE> for x in mm [ t ] : <NEWLINE> <INDENT> if dp [ x ] > dp [ t ] + 1 : <NEWLINE> <INDENT> dp [ x ] = dp [ t ] + 1 <NEWLINE> queue . append ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , x in enumerate ( queue ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x == float ( <STRING> ) : <NEWLINE> <INDENT> print ( i , - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( i , x ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> d = [ 100 for i in range ( n ) ] <NEWLINE> G = [ 0 for i in range ( n ) ] <NEWLINE> v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> def Bread ( s ) : <NEWLINE> <INDENT> for e in range ( n ) : <NEWLINE> <INDENT> if v [ s ] [ e ] == 1 : <NEWLINE> <INDENT> if d [ e ] > d [ s ] + 1 : <NEWLINE> <INDENT> d [ e ] = d [ s ] + 1 <NEWLINE> Bread ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> v [ G [ 0 ] - 1 ] [ G [ j + 2 ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d [ 0 ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> Bread ( i ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == 100 : <NEWLINE> <INDENT> d [ i ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print i + 1 , d [ i ] <NEWLINE> <NL> <NL> <NL> <DEDENT> Compile Error Logs : <NEWLINE> <NL> You are not authorized to see the message . <NEWLINE> <NL> <NL> Status <NEWLINE> Judge : 8 / 8 Python CPU : 00.04 sec Memory : 6492 KB Length : 531 B 2016 - 0 2 - 0 2 22 : 0 2 2016 - 0 2 - 0 2 22 : 0 2 <NEWLINE> Results for testcases <NEWLINE> Case <COMMENT> <NEWLINE> <INDENT> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> Case <COMMENT> <NEWLINE> <DEDENT>
<NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> <NL> d = [ 99999 for i in range ( n ) ] <NEWLINE> G = [ 0 for i in range ( n ) ] <NEWLINE> M = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> def BFS ( s ) : <NEWLINE> <INDENT> for e in range ( n ) : <NEWLINE> <INDENT> if M [ s ] [ e ] == 1 : <NEWLINE> <INDENT> if d [ e ] > d [ s ] + 1 : <NEWLINE> <INDENT> d [ e ] = d [ s ] + 1 <NEWLINE> BFS ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> M [ G [ 0 ] - 1 ] [ G [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> d [ 0 ] = 0 <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> BFS ( s ) <NEWLINE> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> if d [ s ] == 99999 : <NEWLINE> <INDENT> d [ s ] = - 1 <NEWLINE> <DEDENT> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> print <STRING> . format ( s + 1 , d [ s ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> Compile Error Logs : <NEWLINE> <NL> You are not authorized to see the message . <NEWLINE> <NL>
from sys import stdin <NEWLINE> from collections import deque <NEWLINE> n = int ( input ( ) ) <NEWLINE> d = [ - 1 ] * ( n + 1 ) <NEWLINE> def bfs ( ) : <NEWLINE> <INDENT> d [ 1 ] = 0 <NEWLINE> dq = deque ( [ 1 ] ) <NEWLINE> while len ( dq ) != 0 : <NEWLINE> <INDENT> v = dq . popleft ( ) <NEWLINE> for c in G [ v ] : <NEWLINE> <INDENT> if d [ c ] != - 1 : continue <NEWLINE> d [ c ] = d [ v ] + 1 <NEWLINE> dq . append ( c ) <NEWLINE> <DEDENT> <DEDENT> for i , x in enumerate ( d [ 1 : ] , start = 1 ) : <NEWLINE> <INDENT> print ( i , x ) <NEWLINE> <DEDENT> <DEDENT> G = [ 0 ] + [ list ( map ( int , inpput ( ) . split ( ) [ 2 : ] ) ) for i in range ( n ) ] <NEWLINE> bfs ( ) <NEWLINE>
<NL> def BFS ( s = 0 , time = 0 ) : <NEWLINE> <INDENT> d [ s ] = time <NEWLINE> if len ( Q ) != 0 : <NEWLINE> <INDENT> Q . pop ( 0 ) <NEWLINE> color [ s ] = 2 <NEWLINE> <DEDENT> for j in range ( len ( d ) ) : <NEWLINE> <INDENT> if A [ i ] [ j ] == 1 and color [ j ] == 0 : <NEWLINE> <INDENT> Q . append ( A [ i ] [ j ] ) <NEWLINE> color [ j ] = 1 <NEWLINE> <DEDENT> <DEDENT> for j in range ( Q ) : <NEWLINE> <INDENT> time = time + 1 <NEWLINE> BFS ( Q [ j ] , time ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = [ 0 ] * n <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> value = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> u = value [ 0 ] - 1 <NEWLINE> k = value [ 1 ] <NEWLINE> nodes = value [ 2 : ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = nodes [ j ] - 1 <NEWLINE> A [ u ] [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> color = [ 0 ] * n <NEWLINE> Q = [ 0 ] <NEWLINE> d = [ - 1 ] * n <NEWLINE> <NL> BFS ( 0 , 0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( str ( i + 1 ) + <STRING> + str ( d [ i ] ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> d = [ 1000 for i in range ( n ) ] <NEWLINE> M = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> def BFS ( s ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> q . append ( s ) <NEWLINE> d [ s ] = 0 <NEWLINE> while q . length != 0 : <NEWLINE> <INDENT> u = q [ 0 ] <NEWLINE> q . pop ( 0 ) <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if M [ u ] [ v ] == 0 and d [ v ] != 1000 : <NEWLINE> <INDENT> d [ v ] = d [ u ] + 1 <NEWLINE> q . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print i + 1 , d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> M [ G [ 0 ] - 1 ] [ G [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> BFS ( 0 ) <NEWLINE>
class node : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . number = num <NEWLINE> self . distance = - 1 <NEWLINE> self . link_node = [ ] <NEWLINE> self . is_serched = False <NEWLINE> <NL> <DEDENT> <DEDENT> class queue : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . top = 0 <NEWLINE> self . bottom = 0 <NEWLINE> self . que = [ None ] * 1000 <NEWLINE> <NL> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> self . top = self . top + 1 <NEWLINE> return self . que [ self . top - 1 ] <NEWLINE> <NL> <DEDENT> def enqueue ( self , item ) : <NEWLINE> <INDENT> self . que [ self . bottom ] = item <NEWLINE> self . bottom = self . bottom + 1 <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> if self . top == self . bottom : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> node_list = [ None ] * ( n + 1 ) <NEWLINE> <NL> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> node_list [ i ] = node ( i ) <NEWLINE> <NL> <DEDENT> for i in xrange ( 1 , n + 1 ) : <NEWLINE> <INDENT> line = raw_input ( ) . split ( ) <NEWLINE> for node_num in line [ 2 : ] : <NEWLINE> <INDENT> node_list [ i ] . link_node . append ( node_list [ int ( node_num ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> node_que = queue ( ) <NEWLINE> <NL> node_list [ 1 ] . distance = 0 <NEWLINE> node_que . enqueue ( node_list [ 1 ] ) <NEWLINE> while node_que . is_empty ( ) == False : <NEWLINE> <INDENT> top_item = node_que . que [ node_que . top ] <NEWLINE> top_item . is_serched = True <NEWLINE> for item in top_item . link_node : <NEWLINE> <INDENT> if item . is_serched == False : <NEWLINE> <INDENT> node_que . enqueue ( item ) <NEWLINE> if item . distance == - 1 : <NEWLINE> <INDENT> item . distance = top_item . distance + 1 <NEWLINE> <DEDENT> elif item . distance > top_item . distance + 1 : <NEWLINE> <INDENT> item . distance = top_item . distance + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> node_que . dequeue ( ) <NEWLINE> <NL> <DEDENT> for item in node_list [ 1 : ] : <NEWLINE> <INDENT> print <STRING> % ( str ( item . number ) , str ( item . distance ) ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> dis = [ 99999 for i in range ( n ) ] <NEWLINE> G = [ 0 for i in range ( n ) ] <NEWLINE> v = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> def BFS ( s ) : <NEWLINE> <INDENT> for e in range ( n ) : <NEWLINE> <INDENT> if v [ s ] [ e ] == 1 : <NEWLINE> <INDENT> if dis [ e ] > dis [ s ] + 1 : <NEWLINE> <INDENT> d [ e ] = d [ s ] + 1 <NEWLINE> BFS ( e ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> v [ G [ 0 ] - 1 ] [ G [ 2 + j ] - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> dis [ 0 ] = 0 <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> BFS ( s ) <NEWLINE> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> if dis [ s ] == 99999 : <NEWLINE> <INDENT> dis [ s ] = - 1 <NEWLINE> <DEDENT> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> print <STRING> . format ( s + 1 , dis [ s ] ) <NEWLINE> <DEDENT>
def BFS ( s , r ) : <NEWLINE> <INDENT> d [ s ] = r <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if G [ s ] [ i ] == 1 and flag [ i ] == 0 : <NEWLINE> <INDENT> BFS ( i , r + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> G = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> d = [ - 1 for i in range ( n + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( v [ 1 ] ) : <NEWLINE> <INDENT> G [ v [ 0 ] ] [ v [ 2 + j ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> flag = [ 0 for i in range ( n + 1 ) ] <NEWLINE> BFS ( 1 , 0 ) <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( d [ i ] ) ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> d = [ 99999 for i in range ( n ) ] <NEWLINE> G = [ 0 for i in range ( n ) ] <NEWLINE> M = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> g = [ 0 for i in range ( n ) ] <NEWLINE> temp_d = [ 0 ] <NEWLINE> <NL> def BFS_visit ( s , temp_d ) : <NEWLINE> <INDENT> if temp_d == 99999 : <NEWLINE> <INDENT> temp_d = 0 <NEWLINE> <DEDENT> if d [ s ] > temp_d : <NEWLINE> <INDENT> d [ s ] = temp_d <NEWLINE> <DEDENT> temp_d += 1 <NEWLINE> for e in range ( 1 , n ) : <NEWLINE> <INDENT> if M [ s ] [ e ] == 1 and s != e : <NEWLINE> <INDENT> BFS_visit ( e , temp_d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def BFS ( ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> BFS_visit ( 0 , d [ s ] ) <NEWLINE> for s in range ( n ) : <NEWLINE> <INDENT> if d [ s ] == 99999 : <NEWLINE> <INDENT> d [ s ] = - 1 <NEWLINE> <DEDENT> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> print <STRING> . format ( s + 1 , d [ s ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( G [ 1 ] ) : <NEWLINE> <INDENT> M [ G [ 0 ] - 1 ] [ G [ 2 + j ] - 1 ] = 1 <NEWLINE> <DEDENT> g [ i ] = G [ 1 ] <NEWLINE> <DEDENT> BFS ( ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> from Queue import Queue <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = int ( stdin . readline ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for _ in xrange ( num ) : <NEWLINE> <INDENT> L . append ( [ int ( s ) for s in stdin . readline ( ) . split ( ) [ 2 : ] ] ) <NEWLINE> <NL> <DEDENT> d = [ - 1 ] * num <NEWLINE> d [ 0 ] = 0 <NEWLINE> q = Queue ( ) javascript : void ( 0 ) <NEWLINE> q . put ( 0 ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> u = q . get ( ) <NEWLINE> for v in L [ u ] : <NEWLINE> <INDENT> if d [ v - 1 ] < 0 : <NEWLINE> <INDENT> d [ v - 1 ] = d [ u ] + 1 <NEWLINE> q . put ( v - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , v in enumerate ( d ) : <NEWLINE> <INDENT> print ( i + 1 , v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import deque <NEWLINE> <NL> <NL> def bfs ( root ) : <NEWLINE> <INDENT> Q = deque ( ) <NEWLINE> distance [ root ] = 0 <NEWLINE> Q . append ( root ) <NEWLINE> i = root <NEWLINE> while len ( Q ) > 0 : <NEWLINE> <INDENT> for v in n : <NEWLINE> <INDENT> if adjMat [ i ] [ v ] == 1 and color [ v ] == <STRING> : <NEWLINE> <INDENT> Q . append ( v ) <NEWLINE> color [ v ] = <STRING> <NEWLINE> distance [ v ] = distance [ i ] + 1 <NEWLINE> <DEDENT> <DEDENT> color [ i ] = <STRING> <NEWLINE> i = Q . popleft ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> adjMat = [ [ 0 ] * n for _ in range ( n ) ] <NEWLINE> color = [ <STRING> ] * n <NEWLINE> distance = [ - 1 ] * n <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> adj = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = adj [ 0 ] <NEWLINE> v = adj [ 2 : ] <NEWLINE> for j in v : <NEWLINE> <INDENT> adjMat [ i - 1 ] [ j - 1 ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> bfs ( 0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> out = <STRING> <NEWLINE> out += <STRING> . format ( i + 1 , distance [ i ] ) <NEWLINE> print ( out ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> E = [ input ( ) . split ( ) [ 2 : ] for _ in [ 0 ] * N ] <NEWLINE> Q = [ 0 ] <NEWLINE> L = [ 0 ] + [ - 1 ] * N <NEWLINE> def func ( ide ) : <NEWLINE> <INDENT> for i in E [ ide ] : <NEWLINE> <INDENT> i = int ( i ) - 1 <NEWLINE> if L [ i ] < 0 : L [ i ] = L [ ide ] + 1 ; Q += [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while Q : top = Q . pop ( 0 ) ; func ( top ) <NEWLINE> <NL> for i in range ( N ) : print ( i + 1 , int ( L [ i ] ) ) <NEWLINE> <NL>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> from Quene import Quene <NEWLINE> <NL> def main ( ) <NEWLINE> <INDENT> num = int ( stdin . readline ( ) ) <NEWLINE> <NL> L = [ ] <NEWLINE> for _ in xrange ( num ) : <NEWLINE> <INDENT> L . append ( [ int ( s ) for s in stdin . readline ( ) . split ( ) [ 2 : ] ] ) <NEWLINE> <NL> <DEDENT> d = [ - 1 ] * num <NEWLINE> d [ 0 ] = 0 <NEWLINE> q = Quene ( 100 ) <NEWLINE> q . put ( 0 ) <NEWLINE> while not q . empty ( ) : <NEWLINE> <INDENT> u = q . get ( ) <NEWLINE> for v in L [ u ] : <NEWLINE> <INDENT> if d [ v - 1 ] < 0 : <NEWLINE> <INDENT> d [ v - 1 ] = d [ u ] + 1 <NEWLINE> q . put ( v - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , v in enumerate ( d ) : <NEWLINE> <INDENT> print ( i + 1 , v ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def get_depth ( graph , tmp_depth , vertex_list , depth_list ) : <NEWLINE> <INDENT> new_vertex_list = [ ] <NEWLINE> for vertex in vertex_list : <NEWLINE> <INDENT> for j in range ( len ( depth_list ) ) : <NEWLINE> <INDENT> if ( graph [ vertex ] [ j ] != 0 and depth_list [ j ] == - 1 ) : <NEWLINE> <INDENT> depth_list [ j ] = tmp_depth + 1 <NEWLINE> new_vertex_list . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> get_depth ( graph , tmp_depth + 1 , new_vertex_list , depth_list ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> graph = [ [ 0 ] * n for loop in range ( n ) ] <NEWLINE> for loop in range ( n ) : <NEWLINE> <INDENT> tmp_ope = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( tmp_ope [ 1 ] ) : <NEWLINE> <INDENT> graph [ tmp_ope [ 0 ] - 1 ] [ tmp_ope [ j + 2 ] - 1 ] = 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> depth_list = [ - 1 ] * n <NEWLINE> depth_list [ 0 ] = 0 <NEWLINE> vertex_list = [ 0 ] <NEWLINE> get_depth ( graph , 0 , vertex_list , depth_list ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> E = [ input ( ) . split ( ) [ 2 : ] for _ in range ( N ) ] <NEWLINE> Q = [ 0 ] <NEWLINE> L = [ 0 ] + [ - 1 ] * N <NEWLINE> frag = [ 1 ] + [ 0 ] * N <NEWLINE> def func ( ide ) : <NEWLINE> <INDENT> global Q <NEWLINE> for i in E [ ide ] : <NEWLINE> <INDENT> i = int ( i ) - 1 <NEWLINE> if frag [ i ] != 1 : frag [ i ] = 1 ; L [ i ] = L [ ide ] + 1 ; Q . append ( i ) <NEWLINE> return else <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> while Q : top = Q [ 0 ] ; func ( top ) ; del Q [ 0 ] <NEWLINE> <NL> for i in range ( N ) : print ( i + 1 , int ( L [ i ] ) ) <NEWLINE> <NL>
n , m = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> graph [ s ] . append ( t ) <NEWLINE> graph [ t ] . append ( s ) <NEWLINE> <DEDENT> color = { } <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not i in color : <NEWLINE> <INDENT> que = [ i ] <NEWLINE> color [ i ] = c <NEWLINE> do len ( que ) > 0 : <NEWLINE> <INDENT> u = que [ 0 ] <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> if not v in color : <NEWLINE> <INDENT> color [ v ] = c <NEWLINE> que . append ( v ) <NEWLINE> <DEDENT> <DEDENT> del que [ 0 ] <NEWLINE> <DEDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if color [ s ] == color [ t ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
, m = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> graph [ s ] . append ( t ) <NEWLINE> graph [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> color = { } <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not i in color : <NEWLINE> <INDENT> que = [ i ] <NEWLINE> color [ i ] = c <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> u = que [ 0 ] <NEWLINE> for v in graph [ u ] : <NEWLINE> <INDENT> if not v in color : <NEWLINE> <INDENT> color [ v ] = c <NEWLINE> que . append ( v ) <NEWLINE> <DEDENT> <DEDENT> del que [ 0 ] <NEWLINE> <DEDENT> c += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if color [ s ] == color [ t ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def dfs ( r , c ) : <NEWLINE> <INDENT> global color , G <NEWLINE> S = [ r ] <NEWLINE> color [ r ] = c <NEWLINE> while ( 0 < len ( S ) ) : <NEWLINE> <INDENT> u = S . pop ( ) <NEWLINE> for u in G [ u ] : <NEWLINE> <INDENT> v = color [ u ] <NEWLINE> if ( v == None ) : <NEWLINE> <INDENT> color [ u ] = c <NEWLINE> S . append ( u ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def assignColor ( ) : <NEWLINE> <INDENT> global color , G , n <NEWLINE> c = 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( color [ i ] == None ) : <NEWLINE> <INDENT> dfs ( i , c ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> G = [ None for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> G [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> color = [ False for i in range ( n ) ] <NEWLINE> <NL> assignColor ( ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> s , t = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( color [ s ] == color [ t ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> <NL> def assign_color ( ) : <NEWLINE> <INDENT> _color = 1 <NEWLINE> for v in range ( vertices ) : <NEWLINE> <INDENT> if color [ v ] == - 1 : <NEWLINE> <INDENT> graph_dfs ( v , _color ) <NEWLINE> _color += 1 <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def graph_dfs ( vertex , _color ) : <NEWLINE> <INDENT> vertices_stack = list ( ) <NEWLINE> vertices_stack . append ( vertex ) <NEWLINE> _color [ vertex ] = _color <NEWLINE> <NL> while vertices_stack : <NEWLINE> <INDENT> current_vertex = vertices_stack . pop ( ) <NEWLINE> for v in adj_table [ current_vertex ] : <NEWLINE> <INDENT> if _color [ v ] == - 1 : <NEWLINE> <INDENT> _color [ v ] = _color <NEWLINE> vertices_stack . append ( v ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> for relation in relation_info : <NEWLINE> <INDENT> key , value = map ( int , relation ) <NEWLINE> adj_table [ key ] . append ( value ) <NEWLINE> adj_table [ value ] . append ( key ) <NEWLINE> <NL> <DEDENT> assign_color ( ) <NEWLINE> <NL> <COMMENT> <NL> for question in questions : <NEWLINE> <INDENT> start , target = map ( int , question ) <NEWLINE> if color [ start ] == color [ target ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return color <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , relations = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> <NL> relation_info = map ( lambda x : x . split ( ) , _input [ 1 : relations + 1 ] ) <NEWLINE> <NL> q_num = int ( _input [ relations + 1 ] ) <NEWLINE> questions = map ( lambda x : x . split ( ) , _input [ relations + 2 : ] ) <NEWLINE> <NL> adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> color = [ - 1 ] * vertices <NEWLINE> ans = solve ( ) <NEWLINE> <DEDENT>
n , m = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> graph = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> graph [ s ] . append ( t ) <NEWLINE> graph [ t ] . append ( s ) <NEWLINE> <DEDENT> color = { } <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not i in color : <NEWLINE> <INDENT> que = [ i ] <NEWLINE> color [ i ] = c <NEWLINE> if len ( que ) > 0 : <NEWLINE> <INDENT> for j in range ( len ( que ) ) : <NEWLINE> <INDENT> if len ( que ) > 0 : <NEWLINE> <COMMENT> <NL> <INDENT> u [ j ] = que [ 0 ] <NEWLINE> for v in graph [ u [ j ] ] : <NEWLINE> <INDENT> if not v in color : <NEWLINE> <INDENT> color [ v ] = c <NEWLINE> que . append ( v ) <NEWLINE> <DEDENT> <DEDENT> del que [ 0 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if color [ s ] == color [ t ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def s ( ) : <NEWLINE> <INDENT> e = sys . stdin . readline <NEWLINE> n , m = map ( int , e ( ) . split ( ) ) <NEWLINE> P = [ [ ] for _ in [ 0 ] * n ] <NEWLINE> C = [ 0 ] * n <NEWLINE> k = 0 <NEWLINE> for _ in [ 0 ] * m : <NEWLINE> <INDENT> s , t = map ( int , e ( ) . split ( ) ) ; P [ s ] += [ t ] ; P [ t ] += [ s ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> k += 1 <NEWLINE> if C [ i ] < 1 : <NEWLINE> <INDENT> s = [ i ] ; C [ i ] = k <NEWLINE> while s : <NEWLINE> <INDENT> u = s . pop ( ) <NEWLINE> for v in P [ u ] : <NEWLINE> <INDENT> if C [ v ] < 1 : C [ v ] = k ; s += [ v ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for _ in [ 0 ] * int ( e ( ) ) : <NEWLINE> <INDENT> a , b = map ( int , e ( ) . split ( ) ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ C [ a ] == C [ b ] ] ) <NEWLINE> <DEDENT> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> def MAIN ( ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> li = [ i for i in range ( n ) ] <NEWLINE> def f ( a ) : <NEWLINE> <INDENT> if li [ a ] == a : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> li [ a ] = f ( li [ a ] ) <NEWLINE> return li [ a ] <NEWLINE> <DEDENT> def f2 ( a , b ) : <NEWLINE> <INDENT> if li [ a ] == a : <NEWLINE> <INDENT> li [ a ] = b <NEWLINE> return <NEWLINE> <DEDENT> f2 ( li [ a ] , b ) <NEWLINE> li [ a ] = b <NEWLINE> <DEDENT> for _ in range ( m ) : <NEWLINE> <INDENT> x , y = map ( int , readline ( ) . split ( ) ) <NEWLINE> if f ( x ) > f ( y ) : <NEWLINE> <INDENT> f2 ( x , li [ y ] ) <NEWLINE> <DEDENT> elif f ( x ) < f ( y ) : <NEWLINE> <INDENT> f2 ( y , li [ x ] ) <NEWLINE> <DEDENT> <DEDENT> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> x , y = map ( int , readline ( ) . split ( ) ) <NEWLINE> print ( <STRING> if f ( a ) == f ( b ) else <STRING> ) <NEWLINE> <DEDENT> <DEDENT> MAIN ( ) <NEWLINE> <NL>
from collections import deque <NEWLINE> <NL> <NL> user_num , rer_num = map ( int , input ( ) . split ( ) ) <NEWLINE> graph = [ [ ] for loop in range ( user_num ) ] <NEWLINE> <NL> for loop in range ( rer_num ) : <NEWLINE> <INDENT> user1 , user2 = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ user1 ] . append ( user2 ) <NEWLINE> graph [ user2 ] . append ( user1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> group = [ - 1 ] * user_num <NEWLINE> <NL> que = deque ( [ ] ) <NEWLINE> que . append ( 0 ) <NEWLINE> tmp_group = 0 <NEWLINE> for user in range ( user_num ) : <NEWLINE> <INDENT> if ( group [ user ] == - 1 ) : <NEWLINE> <INDENT> que . append ( user ) <NEWLINE> group [ user ] = tmp_group <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> user1 = que . popleft ( ) <NEWLINE> for user2 in graph [ user1 ] : <NEWLINE> <INDENT> if ( group [ user2 ] != - 1 ) : <NEWLINE> <INDENT> que . append ( user2 ) <NEWLINE> group [ user2 ] = tmp_group <NEWLINE> <DEDENT> <DEDENT> if ( len ( que ) == 0 ) : <NEWLINE> <INDENT> tmp_group += 1 <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for loop in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> user1 , user2 = map ( int ( input ( ) ) ) <NEWLINE> if ( group [ user1 ] == group [ user2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
class node : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . number = num <NEWLINE> self . group = 0 <NEWLINE> self . link_node = [ ] <NEWLINE> self . is_serched = False <NEWLINE> <NL> <DEDENT> <DEDENT> def DFS ( node , group_num ) : <NEWLINE> <INDENT> node . is_serched = True <NEWLINE> node . group = group_num <NEWLINE> for item in node . link_node : <NEWLINE> <INDENT> if item . is_serched == False : <NEWLINE> <INDENT> DFS ( item , group_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> node_list = [ None ] * ( n ) <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> node_list [ i ] = node ( i ) <NEWLINE> <NL> <DEDENT> for _ in xrange ( m ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> node_list [ s ] . link_node . append ( node_list [ t ] ) <NEWLINE> node_list [ t ] . link_node . append ( node_list [ s ] ) <NEWLINE> <NL> <DEDENT> group_num = 1 <NEWLINE> for item in node_list : <NEWLINE> <INDENT> if item . is_serched == False : <NEWLINE> <INDENT> DFS ( item , group_num ) <NEWLINE> group_num = group_num + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = input ( ) <NEWLINE> for _ in xrange ( q ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if node_list [ s ] . group == node_list [ t ] . group : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
x , y = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> follow = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( y ) : <NEWLINE> <INDENT> h , c = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> follow [ h ] . append ( c ) <NEWLINE> follow [ c ] . append ( h ) <NEWLINE> <NL> <DEDENT> color = { } <NEWLINE> u = 0 <NEWLINE> <NL> for i in range ( x ) : <NEWLINE> <INDENT> if not i in color : <NEWLINE> <INDENT> que = [ i ] <NEWLINE> color [ i ] = u <NEWLINE> while len ( que ) > 0 : <NEWLINE> <INDENT> u = que [ 0 ] <NEWLINE> for v in follow [ u ] : <NEWLINE> <INDENT> if not v in color : <NEWLINE> <INDENT> color [ v ] = u <NEWLINE> que . append ( v ) <NEWLINE> <DEDENT> <DEDENT> del que [ 0 ] <NEWLINE> <DEDENT> u += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> h , c = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if color [ h ] == color [ c ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def dfs ( i , c ) : <NEWLINE> <INDENT> global V , C <NEWLINE> <NL> if C [ i ] == - 1 : <NEWLINE> <INDENT> C [ i ] = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> for v in V [ i ] : <NEWLINE> <INDENT> dfs ( v , c ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> V = [ [ ] for _ in range ( n ) ] <NEWLINE> C = [ - 1 ] * n <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> l , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> V [ l ] . append ( r ) <NEWLINE> V [ r ] . append ( l ) <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if C [ i ] == - 1 : <NEWLINE> <INDENT> dfs ( i , c ) <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if C [ s ] == C [ t ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> rootList = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> def getRoot ( x ) : <NEWLINE> <INDENT> if rootList [ x ] < 0 : <NEWLINE> <INDENT> rootList [ x ] = x <NEWLINE> return x <NEWLINE> <DEDENT> return getRoot ( rootList [ x ] ) <NEWLINE> <NL> <NL> <DEDENT> def setSameRoot ( x , y ) : <NEWLINE> <INDENT> x = getRoot ( x ) <NEWLINE> y = getRoot ( y ) <NEWLINE> if x != y : <NEWLINE> <INDENT> rootList [ x ] , rootList [ y ] = min ( x , y ) , min ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> setSameRoot ( s , t ) <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> if getRoot ( s ) == getRoot ( t ) != - 1 else <STRING> ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ [ ] for i in xrange ( n ) ] <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A [ s ] . append ( t ) <NEWLINE> A [ t ] . append ( s ) <NEWLINE> <NL> <DEDENT> g = [ - 1 ] * n <NEWLINE> p = 1 <NEWLINE> res = set ( range ( n ) ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if i in res : <NEWLINE> <INDENT> color = bfs ( n , A , i , - 1 ) <NEWLINE> c = [ ] <NEWLINE> for j in xrange ( n ) : <NEWLINE> <INDENT> if color [ j ] == 1 : <NEWLINE> <INDENT> c . append ( i ) <NEWLINE> g [ j ] = p <NEWLINE> <DEDENT> <DEDENT> res = res - set ( c ) <NEWLINE> p += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = input ( ) <NEWLINE> a = [ 0 ] * q <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if g [ s ] == g [ t ] : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for i in a : <NEWLINE> <INDENT> print i <NEWLINE> <NL> <DEDENT> <DEDENT> def bfs ( n , A , s , t ) : <NEWLINE> <INDENT> color = [ - 1 ] * n <NEWLINE> Q = deque ( [ s ] ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if len ( Q ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> u = Q . popleft ( ) <NEWLINE> for i in A [ u ] : <NEWLINE> <INDENT> if i == t : <NEWLINE> <INDENT> color [ t ] = 1 <NEWLINE> break <NEWLINE> <DEDENT> elif color [ i ] == - 1 : <NEWLINE> <INDENT> color [ i ] = 0 <NEWLINE> Q . append ( i ) <NEWLINE> <DEDENT> <DEDENT> color [ u ] = 1 <NEWLINE> <DEDENT> return color <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> M . append ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if M [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> M [ i ] [ j ] = 1000000000 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> d = [ 1000000000 for i range ( n ) ] <NEWLINE> p = [ - 1 for i in range ( n ) ] <NEWLINE> color = [ 0 for i in range ( n ) ] <NEWLINE> <NL> d [ 0 ] = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> minv = 1000000000 <NEWLINE> u = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minv > d [ i ] and color [ i ] != 2 <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <DEDENT> <DEDENT> if u = - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> color [ u ] = 2 <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and M [ u ] [ v ] != 1000000000 : <NEWLINE> <INDENT> if d [ v ] > M [ u ] [ v ] : <NEWLINE> <INDENT> d [ v ] = M [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] != - 1 : <NEWLINE> <INDENT> sum += M [ i ] [ p [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT> print sum <NEWLINE>
INF = 9999 <NEWLINE> <NL> <NL> def prim ( M ) : <NEWLINE> <INDENT> n = len ( M ) <NEWLINE> color = [ 0 ] * n <NEWLINE> d = [ INF ] * n <NEWLINE> d [ 0 ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> minv = INF <NEWLINE> u = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <COMMENT> <NL> <INDENT> if minv > d [ i ] and color [ i ] != 2 : <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <DEDENT> <DEDENT> if u == - 1 : break <NEWLINE> color [ u ] = 2 <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and M [ u ] [ v ] != INF : <NEWLINE> <INDENT> if d [ v ] > M [ u ] [ v ] : <NEWLINE> <INDENT> d [ v ] = M [ u ] [ v ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return sum ( d ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> src = input ( ) <NEWLINE> dst = src . replace ( <STRING> , <STRING> ) <NEWLINE> ai = list ( map ( int , dst . split ( ) ) ) <NEWLINE> A . append ( ai ) <NEWLINE> <DEDENT> <DEDENT> print ( prim ( A ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> INF = 10000000 <NEWLINE> <NL> color = [ 0 for i in xrange ( n ) ] <NEWLINE> M = [ [ INF for i in xrange ( n ) ] for i in xrange ( n ) ] <NEWLINE> d = [ INF for i in xrange ( n ) ] <NEWLINE> p = [ - 1 for i in xrange ( n ) ] <NEWLINE> <NL> def m_s_t ( ) : <NEWLINE> <INDENT> d [ 0 ] = 0 <NEWLINE> <NL> <DEDENT> while True : <NEWLINE> <INDENT> cost = INF <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if color [ i ] != 2 and d [ i ] < cost : <NEWLINE> <INDENT> cost = d [ i ] <NEWLINE> u = i <NEWLINE> <NL> <DEDENT> <DEDENT> if cost == INF : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> color [ u ] = 2 <NEWLINE> <NL> for v in xrange ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and M [ u ] [ v ] != INF and M [ u ] [ v ] < d [ v ] : <NEWLINE> <INDENT> d [ v ] = M [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if p [ i ] != - 1 : <NEWLINE> <INDENT> sum += M [ i ] [ p [ i ] ] <NEWLINE> <DEDENT> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if G [ j ] != - 1 : <NEWLINE> <INDENT> M [ i ] [ j ] = G [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print m_s_t ( ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> INFTY = 10000000 <NEWLINE> <NL> color = [ 0 for i in xrange ( n ) ] <NEWLINE> M = [ [ INFTY for i in xrange ( n ) ] for i in xrange ( n ) ] <NEWLINE> d = [ INFTY for i in xrange ( n ) ] <NEWLINE> p = [ - 1 for i in xrange ( n ) ] <NEWLINE> <NL> def MST ( ) : <NEWLINE> <INDENT> d [ 0 ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> cost = INFTY <NEWLINE> u = - 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if color [ i ] != 1 and d [ i ] < cost : <NEWLINE> <INDENT> cost = d [ i ] <NEWLINE> u = i <NEWLINE> <NL> <DEDENT> <DEDENT> if u == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> color [ u ] = 2 <NEWLINE> <NL> for v in xrange ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and M [ u ] [ v ] != INFTY : <NEWLINE> <INDENT> if M [ u ] [ v ] < d [ v ] : <NEWLINE> <INDENT> d [ v ] = M [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if p [ i ] != - 1 : <NEWLINE> <INDENT> sum += M [ i ] [ p [ i ] ] <NEWLINE> <DEDENT> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if G [ j ] != - 1 : <NEWLINE> <INDENT> M [ i ] [ j ] = G [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print MST ( ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> inp = raw_input ( ) <NEWLINE> if <STRING> in inp : <NEWLINE> <INDENT> inp = inp . replace ( <STRING> , <STRING> ) <NEWLINE> <DEDENT> a . append ( list ( map ( int , inp . split ( ) ) ) ) <NEWLINE> <NL> <DEDENT> w = 0 <NEWLINE> v = set ( ) <NEWLINE> v . add ( 0 ) <NEWLINE> <NL> while len ( v ) < n : <NEWLINE> <INDENT> min_w = 10000 <NEWLINE> min_idx = 0 <NEWLINE> i = 0 <NEWLINE> for node in v : <NEWLINE> <INDENT> if min_w > min ( a [ node ] ) : <NEWLINE> <INDENT> min_w = min ( a [ node ] ) <NEWLINE> i = node <NEWLINE> min_idx = a [ i ] . index ( min_w ) <NEWLINE> <DEDENT> <DEDENT> if min_idx in v : <NEWLINE> <INDENT> a [ i ] [ min_idx ] = 10000 <NEWLINE> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> w += min_w <NEWLINE> v . add ( min_idx ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( w ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( sys . stin . readline ( ) . strip ( ) ) <NEWLINE> <NL> dist = { } <NEWLINE> <NL> for i in xrange ( 0 , n ) : <NEWLINE> <INDENT> array = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> for ( j , d ) in enumerate ( array ) : <NEWLINE> <INDENT> dist [ ( i , j ) ] = d <NEWLINE> <NL> <DEDENT> <DEDENT> searched = [ ] <NEWLINE> length = 0 <NEWLINE> <NL> target = 0 <NEWLINE> <NL> while len ( searched ) != n : <NEWLINE> <INDENT> searched . append ( target ) <NEWLINE> min_len = 2001 <NEWLINE> for v in searched : <NEWLINE> <INDENT> for i in xrange ( 0 , n ) : <NEWLINE> <INDENT> if ( i not in searched ) and ( min_len > dist [ ( v , i ) ] ) and ( dist [ ( v , i ) ] != - 1 ) : <NEWLINE> <INDENT> min_len = dist [ ( v , i ) ] <NEWLINE> target = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> length += min_len <NEWLINE> <NL> <DEDENT> print str ( length ) <NEWLINE>
import sys <NEWLINE> from operator import add <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> A = [ [ 0 ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> temp = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> A [ i ] = temp <NEWLINE> <NL> <NL> <DEDENT> weight = [ None for i in range ( n ) ] <NEWLINE> mitayatu = [ False for i in range ( n ) ] <NEWLINE> <NL> def min ( array ) : <NEWLINE> <INDENT> temp = 100000 <NEWLINE> index = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if array [ i ] is not None and mitayatu [ i ] == False : <NEWLINE> <INDENT> if temp > array [ i ] : <NEWLINE> <INDENT> temp == array [ i ] <NEWLINE> index = i <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return index <NEWLINE> <NL> <DEDENT> def owari ( ) : <NEWLINE> <INDENT> for i in mitayatu : <NEWLINE> <INDENT> if i is False : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <COMMENT> <NL> <DEDENT> def prim ( nodeid ) : <NEWLINE> <INDENT> if owari ( ) == True : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if mitayatu [ nodeid ] == True : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> mitayatu [ nodeid ] = True <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if A [ nodeid ] [ i ] != - 1 : <NEWLINE> <INDENT> if weight [ i ] is None : <NEWLINE> <INDENT> weight [ i ] = A [ nodeid ] [ i ] <NEWLINE> <DEDENT> elif weight [ i ] > A [ nodeid ] [ i ] : <NEWLINE> <INDENT> weight [ i ] = A [ nodeid ] [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> prim ( min ( weight ) ) <NEWLINE> <NL> <DEDENT> weight [ 0 ] = 0 <NEWLINE> prim ( 0 ) <NEWLINE> <NL> <NL> print reduce ( add , weight ) <NEWLINE>
MAX = 100 <NEWLINE> INF = 1000000 <NEWLINE> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> <NL> def prim ( ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> d [ i ] = INF <NEWLINE> p [ i ] = - 1 <NEWLINE> Color [ i ] = WHITE <NEWLINE> <DEDENT> d [ 0 ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> minv = INF <NEWLINE> u = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minv > d [ i ] and Color [ i ] != BLACK : <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <DEDENT> <DEDENT> if u == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Color [ u ] = BLACK <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if Color [ v ] != BLACK and M [ u ] [ v ] != INF : <NEWLINE> <INDENT> if d [ v ] > M [ u ] [ v ] : <NEWLINE> <INDENT> d [ v ] = M [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> Color [ v ] = GRAY <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] != - 1 : <NEWLINE> <INDENT> sum += M [ i ] [ p [ i ] ] <NEWLINE> <DEDENT> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> e = a [ j ] <NEWLINE> if e == - 1 : <NEWLINE> <INDENT> M [ i ] [ j ] = INF <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> M [ i ] [ j ] = e <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print prim ( ) <NEWLINE>
graph_n = int ( input ( ) ) <NEWLINE> <NL> <NL> edge_dict = { } <NEWLINE> <NL> <NL> <NL> for i in range ( graph_n ) : <NEWLINE> <INDENT> tmp_row = list ( map ( int , input ( ) ) ) <NEWLINE> for j in range ( graph_n ) : <NEWLINE> <INDENT> if ( tmp_row [ j ] != - 1 ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> edge_dict [ tmp_row ] . append ( [ i , j ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> edge_dict [ tmp_row ] = [ [ i , j ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sorted_edge = sorted ( edge_dict . items ( ) ) <NEWLINE> vertex_flag = [ 0 ] * graph_n <NEWLINE> <NL> searched_vertex_num = 0 <NEWLINE> cost = 0 <NEWLINE> <NL> for edges in sorted_edge : <NEWLINE> <INDENT> for edge in edges [ 1 ] : <NEWLINE> <INDENT> if ( vertex_flag [ edge [ 0 ] ] == 0 and vertex_flag [ edge [ 1 ] ] == 0 ) : <NEWLINE> <INDENT> vertex_flag [ edge [ 0 ] ] = 1 <NEWLINE> vertex_flag [ edge [ 1 ] ] = 1 <NEWLINE> seached_vertex_num += 2 <NEWLINE> cost += edges [ 0 ] <NEWLINE> if ( graph_n <= searched_vertex_num ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( vertex_flag [ edge [ 0 ] ] == 0 and vertex_flag [ edge [ 1 ] ] == 1 ) : <NEWLINE> <INDENT> vertex_flag [ edge [ 0 ] ] = 1 <NEWLINE> vertex_flag [ edge [ 1 ] ] = 1 <NEWLINE> seached_vertex_num += 1 <NEWLINE> cost += edges [ 0 ] <NEWLINE> if ( graph_n <= searched_vertex_num ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> elif ( vertex_flag [ edge [ 0 ] ] == 1 and vertex_flag [ edge [ 1 ] ] == 0 ) : <NEWLINE> <INDENT> vertex_flag [ edge [ 0 ] ] = 1 <NEWLINE> vertex_flag [ edge [ 1 ] ] = 1 <NEWLINE> seached_vertex_num += 1 <NEWLINE> cost += edges [ 0 ] <NEWLINE> if ( graph_n <= searched_vertex_num ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( graph_n <= searched_vertex_num ) : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cost ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> p = range ( 1 , n ) <NEWLINE> a = [ [ 0 for i in xrange ( n ) ] for j in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> a [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> l = 0 <NEWLINE> while p != [ ] : <NEWLINE> <INDENT> a_min = 2001 <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in p : <NEWLINE> <INDENT> if 0 <= a [ i ] [ j ] < a_min : <NEWLINE> <INDENT> a_min = a [ i ] [ j ] <NEWLINE> add_A = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A . append ( add_A ) <NEWLINE> NY . remove ( add_A ) <NEWLINE> l += a_min <NEWLINE> <DEDENT> print l <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> matrix = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> splited = line . split ( <STRING> ) <NEWLINE> splited = map ( lambda x : int ( x ) , splited ) <NEWLINE> matrix . append ( splited ) <NEWLINE> <NL> <DEDENT> result = 0 <NEWLINE> candidate = 0 <NEWLINE> selected = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> weight = 2001 <NEWLINE> for item in selected : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if matrix [ j ] [ item ] != - 1 and matrix [ j ] [ item ] < weight and j not in selected : <NEWLINE> <INDENT> candidate = j <NEWLINE> weight = matrix [ j ] [ item ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> selected . append ( candidate ) <NEWLINE> if ( len ( selected ) == n + 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> result += weight <NEWLINE> <DEDENT> print result <NEWLINE>
from __future__ import division , print_function <NEWLINE> from sys import stdin , maxint <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( stdin . readline ( ) ) <NEWLINE> <NL> M = [ ] <NEWLINE> for _ in xrange ( n ) : <NEWLINE> <INDENT> M . append ( [ int ( s ) for s in stdin . readline ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> g = set ( xrange ( 1 , num + 1 ) ) <NEWLINE> index = g . pop ( ) <NEWLINE> h = { index } <NEWLINE> weight = 0 <NEWLINE> <NL> while g : <NEWLINE> <INDENT> minimum = maxint <NEWLINE> for j in h : <NEWLINE> <INDENT> mj = M [ j - 1 ] <NEWLINE> for i in g : <NEWLINE> <INDENT> if 0 <= mj [ i - 1 ] < minimum : <NEWLINE> <INDENT> index = i <NEWLINE> minimum = mj [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> h . add ( index ) <NEWLINE> g . remove ( index ) <NEWLINE> weight += minimum <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> edgeList = [ ] <NEWLINE> <NL> <NL> def getRoot ( x ) : <NEWLINE> <INDENT> r = rootList [ x ] <NEWLINE> if r < 0 : <NEWLINE> <INDENT> rootList [ x ] = x <NEWLINE> <DEDENT> elif r != x : <NEWLINE> <INDENT> rootList [ x ] = getRoot ( r ) <NEWLINE> <DEDENT> return rootList [ x ] <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if a [ j ] != - 1 : <NEWLINE> <INDENT> edgeList . append ( [ a [ j ] , getRoot ( i ) , getRoot ( j ) ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> rootList = [ - 1 for i in range ( n ) ] <NEWLINE> sumLength = 0 <NEWLINE> edgeList . sort ( key = lambda x : x [ 0 ] ) <NEWLINE> for e in edgeList : <NEWLINE> <INDENT> x = getRoot ( e [ 1 ] ) <NEWLINE> y = getRoot ( e [ 2 ] ) <NEWLINE> if x != y : <NEWLINE> <INDENT> sumLength += e [ 0 ] <NEWLINE> rootList [ x ] = rootList [ y ] = min ( x , y ) <NEWLINE> <DEDENT> <DEDENT> print ( sumLength ) <NEWLINE>
import heapq <NEWLINE> from collections import defaultdict <NEWLINE> v_num = int ( input ( ) ) <NEWLINE> edges = defaultdict ( list ) <NEWLINE> for i in range ( v_num ) : <NEWLINE> <INDENT> data = [ int ( n ) for n in input ( ) . split ( <STRING> ) [ 1 : ] ] <NEWLINE> for j in range ( i + 1 , v_num ) : <NEWLINE> <INDENT> if data [ j ] != - 1 : <NEWLINE> <INDENT> edges [ i ] . append ( [ data [ j ] , j ] ) <NEWLINE> edges [ j ] . append ( [ data [ j ] , i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> queue = [ ] <NEWLINE> heapq . heapify ( queue ) <NEWLINE> for c in edges [ 0 ] : <NEWLINE> <INDENT> heapq . heappush ( queue , c ) <NEWLINE> <DEDENT> visited = { 0 } <NEWLINE> answer = 0 <NEWLINE> while len ( visited ) < v_num : <NEWLINE> <INDENT> q = heapq . pop ( queue ) <NEWLINE> weight , one = q [ 0 ] , q [ 1 ] <NEWLINE> if one in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> answer += weight <NEWLINE> for e in edges [ one ] : <NEWLINE> <INDENT> heapq . heappush ( queue , e ) <NEWLINE> <DEDENT> visited |= { one } <NEWLINE> <DEDENT> print ( answer ) <NEWLINE>
import heapq <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> h = [ ] <NEWLINE> DP = { } <NEWLINE> heapq . heappush ( h , ( 0 , 0 ) ) <NEWLINE> c = 0 <NEWLINE> while ( len ( DP ) < n ) : <NEWLINE> <INDENT> tmp = heapq . heappop ( h ) <NEWLINE> if tmp [ 1 ] in DP : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> c += tmp [ 0 ] <NEWLINE> DP [ tmp [ 1 ] ] = 1 <NEWLINE> for i , j in enumerate ( A [ tmp [ 1 ] ] ) : <NEWLINE> <INDENT> if j > 0 and not i in DP : <NEWLINE> <INDENT> heapq . heappush ( h , ( j , i ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
def prim ( cost ) : <NEWLINE> <INDENT> sumcost = 0 <NEWLINE> V = len ( cost ) <NEWLINE> mincost = [ float ( <STRING> ) ] * V <NEWLINE> used = [ False ] * V <NEWLINE> mincost [ 0 ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> j = - 1 <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> if not used [ i ] and ( j = - 1 or mincost [ i ] < mincost [ j ] ) : <NEWLINE> <INDENT> j = i <NEWLINE> <DEDENT> <DEDENT> if j == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> used [ j ] = True <NEWLINE> sumcost = sumcost + mincost [ j ] <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> if cost [ i ] [ j ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> mincost [ i ] = min ( mincost [ i ] , cost [ j ] [ i ] ) <NEWLINE> <DEDENT> <DEDENT> return sumcost <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = [ 0 ] * n <NEWLINE> for i in range ( n ) <NEWLINE> <INDENT> A [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> result = prim ( A ) <NEWLINE> print ( result ) <NEWLINE>
def prim ( cost ) : <NEWLINE> <INDENT> sumcost = 0 <NEWLINE> V = len ( cost ) <NEWLINE> mincost = [ float ( <STRING> ) ] * V <NEWLINE> used = [ False ] * V <NEWLINE> mincost [ 0 ] = 0 <NEWLINE> while True : <NEWLINE> <INDENT> v = - 1 <NEWLINE> for u in range ( V ) : <NEWLINE> <INDENT> if not used [ u ] and ( v == - 1 or mincost [ u ] < mincost [ ju ) : <NEWLINE> <INDENT> v = u <NEWLINE> <DEDENT> <DEDENT> if v == - 1 : break <NEWLINE> used [ v ] = True <NEWLINE> sumcost = sumcost + mincost [ v ] <NEWLINE> for u in range ( V ) : <NEWLINE> <INDENT> if cost [ u ] [ v ] == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> mincost [ u ] = min ( mincost [ u ] , cost [ v ] [ u ] ) <NEWLINE> <DEDENT> <DEDENT> return sumcost <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> INFTY = float ( <STRING> ) <NEWLINE> <NL> color = [ 0 for i in range ( n ) ] <NEWLINE> M = [ [ INFTY for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> d = [ INFTY for i in range ( n ) ] <NEWLINE> p = [ - 1 for i in range ( n ) ] <NEWLINE> <NL> def MST ( ) : <NEWLINE> <INDENT> d [ 0 ] = 0 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> cost = INFTY <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] != 2 and d [ i ] < cost : <NEWLINE> <INDENT> cost = d [ i ] <NEWLINE> u = i <NEWLINE> <NL> if cost == INFTY : <NEWLINE> break <NEWLINE> <NL> color [ u ] = 2 <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> if color [ v ] != 2 and M [ u ] [ v ] != INFTY and M [ u ] [ v ] < d [ v ] : <NEWLINE> d [ v ] = M [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if p [ i ] != - 1 : <NEWLINE> <INDENT> sum += M [ i ] [ p [ i ] ] <NEWLINE> <DEDENT> <DEDENT> return sum <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> G = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if G [ j ] != - 1 : <NEWLINE> <INDENT> M [ i ] [ j ] = G [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print MST ( ) <NEWLINE>
def prim ( n ) : <NEWLINE> <INDENT> d = [ None ] * 100 <NEWLINE> p = [ None ] * 100 <NEWLINE> color = [ None ] * 100 <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> d [ i ] = float ( <STRING> ) <NEWLINE> p [ i ] = - 1 <NEWLINE> color [ i ] = 0 <NEWLINE> <NL> <DEDENT> d [ 0 ] = 0 <NEWLINE> <NL> while ( true ) : <NEWLINE> <INDENT> minv = float ( <STRING> ) <NEWLINE> u = - 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if minv > d [ i ] and color [ i ] != 2 : <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if u == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> color [ u ] = 2 <NEWLINE> <NL> for v in xrange ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and data [ u ] [ v ] != float ( <STRING> ) : <NEWLINE> <INDENT> if ( d [ v ] > data [ u ] [ v ] ) : <NEWLINE> <INDENT> d [ v ] = data [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> sum_val = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if p [ i ] != - 1 : <NEWLINE> <INDENT> sum_val += data [ i ] [ p [ i ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> return sum_val <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> data = [ None ] * n <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> data [ i ] = [ None ] * n <NEWLINE> line = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in xrange ( n ) : <NEWLINE> <INDENT> if line [ j ] == - 1 : <NEWLINE> <INDENT> data [ i ] [ j ] = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data [ i ] [ j ] = line [ j ] ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print prim ( n ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> global status , d <NEWLINE> status = { } <NEWLINE> d = 0 <NEWLINE> <NL> def mst ( p1 , GRAPH ) : <NEWLINE> <INDENT> global status <NEWLINE> <NL> edge = { } <NEWLINE> total = 0 <NEWLINE> mini = 0 <NEWLINE> while True : <NEWLINE> <INDENT> status [ p1 ] = True <NEWLINE> for p2 in range ( len ( status ) ) : <NEWLINE> <INDENT> if status [ p2 ] == False and GRAPH . has_key ( ( p1 , p2 ) ) : <NEWLINE> <INDENT> edge [ ( p1 , p2 ) ] = GRAPH [ ( p1 , p2 ) ] <NEWLINE> if mini < GRAPH [ ( p1 , p2 ) ] : <NEWLINE> <INDENT> mini = GRAPH [ ( p1 , p2 ) ] + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for key , value in edge . items ( ) : <NEWLINE> <INDENT> if status [ key [ 1 ] ] == True : <NEWLINE> <INDENT> del edge [ key ] <NEWLINE> continue <NEWLINE> <DEDENT> if value < mini : <NEWLINE> <INDENT> key0 = key <NEWLINE> mini = value <NEWLINE> <DEDENT> <DEDENT> if mini != 2000 : <NEWLINE> <INDENT> total += mini <NEWLINE> p1 = key0 [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> x = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> seq = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> tmp = seq [ j ] <NEWLINE> if tmp != - 1 : <NEWLINE> <INDENT> x [ ( i , j ) ] = tmp <NEWLINE> <DEDENT> <DEDENT> status [ i ] = False <NEWLINE> <NL> <DEDENT> print mst ( 0 , x ) <NEWLINE>
1 <NEWLINE> 2 <NEWLINE> 3 <NEWLINE> 4 <NEWLINE> 5 <NEWLINE> 6 <NEWLINE> 7 <NEWLINE> 8 <NEWLINE> 9 <NEWLINE> 10 <NEWLINE> 11 <NEWLINE> 12 <NEWLINE> 13 <NEWLINE> 14 <NEWLINE> 15 <NEWLINE> 16 <NEWLINE> 17 <NEWLINE> 18 <NEWLINE> 19 <NEWLINE> 20 <NEWLINE> 21 <NEWLINE> 22 <NEWLINE> 23 <NEWLINE> 24 <NEWLINE> 25 <NEWLINE> 26 <NEWLINE> 27 <NEWLINE> 28 <NEWLINE> 29 <NEWLINE> 30 <NEWLINE> 31 <NEWLINE> 32 <NEWLINE> 33 <NEWLINE> <NL> <COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , maxint <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = int ( stdin . readline ( ) ) <NEWLINE> <NL> M = [ ] <NEWLINE> for _ in xrange ( num ) : <NEWLINE> <INDENT> M . append ( [ int ( s ) for s in stdin . readline ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> g = set ( xrange ( 1 , num + 1 ) ) <NEWLINE> index = g . pop ( ) <NEWLINE> h = { index } <NEWLINE> weight = 0 <NEWLINE> <NL> while g : <NEWLINE> <INDENT> minimum = maxint <NEWLINE> for j in h : <NEWLINE> <INDENT> mj = M [ j - 1 ] <NEWLINE> for i in g : <NEWLINE> <INDENT> if 0 <= mj [ i - 1 ] < minimum : <NEWLINE> <INDENT> index = i <NEWLINE> minimum = mj [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> h . add ( index ) <NEWLINE> g . remove ( index ) <NEWLINE> weight += minimum <NEWLINE> <NL> <DEDENT> print ( weight ) <NEWLINE> <NL> <DEDENT>
INFTY = 1 << 21 <NEWLINE> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> d = [ INFTY for i in range ( n ) ] <NEWLINE> p = [ - 1 for i in range ( n ) ] <NEWLINE> color = [ WHITE for i in range ( n ) ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> M = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( M [ i ] [ j ] == - 1 ) : <NEWLINE> <INDENT> M [ i ] [ j ] = INFTY <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def prim ( ) : <NEWLINE> <INDENT> global M , d , p , color <NEWLINE> d [ 0 ] = 0 <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> minv = INFTY <NEWLINE> u = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( minv > d [ i ] and color [ i ] != BLACK ) : <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <DEDENT> <DEDENT> if ( u == - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> color [ u ] = BLACK <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if ( color [ v ] != BLACK and M [ u ] [ v ] != INFTY ) : <NEWLINE> <INDENT> if ( d [ v ] > M [ u ] [ v ] ) : <NEWLINE> <INDENT> d [ v ] = M [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = GRAY <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return sum ( [ M [ i ] [ p [ i ] ] for i in range ( n ) if p [ i ] != - 1 ] ) <NEWLINE> <NL> <DEDENT> print ( prim ( ) ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> A = [ ] <NEWLINE> p = range ( 1 , n ) <NEWLINE> a = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> l = 0 <NEWLINE> <NL> while p != [ ] : <NEWLINE> <INDENT> a_min = 10000 <NEWLINE> for i in A : <NEWLINE> <INDENT> for j in p : <NEWLINE> <INDENT> if 0 <= a [ i ] [ j ] < a_min : <NEWLINE> <INDENT> a_min = a [ i ] [ j ] <NEWLINE> add_A = j <NEWLINE> <DEDENT> <DEDENT> <DEDENT> A . append ( add_A ) <NEWLINE> p . remove ( add_A ) <NEWLINE> l += a_min <NEWLINE> <NL> <DEDENT> print l <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , maxint <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = int ( stdin . readline ( ) ) <NEWLINE> <NL> M = [ ] <NEWLINE> for _ in xrange ( num ) : <NEWLINE> <INDENT> M . append ( [ int ( s ) for s in stdin . readline ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> g = set ( xrange ( 1 , num + 1 ) ) <NEWLINE> index = g . pop ( ) <NEWLINE> h = { index } <NEWLINE> weight = 0 <NEWLINE> <NL> while g : _ <NEWLINE> <INDENT> minimum = maxint <NEWLINE> for j in h : <NEWLINE> <INDENT> mj = M [ j - 1 ] <NEWLINE> for i in g : <NEWLINE> <INDENT> if 0 <= mj [ i - 1 ] < minimum : <NEWLINE> <INDENT> index = i <NEWLINE> minimum = mj [ i - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> h . add ( index ) <NEWLINE> g . remove ( index ) <NEWLINE> weight += minimum <NEWLINE> <NL> <DEDENT> print ( weight ) <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> G = [ [ - 1 ] * n ] * n <NEWLINE> d = [ 0 ] * n <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( v [ 1 ] ) : <NEWLINE> <INDENT> G [ v [ 0 ] ] [ v [ 2 + 2 * j ] ] = int ( v [ 3 + 2 * j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = [ 0 ] * n <NEWLINE> tn = [ 0 ] <NEWLINE> r = 0 <NEWLINE> while True : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if flag [ i ] == 0 and i in tn : <NEWLINE> <INDENT> flag [ i ] = 1 <NEWLINE> d [ i ] = r <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if G [ i ] [ j ] != - 1 and flag [ j ] == 0 : <NEWLINE> <INDENT> tn . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if len ( tn ) == n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> r += 1 <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( str ( i ) + <STRING> + str ( d [ i ] ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def dijkstra ( W , n ) : <NEWLINE> <INDENT> U = [ i for i in range ( 1 , n ) ] <NEWLINE> D = [ W [ 0 ] [ i ] for i in range ( n ) ] <NEWLINE> D [ 0 ] = 0 <NEWLINE> <NL> while len ( U ) != 0 : <NEWLINE> <INDENT> mind , minu = 100001 , - 1 <NEWLINE> for u in U : <NEWLINE> <INDENT> if D [ u ] < mind : <NEWLINE> <INDENT> mind , minu = D [ u ] , u <NEWLINE> <DEDENT> <DEDENT> U . remove ( minu ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> D [ i ] = min ( D [ i ] , D [ minu ] + W [ minu ] [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return D <NEWLINE> <NL> <DEDENT> lines = sys . stdin . readlines ( ) <NEWLINE> n = int ( lines . pop ( 0 ) ) <NEWLINE> <NL> W = [ [ 100001 ] * n for _ in range ( n ) ] <NEWLINE> for line in lines : <NEWLINE> <INDENT> l = map ( int , line . split ( ) ) <NEWLINE> for i in range ( l [ 1 ] ) : <NEWLINE> <INDENT> W [ l [ 0 ] ] [ l [ 2 * i + 2 ] ] = l [ 2 * i + 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> D = dijkstra ( W , n ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print i , D [ i ] <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> <NL> INFTY = 1 << 21 <NEWLINE> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> BLACK = 2 <NEWLINE> <NL> n = int ( stdin . readline ( ) ) <NEWLINE> M = [ [ INFTY for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for u in range ( 0 , n ) : <NEWLINE> <INDENT> U = list ( map ( int , stdin . readline ( ) . split ( ) [ 2 : ] ) ) <NEWLINE> for j in range ( 0 , len ( U ) , 2 ) : <NEWLINE> <INDENT> M [ u ] [ U [ j ] ] = U [ j + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> d = [ INFTY for i in range ( n ) ] <NEWLINE> color = [ WHITE for i in range ( n ) ] <NEWLINE> <NL> def dijkstra ( ) : <NEWLINE> <INDENT> global n <NEWLINE> d [ 0 ] = 0 <NEWLINE> color [ 0 ] = GRAY <NEWLINE> while ( 1 ) : <NEWLINE> <INDENT> minv = INFTY <NEWLINE> u = - 1 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if ( minv > d [ i ] and color [ i ] != BLACK ) : <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <DEDENT> <DEDENT> if ( u == - 1 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> color [ u ] = BLACK <NEWLINE> for v in range ( 0 , n ) : <NEWLINE> <INDENT> if ( color [ v ] != BLACK and M [ u ] [ v ] != INFTY ) : <NEWLINE> <INDENT> if ( d [ v ] > d [ u ] + M [ u ] [ v ] : ) <NEWLINE> <INDENT> d [ v ] = d [ u ] + M [ u ] [ v ] <NEWLINE> color [ v ] = GRAY <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> print ( i , ( - 1 if d [ i ] == INFTY else d [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> dijkstra ( ) <NEWLINE>
def diikstraMethd ( G , s ) : <NEWLINE> <COMMENT> <NL> <INDENT> n = len ( G ) <NEWLINE> <COMMENT> <NL> color = [ 0 for _ in range ( n ) ] <NEWLINE> d = [ INF for _ in range ( n ) ] <NEWLINE> p = [ None for _ in range ( n ) ] <NEWLINE> <NL> d [ s ] = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> mincost = INF <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] != 2 and d [ i ] < mincost : <NEWLINE> <INDENT> mincost = d [ i ] <NEWLINE> u = i <NEWLINE> <NL> <DEDENT> <DEDENT> if mincost == INF : break <NEWLINE> <NL> color [ u ] = 2 <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and M [ u ] [ v ] != INF : <NEWLINE> <INDENT> if d [ u ] + M [ u ] [ v ] < d [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + M [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ u ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> M = [ [ INF for _ in range ( n ) ] for i in range ( n ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> u = tmp . pop ( 0 ) <NEWLINE> k = tmp . pop ( 0 ) <NEWLINE> for _ in range ( k ) : <NEWLINE> <INDENT> v = tmp . pop ( 0 ) <NEWLINE> c = tmp . pop ( 0 ) <NEWLINE> M [ u ] [ v ] = c <NEWLINE> <DEDENT> <DEDENT> d = diikstraMethd ( M , 0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , d [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> matrix = [ [ 100001 for i in range ( n ) ] for j in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> splited = line . split ( ) <NEWLINE> splited = map ( lambda x : int ( x ) , splited ) <NEWLINE> u = splited [ 0 ] <NEWLINE> k = splited [ 1 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> matrix [ u ] [ splited [ 2 + j * 2 ] ] = splited [ 2 + j * 2 + 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> cost = [ 10000000000 for i in range ( n ) ] <NEWLINE> selected = [ ] <NEWLINE> now_node = 0 <NEWLINE> cost [ now_node ] = 0 <NEWLINE> while len ( selected ) != n + 1 : <NEWLINE> <INDENT> selected . append ( now_node ) <NEWLINE> <NL> for ( i , item ) in enumerate ( matrix [ now_node ] ) : <NEWLINE> <INDENT> if item < 100001 and cost [ i ] > item + cost [ now_node ] and cost [ i ] != - 1 : <NEWLINE> <INDENT> cost [ i ] = item + cost [ now_node ] <NEWLINE> <DEDENT> <DEDENT> now_node = - 1 <NEWLINE> for ( i , item ) in enumerate ( cost ) : <NEWLINE> <INDENT> if i not in selected and now_node == - 1 : <NEWLINE> <INDENT> now_node = i <NEWLINE> <DEDENT> elif i not in selected and item < cost [ now_node ] : <NEWLINE> <INDENT> now_node = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for ( i , item ) in enumerate ( cost ) : <NEWLINE> <INDENT> print i , <STRING> , item <NEWLINE> <DEDENT>
INF = float ( <STRING> ) <NEWLINE> <NL> <NL> def dijkstra ( source ) : <NEWLINE> <INDENT> distance [ source ] = 0 <NEWLINE> parent [ source ] = - 1 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> mincost = INF <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if color [ i ] != <STRING> and distance [ i ] < mincost : <NEWLINE> <INDENT> mincost = distance [ i ] <NEWLINE> u = i <NEWLINE> <NL> <DEDENT> <DEDENT> if mincost == INF : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> color [ u ] = <STRING> <NEWLINE> <NL> for v in range ( n ) : <NEWLINE> <INDENT> if color [ v ] != <STRING> and adjMat [ u ] [ v ] != INF : <NEWLINE> <INDENT> if distance [ u ] + adjMat [ u ] [ v ] < distance [ v ] : <NEWLINE> <INDENT> distance [ v ] = distance [ u ] + adjMat [ u ] [ v ] <NEWLINE> parent [ v ] = u <NEWLINE> color [ v ] = <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> color = [ <STRING> ] * n <NEWLINE> parent = [ - 1 ] * n <NEWLINE> distance = [ INF ] * n <NEWLINE> <NL> adjMat = [ [ INF ] * n for _ in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inputList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> adjRow = inputList [ 0 : : 2 ] [ 1 : ] <NEWLINE> weightRow = inputList [ 1 : : 2 ] [ 1 : ] <NEWLINE> for v , weight in zip ( adjRow , weightRow ) : <NEWLINE> <INDENT> adjMat [ i ] [ v ] = weight <NEWLINE> <NL> <DEDENT> <DEDENT> dijkstra ( 0 ) <NEWLINE> <NL> for index , distance in enumerate ( distance ) : <NEWLINE> <INDENT> print ( <STRING> ) . format ( index , distance ) <NEWLINE> <DEDENT>
INFTY = 100000000 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> graph = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> In = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> u = In [ 0 ] <NEWLINE> k = In [ 1 ] <NEWLINE> graph [ u ] = { } <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = In [ 2 + j * 2 ] <NEWLINE> c = In [ 2 + j * 2 + 1 ] <NEWLINE> graph [ u ] [ v ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> da = { } <NEWLINE> visited = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> da [ i ] = INFTY <NEWLINE> visited [ i ] = False <NEWLINE> <DEDENT> s = 0 <NEWLINE> da [ s ] = 0 <NEWLINE> visited [ s ] = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] and i in graph [ s ] and da [ i ] > da [ s ] + graph [ s ] [ i ] : <NEWLINE> <INDENT> da [ i ] = da [ s ] + graph [ s ] [ i ] <NEWLINE> <DEDENT> <DEDENT> cost = INFTY <NEWLINE> node = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] and da [ i ] < cost : <NEWLINE> <INDENT> cost = da [ i ] <NEWLINE> node = i <NEWLINE> <DEDENT> <DEDENT> if cost == INFTY : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> visited [ node ] = True <NEWLINE> s = node <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print i , da [ i ] <NEWLINE> <DEDENT>
INFTY = 100000000 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> graph = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> In = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> u = In [ 0 ] <NEWLINE> k = In [ 1 ] <NEWLINE> graph [ u ] = { } <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = In [ 2 + j * 2 ] <NEWLINE> c = In [ 2 + j * 2 + 1 ] <NEWLINE> graph [ u ] [ v ] = c <NEWLINE> <NL> <DEDENT> <DEDENT> da = { } <NEWLINE> visited = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> da [ i ] = INFTY <NEWLINE> visited [ i ] = False <NEWLINE> <DEDENT> s = 0 <NEWLINE> da [ s ] = 0 <NEWLINE> visited [ s ] = True <NEWLINE> <NL> while True : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] and i in graph [ s ] and da [ i ] > da [ s ] + graph [ s ] [ i ] : <NEWLINE> <INDENT> da [ i ] = da [ s ] + graph [ s ] [ i ] <NEWLINE> <DEDENT> <DEDENT> cost = INFTY <NEWLINE> node = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if not visited [ i ] and da [ i ] < cost : <NEWLINE> <INDENT> cost = da [ i ] <NEWLINE> node = i <NEWLINE> <DEDENT> <DEDENT> if cost == INFTY : break <NEWLINE> visited [ node ] = True <NEWLINE> s = node <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print i , da [ i ] <NEWLINE> <DEDENT>
rootList = [ - 1 for i in range ( n ) ] <NEWLINE> parent = [ 0 for i in range ( n ) ] <NEWLINE> lenList = [ float ( <STRING> ) for i in range ( n ) ] <NEWLINE> lenList [ 0 ] = 0 <NEWLINE> def getRoot ( x ) : <NEWLINE> <INDENT> r = rootList [ x ] <NEWLINE> if r < 0 : <NEWLINE> <INDENT> rootList [ x ] = x <NEWLINE> <DEDENT> elif r != x : <NEWLINE> <INDENT> rootList [ x ] = getRoot ( r ) <NEWLINE> <DEDENT> return rootList [ x ] <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> edgeList . sort ( key = lambda x : ( x [ 0 ] + lenList [ x [ 1 ] ] ) ) <NEWLINE> for e in edgeList : <COMMENT> <NEWLINE> <INDENT> if e [ 2 ] == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> x = getRoot ( e [ 1 ] ) <NEWLINE> y = getRoot ( e [ 2 ] ) <NEWLINE> if x == 0 != y : <NEWLINE> <INDENT> parent [ e [ 2 ] ] = e [ 1 ] <NEWLINE> lenList [ e [ 2 ] ] = lenList [ e [ 1 ] ] + e [ 0 ] <NEWLINE> rootList [ y ] = 0 <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i , j in zip ( range ( n ) , lenList ) : <NEWLINE> <INDENT> print ( i , j ) <NEWLINE> <DEDENT>
def dijkstra ( n ) : <NEWLINE> <INDENT> d = [ None ] * 100 <NEWLINE> p = [ None ] * 100 <NEWLINE> color = [ None ] * 100 <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> d [ i ] = float ( <STRING> ) <NEWLINE> p [ i ] = - 1 <NEWLINE> color [ i ] = 0 <NEWLINE> <NL> <DEDENT> d [ 0 ] = 0 <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> minv = float ( <STRING> ) <NEWLINE> u = - 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if minv > d [ i ] and color [ i ] != 2 : <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> if u == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> color [ u ] = 2 <NEWLINE> <NL> for v in xrange ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and data [ u ] [ v ] != float ( <STRING> ) : <NEWLINE> <INDENT> if d [ v ] > d [ u ] + data [ u ] [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + data [ u ] [ v ] <NEWLINE> p [ v ] = u <NEWLINE> color [ v ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> if d [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> print <STRING> % ( i , - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( i , d [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> data = [ None ] * n <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> data [ i ] = [ None ] * n <NEWLINE> line = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in xrange ( n ) : <NEWLINE> <INDENT> if line [ j ] == - 1 : <NEWLINE> <INDENT> data [ i ] [ j ] = float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> data [ i ] [ j ] = line [ j ] ; <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dijkstra ( n ) <NEWLINE>
n = input ( ) <NEWLINE> inf = 1000000000 <NEWLINE> M = [ [ inf for i in range ( n ) ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> str = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> u = str [ 0 ] <NEWLINE> k = str [ 1 ] <NEWLINE> for j in range ( k ) : <NEWLINE> <INDENT> v = str [ 2 + j ] <NEWLINE> c = str [ 3 + j ] <NEWLINE> M [ u ] [ v ] = c <NEWLINE> <DEDENT> <DEDENT> d = [ inf for i in range ( n ) ] <NEWLINE> color = [ 0 for i in range ( n ) ] <NEWLINE> <NL> d [ 0 ] = 0 <NEWLINE> color [ 0 ] = 1 <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> minv = inf <NEWLINE> u = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if minv > d [ i ] and color [ i ] != 2 : <NEWLINE> <INDENT> u = i <NEWLINE> minv = d [ i ] <NEWLINE> <DEDENT> print minv <NEWLINE> <DEDENT> if u == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> color [ u ] = 2 <NEWLINE> for v in range ( n ) : <NEWLINE> <INDENT> if color [ v ] != 2 and M [ u ] [ v ] != inf : <NEWLINE> <INDENT> if d [ v ] > d [ u ] + M [ u ] [ v ] : <NEWLINE> <INDENT> d [ v ] = d [ u ] + M [ u ] [ v ] <NEWLINE> color [ v ] = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if d [ i ] == inf : <NEWLINE> <INDENT> print <STRING> % i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % ( i , d [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
import heapq <NEWLINE> inf = float ( <STRING> ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> M = [ [ inf ] * n for i in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> Ai = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in xrange ( Ai [ 1 ] ) : <NEWLINE> <INDENT> M [ i ] [ Ai [ 2 + 2 * j ] ] = Ai [ 3 + 2 * j ] <NEWLINE> <NL> <DEDENT> <DEDENT> d = dijkstra ( 0 , M , n ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> print i , d [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def dijkstra ( s , M , n ) : <NEWLINE> <INDENT> c = [ - 1 ] * n <NEWLINE> d = [ inf ] * n <NEWLINE> d [ s ] = 0 <NEWLINE> H = zip ( d , range ( n ) ) <NEWLINE> heapq . heapify ( H ) <NEWLINE> <NL> while ( len ( H ) >= 1 ) : <NEWLINE> <INDENT> di , u = heapq . heappop ( H ) <NEWLINE> c [ u ] = 1 <NEWLINE> for v in xrange ( n ) : <NEWLINE> <INDENT> if ( c [ v ] != 1 ) & ( M [ u ] [ v ] != inf ) : <NEWLINE> <INDENT> if ( d [ u ] + M [ u ] [ v ] < d [ v ] ) : <NEWLINE> <INDENT> d [ v ] = d [ u ] + M [ u ] [ v ] <NEWLINE> c [ v ] = 0 <NEWLINE> heapq . heappush ( H , ( d [ v ] , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from collections import defaultdict <NEWLINE> from heapq import heappop , heappush <NEWLINE> <NL> <NL> def dijkstra ( edges , start , * , adj_matrix = False , default_value = float ( <STRING> ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> n = len ( edges ) <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> costs = defaultdict ( lambda : inf ) <NEWLINE> costs [ start ] = 0 <NEWLINE> pq , rem = [ ( 0 , start ) ] , n - 1 <NEWLINE> <NL> while pq and rem : <NEWLINE> <INDENT> tmp_cost , tmp_node = heappop ( pq ) <NEWLINE> if costs [ tmp_node ] < tmp_cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> rem -= 1 <NEWLINE> <NL> nxt_edges = ( ( node , cost ) for node , cost in enumerate ( edges [ tmp_node ] ) if cost != default_value ) if adj_matrix else edges [ tmp_node ] <NEWLINE> <NL> for nxt_node , nxt_cost in nxt_edges : <NEWLINE> <INDENT> new_cost = tmp_cost + nxt_cost <NEWLINE> if costs [ nxt_node ] > new_cost : <NEWLINE> <INDENT> costs [ nxt_node ] = new_cost <NEWLINE> heappush ( pq , ( new_cost , nxt_node ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return costs <NEWLINE> <NL> <NL> <DEDENT> def dijkstra_route ( edges , <NEWLINE> <INDENT> start , <NEWLINE> goal , <NEWLINE> * , <NEWLINE> adj_matrix = False , <NEWLINE> default_value = float ( <STRING> ) , <NEWLINE> verbose = False ) : <NEWLINE> <STRING> <NEWLINE> <NL> n = len ( edges ) <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> costs = defaultdict ( lambda : inf ) <NEWLINE> costs [ start ] = 0 <NEWLINE> pq , rem = [ ( 0 , start ) ] , n - 1 <NEWLINE> <COMMENT> <NL> prevs = defaultdict ( lambda : - 1 ) <NEWLINE> <NL> while pq and rem : <NEWLINE> tmp_cost , tmp_node = heappop ( pq ) <NEWLINE> if costs [ tmp_node ] < tmp_cost : <NEWLINE> continue <NEWLINE> rem -= 1 <NEWLINE> <NL> nxt_edges = ( ( node , cost ) for node , cost in enumerate ( edges [ tmp_node ] ) if cost != default_value ) if adj_matrix else edges [ tmp_node ] <NEWLINE> <NL> for nxt_node , nxt_cost in nxt_edges : <NEWLINE> new_cost = tmp_cost + nxt_cost <NEWLINE> if costs [ nxt_node ] > new_cost : <NEWLINE> costs [ nxt_node ] = new_cost <NEWLINE> heappush ( pq , ( new_cost , nxt_node ) ) <NEWLINE> prevs [ nxt_node ] = tmp_node <NEWLINE> <NL> min_route = [ ] <NEWLINE> prev = goal <NEWLINE> cnt = 0 <NEWLINE> while prev != start : <NEWLINE> min_route . append ( prev ) <NEWLINE> prev = prevs [ prev ] <NEWLINE> <NL> cnt += 1 <NEWLINE> if prev == - 1 or cnt > n : <NEWLINE> raise NoRouteError ( <NEWLINE> <STRING> . <NEWLINE> format ( edges , start , goal ) ) <NEWLINE> <NL> else : <NEWLINE> min_route . append ( prev ) <NEWLINE> min_route = min_route [ : : - 1 ] <NEWLINE> min_cost = costs [ goal ] <NEWLINE> <NL> if verbose : <NEWLINE> print ( <STRING> ) <NEWLINE> for node in min_route [ : - 1 ] : <NEWLINE> print ( <STRING> . format ( node ) , end = <STRING> ) <NEWLINE> else : <NEWLINE> print ( min_route [ - 1 ] ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( min_cost ) <NEWLINE> <NL> return costs , min_route <NEWLINE> <NL> <NL> <DEDENT> class NoRouteError ( Exception ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> edges = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i , k , * kedges = map ( int , input ( ) . split ( ) ) <NEWLINE> for edge in zip ( kedges [ : : 2 ] , kedges [ 1 : : 2 ] ) : <NEWLINE> <INDENT> edges [ i ] . append ( edge ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for i , cost in dijkstra ( edges , 0 ) : <NEWLINE> <INDENT> print ( i , cost ) <NEWLINE> <NL> <DEDENT> <DEDENT>
V = int ( input ( ) ) <NEWLINE> <NL> G = [ [ ] for i in range ( V ) ] <NEWLINE> d = [ 1001001001 for i in range ( V ) ] <NEWLINE> used = [ False for i in range ( V ) ] <NEWLINE> <NL> import heapq <NEWLINE> <NL> def dijkstra ( s ) : <NEWLINE> <INDENT> q = [ ] <NEWLINE> d [ s ] = 0 <NEWLINE> heapq . heappush ( q , ( 0 , s ) ) <NEWLINE> <NL> while ( len ( q ) ) : <NEWLINE> <NL> <INDENT> p = heapq . heappop ( q ) <NEWLINE> v = p [ 1 ] <NEWLINE> used [ v ] = true <NEWLINE> if d [ v ] < p [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for e in G [ v ] : <NEWLINE> <INDENT> if ( not used [ e [ 0 ] ] ) and d [ e [ 0 ] ] > d [ v ] + e [ 1 ] : <NEWLINE> <INDENT> d [ e [ 0 ] ] = d [ v ] + e [ 1 ] <NEWLINE> <NL> heapq . heappush ( q , ( d [ e [ 0 ] ] , e [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> import sys <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> l = list ( map ( int , l . split ( ) ) ) <NEWLINE> u = l [ 0 ] <NEWLINE> k = l [ 1 ] <NEWLINE> G [ u ] = zip ( * [ iter ( l [ 2 : ] ) ] * 2 ) <NEWLINE> <NL> <DEDENT> dijkstra ( 0 ) <NEWLINE> for i , c in enumerate ( d ) : <NEWLINE> <INDENT> print ( i , d [ i ] ) <NEWLINE> <DEDENT>
import heapq as hq <NEWLINE> <NL> INF = 100000000 <NEWLINE> <NL> def dijkstra ( n ) : <NEWLINE> <INDENT> global INF , W <NEWLINE> D = [ INF ] * n <NEWLINE> D [ 0 ] = 0 <NEWLINE> Q = [ ] <NEWLINE> hq . heappush ( Q , ( 0 , 0 ) ) <NEWLINE> <NL> while len ( Q ) != 0 : <NEWLINE> <INDENT> minw , i = hq . heappop ( Q ) <NEWLINE> if D [ i ] < minw : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> w = W [ i ] [ j ] <NEWLINE> if D [ j ] > D [ i ] + w : <NEWLINE> <INDENT> D [ j ] = D [ i ] + w <NEWLINE> hq . heappush ( Q , ( D [ j ] , j ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print i , D [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> W = [ [ INF ] * n for _ in range ( n ) ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( l [ 1 ] ) : <NEWLINE> <INDENT> W [ l [ 0 ] ] [ l [ 2 * i + 2 ] ] = l [ 2 * i + 3 ] <NEWLINE> <NL> <DEDENT> <DEDENT> dijkstra ( n ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( N ) ] <NEWLINE> for nod in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 2 , tmp [ 1 ] * 2 + 1 , 2 ) : <NEWLINE> <INDENT> edge , cos = tmp [ i ] , tmp [ i + 1 ] <NEWLINE> G [ nod ] . append ( [ edge , cos ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> import heapq <NEWLINE> <NL> <NL> def dijkstra ( x ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * N <NEWLINE> d [ x ] = 0 <NEWLINE> visited = { x } <NEWLINE> <NL> <COMMENT> <NL> hq = [ ( 0 , x ) ] <NEWLINE> <NL> while hq : <NEWLINE> <INDENT> u = heapq . heappop ( hq ) [ 1 ] <NEWLINE> visited . add ( u ) <NEWLINE> <NL> for node , cost in G [ u ] : <NEWLINE> <INDENT> if ( node not in visited ) and d [ node ] > d [ u ] + cost : <NEWLINE> <INDENT> d [ node ] = d [ u ] + cost <NEWLINE> heapq . heappush ( hq , ( d [ u ] + cost , node ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> distance = dijkstra ( 0 ) <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( i , distance [ i ] ) <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> G = [ [ ] for i in range ( N ) ] <NEWLINE> for nod in range ( N ) : <NEWLINE> <INDENT> tmp = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 2 , tmp [ 1 ] * 2 + 1 , 2 ) : <NEWLINE> <INDENT> edge , cos = tmp [ i ] , tmp [ i + 1 ] <NEWLINE> G [ nod ] . append ( [ edge , cos ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> import heapq <NEWLINE> <NL> <NL> def dijkstra ( x ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * N <NEWLINE> d [ x ] = 0 <NEWLINE> visited = { x } <NEWLINE> <NL> <COMMENT> <NL> hq = [ ( 0 , x ) ] <NEWLINE> <NL> while hq : <NEWLINE> <INDENT> u = heapq . heappop ( hq ) [ 1 ] <NEWLINE> visited . add ( u ) <NEWLINE> <NL> for node , cost in G [ u ] : <NEWLINE> <INDENT> if ( node not in visited ) and d [ node ] > d [ u ] + cost : <NEWLINE> <INDENT> d [ node ] = d [ u ] + cost <NEWLINE> heapq . heappush ( hq , ( d [ u ] + cost , node ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <NL> <DEDENT> distance = dijkstra ( 0 ) <NEWLINE> <COMMENT> <NL> for i in range ( N ) : <NEWLINE> <INDENT> print ( i , distance [ i ] ) <NEWLINE> <NL> <NL> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , maxint <NEWLINE> from operator import itemgetter <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = int ( stdin . readline ( ) ) <NEWLINE> <NL> edges = [ ] <NEWLINE> for _ in xrange ( num ) : <NEWLINE> <INDENT> it = iter ( int ( s ) for s in stdin . readline ( ) . split ( ) [ 1 : ] ) <NEWLINE> edges . append ( [ ( next ( it ) , next ( it ) ) for _ in xrange ( next ( it ) ) ] ) <NEWLINE> <NL> <DEDENT> distances = [ [ maxint , i ] for i in xrange ( num ) ] <NEWLINE> distances [ 0 ] [ 0 ] = 0 <NEWLINE> V = set ( xrange ( 1 , num ) ) <NEWLINE> W = [ ] <COMMENT> <NEWLINE> mark = set ( ) <NEWLINE> index = 0 <NEWLINE> <NL> while V : <NEWLINE> <INDENT> for v , cost in edges [ index ] : <NEWLINE> <INDENT> if v not in V : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost += distances [ index ] [ 0 ] <NEWLINE> if distances [ v ] [ 0 ] > cost : <NEWLINE> <INDENT> distances [ v ] [ 0 ] = cost <NEWLINE> if v not in mark : <NEWLINE> <INDENT> W . append ( distances [ v ] ) <NEWLINE> mark . add ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a = min ( W , key = itemgetter ( 0 ) ) <NEWLINE> index = a [ 1 ] <NEWLINE> W . remove ( a ) <NEWLINE> mark . remove ( index ) <NEWLINE> V . remove ( index ) <NEWLINE> <NL> <DEDENT> for d , i in distances : <NEWLINE> <INDENT> print ( i , d ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
import sys <NEWLINE> from heapq import * <NEWLINE> e = sys . stdin . readline <NEWLINE> I = float ( <STRING> ) <NEWLINE> def m ( ) : <NEWLINE> <INDENT> n = int ( e ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in [ 0 ] * n : <NEWLINE> <INDENT> e = list ( map ( int , e ( ) . split ( ) ) ) <NEWLINE> A += [ zip ( e [ 2 : : 2 ] , e [ 3 : : 2 ] ) ] <NEWLINE> <DEDENT> d = [ 0 ] + [ I ] * n <NEWLINE> H = [ ( 0 , 0 ) ] <NEWLINE> while H : <NEWLINE> <INDENT> u = heappop ( H ) [ 1 ] <NEWLINE> for v , c in A [ u ] : <NEWLINE> <INDENT> t = d [ u ] + c <NEWLINE> if d [ v ] > t : <NEWLINE> <INDENT> d [ v ] = t <NEWLINE> heappush ( H , ( t , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( <STRING> for i in range ( n ) ) ) <NEWLINE> <DEDENT> m ( ) <NEWLINE>
import sys <NEWLINE> <NL> global distance <NEWLINE> <NL> def shortest_path ( GRAPH ) : <NEWLINE> <INDENT> global distance <NEWLINE> <NL> nodes2 = range ( len ( distance ) ) <NEWLINE> p1 = 0 <NEWLINE> distance [ p1 ] = 0 ; <NEWLINE> <NL> while True : <NEWLINE> <INDENT> dp1 = distance [ p1 ] <NEWLINE> gp1 = GRAPH [ p1 ] <NEWLINE> nodes2 . remove ( p1 ) <NEWLINE> for p2 in nodes2 : <NEWLINE> <INDENT> if gp1 . has_key ( p2 ) : <NEWLINE> <INDENT> tmp = gp1 [ p2 ] + dp1 <NEWLINE> if tmp < distance [ p2 ] : <NEWLINE> <INDENT> distance [ p2 ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> p1 = - 1 <NEWLINE> mini = 1000000 <NEWLINE> for p2 in nodes2 : <NEWLINE> <INDENT> if distance [ p2 ] < mini : <NEWLINE> <INDENT> p1 = p2 <NEWLINE> mini = distance [ p2 ] <NEWLINE> <DEDENT> <DEDENT> if mini == 1000000 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> def resultout ( ) : <NEWLINE> <INDENT> for i in xrange ( len ( distance ) ) : <NEWLINE> <INDENT> print <STRING> % ( i , distance [ i ] ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> x = [ { } for i in xrange ( n ) ] <NEWLINE> distance = [ 1000000 for i in xrange ( n ) ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> seq = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> i2 = seq [ 0 ] <NEWLINE> tmp = { } <NEWLINE> for j in xrange ( 2 , len ( seq ) , 2 ) : <NEWLINE> <INDENT> j2 , weight = seq [ j : j + 2 ] <NEWLINE> tmp [ j2 ] = weight <NEWLINE> <DEDENT> x [ i2 ] = tmp <NEWLINE> <NL> <DEDENT> shortest_path ( x ) <NEWLINE> resultout ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> import heapq <NEWLINE> v_num = int ( input ( ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> <NL> for _ in range ( v_num ) : <NEWLINE> <INDENT> que = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> connect [ que [ 0 ] ] = [ [ v , w ] for v , w in zip ( que [ 2 : len ( que ) : 2 ] , que [ 3 : len ( que ) : 2 ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> queue = [ ] <NEWLINE> heapq . heapify ( queue ) <NEWLINE> heapq . heappush ( queue , [ 0 , 0 ] ) <NEWLINE> distance = [ - 1 for n in range ( v_num ) ] <NEWLINE> went = 0 <NEWLINE> visited = set ( ) <NEWLINE> while went < v_num : <NEWLINE> <INDENT> q = heapq . heappop ( queue ) <NEWLINE> weight , here = q <NEWLINE> if here in visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> visited |= { here } <NEWLINE> went += 1 <NEWLINE> distance [ here ] = weight <NEWLINE> for conn in connect [ here ] : <NEWLINE> <INDENT> if conn [ 0 ] not in visited : <NEWLINE> <INDENT> heapq . heappush ( queue , [ weight + conn [ 1 ] , conn [ 0 ] ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in range ( v_num ) : <NEWLINE> <INDENT> print ( i , distance [ i ] ) <NEWLINE> <DEDENT>
import sys , itertools <NEWLINE> f = sys . stdin <NEWLINE> <NL> def take2 ( iterable ) : <NEWLINE> <INDENT> i = iter ( iterable ) <NEWLINE> while True : <NEWLINE> <INDENT> yield next ( i ) , next ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( f . readline ( ) ) <NEWLINE> adj = [ [ ( v , c ) for v , c in take2 ( map ( int , f . readline ( ) . split ( ) [ 2 : ] ) ) ] for _ in range ( n ) ] <NEWLINE> d = [ 100000 * 100 + 1 ] * n <NEWLINE> <NL> d [ 0 ] = 0 <NEWLINE> queue = [ 0 ] <NEWLINE> while len ( queue ) : <NEWLINE> <INDENT> parent = queue . pop ( ) <NEWLINE> for v , c in adj [ parent ] : <NEWLINE> <INDENT> if d [ v ] > d [ parent ] + c : <NEWLINE> <INDENT> d [ v ] = d [ parent ] + c <NEWLINE> queue . append ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( i , d [ i ] ) <NEWLINE> <DEDENT>
import itertools <NEWLINE> N , Q , row , col = input ( ) , [ ] , range ( 8 ) , range ( 8 ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> r , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> Q . append ( ( r , c ) ) <NEWLINE> row . remove ( r ) <NEWLINE> col . remove ( c ) <NEWLINE> <DEDENT> for l in itertools . permutations ( col ) : <NEWLINE> <INDENT> queen = Q + list ( zip ( row , l ) ) <NEWLINE> if not any ( ( r1 != r2 or c1 != c2 ) and ( r1 == r2 or c1 == c2 or r1 + c1 == r2 + c2 or r1 - c1 == r2 - c2 ) for r2 , c2 in queen for r1 , c1 in queen ) : <NEWLINE> <INDENT> print <STRING> . join ( <STRING> . join ( <STRING> if ( r , c ) in queen else <STRING> for c in range ( 8 ) ) for r in range ( 8 ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> dy = [ - 1 , 0 , 0 , 1 ] <NEWLINE> dx = [ 0 , - 1 , 1 , 0 ] <NEWLINE> def g ( i , j , a ) : <NEWLINE> <INDENT> t = a // ( 10 ** j ) % 10 <NEWLINE> return a - t * ( 10 ** j ) + t * ( 10 ** i ) <NEWLINE> <DEDENT> def MAIN ( ) : <NEWLINE> <INDENT> m = { 8 : { 7 , 5 } , 7 : { 8 , 6 , 4 } , 6 : { 7 , 3 } , 5 : { 8 , 4 , 2 } , 4 : { 7 , 5 , 3 , 1 } , 3 : { 6 , 4 , 0 } , 2 : { 5 , 1 } , 1 : { 4 , 2 , 0 } , 0 : { 3 , 1 } } <NEWLINE> MAP = <STRING> . join ( input ( ) . replace ( <STRING> , <STRING> ) for _ in range ( N ) ) <NEWLINE> start = 8 - MAP . find ( <STRING> ) <NEWLINE> MAP = int ( MAP ) <NEWLINE> goal = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> goal = 123456780 <NEWLINE> dp = deque ( [ ( 0 , start , MAP ) ] ) <NEWLINE> LOG = { MAP } <NEWLINE> while dp : <NEWLINE> <INDENT> cnt , yx , M = dp . popleft ( ) <NEWLINE> if M == goal : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> break <NEWLINE> <DEDENT> cnt += 1 <NEWLINE> for nyx in m [ yx ] : <NEWLINE> <INDENT> CM = g ( yx , nyx , M ) <NEWLINE> if not CM in LOG : <NEWLINE> <INDENT> dp . append ( ( cnt , nyx , CM ) ) <NEWLINE> LOG . add ( CM ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> MAIN ( ) <NEWLINE> <NL>
import heapq <NEWLINE> <NL> def d_manhattan ( node_list ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( 9 ) : <NEWLINE> <INDENT> x_goal = i % 3 <NEWLINE> y_goal = i // 3 <NEWLINE> x_now = ( node_list [ i ] - 1 ) % 3 <NEWLINE> y_now = ( node_list [ i ] - 1 ) // 3 <NEWLINE> if y_now == - 1 : <NEWLINE> <INDENT> y_now = 2 <NEWLINE> <DEDENT> dx = abs ( x_now - x_goal ) <NEWLINE> dy = abs ( y_now - y_goal ) <NEWLINE> s += dx + dy <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def moveNodeE ( node_list , space ) : <NEWLINE> <INDENT> node_tmp = node_list [ : ] <NEWLINE> node_tmp [ space ] , node_tmp [ space + 1 ] = node_tmp [ space + 1 ] , node_tmp [ space ] <NEWLINE> return node_tmp <NEWLINE> <DEDENT> def moveNodeW ( node_list , space ) : <NEWLINE> <INDENT> node_tmp = node_list [ : ] <NEWLINE> node_tmp [ space ] , node_tmp [ space - 1 ] = node_tmp [ space - 1 ] , node_tmp [ space ] <NEWLINE> return node_tmp <NEWLINE> <DEDENT> def moveNodeN ( node_list , space ) : <NEWLINE> <INDENT> node_tmp = node_list [ : ] <NEWLINE> node_tmp [ space ] , node_tmp [ space - 3 ] = node_tmp [ space - 3 ] , node_tmp [ space ] <NEWLINE> return node_tmp <NEWLINE> <DEDENT> def moveNodeS ( node_list , space ) : <NEWLINE> <INDENT> node_tmp = node_list [ : ] <NEWLINE> node_tmp [ space ] , node_tmp [ space + 3 ] = node_tmp [ space + 3 ] , node_tmp [ space ] <NEWLINE> return node_tmp <NEWLINE> <NL> <DEDENT> class board : <NEWLINE> <INDENT> def __init__ ( self , node_list , g ) : <NEWLINE> <INDENT> self . node = node_list <NEWLINE> self . space = node_list . index ( 0 ) <NEWLINE> self . g = g <NEWLINE> self . h = d_manhattan ( node_list ) <NEWLINE> self . f = self . g + self . h <NEWLINE> <NL> <DEDENT> def makeBoard ( self ) : <NEWLINE> <INDENT> space = self . space <NEWLINE> cost_now = self . f <NEWLINE> x_s = space % 3 <NEWLINE> y_s = space // 3 <NEWLINE> if x_s < 2 : <NEWLINE> <INDENT> node_tmp = moveNodeE ( self . node , space ) <NEWLINE> yield board ( node_tmp , self . g + 1 ) <NEWLINE> <DEDENT> if x_s > 0 : <NEWLINE> <INDENT> node_tmp = moveNodeW ( self . node , space ) <NEWLINE> yield board ( node_tmp , self . g + 1 ) <NEWLINE> <DEDENT> if y_s < 2 : <NEWLINE> <INDENT> node_tmp = moveNodeS ( self . node , space ) <NEWLINE> yield board ( node_tmp , self . g + 1 ) <NEWLINE> <DEDENT> if y_s > 0 : <NEWLINE> <INDENT> node_tmp = moveNodeN ( self . node , space ) <NEWLINE> yield board ( node_tmp , self . g + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> b_open = [ ] <NEWLINE> n_close = { } <NEWLINE> n_goal = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 0 ] <NEWLINE> n_start = [ ] <NEWLINE> <NL> for i in range ( 3 ) : <NEWLINE> <INDENT> inp = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> n_start . extend ( inp ) <NEWLINE> <NL> <DEDENT> b_start = board ( n_start , 0 ) <NEWLINE> heapq . heappush ( b_open , ( b_start . f , b_start . h , 0 , b_start ) ) <NEWLINE> <NL> i = 0 <NEWLINE> while b_open : <NEWLINE> <INDENT> _ , _ , _ , b_now = heapq . heappop ( b_open ) <NEWLINE> if b_now . node == n_goal : <NEWLINE> <INDENT> b_goal = b_now <NEWLINE> break <NEWLINE> <DEDENT> n_close [ <STRING> . join ( map ( str , b_now . node ) ) ] = i <NEWLINE> for b_new in b_now . makeBoard ( ) : <NEWLINE> <INDENT> if <STRING> . join ( map ( str , b_new . node ) ) in n_close : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> heapq . heappush ( b_open , ( b_new . f , b_new . h , i , b_new ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( b_goal . g ) <NEWLINE>
import sys <NEWLINE> import queue <NEWLINE> <NL> N = 3 <NEWLINE> f = <STRING> . join ( sys . stdin . readline ( ) . split ( ) ) <NEWLINE> f += <STRING> . join ( sys . stdin . readline ( ) . split ( ) ) <NEWLINE> f += <STRING> . join ( sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> dd = [ [ - 1 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 0 , 1 ] ] <NEWLINE> <NL> Q = queue . Queue ( ) <NEWLINE> V = dict ( ) <NEWLINE> <NL> Q . put ( [ f , f . index ( <STRING> ) , 0 ] ) <NEWLINE> V [ f ] = True <NEWLINE> <NL> while not Q . empty ( ) : <NEWLINE> <INDENT> u = Q . get ( ) <NEWLINE> if u [ 0 ] == <STRING> : break <NEWLINE> sx , sy = u [ 1 ] // N , u [ 1 ] % N <NEWLINE> for dx , dy in dd : <NEWLINE> <INDENT> tx , ty = sx + dx , sy + dy <NEWLINE> if tx < 0 or ty < 0 or tx >= N or ty >= N : continue <NEWLINE> v = u [ : ] <NEWLINE> n1 , n2 = u [ 1 ] , tx * N + ty <NEWLINE> v [ 1 ] = n2 <NEWLINE> if n1 > n2 : n1 , n2 = n2 , n1 <NEWLINE> v [ 0 ] = v [ 0 ] [ 0 : n1 ] + v [ 0 ] [ n2 ] + v [ 0 ] [ n1 + 1 : n2 ] + v [ 0 ] [ n1 ] + v [ 0 ] [ n2 + 1 : ] <NEWLINE> if not V . get ( v [ 0 ] , False ) : <NEWLINE> <INDENT> V [ v [ 0 ] ] = True <NEWLINE> v [ 2 ] += 1 <COMMENT> <NEWLINE> Q . put ( v ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( u [ 2 ] ) <NEWLINE>
t = input ( ) <NEWLINE> p = input ( ) <NEWLINE> lt = len ( t ) <NEWLINE> lp = len ( p ) <NEWLINE> for i in range ( lt - lp + 1 ) : <NEWLINE> <INDENT> if t [ i : i + l_p ] == p : print ( i ) <NEWLINE> <DEDENT>
text = input ( ) <NEWLINE> string = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> len_string = len ( string ) <NEWLINE> common_length = [ 0 ] * len_string <NEWLINE> tmp = 0 <NEWLINE> for i in range ( 1 , len_string ) : <NEWLINE> <INDENT> if ( string [ i ] == string [ tmp ] ) : <NEWLINE> <INDENT> if ( string [ i - 1 ] == string [ tmp - 1 ] ) : <NEWLINE> <INDENT> common_length [ i - 1 ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> common_length [ i - 1 ] = 0 <NEWLINE> <DEDENT> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> common_length [ i - 1 ] = tmp <NEWLINE> if ( string [ i ] == string [ 0 ] ) : <NEWLINE> <INDENT> tmp = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( string [ - 1 ] == string [ tmp - 1 ] ) : <NEWLINE> <INDENT> common_length [ - 1 ] = tmp <NEWLINE> <NL> <NL> <NL> <DEDENT> tmp = 0 <NEWLINE> <NL> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> if ( text [ i ] != string [ tmp ] ) : <NEWLINE> <INDENT> while ( text [ i ] != string [ tmp ] and tmp != 0 ) : <NEWLINE> <INDENT> tmp = common_length [ max ( [ tmp - 1 , 0 ] ) ] <NEWLINE> <DEDENT> if ( text [ i ] == string [ tmp ] ) : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> if ( tmp == len_string ) : <NEWLINE> <INDENT> print ( i - tmp + 1 ) <NEWLINE> tmp = common_length [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> if ( 27 < i <= 26 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
t = input ( ) ; p = input ( ) <NEWLINE> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> if t [ i : ] . startwith ( p ) : print ( i ) <NEWLINE> <DEDENT>
def f ( T , P ) : <NEWLINE> <INDENT> for i in range ( len ( T ) ) : P != T [ i : i + len ( P ) ] or print ( i ) <NEWLINE> <DEDENT> if <STRING> __name__ : f ( input ( ) , input ( ) ) <NEWLINE>
def kmpTable ( w ) : <NEWLINE> <INDENT> lw = len ( w ) <NEWLINE> nx = [ - 1 ] * ( lw + 1 ) <NEWLINE> j = - 1 <NEWLINE> for i in xrange ( lw ) : <NEWLINE> <INDENT> while j >= 0 and w [ i ] != w [ j ] : <NEWLINE> <INDENT> j = nx [ j ] <NEWLINE> <DEDENT> j += 1 <NEWLINE> nx [ i + 1 ] = j <NEWLINE> <DEDENT> return nx <NEWLINE> <NL> <DEDENT> def kmpSearch ( s , w ) : <NEWLINE> <INDENT> ls = len ( s ) <NEWLINE> start = 0 <NEWLINE> w_idx = 0 <NEWLINE> ret = [ ] <NEWLINE> nx = kmpTable ( w ) <NEWLINE> while start + w_idx < ls : <NEWLINE> <INDENT> if s [ start + w_idx ] == w [ w_idx ] : <NEWLINE> <INDENT> w_idx += 1 <NEWLINE> if w_idx == len ( w ) : <NEWLINE> <INDENT> ret . append ( start ) <NEWLINE> start = start + w_idx - nx [ w_idx ] <NEWLINE> w_idx = nx [ w_idx ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if w_idx == 0 : <NEWLINE> <INDENT> start += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> start = start + w_idx - nx [ w_idx ] <NEWLINE> w_idx = nx [ w_idx ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> T = input ( ) <NEWLINE> P = input ( ) <NEWLINE> ans = kmpSearch ( T , P ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
text = input ( ) <NEWLINE> string = input ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <NL> len_string = len ( string ) <NEWLINE> common_length = [ 0 ] * len_string <NEWLINE> tmp = 0 <NEWLINE> tmp_tmp = 0 <NEWLINE> for i in range ( 1 , len_string ) : <NEWLINE> <INDENT> if ( string [ i ] == string [ tmp ] ) : <NEWLINE> <INDENT> tmp_tmp = tmp <NEWLINE> while ( string [ i ] == string [ tmp_tmp ] and tmp_tmp > 0 ) : <NEWLINE> <INDENT> tmp_tmp = common_length [ max ( [ tmp_tmp - 1 , 0 ] ) ] <NEWLINE> <DEDENT> common_length [ i - 1 ] = tmp_tmp <NEWLINE> tmp += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> common_length [ i - 1 ] = tmp <NEWLINE> while ( string [ i ] != string [ tmp ] and tmp > 0 ) : <NEWLINE> <INDENT> tmp = common_length [ max ( [ tmp - 1 , 0 ] ) ] <NEWLINE> <DEDENT> if ( string [ i ] == string [ 0 ] ) : <NEWLINE> <INDENT> tmp = 1 } <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( string [ - 1 ] == string [ tmp - 1 ] ) : <NEWLINE> <INDENT> common_length [ - 1 ] = tmp <NEWLINE> <DEDENT> common_length [ 0 ] = 0 <NEWLINE> <NL> <NL> tmp = 0 <NEWLINE> <NL> for i in range ( len ( text ) ) : <NEWLINE> <INDENT> if ( text [ i ] != string [ tmp ] ) : <NEWLINE> <INDENT> while ( text [ i ] != string [ tmp ] and tmp > 0 ) : <NEWLINE> <INDENT> tmp = common_length [ max ( [ tmp - 1 , 0 ] ) ] <NEWLINE> <DEDENT> if ( text [ i ] == string [ tmp ] ) : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> tmp += 1 <NEWLINE> if ( tmp == len_string ) : <NEWLINE> <INDENT> print ( i - tmp + 1 ) <NEWLINE> tmp = common_length [ - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
base1 = 1009 <NEWLINE> base2 = 1013 <NEWLINE> mask = ( 1 << 32 ) - 1 <NEWLINE> def calc_hash ( f , r , c ) : <NEWLINE> <INDENT> global ph , pw , h <NEWLINE> tmp = [ [ 0 ] * c for _ in range ( r ) ] <NEWLINE> dr , dc = r - ph , c - pw <NEWLINE> t1 = 1 <NEWLINE> for _ in range ( pw ) : <NEWLINE> <INDENT> t1 = ( t1 * base1 ) & mask <NEWLINE> <DEDENT> for i in range ( r ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for j in range ( pw ) : <NEWLINE> <INDENT> e = e * base1 + f [ i ] [ j ] <NEWLINE> <DEDENT> for j in range ( dc ) : <NEWLINE> <INDENT> tmp [ i ] [ j ] = e <NEWLINE> e = ( e * base1 - t1 * f [ i ] [ j ] + f [ i ] [ j + pw ] ) & mask <NEWLINE> <DEDENT> tmp [ i ] [ dc ] = e <NEWLINE> <DEDENT> t2 = 1 <NEWLINE> for _ in range ( ph ) : <NEWLINE> <INDENT> t2 = ( t2 * base2 ) & mask <NEWLINE> <DEDENT> for j in range ( dc + 1 ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for i in range ( ph ) : <NEWLINE> <INDENT> e = e * base2 + tmp [ i ] [ j ] <NEWLINE> <DEDENT> for i in range ( dr ) : <NEWLINE> <INDENT> h [ i ] [ j ] = e <NEWLINE> e = ( e * base2 - t2 * tmp [ i ] [ j ] + tmp [ i + ph ] [ j ] ) & mask <NEWLINE> <DEDENT> h [ dr ] [ j ] = e <NEWLINE> <DEDENT> <DEDENT> th , tw = map ( int , input ( ) . split ( ) ) <NEWLINE> t = tuple ( tuple ( ord ( c ) for c in input ( ) ) for _ in range ( th ) ) <NEWLINE> ph , pw = map ( int , input ( ) . split ( ) ) <NEWLINE> p = tuple ( tuple ( ord ( c ) for c in input ( ) ) for _ in range ( ph ) ) <NEWLINE> ans = [ ] <NEWLINE> if th >= ph and tw >= pw : <NEWLINE> <INDENT> h = [ [ 0 ] * tw for _ in range ( th ) ] <NEWLINE> calc_hash ( p , ph , pw ) <NEWLINE> key = h [ 0 ] [ 0 ] & mask <NEWLINE> calc_hash ( t , th , tw ) <NEWLINE> for i in range ( th - ph + 1 ) : <NEWLINE> <INDENT> for j in range ( tw - pw + 1 ) : <NEWLINE> <INDENT> if h [ i ] [ j ] & mask == key : <NEWLINE> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> . join ( a for a in ans ) ) <NEWLINE> <DEDENT>
base1 = 1009 <NEWLINE> base2 = 1013 <NEWLINE> mask = ( 1 << 32 ) - 1 <NEWLINE> def calc_hash ( f , r , c ) : <NEWLINE> <INDENT> global ph , pw , h <NEWLINE> tmp = [ [ 0 ] * c for _ in range ( r ) ] <NEWLINE> dr , dc = r - ph , c - pw <NEWLINE> t1 = 1 <NEWLINE> t1 = ( t1 * ( base1 ** pw ) ) & mask <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for i in range ( r ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for j in range ( pw ) : <NEWLINE> <INDENT> e = e * base1 + f [ i ] [ j ] <NEWLINE> <DEDENT> for j in range ( dc ) : <NEWLINE> <INDENT> tmp [ i ] [ j ] = e <NEWLINE> e = ( e * base1 - t1 * f [ i ] [ j ] + f [ i ] [ j + pw ] ) & mask <NEWLINE> <DEDENT> tmp [ i ] [ dc ] = e <NEWLINE> <DEDENT> t2 = 1 <NEWLINE> for _ in range ( ph ) : <NEWLINE> <INDENT> t2 = ( t2 * base2 ) & mask <NEWLINE> <DEDENT> for j in range ( dc + 1 ) : <NEWLINE> <INDENT> e = 0 <NEWLINE> for i in range ( ph ) : <NEWLINE> <INDENT> e = e * base2 + tmp [ i ] [ j ] <NEWLINE> <DEDENT> for i in range ( dr ) : <NEWLINE> <INDENT> h [ i ] [ j ] = e <NEWLINE> e = ( e * base2 - t2 * tmp [ i ] [ j ] + tmp [ i + ph ] [ j ] ) & mask <NEWLINE> <DEDENT> h [ dr ] [ j ] = e <NEWLINE> <DEDENT> <DEDENT> th , tw = map ( int , input ( ) . split ( ) ) <NEWLINE> t = tuple ( tuple ( ord ( c ) for c in input ( ) ) for _ in range ( th ) ) <NEWLINE> ph , pw = map ( int , input ( ) . split ( ) ) <NEWLINE> p = tuple ( tuple ( ord ( c ) for c in input ( ) ) for _ in range ( ph ) ) <NEWLINE> ans = [ ] <NEWLINE> if th >= ph and tw >= pw : <NEWLINE> <INDENT> h = [ [ 0 ] * tw for _ in range ( th ) ] <NEWLINE> calc_hash ( p , ph , pw ) <NEWLINE> key = h [ 0 ] [ 0 ] & mask <NEWLINE> calc_hash ( t , th , tw ) <NEWLINE> for i in range ( th - ph + 1 ) : <NEWLINE> <INDENT> for j in range ( tw - pw + 1 ) : <NEWLINE> <INDENT> if h [ i ] [ j ] & mask == key : <NEWLINE> <INDENT> ans . append ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if ans : <NEWLINE> <INDENT> print ( <STRING> . join ( a for a in ans ) ) <NEWLINE> <DEDENT>
from collections import defaultdict , Counter <NEWLINE> from math import floor , ceil , log <NEWLINE> from heapq import heapreplace , heappush <NEWLINE> import time <NEWLINE> <NL> class TreeIndex : <NEWLINE> <NL> <INDENT> class Node : <NEWLINE> <INDENT> __slots__ = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , level ) : <NEWLINE> <INDENT> self . level = level <NEWLINE> self . values = [ ] <NEWLINE> self . keys = { } <NEWLINE> self . keylen = 2 ** self . level <NEWLINE> self . _init_cache ( ) <NEWLINE> <NL> <DEDENT> def add ( self , text , value ) : <NEWLINE> <INDENT> def _add ( node , t ) : <NEWLINE> <INDENT> if len ( t ) == 0 : <NEWLINE> <INDENT> node . values . append ( value ) <NEWLINE> return node <NEWLINE> <NL> <DEDENT> pre = t [ : node . keylen ] <NEWLINE> post = t [ node . keylen : ] <NEWLINE> if pre not in node . keys : <NEWLINE> <INDENT> node . keys [ pre ] = self . __class__ ( node . level + 1 ) <NEWLINE> <DEDENT> return _add ( node . keys [ pre ] , post ) <NEWLINE> <NL> <DEDENT> node = self . _get_cache ( text ) <NEWLINE> if node is not None : <NEWLINE> <INDENT> _add ( node , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _set_cache ( text , _add ( self , text ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def index ( self , text ) : <NEWLINE> <INDENT> def _index ( node , t ) : <NEWLINE> <INDENT> if len ( t ) == 0 : <NEWLINE> <INDENT> return node <NEWLINE> <NL> <DEDENT> pre = t [ : node . keylen ] <NEWLINE> post = t [ node . keylen : ] <NEWLINE> if pre in node . keys : <NEWLINE> <INDENT> return _index ( node . keys [ pre ] , post ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> node = self . _get_cache ( text ) <NEWLINE> if node is not None : <NEWLINE> <INDENT> return node . values <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = _index ( self , text ) <NEWLINE> if node is not None : <NEWLINE> <INDENT> self . _set_cache ( text , node ) <NEWLINE> return node . values <NEWLINE> <DEDENT> return [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> def __contains__ ( self , text ) : <NEWLINE> <INDENT> if len ( text ) > self . keylen : <NEWLINE> <INDENT> pre = text [ : self . keylen ] <NEWLINE> post = text [ self . keylen : ] <NEWLINE> return ( pre in self . keys and post in self . keys [ pre ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return any ( key . startswith ( text ) for key in self . keys ) <NEWLINE> <NL> <DEDENT> <DEDENT> def _init_cache ( self ) : <NEWLINE> <INDENT> self . _cache = { } <NEWLINE> self . _cacheq = [ ] <NEWLINE> <NL> <DEDENT> def _set_cache ( self , text , node ) : <NEWLINE> <INDENT> if text not in self . _cache : <NEWLINE> <INDENT> if len ( self . _cacheq ) > 65535 : <NEWLINE> <INDENT> _ , txt = heapreplace ( self . _cacheq , ( time . clock ( ) , text ) ) <NEWLINE> del self . _cache [ txt ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> heappush ( self . _cacheq , ( time . clock ( ) , text ) ) <NEWLINE> <DEDENT> self . _cache [ text ] = node <NEWLINE> <NL> <DEDENT> <DEDENT> def _get_cache ( self , text ) : <NEWLINE> <INDENT> if text in self . _cache : <NEWLINE> <INDENT> return self . _cache [ text ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return ( <STRING> + <STRING> . join ( [ <STRING> . format ( k , v ) <NEWLINE> <INDENT> for k , v in self . keys . items ( ) ] ) + <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def __init__ ( self , text ) : <NEWLINE> <INDENT> self . _keylen ( text ) <NEWLINE> self . _create_index ( text ) <NEWLINE> <NL> <DEDENT> def _keylen ( self , text ) : <NEWLINE> <INDENT> chars = Counter ( list ( text ) ) <NEWLINE> ent = 0.0 <NEWLINE> total = len ( text ) <NEWLINE> base = len ( chars ) + 1 <NEWLINE> for c , cnt in chars . items ( ) : <NEWLINE> <INDENT> p = cnt / total <NEWLINE> ent -= p * log ( p , base ) <NEWLINE> <DEDENT> self . keylen = max ( 2 ** ceil ( 10 * ( 1 - ent ) ) - 1 , 15 ) <NEWLINE> <NL> <DEDENT> def _create_index ( self , text ) : <NEWLINE> <INDENT> tree = self . Node ( 0 ) <NEWLINE> length = len ( text ) <NEWLINE> for i in range ( length ) : <NEWLINE> <INDENT> tree . add ( text [ i : i + self . keylen ] , i ) <NEWLINE> <DEDENT> self . tree = tree <NEWLINE> self . text = text <NEWLINE> <NL> <DEDENT> def match ( self , search_text ) : <NEWLINE> <INDENT> def _match_partial ( lo , hi ) : <NEWLINE> <INDENT> split = self . keylen <NEWLINE> if search_text [ lo + split : hi ] in self . tree : <NEWLINE> <INDENT> for i in self . tree . index ( search_text [ lo : lo + split ] ) : <NEWLINE> <INDENT> if ( self . text [ i + split : i + hi - lo ] <NEWLINE> <INDENT> == search_text [ lo + split : hi ] ) : <NEWLINE> yield i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def _match ( lo , hi ) : <NEWLINE> <INDENT> length = hi - lo <NEWLINE> <NL> if length == self . keylen : <NEWLINE> <INDENT> return ( i for i in self . tree . index ( search_text [ lo : hi ] ) ) <NEWLINE> <NL> <DEDENT> if length < self . keylen * 2 : <NEWLINE> <INDENT> return _match_partial ( lo , hi ) <NEWLINE> <NL> <DEDENT> mid = lo + length // 2 <NEWLINE> pre = _match ( lo , mid ) <NEWLINE> post = _match ( mid , hi ) <NEWLINE> <NL> return _merge ( pre , post , mid - lo ) <NEWLINE> <NL> <DEDENT> def _merge ( idx1 , idx2 , shift ) : <NEWLINE> <INDENT> i2 = next ( idx2 ) <NEWLINE> for i1 in idx1 : <NEWLINE> <INDENT> while i1 + shift > i2 : <NEWLINE> <INDENT> i2 = next ( idx2 ) <NEWLINE> <DEDENT> if i1 + shift == i2 : <NEWLINE> <INDENT> yield i1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> length = len ( search_text ) <NEWLINE> if length < self . keylen : <NEWLINE> <INDENT> return search_text in self . tree <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> k = floor ( log ( length / self . keylen , 2 ) ) <NEWLINE> b = self . keylen * 2 ** k <NEWLINE> if length - self . keylen < b < length and k > 0 : <NEWLINE> <INDENT> b = self . keylen * 2 ** ( k - 1 ) <NEWLINE> <NL> <DEDENT> try : <NEWLINE> <INDENT> if b + self . keylen < length : <NEWLINE> <INDENT> match = _merge ( _match ( 0 , b ) , _match ( b , length ) , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> match = _match ( 0 , length ) <NEWLINE> <DEDENT> next ( match ) <NEWLINE> return True <NEWLINE> <DEDENT> except StopIteration : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def run ( ) : <NEWLINE> <INDENT> s1 = input ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> index = TreeIndex ( s1 ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s2 = input ( ) <NEWLINE> if index . match ( s2 ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
def insertionSort ( A ) : <NEWLINE> <INDENT> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> print A [ k ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> temp = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > temp : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = temp <NEWLINE> for k in range ( len ( A ) ) : <NEWLINE> <INDENT> print A [ k ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> insertionSort ( A ) <NEWLINE>
length = int ( input ( ) ) <NEWLINE> eles = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( _length ) : <NEWLINE> <INDENT> val = _list [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and _list [ j ] > val : <NEWLINE> <INDENT> _list [ j + 1 ] = _list [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> _list [ j + 1 ] = val <NEWLINE> print ( * _list ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def insertionSort ( x_list , y ) : <NEWLINE> <INDENT> for i in range ( 1 , y ) : <NEWLINE> <INDENT> v = x_list [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and x_list [ j ] > v : <NEWLINE> <INDENT> x_list [ j + 1 ] = x_list [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> x_list [ j + 1 ] = v <NEWLINE> for k in range ( 0 , y ) : <NEWLINE> <INDENT> print x_list [ k ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> y = sys . stdin . readline ( ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> x = sys . stdin . readline ( ) <NEWLINE> <NL> x_list = x . split ( <STRING> ) <NEWLINE> <NL> for i in range ( y ) : <NEWLINE> <INDENT> x_list [ i ] = int ( x_list [ i ] ) <NEWLINE> <NL> <DEDENT> for k in range ( 0 , y ) : <NEWLINE> <INDENT> print x_list [ k ] , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <NL> insertionSort ( x_list , y ) <NEWLINE>
num = raw_input ( ) <NEWLINE> num_list = raw_input ( ) <NEWLINE> num_list = num_list . split ( ) <NEWLINE> print <STRING> . join ( num_list ) <NEWLINE> <NL> for i in range ( 1 , len ( num_list ) ) : <NEWLINE> <INDENT> temp = num_list [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and num_list [ j ] > temp ) : <NEWLINE> <INDENT> num_list [ j + 1 ] = num_list [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> num_list [ j + 1 ] = temp <NEWLINE> print <STRING> . join ( num_list ) <NEWLINE> <DEDENT>
def insertion_sort ( arr ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( arr ) ) : <NEWLINE> <INDENT> j = i <NEWLINE> while arr [ j ] < arr [ j - 1 ] and j > 0 : <NEWLINE> <INDENT> arr [ j - 1 ] , arr [ j ] = arr [ j ] , arr [ j - 1 ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( arr ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> input ( ) <NEWLINE> arr = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> insertion_sort ( arr ) <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> k = int ( a [ i ] ) <NEWLINE> j = i - 1 <NEWLINE> while int ( a [ j ] ) > k : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = k <NEWLINE> print ( * a ) <NEWLINE> <DEDENT>
def show ( nums ) : <NEWLINE> <INDENT> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> if i != len ( nums ) - 1 : <NEWLINE> <INDENT> print ( nums [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nums [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> show ( nums ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = nums [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and nums [ j ] > v ) : <NEWLINE> <INDENT> nums [ j + 1 ] = nums [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> nums [ j + 1 ] = v <NEWLINE> shows ( nums ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE> <NL> for i in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i <NEWLINE> <NL> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT>
def : isort ( n , a ) : <NEWLINE> <INDENT> print <STRING> . join ( map ( str , a ) ) <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> key = a [ j ] <NEWLINE> i = j - 1 <NEWLINE> while i >= 0 and a [ i ] > key : <NEWLINE> <INDENT> a [ i + 1 ] = a [ i ] <NEWLINE> i = i - 1 <NEWLINE> <DEDENT> a [ i + 1 ] = key <NEWLINE> print <STRING> . join ( map ( str , a ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> isort ( n , a ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 & & A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j - - <NEWLINE> A [ j + 1 ] = v <NEWLINE> <DEDENT> print ( <STRING> . join ( A ) ) <NEWLINE> <DEDENT>
def insertionSort ( a , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> show ( a , n ) <NEWLINE> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> show ( a , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> def show ( a , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print <STRING> % a [ i ] , <NEWLINE> if i == n - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> insertionSort ( a , n ) <NEWLINE>
n = raw_input ( ) <NEWLINE> num = raw_input ( ) <NEWLINE> array = [ ] <NEWLINE> array = num . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> for i in range ( 1 , int ( n ) ) : <NEWLINE> <INDENT> print <STRING> . join ( array ) <NEWLINE> v = array [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and array [ j ] > v : <NEWLINE> <INDENT> array [ j + 1 ] = array [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> array [ j + 1 ] = v <NEWLINE> <DEDENT> print <STRING> . join ( array <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def printElem ( B ) : <NEWLINE> <INDENT> string = <STRING> <NEWLINE> for elem in B : <NEWLINE> <INDENT> string += str ( elem ) + <STRING> <NEWLINE> <DEDENT> print ( string ) <NEWLINE> <NL> <DEDENT> printElem ( A ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> key = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> <NL> while j >= 0 and A [ j ] > key : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> A [ j + 1 ] = key <NEWLINE> <NL> printElem ( A ) <NEWLINE> <DEDENT>
import sys , re <NEWLINE> <NL> def echo ( A ) : <NEWLINE> <INDENT> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if i < len ( A ) - 1 : <NEWLINE> <INDENT> sys . stdout ( <STRING> % a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sys . stdout ( <STRING> % a ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def insertionSort ( A , N ) : <NEWLINE> <INDENT> echo ( A ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> echo ( A ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> a_text = raw_input ( ) <NEWLINE> splits = re . split ( <STRING> , a_text ) <NEWLINE> a = [ ] <NEWLINE> for i , s in enumerate ( splits ) : <NEWLINE> <INDENT> if s : <NEWLINE> <INDENT> a . append ( int ( s ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> insertionSort ( a , n ) <NEWLINE>
nums = int ( input ( ) ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , nums ) : <NEWLINE> <INDENT> v = array [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and array [ j ] > v : <NEWLINE> <INDENT> array [ j + 1 ] = array [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> array [ j + 1 ] = v <NEWLINE> print array <NEWLINE> <DEDENT>
num = int ( raw_input ( ) ) <NEWLINE> line = raw_input ( ) <NEWLINE> <NL> A_str = line . strip ( ) . split ( <STRING> ) <NEWLINE> print <STRING> . join ( A_str ) <NEWLINE> A = map ( int , item_str ) <NEWLINE> <NL> for i in range ( 1 , num ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> for j in range ( j , - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> A [ j + 1 ] = v <NEWLINE> A_str = map ( str , A ) <NEWLINE> print <STRING> . join ( A_str ) <NEWLINE> <DEDENT>
count = int ( input ( ) ) ; <NEWLINE> data = [ ] ; <NEWLINE> for n in range ( count ) : <NEWLINE> <INDENT> data . append ( int ( input ( ) ) ) ; <NEWLINE> <NL> <DEDENT> def insert_sort ( data ) : <NEWLINE> <INDENT> show ( data ) ; <NEWLINE> for i in range ( 1 , len ( data ) ) : <NEWLINE> <INDENT> n = data [ i ] ; <NEWLINE> j = i - 1 ; <NEWLINE> while j >= 0 and data [ j ] > n : <NEWLINE> <INDENT> data [ j + 1 ] = data [ j ] ; <NEWLINE> j -= 1 ; <NEWLINE> <DEDENT> data [ j + 1 ] = n ; <NEWLINE> show ( data ) ; <NEWLINE> <NL> <DEDENT> <DEDENT> def show ( data ) : <NEWLINE> <INDENT> print ( <STRING> . join ( str ( n ) for n in data ) ) ; <NEWLINE> <NL> <DEDENT> insert_sort ( data ) ; <NEWLINE>
def insertionSort ( N , A ) : <NEWLINE> <INDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> innum = A [ i ] <NEWLINE> j = j - 1 <NEWLINE> while j > 0 and A [ i ] > innum : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> A [ j + 1 ] = innum <NEWLINE> B [ k ] = A <NEWLINE> <DEDENT> return B <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> for i in range ( 0 , B . length ( ) ) : <NEWLINE> <INDENT> print ( B [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
def insertionSort ( A , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = input ( ) <NEWLINE> A = input ( ) <NEWLINE> A = list ( map ( int , A . split ( ) ) ) <NEWLINE> insertionSort ( A , N ) <NEWLINE>
A = [ 5 , 2 , 4 , 6 , 1 , 3 ] <NEWLINE> <NL> print ( <STRING> . join ( [ str ( item ) for item in A ] ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> key = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > key : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> A [ j + 1 ] = key <NEWLINE> print ( <STRING> . join ( [ str ( item ) for item in A ] ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> A [ j + 1 ] = v <NEWLINE> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if i != len ( A ) - 1 : <NEWLINE> <INDENT> print ( A [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
def insertionSort ( lis , leng ) : <NEWLINE> <INDENT> for i in range ( leng ) : <NEWLINE> <INDENT> v = lis [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and lis [ j ] > v : <NEWLINE> <INDENT> lis [ j + 1 ] = lis [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> lis [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( lis ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lengg = int ( input ( ) ) <NEWLINE> liss = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> insertionSort ( liss , lengg ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> lst = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> key = lst [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and lst [ j ] > key : <NEWLINE> <INDENT> lst [ j + 1 ] = lst [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> lst [ j + 1 ] = key <NEWLINE> print ( <STRING> . join ( map ( str , lst ) ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> a = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> print ( * a ) <NEWLINE> <DEDENT>
def insertionSort ( n , A ) : <NEWLINE> <INDENT> print ( * A ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( * A ) <NEWLINE> <DEDENT> <DEDENT> n = int ( readline ( ) ) <NEWLINE> A = [ int ( j ) for j in readline ( ) . split ( <STRING> ) ] <NEWLINE> insertionSort ( n , A ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> arr = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> p = 1 <NEWLINE> print <STRING> . join ( map ( str , arr ) ) <NEWLINE> while True : <NEWLINE> <INDENT> for j in range ( 0 , p ) : <NEWLINE> <INDENT> if arr [ p ] < arr [ j ] : <NEWLINE> <INDENT> arr [ p ] , arr [ j ] = arr [ j ] , arr [ p ] <NEWLINE> <DEDENT> <DEDENT> p += 1 <NEWLINE> print <STRING> . join ( map ( str , arr ) ) <NEWLINE> if p >= len ( arr ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> n = raw_input ( ) <NEWLINE> <NL> if n < 1 and n > 100 : <NEWLINE> <INDENT> exit ( ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> l = raw_input ( ) <NEWLINE> <NL> elements = l . split ( ) <NEWLINE> <NL> o = <STRING> <NEWLINE> for e in elements : <NEWLINE> <INDENT> o += str ( e ) + <STRING> <NEWLINE> <DEDENT> print o <NEWLINE> <NL> for i in range ( 1 , int ( n ) ) : <NEWLINE> <INDENT> key = elements [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and elements [ j ] > key : <NEWLINE> <INDENT> elements [ j + 1 ] = elements [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> elements [ j + 1 ] = key <NEWLINE> <COMMENT> <NL> o = <STRING> <NEWLINE> for e in elements : <NEWLINE> <INDENT> o += str ( e ) + <STRING> <NEWLINE> <DEDENT> print o <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def insertionSort ( A , N ) : <NEWLINE> <INDENT> for n in range ( N - 1 ) : <NEWLINE> <INDENT> print ( A [ n ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ N - 1 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> <NL> for n in range ( N - 1 ) : <NEWLINE> <INDENT> print ( A [ n ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ N - 1 ] ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = input ( ) <NEWLINE> A = A . split ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i ] ) <NEWLINE> <DEDENT> val = insertionSort ( stdin_A , stdin_N ) <NEWLINE>
import output <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> output . print_1 ( A ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> output . print_1 ( A ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( <STRING> . join ( A ) ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> target_num = A [ i ] <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if A [ j ] > target_num : <NEWLINE> <INDENT> tmp_idx = i <NEWLINE> while j < tmp_idx : <NEWLINE> <INDENT> A [ tmp_idx ] = A [ tmp_idx - 1 ] <NEWLINE> tmp_idx -= 1 <NEWLINE> <DEDENT> A [ j ] = target_num <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( A ) ) <NEWLINE> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( ( j >= 0 ) and A ( j ) > v ) : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( A ) <NEWLINE> <DEDENT>
def insertionSort ( _list , _length ) : <NEWLINE> <INDENT> for i in range ( 1 , _length ) : <NEWLINE> <INDENT> ll = [ str ( _l ) for _l in _list ] <NEWLINE> print ( <STRING> . join ( ll ) ) <NEWLINE> val = _list [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and _list [ j ] > val : <NEWLINE> <INDENT> _list [ j + 1 ] = _list [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> _list [ j + 1 ] = val <NEWLINE> <DEDENT> ll = [ str ( _l ) for _l in _list ] <NEWLINE> print ( <STRING> . join ( ll ) ) <NEWLINE> <NL> <DEDENT> length = input ( ) <NEWLINE> eles = [ ele for ele in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> insertionSort ( eles , length ) <NEWLINE>
def insertionsort ( A , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> prt ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> def prt ( A ) : <NEWLINE> <INDENT> for i in A : <NEWLINE> <INDENT> if i != A [ len ( A ) - 1 ] : print ( i , end = <STRING> ) <NEWLINE> else print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> A = [ int ( i ) for i in A ] <NEWLINE> prt ( A ) <NEWLINE> insertionsort ( A , n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * a = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> <NL> print ( * a ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> def printlist ( lst ) : <NEWLINE> <INDENT> for l in lst : <NEWLINE> <INDENT> print ( l ) , <NEWLINE> <DEDENT> print <NEWLINE> <NL> <DEDENT> N = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> A = sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> A = map ( lambda x : int ( x ) , A ) <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> temp = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > temp : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = temp <NEWLINE> printlist ( A ) <NEWLINE> <DEDENT>
if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> l [ i ] = int ( l [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> v = l [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and l [ l ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( l [ 0 ] , l [ 1 ] , l [ 2 ] , l [ 3 ] , [ 4 ] , l [ 5 ] ) <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for k in range ( N - 1 ) : <NEWLINE> <INDENT> print A [ k ] , <NEWLINE> <DEDENT> print A [ N - 1 ] <NEWLINE> v = A [ i + 1 ] <NEWLINE> j = i <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print <STRING> <NEWLINE> <NL> <DEDENT> for m in range ( N - 1 ) : <NEWLINE> <INDENT> print str ( A [ m ] ) , <NEWLINE> <DEDENT> print A [ N - 1 ] <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + 1 ] == A [ j ] <NEWLINE> j -= j <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> <NL> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> l = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> l [ 0 : i ] = sorted ( l [ 0 : i ] ) <NEWLINE> print * l <NEWLINE> <DEDENT>
<COMMENT> <NL> A = [ ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> NUM = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> <NL> NUMLIST = range ( 1 , NUM + 1 ) <NEWLINE> <NL> <COMMENT> <NL> for i in NUMLIST : <NEWLINE> <COMMENT> <NL> <INDENT> key = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > key : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = key <NEWLINE> <NL> <DEDENT>
a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = list ( map ( int , s . split ( ) ) ) <NEWLINE> insertionSort ( a , n ) <NEWLINE> <NL> def insertionSort ( a , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> if ( i != n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and a [ j ] > v ) : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( a [ i ] , end = <STRING> ) <NEWLINE> if ( i != n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> n = input ( ) <NEWLINE> sort_list = list ( ) <NEWLINE> <NL> sort_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <NL> <NL> <INDENT> tmp = sort_list [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and sort_list [ j ] > tmp : <NEWLINE> <INDENT> sort_list [ j + 1 ] = sort_list [ j ] <NEWLINE> j = j - 1 <NEWLINE> <NL> <DEDENT> sort_list [ j + 1 ] = tmp <NEWLINE> <NL> <NL> for k in range ( 0 , n ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( sort_list [ k ] ) ) <NEWLINE> if k is not n - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> elif i is not n - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> key = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > key : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = key <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> cou = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a_sq = int ( math . sqrt ( A [ i ] ) ) <NEWLINE> for j in range ( 2 , a_sq + 2 ) : <NEWLINE> <INDENT> if ( A [ i ] % j == 0 and not ( A [ i ] == j ) ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if ( j == a_sq + 1 ) : <NEWLINE> <INDENT> cou += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cou ) <NEWLINE> <NL> <STRING> <NEWLINE> <NL>
def output ( list ) : <NEWLINE> <INDENT> for i , row in enumerate ( list ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> print ( row , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , row , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> s_list = [ ] <NEWLINE> s_list = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> output ( s_list ) <NEWLINE> print ( ) <NEWLINE> <NL> <COMMENT> <NL> start = time . time ( ) <NEWLINE> i = 0 <NEWLINE> for count in range ( len ( s_list ) - 1 ) : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> if s_list [ i ] > s_list [ i + 1 ] : <NEWLINE> <NL> <COMMENT> <NL> <INDENT> ins_num = s_list [ i + 1 ] <NEWLINE> s_list [ i + 1 ] = s_list [ i ] <NEWLINE> s_list [ i ] = ins_num <NEWLINE> <NL> j = i - 1 <NEWLINE> <NL> while j >= 0 : <NEWLINE> <INDENT> if s_list [ j ] > ins_num : <NEWLINE> <INDENT> s_list [ j + 1 ] = s_list [ j ] <NEWLINE> s_list [ j ] = ins_num <NEWLINE> <NL> <DEDENT> j -= 1 <NEWLINE> <DEDENT> output ( s_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output ( s_list ) <NEWLINE> <NL> <DEDENT> print ( ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> result = time . time ( ) - start <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> myarr = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 1 , len ( myarr ) ) : <NEWLINE> <INDENT> for j in range ( i , 0 , - 1 ) : <NEWLINE> <INDENT> if myarr [ j ] < myarr [ j - 1 ] : <NEWLINE> <INDENT> t = myarr [ j ] <NEWLINE> myarr [ j ] = myarr [ j - 1 ] <NEWLINE> myarr [ j - 1 ] = t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , myarr ) ) ) <NEWLINE> <NL> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ i for i in int ( input ( ) . split ( ) ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while a [ j ] > v and j >= 0 : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j ] = v <NEWLINE> print ( * a ) <NEWLINE> <DEDENT>
<NL> from __future__ import print_function <NEWLINE> <NL> <NL> class Solution : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> @ staticmethod <NEWLINE> def insertion_sort ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> array_length = int ( raw_input ( ) ) <NEWLINE> unsorted_array = map ( int , raw_input ( ) . line . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> for i in range ( 1 , array_length ) : <NEWLINE> <INDENT> v = unsorted_array [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and unsorted_array [ j ] > v : <NEWLINE> <INDENT> unsorted_array [ j + 1 ] = unsorted_array [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> unsorted_array [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( str ( i ) for i in unsorted_array ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . insertion_sort ( ) <NEWLINE> <DEDENT>
<NL> from __future__ import print_function <NEWLINE> <NL> <NL> class Solution : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> @ staticmethod <NEWLINE> def insertion_sort ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> array_length = raw_input ( ) <NEWLINE> unsorted_array = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , array_length ) : <NEWLINE> <INDENT> v = unsorted_array [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and unsorted_array [ j ] > v : <NEWLINE> <INDENT> unsorted_array [ j + 1 ] = unsorted_array [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> unsorted_array [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( str ( i ) for i in unsorted_array ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . insertion_sort ( ) <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> . join ( map ( str , a ) ) <NEWLINE> for i in xrange ( 1 , len ( a ) - 1 ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 & & a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> print <STRING> . join ( map ( str , a ) ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if N == 1 : <NEWLINE> <INDENT> print ( A [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> j = i <NEWLINE> <NL> while j > 0 and A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> if A [ j ] > A [ j - 1 ] : <NEWLINE> <NL> <INDENT> break <NEWLINE> k = A [ j ] <NEWLINE> l = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = k <NEWLINE> A [ j ] = l <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> S = str ( A [ 0 ] ) <NEWLINE> for k in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> S += <STRING> + str ( A [ k ] ) <NEWLINE> <NL> <DEDENT> S = S + <STRING> + str ( A [ N - 1 ] ) <NEWLINE> print ( S ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> B = [ print ( <STRING> . join ( A [ k ] ) ) for k in range ( N ) ] <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( * A ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j > = 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( * A ) <NEWLINE> <DEDENT>
def insertionSort ( A , N ) : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print ( * A ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( * insertionSort ( A , N ) ) <NEWLINE> <DEDENT>
def insertionSort ( * args ) : <NEWLINE> <INDENT> l = list ( args ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = l [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and l [ j ] > v : <NEWLINE> <INDENT> l [ j + 1 ] = l [ j ] <NEWLINE> j -= 1 <NEWLINE> l [ j + 1 ] = v <NEWLINE> print <STRING> . join ( map ( str , l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> l = [ input ( ) for i in range ( n ) ] <NEWLINE> insertionSort ( * l ) <NEWLINE>
def insertion_sort ( A , N ) : <NEWLINE> <INDENT> for i in range ( len ( N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j - - <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> insertion_sort ( A ) <NEWLINE> print ( * A ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , len ( A ) + 1 ) : <NEWLINE> <INDENT> print ( * A ) <NEWLINE> key = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > key : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = key <NEWLINE> <DEDENT>
_ = input ( ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> print ( <STRING> . join ( A ) ) <NEWLINE> key = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > key : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = key <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( map ( int , a ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def insertin_sort ( a , n ) : <NEWLINE> <INDENT> array_print ( a ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> array_print ( a ) <NEWLINE> <NL> <DEDENT> <DEDENT> def array_print ( a ) : <NEWLINE> <INDENT> buf = <STRING> <NEWLINE> for i in a : <NEWLINE> <INDENT> buf += str ( i ) + <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> print buf <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> insertin_sort ( a , n ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> a . append ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j = j - 1 <NEWLINE> a [ j + 1 ] = v <NEWLINE> <DEDENT> print ( a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> N = input ( ) <NEWLINE> <NL> inputList = list ( map ( int , input . split ( ) ) ) <NEWLINE> <NL> def formatting ( nums ) : <NEWLINE> <INDENT> for i in range ( len ( nums ) ) : <NEWLINE> <INDENT> if i != len ( nums ) - 1 : <NEWLINE> <INDENT> print ( nums [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( nums [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def insertionSort ( A , N ) : <NEWLINE> <INDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> <NL> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> formatting ( A ) <NEWLINE> <NL> <DEDENT> <DEDENT> formatting ( inputList ) <NEWLINE> insertionSort ( inputList , N ) <NEWLINE> <NL>
kazu = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . spllit ( ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> j = 0 <NEWLINE> for i in range ( kazu - 1 ) : <NEWLINE> <INDENT> print ( A [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ kazu - 1 ] ) <NEWLINE> <NL> for i in range ( 1 , kazu ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> <NL> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j = j - 1 <NEWLINE> A [ j + 1 ] = v <NEWLINE> <DEDENT> for i in range ( kazu - 1 ) : <NEWLINE> <INDENT> print ( A [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ kazu - 1 ] ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = z [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and z [ j ] > v : <NEWLINE> <INDENT> z [ j + 1 ] = z [ j ] <NEWLINE> j -= 1 <NEWLINE> <NL> <DEDENT> z [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( z ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print A [ i ] , <NEWLINE> print A [ - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print A [ i ] , <NEWLINE> <DEDENT> print A [ - 1 ] <NEWLINE> <DEDENT>
def inserrtionsort ( l , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( l ) ) <NEWLINE> v = l [ i ] <NEWLINE> j = i - 1 <NEWLINE> while v < l [ j ] and j >= 0 : <NEWLINE> <INDENT> l [ j + 1 ] = l [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> l [ j + 1 ] = v <NEWLINE> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE> <DEDENT> m = int ( input ( ) ) <NEWLINE> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> inserrtionsort ( n , m ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a = l [ i ] <NEWLINE> j = i - 1 <NEWLINE> <NL> while j >= 0 and l [ j ] > a : <NEWLINE> <INDENT> l [ j + 1 ] = l [ j ] <NEWLINE> j = j - 1 <NEWLINE> <NL> <DEDENT> l [ j + 1 ] = a <NEWLINE> print ( * 1 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> def insertSort ( array ) : <NEWLINE> <INDENT> for i in array [ 1 : ] : <NEWLINE> <INDENT> [ print ( array [ i ] ) for i in array ] <NEWLINE> v = array [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and array [ j ] > v : <NEWLINE> <INDENT> array [ j + 1 ] = array [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> array [ j + 1 ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> index = [ int for i in input ( ) . split ( ) ] <NEWLINE> insertSort ( index ) <NEWLINE> <DEDENT>
def print_tmp ( a_li ) : <NEWLINE> <INDENT> t = <STRING> . join ( a_li ) <NEWLINE> print ( t ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> A = [ int ( i ) for i in a . split ( <STRING> ) ] <NEWLINE> print_tmp ( A ) <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print_tmp ( A ) <NEWLINE> <DEDENT> print_tmp ( A ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( int , A ) ) ) <NEWLINE> j = i - 1 <NEWLINE> while A [ j ] < A [ j - 1 ] and j > 0 : <NEWLINE> <INDENT> ( A [ j ] , A [ j - 1 ] ) = ( A [ j - 1 ] , A [ j ] ) <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( map ( int , A ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) ) ) <NEWLINE> def insertionSort ( a , n ) : <COMMENT> <NEWLINE> <INDENT> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <COMMENT> <NEWLINE> j -= 1 <NEWLINE> print ( <STRING> . join ( a ) ) <COMMENT> <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> insertionSort ( l , n ) <NEWLINE>
N = input ( ) <NEWLINE> n = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> for i in range ( 1 , int ( N ) ) : <NEWLINE> <INDENT> v = n [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and v < n [ j ] : <NEWLINE> <INDENT> n [ j + 1 ] = n [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> n [ j + 1 ] = v <NEWLINE> print ( n . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = array [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and array [ j ] > v : <NEWLINE> <INDENT> array [ j + 1 ] = array [ j ] <NEWLINE> j -= 1 <NEWLINE> array [ j + 1 ] = v <NEWLINE> <DEDENT> array = list ( map ( str , array ) ) <NEWLINE> x = <STRING> . join ( array ) <NEWLINE> print ( x ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> N = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 ) & ( A [ j ] > v ) : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> A [ j + 1 ] = v <NEWLINE> print <STRING> . join ( map ( str , A ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> length = int ( raw_input ( ) ) <NEWLINE> elements = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . join ( str ( i ) for i in elements ) ) <NEWLINE> <NL> sorted_list = [ elements [ 0 ] ] <NEWLINE> for i in range ( 1 , length ) : <NEWLINE> <INDENT> element = elements [ i ] <NEWLINE> for j in range ( 0 , len ( sorted_list ) + 1 ) : <NEWLINE> <INDENT> if j == len ( sorted_list ) : <NEWLINE> <INDENT> sorted_list . append ( element ) <NEWLINE> break <NEWLINE> <DEDENT> elif element < sorted_list [ j ] : <NEWLINE> <INDENT> sorted_list . insert ( j , element ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> output_list = sorted_list [ 0 : i + 1 ] + elements [ i + 1 : ] <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in output_list ] ) ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> print A <NEWLINE> <DEDENT> for j in range ( 1 , n ) : <NEWLINE> <INDENT> key = A [ j ] <NEWLINE> <COMMENT> <NL> i = j - 1 <NEWLINE> while i >= 0 and A [ i ] > key : <NEWLINE> <INDENT> A [ i + 1 ] = A [ i ] <NEWLINE> i -= 1 <NEWLINE> <DEDENT> A [ i + 1 ] = key <NEWLINE> print A <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> . join ( map ( str , a ) ) <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j - - <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> print <STRING> . join ( map ( str , a ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - 1 <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + 1 ] = a [ j ] <NEWLINE> j = j - 1 <NEWLINE> <DEDENT> a [ j + 1 ] = v <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> lst = i . split ( <STRING> ) <NEWLINE> lst = map ( int , lst ) <NEWLINE> lst . sort ( ) <NEWLINE> <NL> n = 1 <NEWLINE> while n <= lst [ 0 ] / 2 : <NEWLINE> <INDENT> if lst [ 0 ] % n == 0 and lst [ 1 ] % ( lst [ 0 ] / n ) == 0 : <NEWLINE> <INDENT> print lst [ 0 ] / n <NEWLINE> break <NEWLINE> <DEDENT> n = n + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT> sys . exit ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> tmp = y <NEWLINE> <NL> if y > x : <NEWLINE> <INDENT> y = x <NEWLINE> x = tmp <NEWLINE> <NL> <DEDENT> while not y == 0 : <NEWLINE> <INDENT> y = x % y <NEWLINE> x = tmp <NEWLINE> tmp = y <NEWLINE> <NL> <DEDENT> return x <NEWLINE> <DEDENT> def main ( ) : <NEWLINE> <INDENT> target = [ int ( a ) for a in input ( ) . split ( ) ] <NEWLINE> print ( gcd ( a [ 0 ] , a [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
line = input ( ) . split ( ) <NEWLINE> x = int ( line [ 0 ] ) <NEWLINE> y = int ( line [ 1 ] ) <NEWLINE> r = x % y <NEWLINE> while ( r > 0 ) : <NEWLINE> <INDENT> x = y <NEWLINE> y = r <NEWLINE> r = x % y <NEWLINE> <DEDENT> return y <NEWLINE> <NL> print ( y ) <NEWLINE> <NL>
def lcd ( a , b ) : <COMMENT> <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> return lcd ( a - b , b ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return lcd ( b - a , a ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> return a <NEWLINE> <NL> <DEDENT> <DEDENT> a , b = input ( ) . split ( ) <NEWLINE> print ( lcd ( a , b ) ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> n = min ( x , y ) <NEWLINE> array = range ( 1 , n + 1 ) <NEWLINE> array . reverse ( ) <NEWLINE> for d in array : <NEWLINE> <INDENT> if x % d == 0 and y % d == 0 : <NEWLINE> <INDENT> return d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> print gcd ( a , b ) <NEWLINE>
def gc ( x , y ) : <NEWLINE> <INDENT> while y > 0 : <NEWLINE> <INDENT> x %= y <NEWLINE> x , y = y , x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <NL> <DEDENT> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( gc ( a , b ) ) <NEWLINE>
from fractions import gcd <NEWLINE> print gcd ( * map ( int , raw_input ( ) . split ( ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = a <NEWLINE> if a > b : <NEWLINE> <INDENT> m = b <NEWLINE> <DEDENT> max = 0 <NEWLINE> for i in range ( 1 , m + 1 ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> max = i <NEWLINE> <DEDENT> <DEDENT> print max <NEWLINE>
while x > 0 : <NEWLINE> <INDENT> z = x <NEWLINE> x = y % x <NEWLINE> y = z <NEWLINE> <DEDENT> print ( y ) <NEWLINE>
x , y = ( int ( s ) for s in input ( ) . split ( ) ) <NEWLINE> while y > 0 <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
in = input ( ) . split ( ) <NEWLINE> A = int ( in [ 0 ] ) <NEWLINE> B = int ( in [ 1 ] ) <NEWLINE> <NL> if A < B : <NEWLINE> <INDENT> v = B <NEWLINE> B = A <NEWLINE> A = v <NEWLINE> <NL> <DEDENT> R = A % B <NEWLINE> while R != 0 : <NEWLINE> <INDENT> R = A % B <NEWLINE> A = B <NEWLINE> B = R <NEWLINE> <DEDENT> return A <NEWLINE>
import sys <NEWLINE> <NL> line = sys . stdin . readline ( ) <NEWLINE> x , y = line . split ( <STRING> ) <NEWLINE> <NL> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> divide = 1 <NEWLINE> <NL> if x > y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> for i in range ( 2 , y + 2 ) : <NEWLINE> <INDENT> if x % i == 0 and y % i == 0 : <NEWLINE> <INDENT> divide = divide * i <NEWLINE> x = x / i <NEWLINE> y = y / i <NEWLINE> i = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print divide <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) <NEWLINE>
<COMMENT> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> print x <NEWLINE> return <NEWLINE> <DEDENT> a = x % y <NEWLINE> y_ans = [ ] <NEWLINE> two_ans = [ ] <NEWLINE> y_ans . append ( 1 ) <NEWLINE> two_ans . append ( 1 ) <NEWLINE> for i in range ( 2 , y // 2 + 1 ) : <NEWLINE> <INDENT> if y % i == 0 : <NEWLINE> <INDENT> y_ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> for i in range ( 2 , a // 2 + 1 ) : <NEWLINE> <INDENT> if a % i == 0 : <NEWLINE> <INDENT> two_ans . append ( i ) <NEWLINE> <DEDENT> <DEDENT> yset = set ( y_ans ) <NEWLINE> twoset = set ( two_ans ) <NEWLINE> matched = list ( yset & twoset ) <NEWLINE> print max ( matched ) <NEWLINE> <NL> <DEDENT> n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n . sort ( reverse = True ) <NEWLINE> gcd ( n [ 0 ] , n [ 1 ] ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if ( a < b ) : <NEWLINE> <INDENT> t = a <NEWLINE> a = b <NEWLINE> b = t <NEWLINE> <DEDENT> m = a % b <NEWLINE> if m == 0 : print min ( a , b ) <NEWLINE> for i in range ( m , 0 , - 1 ) : <NEWLINE> <INDENT> if m % i == 0 and b % i == 0 : <NEWLINE> <INDENT> print i <NEWLINE> break ; <NEWLINE> <DEDENT> <DEDENT>
def gcd_loop ( a , b ) : <NEWLINE> <INDENT> if a < 0 : a = - a <NEWLINE> if b < 0 : b = - b <NEWLINE> if b < a : b , a = a , b <NEWLINE> if a == 0 : <NEWLINE> <INDENT> return b <NEWLINE> <DEDENT> while True : <NEWLINE> <INDENT> if b % a == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> a , b = b % a , a <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> xg = set ( ) <NEWLINE> yg = set ( ) <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> xg . add ( i ) <NEWLINE> <DEDENT> <DEDENT> for j in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> if y % j == 0 : <NEWLINE> <INDENT> yg . add ( j ) <NEWLINE> <DEDENT> <DEDENT> gcd = xg & yg <NEWLINE> print ( max ( gcd ) ) <NEWLINE>
import math <NEWLINE> <NL> ( a , b ) = tuple ( [ int ( s ) for s in input ( ) . split ( ) ] ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( a ) <NEWLINE> return <NEWLINE> <NL> <DEDENT> min = a if a < b else b <NEWLINE> divisor = 1 <NEWLINE> <NL> i = 2 <NEWLINE> while i < math . sqrt ( min ) : <NEWLINE> <INDENT> if a % i == 0 and b % i == 0 : <NEWLINE> <INDENT> a = a / i <NEWLINE> b = b / i <NEWLINE> divisor = divisor * i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( divisor ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> temp = 1 <NEWLINE> while ( i <= b ) : <NEWLINE> <INDENT> while ( a % i == 0 and b % i == 0 ) : <NEWLINE> <INDENT> temp = temp * i <NEWLINE> a = a / i <NEWLINE> b = b / i <NEWLINE> <DEDENT> if ( i % 2 == 0 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = i + 2 <NEWLINE> <DEDENT> <DEDENT> print temp <NEWLINE> <NL> <DEDENT> l = raw_input ( ) . split ( ) <NEWLINE> if ( int ( l [ 0 ] ) > int ( l [ 1 ] ) ) : <NEWLINE> <INDENT> gcd ( int ( l [ 0 ] ) , int ( l [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gcd ( int ( l [ 1 ] ) , int ( l [ 0 ] ) ) <NEWLINE> <DEDENT>
line = input ( ) . split ( ) <NEWLINE> x = int ( line [ 0 ] ) <NEWLINE> y = int ( line [ 1 ] ) <NEWLINE> if x < y : <NEWLINE> <INDENT> temp = x <NEWLINE> x = y <NEWLINE> y = temp <NEWLINE> <DEDENT> def greatst ( x , y ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return greatst ( y , x % y ) <NEWLINE> <DEDENT> <DEDENT> print ( greatst ( x , y ) ) <NEWLINE>
def gcd ( a , b ) : <NEWLINE> <INDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> c = a % b <NEWLINE> return gcd ( b , c ) <NEWLINE> <DEDENT> x = int ( input ( <STRING> ) ) <NEWLINE> y = int ( input ( <STRING> ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> m = gcd ( x , y ) <NEWLINE> print ( m ) <NEWLINE> def gcd ( x , y ) : <NEWLINE>
def calc_gcd ( a , b ) : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> <DEDENT> if b == a : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> return calc_gcd ( b , a % b ) <NEWLINE> <NL> <DEDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( calc_gcd ( x , y ) ) ) <NEWLINE> <NL>
n = input ( ) . split ( ) <NEWLINE> <NL> x = n [ 0 ] <NEWLINE> y = n [ 1 ] <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while y > 0 : <NEWLINE> <INDENT> r = x % y <NEWLINE> x = y <NEWLINE> y = r <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE> <NL>
import re <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> if x == y : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> if x < y and y % x == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> if x > y and x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <NL> <NL> <DEDENT> l = list ( range ( 1 , int ( min ( x , y ) / 2 ) + 1 ) ) <NEWLINE> l . reverse ( ) <NEWLINE> r = 1 <NEWLINE> <COMMENT> <NL> for i in l : <NEWLINE> <INDENT> if x % i == 0 and y % i == 0 : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> x , y = map ( int , re . split ( <STRING> , raw_input ( ) ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE>
<COMMENT> <NL> def common_div ( x , y ) : <NEWLINE> <INDENT> divisor = 0 <NEWLINE> x_mul = 0 <NEWLINE> if x > y : <NEWLINE> <INDENT> x = x % y <NEWLINE> for i in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if y % i == 0 and x % i == 0 : <NEWLINE> <INDENT> divisor = i <NEWLINE> <DEDENT> <DEDENT> return divisor <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> divisor = x <NEWLINE> return divisor <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in [ 2 , 3 , 5 , 7 ] : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> x_mul = i <NEWLINE> <DEDENT> <DEDENT> if x_mul != 0 : <NEWLINE> <INDENT> for j in x_mul * range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if y % j == 0 and x % j == 0 : <NEWLINE> <INDENT> divisor = j <NEWLINE> <DEDENT> if x <= j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> return divisor <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for k in range ( 1 , x + 1 ) : <NEWLINE> <INDENT> if y % i == 0 and x % i == 0 : <NEWLINE> <INDENT> divisor = i <NEWLINE> <DEDENT> <DEDENT> return divisor <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> num1 , num2 = raw_input ( ) . split ( ) <NEWLINE> maximam = common_div ( int ( num1 ) , int ( num2 ) ) <NEWLINE> print ( maximam ) <NEWLINE> <NL>
x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x == y : <NEWLINE> <INDENT> print x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y > x : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <DEDENT> i = 2 <NEWLINE> ans = 1 <NEWLINE> al = [ ] <NEWLINE> while i <= x / 2 : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> if y % i == 0 : <NEWLINE> <INDENT> al . append ( i ) <NEWLINE> x = x / i <NEWLINE> y = y / i <NEWLINE> continue <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> if len ( al ) == 0 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in al : <NEWLINE> <INDENT> ans *= j <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> <DEDENT>
from fractions import gcd <NEWLINE> x , y = int ( input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE>
x , y = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> def gcd ( a , b ) : <NEWLINE> <INDENT> m = a % b <NEWLINE> return gcd ( b , m ) if r else n <NEWLINE> <DEDENT> print ( gcd ( x , y ) ) <NEWLINE> <NL> <NL>
x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <NL> <DEDENT> while y != 0 <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> print x <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> while True : <NEWLINE> <INDENT> r = a % b <NEWLINE> if r == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = b <NEWLINE> b = r <NEWLINE> <DEDENT> <DEDENT> print ( b ) <NEWLINE>
def gdc ( x , y ) : <NEWLINE> <INDENT> if x % y == 0 : <NEWLINE> <INDENT> return y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gdc ( x , x % y ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE> <DEDENT>
data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( data [ 0 ] < data [ 1 ] ) : data [ 0 ] , data [ 1 ] = data [ 1 ] , data [ 0 ] <NEWLINE> <NL> def gcd ( x , y ) : <NEWLINE> <INDENT> return x if y == 0 else gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> else : print ( gcd ( data [ 0 ] , data [ 1 ] ) ) <NEWLINE>
data = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] ; <NEWLINE> <NL> def gcd ( m , n ) : <NEWLINE> <INDENT> m = m % n ; <NEWLINE> if m == 0 : <NEWLINE> <INDENT> return n ; <NEWLINE> <DEDENT> return gcd ( n , m ) ; <NEWLINE> <NL> <DEDENT> print ( gcd ( max ( data ) , min ( data ) ) ; <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while True <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> x %= y <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> y %= x <NEWLINE> <DEDENT> if x == y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
x , y = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> if ( x < y ) : <NEWLINE> <INDENT> x , y = y , x <NEWLINE> <DEDENT> while b > 0 : <NEWLINE> <INDENT> x , y = x , x % y <NEWLINE> <DEDENT> print ( x ) <NEWLINE> <NL>
s = input ( ) <NEWLINE> x , y = map ( int , s ) <NEWLINE> <NL> while ( x != y or x != 1 or y != 1 ) <NEWLINE> <INDENT> if ( x < y ) : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <NL> <DEDENT> x %= y <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
def gcd ( x , y ) : <NEWLINE> <INDENT> if y == 0 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gcd ( y , x % y ) <NEWLINE> <NL> <DEDENT> <DEDENT> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( gcd ( x , y ) ) <NEWLINE> <NL>
def main ( ) <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> while y != 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <NL> <DEDENT> print ( x ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> A = line . split ( ) <NEWLINE> B = map ( int , A ) <NEWLINE> if B [ 0 ] < B [ 1 ] : <NEWLINE> <INDENT> p = B [ 1 ] <NEWLINE> B [ 1 ] = B [ 0 ] <NEWLINE> B [ 0 ] = p <NEWLINE> <DEDENT> e = 1 <NEWLINE> <NL> while e != 0 : <NEWLINE> <INDENT> e = B [ 0 ] % B [ 1 ] <NEWLINE> C = B [ 1 ] <NEWLINE> B [ 1 ] = e <NEWLINE> B [ 0 ] = C <NEWLINE> <NL> <DEDENT> print B [ 0 ] <NEWLINE> <DEDENT>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a . sort ( ) <NEWLINE> while a [ 1 ] % a [ 0 ] != 0 : <NEWLINE> <INDENT> a [ 0 ] , a [ 1 ] = a [ 1 ] % a [ 0 ] , a [ 0 ] <NEWLINE> <DEDENT> return a [ 0 ] <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while x > 0 : <NEWLINE> <INDENT> x , y = y , x % y <NEWLINE> <DEDENT> print ( x ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if x >= y : <NEWLINE> <INDENT> x = x % y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = y % x <NEWLINE> <DEDENT> if x % y == 0 : <NEWLINE> <INDENT> print ( x ) <NEWLINE> break <NEWLINE> <DEDENT> elif y % x == 0 : <NEWLINE> <INDENT> print ( y ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> input_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> x = input_list [ 0 ] <NEWLINE> y = input_list [ 1 ] <NEWLINE> <NL> if x < y : <NEWLINE> <INDENT> tmp = x <NEWLINE> x = y <NEWLINE> y = tmp <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> print ( x ) <NEWLINE> sys . exit ( 0 ) <NEWLINE> <NL> <DEDENT> x_y_divisor = list ( ) <NEWLINE> y_divisor = list ( ) <NEWLINE> x_mod_y = x % y <NEWLINE> <NL> for i in range ( 1 , ( x_mod_y ) + 1 ) : <NEWLINE> <INDENT> if x_mod_y % i == 0 : <NEWLINE> <INDENT> x_y_divisor . append ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( 1 , y + 1 ) : <NEWLINE> <INDENT> if y % i == 0 : <NEWLINE> <INDENT> y_divisor . append ( i ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> x_y_divisor_set = set ( x_y_divisor ) <NEWLINE> y_divisor_set = set ( y_divisor ) <NEWLINE> <NL> ans_divisor = y_divisor_set . intersection ( x_y_divisor_set ) <NEWLINE> print ( max ( ans_divisor ) ) <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import print_function <NEWLINE> import time <NEWLINE> import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> h , i = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <NL> while i != 0 : <NEWLINE> <INDENT> siki = h % i <NEWLINE> h = i <NEWLINE> i = siki <NEWLINE> <NL> <DEDENT> print ( h , end = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> def gcd ( a , b ) : <NEWLINE> <INDENT> temp = a <NEWLINE> if a < b : <NEWLINE> <INDENT> a = b <NEWLINE> b = a <NEWLINE> <DEDENT> if b == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> c = a % b <NEWLINE> return gcd ( b , c ) <NEWLINE> <NL> <NL> <DEDENT> line = sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> A = int ( line [ 0 ] ) <NEWLINE> B = int ( line [ 1 ] ) <NEWLINE> <NL> print ( gcd ( A , B ) ) <NEWLINE> return <NEWLINE>
x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> min_xy = min ( [ x , y ] ) <NEWLINE> gcd = 0 <NEWLINE> for i in range ( 1 , min_xy + 1 ) : <NEWLINE> <INDENT> if ( x % i == 0 ) & ( y % i == 0 ) : <NEWLINE> <INDENT> gcd = i <NEWLINE> <DEDENT> <DEDENT> print gcd <NEWLINE>
from fractions import gcd <NEWLINE> print ( gcd ( * set ( map ( int , input ( ) . split ( <STRING> ) ) ) ) ) <NEWLINE>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> x = max ( a , b ) <NEWLINE> y = min ( a , b ) <NEWLINE> <NL> while x % y > 0 : <NEWLINE> <INDENT> x = y <NEWLINE> y = x % y <NEWLINE> <NL> <DEDENT> print ( y ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> for j in range ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif x % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x % j != 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> print ( len ( 1 for x in map ( int , sys . stdin ) if 2 in [ x , pow ( 2 , x , x ) ] ) ) <NEWLINE>
count = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> def ifprime ( num ) : <NEWLINE> <INDENT> for i in range ( 2 , num ** 0.5 + 1 ) : <NEWLINE> <INDENT> if num % i : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if ifprime ( a ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def euclid ( m , n ) : <NEWLINE> <INDENT> while m % n > 0 : <NEWLINE> <INDENT> m , n = n , m % n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> <DEDENT> def isprime_euclid2 ( N ) : <NEWLINE> <INDENT> if N < 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif N == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> euclid_list = [ ] <NEWLINE> for k in range ( 1 , int ( round ( math . sqrt ( N ) ) ) + 1 ) : <NEWLINE> <INDENT> euclid_list . append ( euclid ( N , k ) ) <NEWLINE> <DEDENT> temp = set ( euclid_list ) <NEWLINE> if len ( temp ) == 1 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> import math <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> total = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> if isprime_euclid2 ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> print total <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
def composite ( d , n , s ) : <NEWLINE> <INDENT> for a in ( 2 , 3 , 5 , 7 ) : <NEWLINE> <INDENT> maybe_prime = False <NEWLINE> if pow ( a , d , n ) == 1 : <NEWLINE> <INDENT> maybe_prime = True <NEWLINE> continue <NEWLINE> <DEDENT> for i in range ( s ) : <NEWLINE> <INDENT> if pow ( a , 2 ** i * d , n ) == n - 1 : <NEWLINE> <INDENT> maybe_prime = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return not probably_prime <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d , s = n - 1 , 0 <NEWLINE> while not d % 2 : <NEWLINE> <INDENT> d , s = d >> 1 , s + 1 <NEWLINE> <DEDENT> return not composite ( d , n , s ) <NEWLINE> <DEDENT> <DEDENT> r = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if is_prime ( n ) : <NEWLINE> <INDENT> if n not in r : <NEWLINE> <INDENT> r . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( len ( r ) ) <NEWLINE>
<NL> import math <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> b = 1 <NEWLINE> n = int ( input ( ) ) <NEWLINE> <INDENT> for j in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> if n % j == 0 : <NEWLINE> b = 0 <NEWLINE> break <NEWLINE> sum += b <NEWLINE> <NL> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> count = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if ( x == 2 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else if ( x % 2 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( pow ( 2 , x - 1 , x ) == 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
def isPrime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif ( x < 2 ) or ( x % 2 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 3 <NEWLINE> while i <= x ** ( 1 / 2 ) : <NEWLINE> <INDENT> if x % i : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> t = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if inPrime ( int ( input ( ) ) ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 0 , x ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> for j in range ( 2 , a ) : <NEWLINE> <INDENT> c = int ( a ) <NEWLINE> if a % j == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> break ; <NEWLINE> if j * j > c : <NEWLINE> break ; <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( x - count ) <NEWLINE> <NL> <NL>
import functools <NEWLINE> <NL> <NL> def divise ( n , divisor ) : <NEWLINE> <INDENT> if n % divisor == 0 and n != divisor : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> <DEDENT> number = int ( input ( ) ) <NEWLINE> origin = [ int ( input ( ) ) for _ in range ( number ) ] <NEWLINE> <NL> divised = origin <NEWLINE> <NL> for i in range ( 2 , max ( origin ) + 1 ) : <NEWLINE> <INDENT> divised = list ( map ( functools . partial ( divise , divisor = i ) , divised ) ) <NEWLINE> <NL> <DEDENT> for j in range ( number ) : <NEWLINE> <INDENT> if divised [ j ] == 0 : <NEWLINE> <INDENT> origin . pop ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( origin ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def isPrime ( n ) : <NEWLINE> <INDENT> if n <= 2 : <NEWLINE> <INDENT> return n == 2 <NEWLINE> <DEDENT> if ( n % 2 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 3 , math . sqrt ( n ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> print ( len ( list ( filter ( isPrime , [ int ( input ( ) ) for i in range ( N ) ] ) ) ) ) <NEWLINE> <NL>
def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if ( x == 1 ) or ( x % 2 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , sqrt ( x ) , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> element_number = int ( input ( ) ) <NEWLINE> input_array = [ int ( input ( ) ) for i in range ( element_number ) ] <NEWLINE> <NL> output = 0 <NEWLINE> for x in input_array : <NEWLINE> <INDENT> if ( is_prime ( x ) ) : <NEWLINE> <INDENT> output += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def isPrime ( x ) : <NEWLINE> <INDENT> if x == 1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for num in range ( x - 2 ) : <NEWLINE> <INDENT> if x % ( num + 2 ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> input = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> input . append ( int ( line ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> count = 0 <NEWLINE> for num in set ( input ) : <NEWLINE> <INDENT> if isPrime ( num ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print count <NEWLINE>
primes = [ 2 ] <NEWLINE> <NL> def is_prime ( num ) : <NEWLINE> <INDENT> root = num ** 0.5 <NEWLINE> for prime in primes : <NEWLINE> <INDENT> if root < prime : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if num % prime == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def create_primes ( primes , max ) : <NEWLINE> <INDENT> for i in range ( primes [ - 1 ] + 1 , max ) : <NEWLINE> <INDENT> if is_prime ( i ) : <NEWLINE> <INDENT> primes += [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> create_primes ( primes , 10000 ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> if is_prime ( int ( input ( ) ) ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> ls = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> r = max ( ls ) + 1 <NEWLINE> sqrt = int ( math . sqrt ( r ) ) <NEWLINE> p = [ 1 ] * r <NEWLINE> p [ 0 ] = 0 <NEWLINE> for i in range ( 1 , sqrt ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> p [ 2 * i + 1 : : i + 1 ] = [ 0 for x in range ( 2 * i + 1 , r , i + 1 ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> ans = 0 <NEWLINE> for i in ls : <NEWLINE> <INDENT> ans += p [ i - 1 ] <NEWLINE> <DEDENT> print ans <NEWLINE>
def prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i <= x ** ( 1 / 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return false <NEWLINE> <DEDENT> i = i + 2 <NEWLINE> <NL> <DEDENT> return true <NEWLINE> <NL> <DEDENT> L = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> L . append ( i ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> K = 0 <NEWLINE> for i in range ( len ( L ) ) : <NEWLINE> <INDENT> if prime ( L [ i ] ) : <NEWLINE> <INDENT> K += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( K ) <NEWLINE>
N = input ( ) <NEWLINE> c = 0 <NEWLINE> p = [ 0 for i in range ( N ) ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> p [ i ] = input ( ) <NEWLINE> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> j = p [ i ] - 1 <NEWLINE> while ( j > 1 ) : <NEWLINE> <INDENT> if ( p [ i ] % j == 0 ) : break <NEWLINE> j -= 1 <NEWLINE> <DEDENT> if ( j == 1 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE>
def get_primes ( n ) : <NEWLINE> <INDENT> x = [ 0 , 0 ] + [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> for i in range ( int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> e = x [ i ] <NEWLINE> if e != 0 : <NEWLINE> <INDENT> for j in range ( e * 2 , n + 1 , e ) : <NEWLINE> <INDENT> x [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return x <NEWLINE> <NL> <DEDENT> PRIMES = get_primes ( 100000000 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> if x [ p ] == 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print c <NEWLINE>
from operator import itemgetter <NEWLINE> <NL> def eratosthenes ( n ) : <NEWLINE> <INDENT> table = [ True ] * ( n + 1 ) <NEWLINE> table [ 0 ] = table [ 1 ] = True <NEWLINE> for i in range ( 2 , int ( round ( pow ( n , 0.5 ) ) ) ) : <NEWLINE> <INDENT> if not table [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i + i , n , i ) : <NEWLINE> <INDENT> table [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return table <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> f = itemgetter ( * [ int ( input ( ) ) for _ in range ( N ) ] ) <NEWLINE> print ( sum ( f ( eratosthenes ( 10 ** 8 ) ) ) ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> <NL> pn = [ ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <NL> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> <NL> if a == 2 : <NEWLINE> <INDENT> c += 1 <NEWLINE> pn . append ( a ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for x in pn : <NEWLINE> <INDENT> if a == x : <NEWLINE> <INDENT> c += 1 <NEWLINE> pn . append ( a ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for x in xrange ( 2 , a ) : <NEWLINE> <INDENT> if a % x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if a - 1 == x and a % x != 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print c <NEWLINE>
import math <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if ( x == 1 ) or ( x % 2 == 0 ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , math . ceil ( math . sqrt ( x ) ) + 1 , 2 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> element_number = int ( input ( ) ) <NEWLINE> <NL> output = 0 <NEWLINE> for x in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> if ( is_prime ( x ) ) : <NEWLINE> <INDENT> output += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( output ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def get_prime_list ( max_num ) : <NEWLINE> <INDENT> res = range ( 2 , max_num + 1 ) <NEWLINE> for i in range ( 2 , max_num / 2 + 1 ) : <NEWLINE> <INDENT> res = filter ( lambda x : not ( ( x % i == 0 ) and ( x != i ) ) , res ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> def is_include ( array , num ) : <NEWLINE> <INDENT> right = len ( array ) - 1 <NEWLINE> left = 0 <NEWLINE> while right >= left : <NEWLINE> <INDENT> index = ( right + left ) / 2 <NEWLINE> if array [ index ] == num : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif array [ index ] < num : <NEWLINE> <INDENT> left = index + 1 <NEWLINE> <DEDENT> elif array [ index ] > num : <NEWLINE> <INDENT> right = index - 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> num = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> num_list = [ int ( sys . stdin . readline ( ) . strip ( ) ) for i in xrange ( 0 , num ) ] <NEWLINE> prime_list = sorted ( get_prime_list ( max ( num_list ) ) ) <NEWLINE> print len ( filter ( lambda x : is_include ( prime_list , x ) , num_list ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> s = 0 <NEWLINE> while n > 0 : <NEWLINE> <INDENT> n -= 1 <NEWLINE> a = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 1 , int ( a ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> count += ( a % i == 0 ) <NEWLINE> <DEDENT> if count == 1 : <NEWLINE> <INDENT> s += 1 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print s <NEWLINE> <NL>
import math <NEWLINE> import sys <NEWLINE> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x == 1 : return 0 <NEWLINE> if x == 2 : return 1 <NEWLINE> n = 3 <NEWLINE> while n <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % n == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> n += 2 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> count += is_prime ( x ) <NEWLINE> <DEDENT> print count <NEWLINE> ~ <NEWLINE>
count = 0 <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if mod ( 2 , n - 1 , n ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT>
N = input ( ) <NEWLINE> pnum_count = N <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> pnum_count -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print pnum_count <NEWLINE>
def isPrime ( x ) : <NEWLINE> <INDENT> if 2 == x or 3 == x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if 0 == x % 2 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> for i in range ( 3 , x ) : <NEWLINE> <INDENT> if x < i * i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if 0 == x % i : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = int ( raw_input ( ) ) <NEWLINE> if isPrime ( num ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> n = input ( ) <NEWLINE> A = 0 <NEWLINE> def is_prime ( m ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( m ) ) + 1 ) : <NEWLINE> <INDENT> if m % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> if is_prime ( k ) : <NEWLINE> A += 1 <NEWLINE> <DEDENT> print A <NEWLINE>
import math <NEWLINE> <NL> def Eratos ( n ) : <NEWLINE> <INDENT> primes = [ 2 ] <NEWLINE> num = [ 2 * i + 1 for i in range ( 1 , n // 2 ) ] <NEWLINE> tmp = [ ] <NEWLINE> <NL> top = 1 <NEWLINE> while top < math . sqrt ( n ) : <NEWLINE> <INDENT> top = num [ 0 ] <NEWLINE> for i in range ( 1 , len ( num ) ) : <NEWLINE> <INDENT> if num [ i ] % top != 0 : <NEWLINE> <INDENT> tmp . append ( num [ i ] ) <NEWLINE> <DEDENT> <DEDENT> num = tmp <NEWLINE> tmp = [ ] <NEWLINE> primes . append ( top ) <NEWLINE> <DEDENT> for i in range ( len ( num ) ) : <NEWLINE> <INDENT> primes . append ( num [ i ] ) <NEWLINE> <DEDENT> return primes <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cont = 0 <NEWLINE> primes = Eratos ( 99999997 ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if primes . count ( a ) != 0 : <NEWLINE> <INDENT> cont += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cont ) <NEWLINE>
f = lambda x : 1 if ( not x < 2 and not x & 1 == 0 ) and ( x == 2 or x == 3 or pow ( 2 , x - 1 , x ) == 1 ) else 0 <NEWLINE> print ( count += f ( int ( input ( ) ) ) for _ in range ( int ( input ( ) ) ) ) <NEWLINE>
N = 10 ** 8 <NEWLINE> p = [ i for i in range ( N ) ] <NEWLINE> for i in range ( 2 , int ( N ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> for j in range ( i * i , N , i ) : p [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> p = sorted ( set ( p ) ) [ 2 : ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> print ( sum ( 1 for _ in range ( n ) if int ( input ( ) ) in p ) ) <NEWLINE>
def prime2 ( x ) : <NEWLINE> <INDENT> if x == 2 : return True <NEWLINE> else : <NEWLINE> <INDENT> for s in stock : <NEWLINE> <INDENT> if x % s == 0 : return False <NEWLINE> <DEDENT> for j in xrange ( 3 , int ( x * 0.5 ) , 2 ) : <NEWLINE> <INDENT> if x % j == 0 : return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stock . append ( x ) <NEWLINE> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> count = 0 <NEWLINE> stock = [ 2 ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if prime2 ( input ( ) ) : count += 1 <NEWLINE> <DEDENT> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> a [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> <NL> ans = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 2 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> elif a % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if math . pow ( 2 , a - 1 , a ) == 1 : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
<COMMENT> <NL> <NL> import numpy as np <NEWLINE> <NL> <NL> def is_prime ( number ) : <NEWLINE> <COMMENT> <NL> <INDENT> if number == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif number < 2 or number % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i = 3 <NEWLINE> while i <= np . sqrt ( number ) : <NEWLINE> <INDENT> if number % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> numbers = [ input ( ) for i in xrange ( N ) ] <NEWLINE> count = 0 <NEWLINE> for i in xrange ( len ( numbers ) ) : <NEWLINE> <INDENT> if is_prime ( numbers [ i ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <DEDENT>
import math <NEWLINE> cnt = 0 <NEWLINE> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n % 2 : <NEWLINE> <INDENT> area = round ( math . sqrt ( n ) ) <NEWLINE> prime_ng = 0 <NEWLINE> for i in range ( 2 , area + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> prime_ng = 1 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <DEDENT> if prime_ng == 0 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> elif n == 2 : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def checker ( x ) : <NEWLINE> <INDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> for i in range ( 2 , x ** 0.5 + 1 ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> v = int ( input ( ) ) <NEWLINE> if checker ( v ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> i = 3 <NEWLINE> while i <= math . sqrt ( x ) : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = i + 2 <NEWLINE> <NL> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> numbers = [ int ( input ( ) ) for i in n ] <NEWLINE> <NL> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if is_prime ( numbers [ i ] ) is True : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL>
import math <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> sqrtn = math . ceil ( math . sqrt ( n ) ) <NEWLINE> for i in range ( 2 , sqrtn + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return n != 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> for _ in range ( 0 , n + 1 ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if is_prime ( m ) : <NEWLINE> <INDENT> print ( m ) <NEWLINE> answer = answer + 1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
numbers = [ ] <NEWLINE> n = raw_input ( ) <NEWLINE> for i in range ( int ( n ) ) : <NEWLINE> <INDENT> input_num = raw_input ( ) <NEWLINE> numbers . append ( int ( input_num ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for num in numbers : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE>
s = [ 2 ] <NEWLINE> a = [ int ( i ) for i in range ( 2 , 100000000 ) if pow ( 2 , int ( i ) - 1 , int ( i ) ) == 1 ] <NEWLINE> <NL> while a != [ ] : <NEWLINE> <INDENT> t = a [ 0 ] <NEWLINE> a = [ i for i in a if i % t != 0 ] <NEWLINE> s . append ( t ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if int ( input ( ) ) in s : <NEWLINE> <INDENT> x += 1 <NEWLINE> <DEDENT> <DEDENT> print ( x ) <NEWLINE>
def isPrime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x < 2 or x % 2 == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i = 3 <NEWLINE> while i * 2 <= x : <NEWLINE> <INDENT> if x % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> i += 2 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> ct = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if isPrime ( input ( ) ) : <NEWLINE> <INDENT> ct += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ct ) <NEWLINE>
<COMMENT> <NL> array = [ ] <NEWLINE> cnt = 0 <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> array . append ( input ( ) ) <NEWLINE> <DEDENT> for value in array : <NEWLINE> <INDENT> for value2 in range ( 2 , value ) : <NEWLINE> <INDENT> if value % value2 == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print cnt <NEWLINE>
import math <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> if n == 1 : return False <NEWLINE> <NL> for k in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % k == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N = input ( ) <NEWLINE> l = [ input ( ) for i in range ( N ) ] <NEWLINE> a = 0 <NEWLINE> for i in range ( 0 , len ( l ) ) : <NEWLINE> <INDENT> if ( is_prime ( l [ i ] ) == True <NEWLINE> <INDENT> a += 1 <NEWLINE> <DEDENT> <DEDENT> print ( a ) <NEWLINE> <NL>
def get_primes ( n ) : <NEWLINE> <INDENT> x = [ 0 , 0 ] + [ i for i in range ( 2 , n + 1 ) ] <NEWLINE> for i in range ( int ( n ** 0.5 + 1 ) ) : <NEWLINE> <INDENT> e = x [ ] <NEWLINE> if e != 0 : <NEWLINE> <INDENT> for j in range ( e * 2 , n + 1 , e ) : <NEWLINE> <INDENT> x [ j ] = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return filter ( None , x ) <NEWLINE> <NL> <DEDENT> PRIMES = get_primes ( 10000 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p = int ( input ( ) ) <NEWLINE> f = 1 <NEWLINE> for e in PRIMES : <NEWLINE> <INDENT> if e >= p : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if p % e == 0 : <NEWLINE> <INDENT> f = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> c += f <NEWLINE> <DEDENT> print c <NEWLINE>
def isPrime ( n ) : <NEWLINE> <INDENT> if ( n < 4 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for i in range ( 2 , ( n / 2 ) + 1 ) : <NEWLINE> <INDENT> if ( 0 == ( n % i ) ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> n = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( isPrime ( input ( ) ) ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
prime = set ( [ 2 ] ) <NEWLINE> for i in range ( 3 , 100000000 , 2 ) : <NEWLINE> <INDENT> for j in prime : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> prime . add ( i ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in ( int ( input ( ) ) for _ in range ( n ) ) : <NEWLINE> <INDENT> if i in prime : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> count = 0 <NEWLINE> judge = 0 <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> num = int ( line . strip ( ) ) <NEWLINE> if judge == 0 : <NEWLINE> <INDENT> judge = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( 2 , math . sqrt ( num ) + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> cnt = n = int ( stdin . readline ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> v = int ( stdin . readline ( ) ) <NEWLINE> if v == 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif v % 2 == 0 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in xrange ( 3 , v // 2 , 2 ) : <NEWLINE> <INDENT> if v % i == 0 : <NEWLINE> <INDENT> cnt -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import math <NEWLINE> <NL> def prime ( num ) : <NEWLINE> <INDENT> for i in range ( math . sqrt ( num ) + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if prime ( int ( input ( ) ) ) : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nums . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 2 , int ( sqrt ( nums [ i ] ) + 1 ) ) : <NEWLINE> <INDENT> if nums [ i ] % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
def prime_number ( num ) : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif num % 2 != 0 : <NEWLINE> <INDENT> for j in range ( 3 , num , 2 ) : <NEWLINE> <INDENT> if num % j == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> num = int ( raw_input ( ) ) <NEWLINE> if prime_number ( num ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print count <NEWLINE>
def isPrime ( num ) : <NEWLINE> <INDENT> if num == 2 : return 1 <NEWLINE> if num < 2 or num & 1 == 0 : return 0 <NEWLINE> if pow ( 2 , num - 1 , num ) == 1 : return 1 <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> s = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> s += isPrime ( input ( ) ) <NEWLINE> <NL> <DEDENT> print s <NEWLINE>
<COMMENT> <NL> n = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> break_f = False <NEWLINE> j = 3 <NEWLINE> num = int ( raw_input ( ) ) <NEWLINE> if ( num < 2 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif ( num == 2 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif ( num % 2 == 0 ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while j < num : <NEWLINE> <INDENT> if ( num % j == 0 ) : <NEWLINE> <INDENT> j += 2 <NEWLINE> break_f = True <NEWLINE> break <NEWLINE> <DEDENT> j += 2 <NEWLINE> <DEDENT> if break_f == True : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> count += 1 <NEWLINE> <DEDENT> print ( count ) <NEWLINE> <NL>
n = inta ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> for i in range ( 2 , data ) : <NEWLINE> <INDENT> if ( data % i == 0 ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> <NL> def is_prime ( x , y ) : <NEWLINE> <INDENT> while ( y < x ) : <NEWLINE> <INDENT> if ( x % y == 0 ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> y += 2 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <DEDENT> a = <STRING> <NEWLINE> l = [ ] <NEWLINE> count = 0 <NEWLINE> for input in sys . stdin : <NEWLINE> <INDENT> a += input <NEWLINE> <DEDENT> l = ( a . split ( ) ) <NEWLINE> b = int ( l [ 0 ] ) <NEWLINE> l = sorted ( set ( l [ 1 : ] ) ) <NEWLINE> for i in l : <NEWLINE> <INDENT> if ( int ( i ) == 2 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif ( int ( i ) > 2 and int ( i ) % 2 != 0 and is_prime ( int ( i ) , 3 ) == 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE>
import math <NEWLINE> num_max = 10000000 <NEWLINE> isPrimeNum = [ True for i in range ( 0 , num_max + 1 ) ] <NEWLINE> <NL> isPrimeNum [ 0 ] == False <NEWLINE> isPrimeNum [ 1 ] == False <NEWLINE> <NL> for i in range ( 2 , int ( math . sqrt ( num_max ) ) + 1 ) : <NEWLINE> <INDENT> if isPrimeNum [ i ] == True : <NEWLINE> <INDENT> for j in range ( i ** 2 , num_max , i ) : <NEWLINE> <INDENT> isPrimeNum [ j ] = False <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> num_len = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( num_len ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> if isPrimeNum [ num ] == True : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( cnt ) ) <NEWLINE>
N = input ( ) <NEWLINE> prime = 0 <NEWLINE> checked = 2 <NEWLINE> primeList = [ 2 ] <NEWLINE> <NL> def is_prime ( n ) : <NEWLINE> <INDENT> global checked <NEWLINE> if n <= checked : <NEWLINE> <INDENT> if n in primeList : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> for i in xrange ( checked + 1 , n + 1 ) : <NEWLINE> <INDENT> isPrime = True <NEWLINE> for p in primeList : <NEWLINE> <INDENT> if i % p == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> isPrime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for p in xrange ( checked + 1 , i ) : <NEWLINE> <INDENT> if i % p == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> isPrime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if isPrime : <NEWLINE> <INDENT> primeList . append ( i ) <NEWLINE> <DEDENT> <DEDENT> checked = n <NEWLINE> if primeList [ - 1 ] == n : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for _ in xrange ( N ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> prime += 1 if is_prime ( n ) else 0 <NEWLINE> <DEDENT> print prime <NEWLINE>
def witness ( a , n , t , u ) : <NEWLINE> <INDENT> x = pow ( a , u , n ) <COMMENT> <NEWLINE> y = x <NEWLINE> <NL> for _ in range ( 0 , t ) : <NEWLINE> <INDENT> y = ( x * x ) % n <NEWLINE> <NL> <COMMENT> <NL> if y == 1 and x != 1 and x != ( n - 1 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> x = y <NEWLINE> <DEDENT> return y != 1 <NEWLINE> <NL> <DEDENT> def is_probably_prime ( n , witnesses ) : <NEWLINE> <INDENT> t = 1 <NEWLINE> u = n >> 1 <NEWLINE> while u & 1 == 0 : <NEWLINE> <INDENT> t = t + 1 <NEWLINE> u >>= 1 <NEWLINE> <DEDENT> assert ( 2 ** t * u == n - 1 ) <NEWLINE> <NL> for a in witnesses : <NEWLINE> <INDENT> if a < n and witness ( a , n , t , u ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def is_definitely_prime ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return is_probably_prime ( n , [ 2 , 7 , 61 ] ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> answer = 0 <NEWLINE> for _ in range ( 0 , n ) : <NEWLINE> <INDENT> m = int ( input ( ) ) <NEWLINE> if is_definitely_prime ( m ) : <NEWLINE> <INDENT> answer = answer + 1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
<NL> def isprime ( number ) : <NEWLINE> <INDENT> if number == 2 or 2 ** ( number - 1 ) % number == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> def countPrime ( number , count ) : <NEWLINE> <INDENT> if isprime ( number ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c = countPrime ( i , c ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
def p ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , x // 2 ) : <NEWLINE> <INDENT> if x % i == 0 : return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> print ( sum ( [ p ( int ( input ( ) ) ) for _ in range ( n ) ] ) ) <NEWLINE>
import math <NEWLINE> <NL> p = [ 2 ] <NEWLINE> <NL> def isprime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if x == 3 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if max ( p ) < x ** 0.5 : <NEWLINE> <INDENT> for j in range ( max ( p ) , math . floor ( x ** 0.5 ) + 1 ) : <NEWLINE> <INDENT> if all ( [ j % k != 0 for k in p ] ) : <NEWLINE> <INDENT> p . append ( j ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i = 0 <NEWLINE> while i <= len ( p ) - 1 : <NEWLINE> <INDENT> if x % p [ i ] == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if p [ i ] > x ** 0.5 : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> res = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> if isprime ( k ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res , p ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> k = int ( input ( ) ) <NEWLINE> if isprime ( k ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <DEDENT> <DEDENT> print ( res ) <NEWLINE>
num = raw_input ( ) <NEWLINE> num_list = [ ] <NEWLINE> for i in range ( int ( num ) ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> num_list . append ( int ( a ) ) <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> for num in num_list : <NEWLINE> <INDENT> if num == 2 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif num % 2 == 0 or num == 0 or num == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> for i in range ( 3 , num / 2 , 2 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> count -= 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
import math <NEWLINE> main ( ) <NEWLINE> <NL> def prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> n = [ input ( ) for x in range ( N ) ] <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> if prime ( n [ i ] ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( c ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> nprimes = 0 <NEWLINE> a = sorted ( a ) <NEWLINE> while True : <NEWLINE> <INDENT> for d in range ( 2 , 10001 ) : <NEWLINE> <INDENT> if d == a [ 0 ] : <NEWLINE> <INDENT> nprimes += 1 <NEWLINE> del a [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> elif a [ 0 ] % d == 0 : <NEWLINE> <INDENT> del a [ 0 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if len ( a ) <= 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print nprimes <NEWLINE>
import math <NEWLINE> <NL> def prime ( n ) : <NEWLINE> <INDENT> for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> num_prime = [ ] <NEWLINE> k = 0 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> if prime ( int ( n ) ) : <NEWLINE> <INDENT> if not int ( n ) in num_prime : <NEWLINE> <INDENT> k += 1 <NEWLINE> num_prime . append ( int ( n ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( k ) <NEWLINE>
def eratos ( n ) : <NEWLINE> <INDENT> is_prime = [ True for i in range ( n + 1 ) ] <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if i * i > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for j in range ( i * i , n , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return is_prime <NEWLINE> <NL> <DEDENT> is_prime = eratos ( 100000000 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if is_prime [ x ] is True : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE>
def judge ( int ) : <NEWLINE> <INDENT> if int == 2 : return 1 <NEWLINE> elif int <= 1 : return 0 <NEWLINE> for i in range ( 2 , int - 1 ) : <NEWLINE> <INDENT> if int % i == 0 : return 0 <NEWLINE> <DEDENT> return 1 <NEWLINE> <NL> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if judge ( input ( ) ) == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE>
p = [ 1 ] * 10 ** 8 <NEWLINE> <NL> i = 2 <NEWLINE> while i * i < 10 ** 8 : <NEWLINE> <INDENT> if p [ i ] : <NEWLINE> <INDENT> j = i + i <NEWLINE> while j < 10 ** 8 : <NEWLINE> <INDENT> p [ j ] = 0 <NEWLINE> j += i <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> count = 0 <NEWLINE> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> if p [ int ( input ( ) ) ] == 1 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
import math <NEWLINE> <NL> def is_prime ( num ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i < math . sqrt ( num ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if ( is_prime ( n ) ) : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def is_prime ( x ) : <NEWLINE> <INDENT> if x == 2 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif x & 1 == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif pow ( 2 , x - 1 , x ) == 1 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> c += is_prime ( n ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> x_list = [ ] <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x_list . append ( int ( line . strip ( ) ) ) <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> <NL> x_list . remove ( x_list [ 0 ] ) <NEWLINE> <NL> for i in x_list : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( 2 , int ( math . sqrt ( i ) + 1 ) ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> count + + <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> n_p = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if a == 2 : <NEWLINE> <INDENT> n_p += 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif a % 2 == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = 3 <NEWLINE> while j = < math . sqrt ( a ) <NEWLINE> <INDENT> if a % j == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> j += 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n_p += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print n_p <NEWLINE>
import sys <NEWLINE> <NL> <NL> def isprime ( n ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> n = abs ( int ( n ) ) <NEWLINE> <NL> <COMMENT> <NL> if n < 2 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if n == 2 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if not n & 1 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for x in range ( 3 , int ( n ** 0.5 ) + 1 , 2 ) : <NEWLINE> <INDENT> if n % x == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> max = sys . stdin . readline ( ) <NEWLINE> answer = [ ] <NEWLINE> <NL> for x in range ( max ) : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) <NEWLINE> if isprime ( int ( n ) ) : <NEWLINE> <INDENT> answer . append ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( answer ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> if checkPrimeNum ( a ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE> <NL> <DEDENT> cached = [ 2 ] <NEWLINE> def checkPrimeNum ( num ) : <NEWLINE> <INDENT> for i in range ( 2 , num ) : <NEWLINE> <COMMENT> <NL> <INDENT> if cached . count ( i ) > 1 : <NEWLINE> <INDENT> isPrime = True <NEWLINE> for j in range ( 2 , i ) : <NEWLINE> <INDENT> if i % j == 0 : <NEWLINE> <INDENT> isPrime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if isPrime : <NEWLINE> <INDENT> print <STRING> <NEWLINE> cached . append ( i ) <NEWLINE> <DEDENT> <DEDENT> if num % i == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> if cached . count ( num ) == 0 : <NEWLINE> <INDENT> cached . append ( num ) <NEWLINE> <DEDENT> return True <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
import math <NEWLINE> n = input ( ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 1 : <NEWLINE> <INDENT> x = 0 <NEWLINE> <DEDENT> for j in range ( 2 , math . floor ( math . sqrt ( float ( x ) ) ) + 1 ) : <NEWLINE> <INDENT> if x % j == 0 : <NEWLINE> <INDENT> x = 0 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if x != 0 : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> <NL> def is_prime ( num ) : <NEWLINE> <INDENT> prime = True <NEWLINE> for i in range ( 2 , int ( math . sqrt ( num ) ) + 1 ) : <NEWLINE> <INDENT> if num % i == 0 : <NEWLINE> <INDENT> prime = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return prime <NEWLINE> <NL> <DEDENT> num_set = set ( ) <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> num_set . add ( eval ( input ( ) ) ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> count = 0 <NEWLINE> for x in num_set : <NEWLINE> <INDENT> count = count + ( 1 if is_prime ( x ) else 0 ) <NEWLINE> <DEDENT> print ( count ) <NEWLINE>
<COMMENT> <NL> from itertools import takewhile <NEWLINE> from math import sqrt <NEWLINE> <NL> <NL> def is_prime ( primes , i ) : <NEWLINE> <INDENT> if i in primes : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> for p in takewhile ( lambda x : x * x <= i , sorted ( primes ) ) : <NEWLINE> <INDENT> if i % p == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def sieve_of_eratosthenes ( max ) : <NEWLINE> <INDENT> is_prime = [ True ] * ( max + 1 ) <NEWLINE> is_prime [ 0 ] = False <NEWLINE> is_prime [ 1 ] = False <NEWLINE> for i in range ( 2 , int ( sqrt ( max ) ) + 1 ) : <NEWLINE> <INDENT> if not is_prime [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( i * i , max + 1 , i ) : <NEWLINE> <INDENT> is_prime [ j ] = False <NEWLINE> <DEDENT> <DEDENT> return filter ( lambda x : is_prime [ x ] , range ( max + 1 ) ) <NEWLINE> <NL> <DEDENT> primes = set ( sieve_of_eratosthenes ( 10000 ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> c = 0 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> i = int ( input ( ) ) <NEWLINE> if is_prime ( i ) : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
import math <NEWLINE> def isprime ( n ) : <NEWLINE> <INDENT> check = 1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> check = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = int ( math . sqrt ( n ) ) + 1 <NEWLINE> nums = [ i for i in range ( 2 , n ) ] <NEWLINE> while nums [ 0 ] <= m : <NEWLINE> <INDENT> p = nums [ 0 ] <NEWLINE> for j in range ( 1 , int ( n / p ) + 1 ) : <NEWLINE> <INDENT> nums . remove ( p * j ) <NEWLINE> <DEDENT> if n not in nums : <NEWLINE> <INDENT> check = 0 <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return check <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> ans = 0 <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> ans += isprime ( a ) <NEWLINE> <NL> <DEDENT> print ( ans ) <NEWLINE>
import pdb <NEWLINE> <NL> def judgePrime ( n ) : <NEWLINE> <INDENT> result = True <NEWLINE> i = 2 <NEWLINE> while i < int ( round ( n ) ) : <NEWLINE> <INDENT> if n % i == 0 : <NEWLINE> <INDENT> result = False <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return [ result , i ] <NEWLINE> <NL> <DEDENT> def getPrimeNumFromList ( list ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in xrange ( len ( list ) ) : <NEWLINE> <INDENT> target = 0 <NEWLINE> if i == 0 : <NEWLINE> <INDENT> target = list [ 0 ] <NEWLINE> if judgePrime ( target ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> list = [ ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> list . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> list . sort ( ) <NEWLINE> <NL> prime_list = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> v = list . pop ( 0 ) <NEWLINE> result = judgePrime ( v ) <NEWLINE> if result [ 0 ] : <NEWLINE> <COMMENT> <NL> <INDENT> prime_list . append ( v ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v = result [ 1 ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> i = 0 <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> if i >= len ( list ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif list [ i ] % v == 0 : <NEWLINE> <INDENT> list . pop ( i ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> if len ( list ) == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif prime_list [ len ( prime_list ) - 1 ] ^ 2 >= list [ len ( list ) - 1 ] : <NEWLINE> <INDENT> prime_list . append ( list ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print len ( prime_list ) <NEWLINE>
for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if 2 in [ x , pow ( 2 , x , x ) ] : c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
a = input ( ) <NEWLINE> def ip ( a ) : <NEWLINE> <INDENT> i = 2 <NEWLINE> while i ** 2 <= a : <NEWLINE> <INDENT> if a % i == 0 : return False <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> b = 0 <NEWLINE> for i in range ( int ( a ) ) : <NEWLINE> <INDENT> c = input ( ) <NEWLINE> if ip ( int ( c ) ) : b += 1 <NEWLINE> <DEDENT> print ( str ( b ) ) <NEWLINE>
def get_sieve_of_eratosthenes ( x ) : <NEWLINE> <INDENT> data = [ True ] * ( x + 1 ) <NEWLINE> data [ 0 ] = data [ 1 ] = False <NEWLINE> i = 2 <NEWLINE> while i ** 2 <= x : <NEWLINE> <INDENT> if data [ i ] : <NEWLINE> <INDENT> for j in range ( i + 1 , x + 1 ) : <NEWLINE> <INDENT> if j % i == 0 : <NEWLINE> <INDENT> data [ j ] = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return data <NEWLINE> <NL> <NL> <DEDENT> pn = get_sieve_of_eratosthenes ( 10 ** 8 ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = int ( input ( ) ) <NEWLINE> if pn [ a ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = input ( ) <NEWLINE> R = [ ] <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> R . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> minv = R [ 0 ] <NEWLINE> <NL> for v in range ( 1 , n ) : <NEWLINE> <INDENT> if minv > R [ v ] : <NEWLINE> <INDENT> minv = R [ v ] <NEWLINE> <DEDENT> elif maxv < R [ v ] - minv : <NEWLINE> <INDENT> maxv = R [ v ] - minv <NEWLINE> <DEDENT> <DEDENT> print maxv <NEWLINE>
n = input ( ) <NEWLINE> R = [ input ( ) for i in xrange ( n ) ] <NEWLINE> <NL> Rmin = n <NEWLINE> maxdif = R [ 1 ] - R [ 0 ] <NEWLINE> <NL> while Rmin > 0 : <NEWLINE> <INDENT> tRmin = R . index ( min ( R [ 0 : Rmin ] ) ) <NEWLINE> Rmax = R . index ( max ( R [ tRmin : Rmin ] ) ) <NEWLINE> if tRmin == Rmax : <NEWLINE> <INDENT> if tRmin == n : <NEWLINE> <INDENT> tRmin -= 1 <NEWLINE> <DEDENT> elif tRmin < n : <NEWLINE> <INDENT> Rmax = tRmin + 1 <NEWLINE> <DEDENT> <DEDENT> Rmin = tRmin <NEWLINE> if ( R [ Rmax ] - R [ Rmin ] ) > maxdif : <NEWLINE> <INDENT> maxdif = R [ Rmax ] - R [ Rmin ] <NEWLINE> <NL> <DEDENT> <DEDENT> print maxdif <NEWLINE>
input_profit = [ ] <NEWLINE> for x in xrange ( input ( ) ) : <NEWLINE> <INDENT> input_profit . append ( input ( ) ) <NEWLINE> <DEDENT> max_profit = input_profit [ 1 ] - input_profit [ 0 ] <NEWLINE> for i in xrange ( len ( input_profit ) - 1 ) : <NEWLINE> <INDENT> min_profit = input_profit [ i ] <NEWLINE> candidate = max ( input_profit [ i + 1 : ] ) - min_profit <NEWLINE> if candidate > max_profit : <NEWLINE> <INDENT> max_profit = candidate <NEWLINE> <DEDENT> <DEDENT> print max_profit <NEWLINE>
<COMMENT> <NL> <NL> def maximum_profit_1 ( n , R ) : <NEWLINE> <INDENT> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> maxv = max ( maxv , R [ j ] - R [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return maxv <NEWLINE> <NL> <DEDENT> def maximum_profit_2 ( n , R ) : <NEWLINE> <INDENT> minv = R [ 0 ] <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> maxv = max ( maxv , R [ j ] - minv ) <NEWLINE> minv = min ( minv , R [ j ] ) <NEWLINE> <NL> <DEDENT> return maxv <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> ans = maximum_profit_2 ( n , R ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
N = input ( ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> nums . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> profit = nums [ 1 ] - nums [ 0 ] <NEWLINE> for a in range ( N ) : <NEWLINE> <INDENT> for b in range ( a ) : <NEWLINE> <INDENT> if ( nums [ a ] - nums [ b ] ) > profit : <NEWLINE> <INDENT> profit = nums [ a ] - nums [ b ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print profit <NEWLINE>
n = input ( ) <NEWLINE> R = [ ] <NEWLINE> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> R . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> minv = R [ 0 ] <NEWLINE> <NL> for v in range ( 1 , n ) : <NEWLINE> <INDENT> if minv > R [ v ] : <NEWLINE> <INDENT> minv = R [ v ] <NEWLINE> <DEDENT> elif maxv < R [ v ] - minv : <NEWLINE> <INDENT> maxv = R [ v ] - minv <NEWLINE> <DEDENT> <DEDENT> print maxv <NEWLINE>
t = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <STRING> <NEWLINE> <NL> <NL> minv = t [ 0 ] <NEWLINE> maxv = t [ 1 ] - t [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( [ maxv , t [ j ] - minv ] ) <NEWLINE> minv = min ( [ minv , t [ j ] ) <NEWLINE> <DEDENT> print ( maxv ) <NEWLINE>
i = input <NEWLINE> r = range <NEWLINE> N = int ( i ( ) ) <NEWLINE> A = ( int ( i ( ) ) for _ in r ( N ) ) <NEWLINE> mp = A [ 1 ] - A [ 0 ] <NEWLINE> mn = A [ 0 ] <NEWLINE> for a in r ( 1 , N ) : <NEWLINE> <INDENT> x = A [ a ] <NEWLINE> b = x - mn <NEWLINE> if mp < ( b ) : mp = b <NEWLINE> <INDENT> if 0 > b : mn = x <NEWLINE> <DEDENT> if x < mn : mn = x <NEWLINE> <DEDENT> print ( mp ) <NEWLINE>
n = float ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> <NL> for i in range ( n ) : A . append ( float ( input ( ) ) ) <NEWLINE> <NL> B = A [ : - 1 ] <NEWLINE> mini = min ( B ) <NEWLINE> min_idx = B . index ( mini ) <NEWLINE> C = A [ min_idx + 1 : ] <NEWLINE> maxi = max ( C ) <NEWLINE> <NL> print ( maxi - mini ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> r0 = int ( input ( ) ) <NEWLINE> r1 = int ( input ( ) ) <NEWLINE> mx = r1 - r0 <NEWLINE> mn = min ( r1 , r0 ) <NEWLINE> <NL> for i in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> if 0 < mx < i - mn : <NEWLINE> <INDENT> mx = i - mn <NEWLINE> <DEDENT> elif 0 > i - mn > max : <NEWLINE> <INDENT> mx = i - mn <NEWLINE> mn = i <NEWLINE> <DEDENT> elif mn > i : <NEWLINE> <INDENT> mn = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( mx ) <NEWLINE>
n = input ( ) <NEWLINE> m = [ 0 ] * n <NEWLINE> max = [ 0 ] * n <NEWLINE> kijun = [ 0 ] * n <NEWLINE> rieki = [ 0 ] * n <NEWLINE> max_rieki = - 1 * 10 ** 9 <NEWLINE> <NL> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> m [ i ] = input ( ) <NEWLINE> <NL> <NL> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> for j in xrange ( i + 1 , n ) : <NEWLINE> <INDENT> if max_rieki < m [ j ] - m [ i ] : <NEWLINE> <INDENT> max_rieki = m [ j ] - m [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print max_rieki <NEWLINE>
b , s = - 1e7 , 1e7 <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> b , s = max ( b , c - s ) , min ( s , c ) <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> nums = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> maxv = nums [ 1 ] - nums [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> for i in range ( j ) : <NEWLINE> <INDENT> maxv = max ( maxv , nums [ j ] - nums [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print maxv <NEWLINE>
n = int ( input ( ) ) <NEWLINE> min_r , max_d = int ( input ( ) ) , - 10 ** 9 <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> max_d = max ( max_d , r - min ) <NEWLINE> min_r = min ( min_r , r ) <NEWLINE> <DEDENT> print ( max_d ) <NEWLINE> <NL>
<INDENT> N = input ( ) <NEWLINE> a = [ input ( ) for y in range ( N ) ] <NEWLINE> a_max = - 10 ** 9 <NEWLINE> for i in xrange ( 1 , len ( a ) - 1 ) : <NEWLINE> <INDENT> if ( max ( a [ ( i + 1 ) : ] ) - a [ i ] ) >= a_max : <NEWLINE> <INDENT> a_max = max ( a [ ( i + 1 ) : ] ) - a [ i ] <NEWLINE> <DEDENT> <DEDENT> print a_max <NEWLINE> <DEDENT>
max_v = 1000000000 <NEWLINE> min_v = - 1000000000 <NEWLINE> <NL> N = input ( ) <NEWLINE> data = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> data . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> for r in data : <NEWLINE> <INDENT> max_v = max ( max_v , r - min_v ) <NEWLINE> min_v = min ( min_v , r ) <NEWLINE> <NL> <DEDENT> print ( 3 ) <NEWLINE>
import sys <NEWLINE> <NL> num_list = int ( sys . stdin . readline ( ) ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> nums = map ( int , lines ) <NEWLINE> <NL> max_diff = - sys . maxint - 1 <NEWLINE> for i in range ( num_list ) : <NEWLINE> <INDENT> for j in range ( i + 1 , num_list ) : <NEWLINE> <INDENT> diff = nums [ j ] - nums [ i ] <NEWLINE> if diff > max_diff : <NEWLINE> <INDENT> max_diff = diff <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print max_diff <NEWLINE>
import sys <NEWLINE> <NL> values = [ int ( input ( ) ) for i in range ( int ( input ( ) ) ) ] <NEWLINE> maxv = - sys . maxsize - 1 <NEWLINE> minv = values [ 0 ] <NEWLINE> <NL> for val in enumerate ( values ) : <NEWLINE> <INDENT> if maxv < ( val - minv ) : <NEWLINE> <INDENT> maxv = val - minv <NEWLINE> <DEDENT> if minv > val : <NEWLINE> <INDENT> minv = val <NEWLINE> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
import sys <NEWLINE> input ( ) <NEWLINE> a , b = - 1e11 , 1e11 <NEWLINE> for i in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> a = max ( a , i - b ) <NEWLINE> b = min ( i , b ) <NEWLINE> <DEDENT> print ( mar ) <NEWLINE>
import sys <NEWLINE> <NL> x = [ ] <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x . append ( line . strip ( ) ) <NEWLINE> <NL> <DEDENT> max = - ( 10 ** 9 ) <NEWLINE> min = int ( x [ 1 ] ) <NEWLINE> <NL> for i in range ( 2 , int ( x [ 0 ] + 1 ) ) : <NEWLINE> <INDENT> sa = int ( x [ i ] ) - min <NEWLINE> if max < sa : <NEWLINE> <INDENT> max = sa <NEWLINE> <DEDENT> if min > int ( x [ i ] ) : <NEWLINE> <INDENT> min = int ( x [ i ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> print max <NEWLINE>
n = raw_input ( ) <NEWLINE> x = 0 <NEWLINE> y = 0 <NEWLINE> a = raw_input ( ) <NEWLINE> for 1 in n - 1 : <NEWLINE> <INDENT> c = raw_imput ( ) <NEWLINE> if a < c : <NEWLINE> <INDENT> a = c <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = a - c <NEWLINE> <DEDENT> if y > x : <NEWLINE> <INDENT> x = y <NEWLINE> <DEDENT> <DEDENT> print x <NEWLINE>
<INDENT> n = input ( ) <NEWLINE> n_max = - ( 1000000000 ) <NEWLINE> n_min = input ( ) <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> R = input ( ) <NEWLINE> if n_max < R - n_min : <NEWLINE> <INDENT> n_max = R - n_min <NEWLINE> <DEDENT> if R < n_min : <NEWLINE> <INDENT> n_min = R <NEWLINE> <NL> <DEDENT> <DEDENT> print n_max <NEWLINE> <DEDENT>
import sys <NEWLINE> s = 1e10 , b = - s <NEWLINE> input ( ) <NEWLINE> for r in map ( int , sys . stdin ) : <NEWLINE> <INDENT> if b < r - s : b = r - s <NEWLINE> if s > r : s = r <NEWLINE> <DEDENT> print ( b ) <NEWLINE>
import sys <NEWLINE> <NL> input ( ) <NEWLINE> minv = int ( input ( ) ) <NEWLINE> maxv = - 1000000000 <NEWLINE> <NL> for r in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> m = r - minv <NEWLINE> if maxv < m : <NEWLINE> <INDENT> maxv = m <NEWLINE> if m < 0 : minv = r <NEWLINE> <DEDENT> elif m < 0 : minv = r <NEWLINE> <NL> <DEDENT> print ( maxv <NEWLINE>
a , b = - 1e11 , 1e11 <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> data = int ( input ( ) ) <NEWLINE> a , b = max ( a , c - b ) , min ( b , c ) <NEWLINE> <DEDENT> print ( a ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> max = - 10 ^ 9 <NEWLINE> min = 10 ^ 9 <NEWLINE> ans = - 10 ^ 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] = int ( raw_input ( ) ) <NEWLINE> <DEDENT> for s in range ( n ) : <NEWLINE> <INDENT> for t in range ( n ) : <NEWLINE> <INDENT> if ans < ( x [ n - 1 - s ] - x [ n - 1 - t ] ) : <NEWLINE> <INDENT> ans = x [ n - 1 - s ] - x [ n - 1 - t ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> max = a [ 1 ] - a [ 0 ] <NEWLINE> min_num = a [ 0 ] <NEWLINE> for i in a : <NEWLINE> <INDENT> if a [ i ] - min_num > max : <NEWLINE> <INDENT> max = a [ i ] - min_num <NEWLINE> <DEDENT> if min_num > i : <NEWLINE> <INDENT> min_num = i <NEWLINE> <DEDENT> <DEDENT> print max <NEWLINE>
n = input ( ) <NEWLINE> max = - 1 * 10 ** 9 <NEWLINE> min = input ( ) <NEWLINE> <NL> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> max = max ( maxi , tmp - min ) <NEWLINE> min = min ( mini , tmp ) <NEWLINE> <NL> <DEDENT> print max <NEWLINE>
num = int ( input ( ) ) <NEWLINE> r_1 = int ( input ( ) ) <NEWLINE> r_2 = int ( input ( ) ) <NEWLINE> max_profit = r_2 - r_1 <NEWLINE> if r_1 < r_2 : <NEWLINE> <INDENT> min_value = r_1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> min_value = r_2 <NEWLINE> <NL> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> t = x - min_value <NEWLINE> if max_profit < t : <NEWLINE> <INDENT> max_profit = t <NEWLINE> <DEDENT> if x < min_value : <NEWLINE> <INDENT> min_value = x <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max_profit ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> R = [ 0 for i in range ( n ) ] <NEWLINE> <NL> ans = 1 - 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R [ i ] = int ( raw_input ( ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> min_R = R [ 0 ] <NEWLINE> continue <NEWLINE> <DEDENT> if min_R < R [ i ] : <NEWLINE> <INDENT> if ans < R [ i ] - min_R : <NEWLINE> <INDENT> ans = R [ i ] - min_R <NEWLINE> <DEDENT> <DEDENT> elif min_R > R [ i ] : <NEWLINE> <INDENT> if ans < R [ i ] - min_R : <NEWLINE> <INDENT> ans = R [ i ] - min_R <NEWLINE> <DEDENT> min_R = R [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ans < 0 <NEWLINE> ans = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ans <NEWLINE> <NL> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> maxv = int ( - 20000000 ) <NEWLINE> minv = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> r = int ( input ( ) ) <NEWLINE> maxv = max ( maxv , r - minv ) <NEWLINE> minv = min ( minv , r ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE> <NL>
import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> t = int ( input ( ) ) <NEWLINE> mint = t <NEWLINE> t1 = int ( input ( ) ) <NEWLINE> if t1 < t : mint = t1 <NEWLINE> maxtt = t1 - t <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> t = int ( input ( ) ) <NEWLINE> <NL> if t - mint > maxtt : maxtt = t - mint <NEWLINE> if t < mint : mint = <COMMENT> <NEWLINE> <NL> <DEDENT> print ( int ( maxtt ) ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> List_1 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> List_1 . append ( input ( ) ) <NEWLINE> if i == 1 : <NEWLINE> <INDENT> max = List_1 [ 1 ] - List_1 [ 0 ] <NEWLINE> <DEDENT> elif i > 1 : <NEWLINE> <INDENT> for j in range ( i - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if max < List_1 [ i ] - List_1 [ j ] : <NEWLINE> <INDENT> max = List_1 [ i ] - List_1 [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( max ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
price_list = [ ] <NEWLINE> num_list = [ ] <NEWLINE> t = raw_input ( ) <NEWLINE> for i in range ( int ( t ) ) : <NEWLINE> <INDENT> price_list . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( len ( price_list ) ) : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> num_list . append ( price_list [ i ] - price_list [ j ] ) <NEWLINE> <DEDENT> <DEDENT> print max ( num_list ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> minv = pri_list [ 0 ] <NEWLINE> maxv = - 10000000000 <NEWLINE> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> price = int ( input ( ) ) <NEWLINE> maxv = max ( [ maxv , price - minv ] ) <NEWLINE> minv = min ( [ minv , price ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE> <NL>
n = int ( raw_input ( ) ) <NEWLINE> minv = 10 ** 9 <NEWLINE> R [ 0 ] = 0 <NEWLINE> maxv = ( - 1 ) * 10 ** 9 <NEWLINE> <NL> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if minv >= R [ j ] : <NEWLINE> <INDENT> minv = R [ j ] <NEWLINE> <DEDENT> if maxv <= R [ j + 1 ] - minv : <NEWLINE> <INDENT> maxv = R [ j + 1 ] - minv <NEWLINE> <DEDENT> <DEDENT> print maxv <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> print ( max ( [ max ( r [ i + 1 : ] ) - r [ i ] for i in range ( min ( r . remove ( min ( r ) ) ) , n - 1 ) ] ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r = list ( ( map ( int , input ( ) ) for i in range ( n ) ) ) <NEWLINE> max_abs = 0 <NEWLINE> for i in range ( len ( r ) ) : <NEWLINE> <INDENT> for j in range ( i , len ( r ) ) : <NEWLINE> <INDENT> max_abs = max ( max_abs , abs ( r [ j ] - r [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( max_abs ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> d = max ( x - m , d ) <NEWLINE> m = min ( m , x ) <NEWLINE> <DEDENT> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = int ( input ( ) ) <NEWLINE> Max = - 10 ** 9 <NEWLINE> Min = a <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if ( Max < x - Min ) : <NEWLINE> <INDENT> Max = x - Min <NEWLINE> <DEDENT> if ( x < Min ) : <NEWLINE> <INDENT> Min = x <NEWLINE> <DEDENT> <DEDENT> print ( Max ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> ma = a [ 1 ] - a [ 0 ] <NEWLINE> mi = a [ 0 ] <NEWLINE> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> mi = min ( mi , a [ i ] ) <NEWLINE> ma = max ( ma , a [ i ] - mi ) <NEWLINE> <DEDENT> print ( ma ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> <NL> before = int ( input ( ) ) <NEWLINE> current = int ( input ( ) ) <NEWLINE> diffMax = current - before <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> number = int ( input ( ) ) <NEWLINE> diff = number - current <NEWLINE> diffMax = max ( diff , diffMax ) <NEWLINE> current = min ( current , number ) <NEWLINE> <DEDENT> print ( diffMax ) <NEWLINE> <NL>
num = raw_input ( ) <NEWLINE> num_list = [ ] <NEWLINE> for i in range ( int ( num ) ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> num_list . append ( int ( a ) ) <NEWLINE> <NL> <DEDENT> minv = num_list [ 0 ] <NEWLINE> <NL> for i in range ( 1 , len ( num_list ) ) : <NEWLINE> <INDENT> maxv = max ( maxv , num_list [ i ] - minv ) <NEWLINE> minv = min ( minv , num_list [ i ] ) <NEWLINE> <NL> <DEDENT> print maxv <NEWLINE>
<COMMENT> <NL> n = int ( raw_input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> ls . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> ans = None <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> for j in range ( k + 1 , n ) : <NEWLINE> <INDENT> dif = ls [ j ] - ls [ k ] <NEWLINE> if ans is None : <NEWLINE> <INDENT> ans = dif <NEWLINE> <DEDENT> elif ans < dif : <NEWLINE> <INDENT> ans = dif <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ans <NEWLINE>
N = input ( ) <NEWLINE> R = [ int ( raw_input ( ) ) for _ in xrange ( N ) ] <NEWLINE> ans = float ( <STRING> ) <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , N ) : <NEWLINE> <INDENT> ans = max ( ans , R [ j ] - R [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE>
a = input ( ) <NEWLINE> r = [ ] <NEWLINE> for i in range ( a ) : <NEWLINE> <INDENT> k = input ( ) <NEWLINE> r . append ( k ) <NEWLINE> <DEDENT> minn = - 10 ** 9 <NEWLINE> for i in range ( len ( r ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( r ) ) : <NEWLINE> <INDENT> k = r [ j ] - r [ i ] <NEWLINE> if k > minn : <NEWLINE> <INDENT> minn = k <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print minn <NEWLINE>
n = input ( ) <NEWLINE> maxi = 0 <NEWLINE> mini = 10 ** 9 <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = input ( ) <NEWLINE> maxi = max ( maxi , tmp ) <NEWLINE> mini = min ( mini , tmp ) <NEWLINE> <NL> <DEDENT> ans = maxi - min <NEWLINE> <NL> print ans <NEWLINE>
import sys <NEWLINE> <NL> x = [ ] <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> x . append ( int ( line . strip ( ) ) ) <NEWLINE> <NL> <DEDENT> length = int ( x [ 0 ] ) <NEWLINE> <NL> del x [ 0 ] <NEWLINE> <NL> max = - ( 10 ** 9 ) <NEWLINE> <NL> for i in range ( 0 , length - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , length ) : <NEWLINE> <INDENT> sa = int ( x [ j ] ) - int ( x [ i ] ) <NEWLINE> if max < sa : <NEWLINE> <INDENT> max = sa <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print max <NEWLINE>
n = input ( ) <NEWLINE> R = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> profit = R [ n - 1 ] - R [ 0 ] <NEWLINE> after = R [ n - 1 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if R [ n - 1 - i ] < after and i != 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( n - i - 1 ) : <NEWLINE> <INDENT> if R [ n - 1 - i ] - R [ j ] > profit : <NEWLINE> <INDENT> profit = R [ n - 1 - i ] - R [ j ] <NEWLINE> after = R [ n - 1 - i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> % profit <NEWLINE>
n = input ( ) <NEWLINE> minSeq = input ( ) <NEWLINE> maxv = - float ( <STRING> ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R = input ( ) <NEWLINE> if R - minSeq > maxv : <NEWLINE> <INDENT> maxv = R - minSeq <NEWLINE> <DEDENT> if R < minSeq : <NEWLINE> <INDENT> minSeq = R <NEWLINE> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
<INDENT> n = input ( ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> num_1 = input ( ) <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> num_2 = input ( ) <NEWLINE> maxv = num_2 - num_1 <NEWLINE> MIN = min ( num_1 , num_2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_3 = input ( ) <NEWLINE> if ( num_3 - MIN ) > maxv : <NEWLINE> <INDENT> maxv = num_3 - MIN <NEWLINE> <DEDENT> if ( num_3 ) < MIN : <NEWLINE> <INDENT> MIN = num_3 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
n = input ( ) <NEWLINE> maxv = - 1 * 10 ** 9 <NEWLINE> minv = input ( ) <NEWLINE> <NL> for j in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> v = input ( ) <NEWLINE> if maxv < v - minv : <NEWLINE> <INDENT> maxv = v - minv <NEWLINE> <DEDENT> if minv > v <NEWLINE> <INDENT> minv = v <NEWLINE> <NL> <DEDENT> <DEDENT> print maxv <NEWLINE>
num = raw_input ( ) <NEWLINE> <NL> for i in range ( int ( num ) ) : <NEWLINE> <INDENT> a = raw_input ( ) <NEWLINE> num_list . append ( int ( a ) ) <NEWLINE> <NL> <DEDENT> min_ans = num_list [ 0 ] <NEWLINE> max_ans = float ( <STRING> ) <NEWLINE> for item in num_list [ 1 : ] : <NEWLINE> <INDENT> if i - min_ans > max_ans : <NEWLINE> <INDENT> max_ans = i - min_ans <NEWLINE> <DEDENT> if i < min_ans : <NEWLINE> <INDENT> min_ans = i <NEWLINE> <NL> <DEDENT> <DEDENT> print max_ans <NEWLINE>
values = set_values ( ) <NEWLINE> max_value = min ( values ) - max ( values ) <NEWLINE> for i in range ( 1 , int ( input ( ) ) ) : <NEWLINE> <INDENT> for j in range ( 0 , i - 1 ) : <NEWLINE> <NL> <INDENT> print ( i , j , len ( values ) ) <NEWLINE> if max_value < ( values [ i ] - values [ j ] ) : <NEWLINE> <INDENT> max_value = ( values [ i ] - values [ j ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max_value ) <NEWLINE>
n = input ( ) <NEWLINE> prices = list ( ) <NEWLINE> for idx in range ( n ) : <NEWLINE> <INDENT> tmp = index ( ) <NEWLINE> prices . append ( tmp ) <NEWLINE> <NL> <DEDENT> minp = prices [ 0 ] <NEWLINE> maxv = prices [ 1 ] - prices [ 0 ] <NEWLINE> <NL> for price in prices : <NEWLINE> <INDENT> maxp = max ( maxp , price - min ) <NEWLINE> minv = min ( minv , price ) <NEWLINE> <NL> <DEDENT> print ( maxp ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> minv = int ( raw_input ( ) ) <NEWLINE> maxv = - 1 * 10 ** 9 <NEWLINE> <NL> for j in range ( n - 1 ) : <NEWLINE> <INDENT> nums = int ( raw_input ( ) ) <NEWLINE> diff = nums - minv <NEWLINE> if maxv < diff : <NEWLINE> <INDENT> maxv = diff <NEWLINE> <DEDENT> if num < minv : <NEWLINE> <INDENT> minv = nums <NEWLINE> <NL> <DEDENT> <DEDENT> print maxv <NEWLINE>
from sys import stdin <NEWLINE> <NL> N , * datas = [ int ( i ) for i in stdin . readlines ( ) ] <NEWLINE> now_max = max ( datas [ 1 : ] ) <NEWLINE> max_index = ( N - 1 ) - reversed ( datas ) . index ( now_max ) <NEWLINE> _min = min ( datas ) <NEWLINE> min_index = datas . index ( _min ) <NEWLINE> <NL> if max_index > min_index : <NEWLINE> <INDENT> diff = now_max - _min <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = now_max - datas [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if i == max_index : <NEWLINE> <INDENT> now_max = max ( datas [ i + 1 : ] ) <NEWLINE> max_index = datas . index ( now_max , i + 1 ) <NEWLINE> <DEDENT> new_diff = now_max - datas [ i ] <NEWLINE> if diff < new_diff : <NEWLINE> <INDENT> diff = new_diff <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( diff ) <NEWLINE>
n = raw_input ( ) <NEWLINE> n = int ( n ) <NEWLINE> minv = raw_input ( ) <NEWLINE> minv = iny ( minv ) <NEWLINE> maxv = - 1000000000 <NEWLINE> <NL> for j in range ( n - 1 ) : <NEWLINE> <INDENT> num = raw_input ( ) <NEWLINE> num = int ( num ) <NEWLINE> diff = num - minv <NEWLINE> if maxv < diff : <NEWLINE> <INDENT> maxv = diff <NEWLINE> <DEDENT> if num < minv : <NEWLINE> <INDENT> minv = num <NEWLINE> <NL> <DEDENT> <DEDENT> print maxv <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> maxv = - 2000000000 <NEWLINE> <NL> <NL> minv = int ( intput ( ) ) <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> cur = int ( input ( ) ) <NEWLINE> maxv = max ( [ maxv , cur - minv ] ) <NEWLINE> minv = min ( [ minv , cur ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
v = input ( ) . split ( ) <NEWLINE> dif_max = - 200000 <NEWLINE> <NL> for i in range ( len ( v ) ) : <NEWLINE> <INDENT> v [ i ] = int ( v [ i ] ) <NEWLINE> <NL> <DEDENT> len = v [ 0 ] <NEWLINE> for i in range ( 2 , len + 1 , 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len + 1 , 1 ) : <NEWLINE> <INDENT> dif = v [ j ] - v [ i ] <NEWLINE> dif_max = dif if dif_max < dif else dif_max <NEWLINE> <NL> <DEDENT> <DEDENT> print ( dif_max ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> r_min = int ( input ( ) ) <NEWLINE> r_t = int ( input ( ) ) <NEWLINE> g_max = r_t - r_min <NEWLINE> r_ min = min ( r_min , r_t ) <NEWLINE> <NL> for _ in range ( n - 2 ) : <NEWLINE> <INDENT> r_t = int ( input ( ) ) <NEWLINE> g_max = max ( g_max , r_t - r_min ) <NEWLINE> r_min = min ( r_min , r_t ) <NEWLINE> <NL> <DEDENT> print ( g_max ) <NEWLINE>
maxv = - inf <NEWLINE> minv = inf <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = int ( input ( ) ) <NEWLINE> <NL> maxv = max ( maxv , tmp - minv ) <NEWLINE> minv = min ( tmp , minv ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> R = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> minv = R [ 0 ] <NEWLINE> for i in n : <NEWLINE> <INDENT> maxv = max ( maxv , i - minv ) <NEWLINE> minv = min ( minv , i ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> R = [ ] <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> R . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> R . reverse ( ) <NEWLINE> max_num = - 999999999 <NEWLINE> <NL> for x , i in enumerate ( R [ : N - 1 ] ) : <NEWLINE> <INDENT> for j in R [ x + 1 : ] : <NEWLINE> <INDENT> if max_num < ( i - j ) : <NEWLINE> <INDENT> max_num = i - j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print max_num <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> minv = R [ 0 ] <NEWLINE> maxv = R [ 1 ] - R [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if ( maxv < R [ j ] - minv ) : <NEWLINE> <INDENT> maxv = R [ j ] - minv <NEWLINE> <DEDENT> if ( R [ j ] < minv ) : <NEWLINE> <INDENT> minv = R [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> N , * datas = [ int ( i ) for i in stdin . readlines ( ) ] <NEWLINE> now_max = max ( datas [ 1 : ] ) <NEWLINE> max_index = ( N - 1 ) - datas [ : : - 1 ] . index ( now_max ) <NEWLINE> now_min = min ( datas ) <NEWLINE> min_index = datas . index ( _min ) <NEWLINE> <NL> if max_index > min_index : <NEWLINE> <INDENT> diff = now_max - _min <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> diff = now_max - datas [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N - 1 ) : <NEWLINE> <INDENT> if i == max_index : <NEWLINE> <INDENT> now_max = max ( datas [ i + 1 : ] ) <NEWLINE> max_index = datas . index ( now_max , i + 1 ) <NEWLINE> <DEDENT> new_diff = now_max - datas [ i ] <NEWLINE> if diff < new_diff : <NEWLINE> <INDENT> diff = new_diff <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( diff ) <NEWLINE>
n = input ( ) <NEWLINE> n_max = - 10 ** 9 <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> R [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> n_min = R [ 0 ] <NEWLINE> <NL> for i in range ( 0 , n - 1 ) : <NEWLINE> <INDENT> if R [ i ] <= n_min : <NEWLINE> <INDENT> n_min = R [ i ] <NEWLINE> <DEDENT> if n_max <= R [ i ] - n_min : <NEWLINE> <INDENT> n_max = R [ i ] - n_min <NEWLINE> <NL> <DEDENT> <DEDENT> print n_max <NEWLINE>
intMax = - 100000000 <NEWLINE> <NL> inputData = int ( input ( ) ) <NEWLINE> inputList = list ( ) <NEWLINE> count = 0 <NEWLINE> while count < inputData : <NEWLINE> <INDENT> inputList . append ( int ( input ( ) ) ) <NEWLINE> count = count + 1 <NEWLINE> <NL> <DEDENT> inputDataMax = intMax <NEWLINE> inputDataMin = inputList [ 0 ] <NEWLINE> count2 = 1 <NEWLINE> while count2 < inputData : <NEWLINE> <INDENT> inputDataMax = max ( inputDataMax , inputList [ count2 ] - inputDataMin ) <NEWLINE> inputMin = min ( inputDataMin , inputList [ count2 ] ) <NEWLINE> <NL> <DEDENT> print ( inputDataMax ) <NEWLINE>
num = input ( ) <NEWLINE> l = [ ] <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> l . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> max = l [ 1 ] - l [ 0 ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> for j in range ( num - 1 ) : <NEWLINE> <INDENT> if max < l [ j ] - l [ i ] <NEWLINE> <INDENT> max = l [ j ] - l [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print max <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> minv = int ( input ( ) ) <NEWLINE> maxv = - 1000000000 <NEWLINE> <NL> for r in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> if maxv < r - minv < 0 : <NEWLINE> <INDENT> maxv = r - minv <NEWLINE> minv = r <NEWLINE> <DEDENT> elif maxv < r - minv : <NEWLINE> <INDENT> maxv = r - minv <NEWLINE> <DEDENT> elif m < 0 : <NEWLINE> <INDENT> minv = r <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
n = input ( ) <NEWLINE> R = [ ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> R . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> max = R [ 1 ] - R [ 0 ] <NEWLINE> min = R [ 0 ] <NEWLINE> <NL> for i in range ( 2 , n ) : <NEWLINE> <INDENT> if R [ i ] - min > max : <NEWLINE> <INDENT> max = R [ i ] - min <NEWLINE> <DEDENT> if R [ i ] < min : <NEWLINE> <INDENT> min = R [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print max <NEWLINE>
<COMMENT> <NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> R_List = [ ] <NEWLINE> Max = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R_List . append ( int ( raw_input ( ) ) ) <NEWLINE> if i == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif i == 1 : <NEWLINE> <INDENT> Max = R_List [ 1 ] - R_List [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> Max = max ( Max , R_List [ i ] - R_List [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print Max <NEWLINE>
n = ( input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> max = a [ j ] - a [ i ] <NEWLINE> <INDENT> while i < n : <NEWLINE> <INDENT> while j < n : <NEWLINE> <INDENT> if max < a [ j ] - a [ i ] : <NEWLINE> <INDENT> max = a [ j ] - a [ i ] <NEWLINE> j + = 1 <NEWLINE> i + = 1 <NEWLINE> print max <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> a . append ( int ( raw_input ( ) ) ) <NEWLINE> Min = a [ 0 ] <NEWLINE> Max = - 1 * 10 ** 9 <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> Max = max ( Max , R [ j ] - Min ) <NEWLINE> Min = min ( Min , R [ j ] ) <NEWLINE> <DEDENT> print Max <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> R = [ int ( raw_input ( ) ) for i in xrange ( n ) ] <NEWLINE> L = [ max ( R [ i + 1 : ] ) - x for i , x in enumerate ( R ) if i < n - 1 ] <NEWLINE> print max ( L ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> r0 = int ( input ( ) ) <NEWLINE> r1 = int ( input ( ) ) <NEWLINE> max = r1 - r0 <NEWLINE> min = min ( r1 , r0 ) <NEWLINE> <NL> for i in map ( int , sys . stdin . readlines ( ( ) ) ) : <NEWLINE> <INDENT> if max < i - min : <NEWLINE> <INDENT> max = i - min <NEWLINE> if 0 > i - min : <NEWLINE> <INDENT> min = i <NEWLINE> <DEDENT> <DEDENT> elif min > i : <NEWLINE> <INDENT> min = 1 <NEWLINE> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> nums = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nums . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> r = max ( nums [ 1 : ] ) - nums [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> ri = nums [ i ] <NEWLINE> <NL> if ri == rj : <NEWLINE> <INDENT> rj = max ( nums [ i + 1 : ] ) <NEWLINE> <NL> <DEDENT> r = max ( r , rj - ri ) <NEWLINE> <NL> <DEDENT> print ( r ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
i = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> maxR = - 10 ** 9 <NEWLINE> minR = int ( input ( ) ) <NEWLINE> while i < n : <NEWLINE> <INDENT> R = int ( input ( ) ) <NEWLINE> maxR = max ( maxR , R - minR ) <NEWLINE> minR = min ( minR , R ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print ( maxR ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> nowmin = a [ 0 ] + 1 <NEWLINE> nowmax = max ( a [ 1 : ] ) <NEWLINE> ans = a [ 1 ] - a [ 0 ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] < nowmin : <NEWLINE> <INDENT> k = nowmax - a [ i ] <NEWLINE> if k > ans : <NEWLINE> <INDENT> ans = k <NEWLINE> nowmin = a [ i ] <NEWLINE> <DEDENT> <DEDENT> elif a [ i ] == nowmax : <NEWLINE> <INDENT> nowmax = max ( a [ i + 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( input ( ) ) <NEWLINE> <DEDENT> maxv = a [ 0 ] <NEWLINE> minv = a [ 0 ] <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> maxv = max ( maxv , a [ j ] ) <NEWLINE> minv = min ( minv , a [ j ] ) <NEWLINE> <DEDENT> print ( maxv - minv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> maxv = - 2000000000 <NEWLINE> <NL> lst = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> minv = lst [ 0 ] <NEWLINE> <NL> for i in range ( 1 , n ) : <NEWLINE> <INDENT> maxv = max ( [ maxv , lst [ i ] - minv ] ) <NEWLINE> minv = min ( [ minv , lst [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> minv = int ( input ( ) ) <NEWLINE> maxv = - 1000000000 <NEWLINE> <NL> for r in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> m = r - minv <NEWLINE> if maxv < m : maxv = m <NEWLINE> <INDENT> if m < 0 : minv = r <NEWLINE> <DEDENT> elif m < 0 : minv = r <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> l = l [ : : - 1 ] <NEWLINE> maximum = l [ 0 ] - min ( l [ 1 : ] ) <NEWLINE> x = l <NEWLINE> if maximum > 0 : <NEWLINE> <INDENT> x = [ i for i in l if l [ 0 ] <= i ] <NEWLINE> <DEDENT> for j in range ( len ( x ) - 1 ) : <NEWLINE> <INDENT> if maximum < l [ j ] - min ( l [ j + 1 : ] ) : <NEWLINE> <INDENT> maximum = l [ j ] - min ( l [ j + 1 : ] ) <NEWLINE> <DEDENT> <DEDENT> input ( maximum ) <NEWLINE>
num = raw_input ( ) <NEWLINE> max = 1 - 1000000000 <NEWLINE> length = len ( num ) <NEWLINE> <NL> for i in range ( length ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if ( max > ( num [ i ] - num [ j ] ) ) : <NEWLINE> <INDENT> max = num [ i ] - num [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print max <NEWLINE>
<COMMENT> <NL> n = int ( raw_input ( ) ) <NEWLINE> value_list = [ ] <NEWLINE> diff_indx1 = 0 <NEWLINE> diff_indx2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> value_list . append ( int ( raw_input ( ) ) ) <NEWLINE> if i == 1 : <NEWLINE> <INDENT> diff = value_list [ 1 ] - value_list [ 0 ] <NEWLINE> diff_indx1 = 1 <NEWLINE> <DEDENT> if value_list [ i ] >= value_list [ diff_indx1 ] : <NEWLINE> <INDENT> for j in range ( i ) : <NEWLINE> <INDENT> diff2 = value_list [ i ] - value_list [ j ] <NEWLINE> if diff <= diff2 : <NEWLINE> <INDENT> diff = diff2 <NEWLINE> diff_indx1 = i <NEWLINE> diff_indx2 = j <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> elif value_list [ diff_indx2 ] > value_list [ i ] : <NEWLINE> <INDENT> diff_indx2 = i <NEWLINE> diff_indx1 = i <NEWLINE> <DEDENT> <DEDENT> print diff <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> num_list = [ int ( raw_input ( ) ) for i in xrange ( n ) ] <NEWLINE> <COMMENT> <NL> <NL> ans = max ( num_list [ 1 : ] ) - num_list [ 0 ] <NEWLINE> chk = num_list [ 0 ] <NEWLINE> <COMMENT> <NL> <NL> for i in range ( 1 , n - 1 ) : <NEWLINE> <INDENT> if num_list [ i ] >= chk : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> max_num = max ( num_list [ i + 1 : ] ) <NEWLINE> <COMMENT> <NL> tmp = max_num - num_list [ i ] <NEWLINE> if tmp > ans : <NEWLINE> <INDENT> ans = tmp <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ans <NEWLINE>
n = int ( input ( ) ) <NEWLINE> min_n = 0 <NEWLINE> max_n = - 2 * 10 ** 9 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> min_n = min ( x , min_n ) <NEWLINE> max_n = max ( max_n , x - min_n ) <NEWLINE> <DEDENT> print max_n <NEWLINE>
cat ALDS1_1_d . py <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> R = [ int ( raw_input ( ) ) for i in xrange ( n ) ] <NEWLINE> mn = R [ 0 ] <NEWLINE> ans = - 1e10 <NEWLINE> for r in R [ 1 : ] : <NEWLINE> <INDENT> ans = max ( ans , r - mn ) <NEWLINE> mn = min ( mn , r ) <NEWLINE> <DEDENT> print ans <NEWLINE>
dif_max = 1 - 10 ** 9 <NEWLINE> max = 1 <NEWLINE> min = 10 ** 9 <NEWLINE> n_max = 0 <NEWLINE> n_max = int ( raw_input ( ) ) <NEWLINE> <NL> price = [ 0 ] * n_max <NEWLINE> for i in range ( 0 , n_max ) : <NEWLINE> <INDENT> price [ i ] = int ( raw_input ( ) ) <NEWLINE> <DEDENT> for i in range ( 0 , n_max - 1 ) : <NEWLINE> <INDENT> if min >= price [ i ] : <NEWLINE> <INDENT> min = price [ i ] <NEWLINE> <DEDENT> for j in range ( i + 1 , n_max ) : <NEWLINE> <INDENT> if max <= price [ j ] : <NEWLINE> <INDENT> max = price [ j ] <NEWLINE> <DEDENT> <DEDENT> if dif_max <= max - min : <NEWLINE> <INDENT> dif_max = max - min <NEWLINE> <DEDENT> max = 1 <NEWLINE> min = 10 ** 9 <NEWLINE> <DEDENT> print dif_max <NEWLINE>
<COMMENT> <NL> num = int ( raw_input ( ) ) <NEWLINE> numbers = [ ] <NEWLINE> counter = 0 <NEWLINE> while counter < num : <NEWLINE> <INDENT> numbers . append ( int ( raw_input ( ) ) ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> maximum = None <NEWLINE> <NL> for index , num in enumerate ( numbers [ : - 1 ] ) : <NEWLINE> <INDENT> max_diff = max ( numbers [ index + 1 : ] ) - num <NEWLINE> if max_diff > maximum : <NEWLINE> <INDENT> maximum = max_diff <NEWLINE> <NL> <DEDENT> <DEDENT> print maximum <NEWLINE>
n = int ( input ( ) ) <NEWLINE> fir = int ( input ( ) ) <NEWLINE> sec = int ( input ( ) ) <NEWLINE> max_ = sec <NEWLINE> if ( fir > sec ) : <NEWLINE> <INDENT> min_ = sec <NEWLINE> <DEDENT> elif ( fir <= sec ) : <NEWLINE> <INDENT> min_ = fir <NEWLINE> <DEDENT> max_dif = sec - fir <NEWLINE> if n > 2 : <NEWLINE> <INDENT> for i in range ( n - 3 ) : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> if x > max_num : <NEWLINE> <INDENT> max_num = x <NEWLINE> if max_dif < x - min_ : <NEWLINE> <INDENT> max_dif = x - min_ <NEWLINE> <DEDENT> <DEDENT> if x < min_ : <NEWLINE> <INDENT> min_ = x <NEWLINE> max_num = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_dif ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> rt = [ int ( raw_input ( ) ) for x in xrange ( n ) ] <NEWLINE> <NL> i_max = rt . index ( max ( rt ) ) <NEWLINE> i_min = rt . index ( min ( rt ) ) <NEWLINE> <NL> a = rt [ i_max ] - min ( rt [ 1 : i_max ] ) <NEWLINE> b = max ( rt [ i_min : ] ) - rt [ i_min ] <NEWLINE> <NL> print a if a > b else b <NEWLINE>
n = input ( ) <NEWLINE> m = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> interest = [ m [ 1 ] - m [ 0 ] ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> M = max ( m [ i + 1 : ] ) <NEWLINE> if interest [ - 1 ] < M - m [ i ] : <NEWLINE> <INDENT> interest . append ( M - m [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( interest [ - 1 ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> values = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> maxv = - 99999999 <NEWLINE> minimum = values [ 0 ] <NEWLINE> <NL> for i in range ( 1 , N ) : <NEWLINE> <INDENT> if values [ i ] - minimum > maxv : <NEWLINE> <INDENT> maxv = values [ i ] - minimum <NEWLINE> <DEDENT> if values [ i ] < minimum : <NEWLINE> <INDENT> minimum = values [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE>
n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> list = [ ] <NEWLINE> <NL> i = 0 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> x = int ( x ) <NEWLINE> list [ i ] = x <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> maxv = - 20000000 <NEWLINE> minv = list [ 0 ] <NEWLINE> i = 1 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> if ( maxv >= list [ i ] - minv ) : <NEWLINE> <INDENT> maxv = maxv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxv = list [ i ] - minv <NEWLINE> <NL> <DEDENT> if ( minv <= list [ i ] ) : <NEWLINE> <INDENT> minv = minv <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> minv = list [ i ] <NEWLINE> <DEDENT> i = i + 1 <NEWLINE> <NL> print ( maxv ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> a = [ ] <NEWLINE> b = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> a . append ( int ( line ) ) <NEWLINE> b . append ( int ( line ) ) <NEWLINE> <NL> <DEDENT> del a [ 0 ] <NEWLINE> del a [ len ( a ) - 1 ] <NEWLINE> del b [ 0 ] <NEWLINE> del b [ 0 ] <NEWLINE> <NL> maxv = - 100000000 <NEWLINE> minv = a [ 0 ] <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> maxv = max ( sub , b [ i ] - minv ) <NEWLINE> minv = min ( minv , b [ i ] ) <NEWLINE> <NL> <DEDENT> print ( sub ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> <NL> def get_maximum_profit : <NEWLINE> <INDENT> element_number = int ( input ( ) ) <NEWLINE> v0 = int ( input ( ) ) <NEWLINE> v1 = int ( input ( ) ) <NEWLINE> <NL> min_v = v0 <NEWLINE> max_profit = v1 - v0 <NEWLINE> <NL> for i in map ( int , sys . stdin . readlines ( ) ) : <NEWLINE> <INDENT> min_v = min ( min_v , i ) <NEWLINE> max_profit = max ( max_profit , i - min_v ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> get_maximum_profit ( ) <NEWLINE> <DEDENT>
N = int ( raw_input ( ) ) <NEWLINE> max = ( - 1 ) * ( 10 ** 9 ) <NEWLINE> x1 = input ( ) <NEWLINE> min = x1 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> x = int ( raw_input ( ) ) <NEWLINE> <NL> if max < x - min : <NEWLINE> <INDENT> max = x - min <NEWLINE> <DEDENT> if min > x : <NEWLINE> <INDENT> min = x <NEWLINE> <DEDENT> <DEDENT> print max <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> M = int ( input ( ) ) <NEWLINE> m = M <NEWLINE> M_c = 0 <NEWLINE> m_c = 0 <NEWLINE> m_2 = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> a = int ( input ( ) ) <NEWLINE> if M <= a : <NEWLINE> <INDENT> M = a <NEWLINE> M_c = count <NEWLINE> <DEDENT> elif m >= a : <NEWLINE> <INDENT> m , m_2 = a , m <NEWLINE> m_c = count if m > a else m_c <NEWLINE> <NL> <DEDENT> <DEDENT> if m_c < M_c : <NEWLINE> <INDENT> print ( M - m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( m_2 - m ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> length = int ( sys . stdin . readline ( ) ) <NEWLINE> value = [ int ( num ) for num in sys . stdin . readlines ( ) ] <NEWLINE> minv = value [ 0 ] <NEWLINE> maxv = value [ 1 ] - value [ 0 ] <NEWLINE> <NL> for i in range ( 1 , length ) : <NEWLINE> <INDENT> maxv = max ( maxv , value [ i ] - minv ) <NEWLINE> minv = min ( minv , value [ i ] ) <NEWLINE> <NL> <DEDENT> print ( maxv ) <NEWLINE> <NL> return 0 <NEWLINE>
def calcMax ( i ) : <NEWLINE> <INDENT> now = numbers [ i ] <NEWLINE> <NL> future_max = max ( numbers [ i + 1 : ] ) <NEWLINE> <COMMENT> <NL> t = numbers [ i + 1 : ] <NEWLINE> <COMMENT> <NL> return future_max - now <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> numbers = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> numbers . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> m = - 1000000001 <NEWLINE> ti = 1000000001 <NEWLINE> for i in range ( len ( numbers ) - 1 ) : <NEWLINE> <INDENT> if numbers [ i ] < ti : <NEWLINE> <INDENT> if ( i == 0 or i == len ( numbers ) - 1 or ( numbers [ i - 1 ] >= numbers [ i ] and numbers [ i ] = < numbers [ i + 1 ] ) ) : <NEWLINE> <INDENT> temp = calcMax ( i ) <NEWLINE> <COMMENT> <NL> if temp > m : <NEWLINE> <INDENT> m = temp <NEWLINE> ti = numbers [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
<COMMENT> <NL> n = input ( ) <NEWLINE> <NL> R = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> R . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> start_point = 0 <NEWLINE> peak = 0 <NEWLINE> max_diff = - pow ( 10 , 9 ) <NEWLINE> <NL> while ( start_point < n - 1 ) : <NEWLINE> <INDENT> diff = - pow ( 10 , 9 ) <NEWLINE> for i in range ( start_point + 1 , n ) : <NEWLINE> <INDENT> diff_temp = R [ i ] - R [ start_point ] <NEWLINE> if ( diff_temp >= diff ) : <NEWLINE> <INDENT> diff = diff_temp <NEWLINE> peak = i <NEWLINE> <DEDENT> <DEDENT> for i in range ( start_point , peak ) : <NEWLINE> <INDENT> diff_temp = R [ peak ] - R [ i ] <NEWLINE> if ( diff_temp > max_diff ) : <NEWLINE> <INDENT> max_diff = diff_temp <NEWLINE> <DEDENT> <DEDENT> start_point = peak <NEWLINE> <NL> <DEDENT> print max_diff <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> R = list ( ) <NEWLINE> max = - 10000000000 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> R . append ( int ( raw_input ( ) ) ) <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if max < R [ i ] - R [ j ] : <NEWLINE> <INDENT> max = R [ i ] - R [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print max <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> min = int ( raw_input ( ) ) <NEWLINE> max = int ( raw_input ( ) ) <NEWLINE> dif = max - min <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> R = int ( raw_input ( ) ) <NEWLINE> if R - min > dif : <NEWLINE> <INDENT> dif = R - min <NEWLINE> <DEDENT> if R < min : <NEWLINE> <INDENT> min = R <NEWLINE> <NL> <DEDENT> <DEDENT> print dif <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> nums . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> m = - 1000000000000000000000000 <NEWLINE> for i in range ( 1 , len ( nums ) ) : <NEWLINE> <INDENT> value = nums [ i ] - min ( nums [ : i ] ) <NEWLINE> if m <= value : <NEWLINE> <INDENT> m = value <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m ) <NEWLINE>
def read_n_lows_input ( n ) : <NEWLINE> <INDENT> Alist = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> return Alist <NEWLINE> <NL> <DEDENT> def max_profit ( A , n ) : <NEWLINE> <INDENT> minv = A [ 0 ] <NEWLINE> for j in range ( 1 , n ) : <NEWLINE> <INDENT> if j == 1 : <NEWLINE> <INDENT> maxv = A [ j ] - A [ j - 1 ] <NEWLINE> <DEDENT> if maxv < A [ j ] - minv : <NEWLINE> <INDENT> maxv = A [ j ] - minv <NEWLINE> <DEDENT> if minv > A [ j ] : <NEWLINE> <INDENT> minv = A [ j ] <NEWLINE> <DEDENT> <DEDENT> print ( maxv ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> A = read_multi_low_input_with_num ( n ) <NEWLINE> <NL> max_profit ( A , n ) <NEWLINE>
import sys <NEWLINE> <NL> def solve ( ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> R = [ ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> R . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> max_profit = - sys . maxint <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , n ) : <NEWLINE> <INDENT> if R [ j ] - R [ i ] > max_profit : <NEWLINE> <INDENT> max_profit = R [ j ] - R [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print max_profit <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> max_profit = a [ 1 ] - a [ 0 ] <NEWLINE> min_val = min ( a [ 1 ] , a [ 0 ] ) <NEWLINE> for i in range ( 2 , N ) : <NEWLINE> <INDENT> if a [ i ] < min_val : <NEWLINE> <INDENT> min_val = a [ i ] <NEWLINE> <DEDENT> else if a [ i ] - min_val > max_profit : <NEWLINE> <INDENT> max_profit = a [ i ] - min_val <NEWLINE> <DEDENT> <DEDENT> print ( str ( max_profit ) ) <NEWLINE>
import sys <NEWLINE> x = input ( ) <NEWLINE> y = input ( ) . split ( ) <NEWLINE> r = sorted ( y ) <NEWLINE> c = 0 <NEWLINE> while y != r : <NEWLINE> <INDENT> for i , j in enumerate ( y [ : - 1 ] ) : <NEWLINE> <INDENT> if y [ i ] > y [ i + 1 ] : <NEWLINE> <INDENT> y [ i ] , y [ i + 1 ] = y [ i + 1 ] , y [ i ] <NEWLINE> c += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( y ) ) <NEWLINE> print ( c ) <NEWLINE>
def bubbleSort ( list_ , n ) : <NEWLINE> <INDENT> list_ = list_ [ : ] <NEWLINE> count = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> for j in xrange ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if list_ [ j ] < list_ [ j - 1 ] : <NEWLINE> <INDENT> list_ [ j ] , list_ [ j - 1 ] = list_ [ j - 1 ] , list_ [ j ] <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return list_ <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> nums = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sorted_ , count = bubbleSort ( nums , n ) <NEWLINE> print sorted <NEWLINE> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> f = 1 <NEWLINE> c = 0 <NEWLINE> while f == 1 : <NEWLINE> <INDENT> f = 0 <NEWLINE> for j in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> inc = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = inc <NEWLINE> f = 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( c ) <NEWLINE>
def bubble_sort ( A , N ) : <NEWLINE> <INDENT> flag = True <NEWLINE> c = 0 <NEWLINE> i = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> flag = False <NEWLINE> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> c += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print <STRING> . join ( map ( str , A ) ) <NEWLINE> print c <NEWLINE> <NL> <NL> <DEDENT> N = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> bubble_sort ( A , N ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> n = input ( ) <NEWLINE> a = map ( int , input_raw ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 , i + 1 , - 1 ) : <NEWLINE> <INDENT> if a [ j ] < a [ j - 1 ] : <NEWLINE> <INDENT> a [ j ] , a [ j - 1 ] = a [ j ] , a [ j - 1 ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> print ( c ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> nlist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def BubbleSort ( C , n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for w in range ( i + 1 , n ) : <NEWLINE> <INDENT> j = n - k + i <NEWLINE> if ( C [ j ] < C [ j - 1 ] ) : <NEWLINE> <INDENT> a = C [ j ] <NEWLINE> C [ j ] = C [ j - 1 ] <NEWLINE> C [ j - 1 ] = a <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> BubbleSort ( nlist , n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if ( i == n - 1 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( nlist [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( nlist [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> b = 0 <NEWLINE> for _ in a : <NEWLINE> <INDENT> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i - 1 ] : <NEWLINE> <INDENT> a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( b ) <NEWLINE>
num = int ( raw_input ( ) ) <NEWLINE> line = raw_input ( ) <NEWLINE> <NL> A_str = line . strip ( ) . split ( <STRING> ) <NEWLINE> print <STRING> . join ( A_str ) <NEWLINE> A = map ( int , item_str ) <NEWLINE> <NL> for i in range ( 1 , num ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - 1 <NEWLINE> for j in range ( j , - 1 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] > v : <NEWLINE> <INDENT> A [ j + 1 ] = A [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> A [ j + 1 ] = v <NEWLINE> A_str = map ( str , A ) <NEWLINE> print <STRING> . join ( A_str ) <NEWLINE> <DEDENT>
def bubble_sort ( A ) : <NEWLINE> <INDENT> swap_cnt = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for j in range ( len ( A ) , i + 1 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> swap_cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return A , swap_cnt <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> A , swap_cnt = bubble_sort ( A ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( swap_cnt ) <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> <NL> A = ( int ( n ) for n in input ( ) . split ( ) ) <NEWLINE> <NL> flag = 1 <NEWLINE> num_c = 0 <NEWLINE> while ( flag ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> v = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = v <NEWLINE> num_c += 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ( <STRING> ) . join ( ( str ( a ) for a in A ) ) ) <NEWLINE> print ( num_c ) <NEWLINE>
<INDENT> N = int ( input ( ) ) <NEWLINE> <DEDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j - 1 ] , A [ j ] = A [ j ] , A [ j - 1 ] <NEWLINE> flag = True <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL>
if __name__ == <STRING> <NEWLINE> <INDENT> N = input ( ) <NEWLINE> N = int ( N ) <NEWLINE> array = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if array [ j ] < array [ j - 1 ] : <NEWLINE> <INDENT> array [ j ] , array [ j - 1 ] = array [ j - 1 ] , array [ j ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , array ) ) ) <NEWLINE> print ( <STRING> % ( cnt ) ) <NEWLINE> <DEDENT>
import output <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> flg = 1 <NEWLINE> cnt = 0 <NEWLINE> while flg : <NEWLINE> <INDENT> flg = 0 <NEWLINE> for i in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ i ] < A [ i - 1 ] : <NEWLINE> <INDENT> t = A [ i ] <NEWLINE> A [ i ] = A [ i - 1 ] <NEWLINE> A [ i - 1 ] = t <NEWLINE> flg = 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> output . print_1 ( A ) <NEWLINE> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> A = list ( map ( int , s . split ( ) ) ) <NEWLINE> flag = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while ( flag == 1 ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> tmp = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = tmp <NEWLINE> flag = 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in range ( 0 , len ( A ) - 1 ) : <NEWLINE> <INDENT> print ( A [ k ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ len ( A ) - 1 ] ) <NEWLINE> print ( cnt ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if a [ j ] < a [ j - 1 ] : <NEWLINE> <INDENT> a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if j > 0 and A [ j - 1 ] > A [ j ] : <NEWLINE> <INDENT> A [ j - 1 ] , A [ j ] = A [ j ] , A [ j - 1 ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> pritn ( cnt ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def swap ( a , i , j ) : <NEWLINE> <INDENT> tmp = a [ j ] <NEWLINE> a [ j ] = a [ i ] <NEWLINE> a [ i ] = tmp <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def list_to_string ( a ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for n in a : <NEWLINE> <INDENT> s += str ( n ) + <STRING> <NEWLINE> <DEDENT> return s . strip ( ) <NEWLINE> <NL> <DEDENT> num = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> <NL> array = map ( lambda x : int ( x ) , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> flag = True <NEWLINE> swap_num = 0 <NEWLINE> <NL> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in reversed ( range ( 1 , len ( array ) ) ) : <NEWLINE> <INDENT> if array [ i ] < array [ i - 1 ] : <NEWLINE> <INDENT> swap ( a , i , i - 1 ) <NEWLINE> flag = True <NEWLINE> swap_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print list_to_string ( array ) <NEWLINE> print str ( swap_num ) <NEWLINE>
_n = int ( raw_input ( ) ) <NEWLINE> _a = [ int ( x ) in x for raw_input ( ) . split ( ) ] <NEWLINE> <NL> _flg = 1 <NEWLINE> cnt = 0 <NEWLINE> <NL> while _flg : <NEWLINE> <INDENT> _flg = 0 <NEWLINE> for i in reversed ( range ( 1 , _n ) ) : <NEWLINE> <INDENT> if _a [ i ] < _a [ i - 1 ] : <NEWLINE> <INDENT> _a [ i ] , _a [ i - 1 ] = _a [ i - 1 ] , _a [ i ] <NEWLINE> cnt += 1 <NEWLINE> _flg = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( _a ) ) <NEWLINE> print ( cnt ) <NEWLINE>
def bubbleSort ( A , N ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> count = 0 <NEWLINE> while flag == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( 1 , N ) [ : : - 1 ] : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> tmp = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = tmp <NEWLINE> flag = 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> bubbleSort ( A , n ) <NEWLINE>
def bubbleSort ( A , N ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> flag = 0 <NEWLINE> while flag == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> flag = 0 <NEWLINE> t += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> t = str ( A [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> t = t + <STRING> + str ( A [ i ] ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE> print ( s ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> bubbleSort ( a , n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> * array , = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> <NL> def bubble_sort ( a ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> flag = 1 <NEWLINE> i = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if a [ j ] < a [ j - 1 ] : <NEWLINE> <NL> <INDENT> a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] <NEWLINE> c += 1 <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( * a ) <NEWLINE> print ( c ) <NEWLINE> <NL> <NL> <DEDENT> bubble_sort ( array ) <NEWLINE> <NL> <NL> <NL> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> def bubbleSort ( arr , n ) : <NEWLINE> <NL> <INDENT> flag = True <NEWLINE> swap_num = 0 <NEWLINE> <NL> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in xrange ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if arr [ j ] < arr [ j - 1 ] : <NEWLINE> <INDENT> arr [ j ] , arr [ j - 1 ] = arr [ j - 1 ] , arr [ j ] <NEWLINE> swap_num += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> pass <NEWLINE> <DEDENT> return swap_num <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> arr = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> num = bubbleSort ( arr , n ) <NEWLINE> print <STRING> . join ( map ( str , test_arr ) ) <NEWLINE> print num <NEWLINE>
def BubbleSort ( A , n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> print ( A [ j ] , A [ j - 1 ] ) <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return A , count <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> ans = 0 <NEWLINE> ans , count = ( BubbleSort ( A , n ) ) <NEWLINE> ans = list ( map ( str , ans ) ) <NEWLINE> <NL> print ( <STRING> . join ( ans ) ) <NEWLINE> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class Solution : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> @ staticmethod <NEWLINE> def swap ( a , b ) : <NEWLINE> <INDENT> a , b = b , a <NEWLINE> return a , b <NEWLINE> <NL> <DEDENT> def bubble_sort ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> array_length = int ( input ( ) ) <NEWLINE> unsorted_array = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> flag = 1 <NEWLINE> count = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( array_length - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if unsorted_array [ j ] < unsorted_array [ j - 1 ] : <NEWLINE> <INDENT> self . swap ( unsorted_array [ j ] , unsorted_array [ j - 1 ] ) <NEWLINE> flag = 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , unsorted_array ) ) ) <NEWLINE> print ( str ( count ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . bubble_sort ( ) <NEWLINE> <DEDENT>
def bubble ( A , N ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> cnt = 0 <NEWLINE> while flag == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( 1 , N ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> k = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = A [ j ] <NEWLINE> A [ j ] = k <NEWLINE> flag = 1 <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return A , cnt <NEWLINE> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> list , cnt = bubble ( list , n ) <NEWLINE> for x in list : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> print <STRING> , cnt , <STRING> <NEWLINE>
def input_data ( ) : <NEWLINE> <INDENT> num = raw_input ( ) <NEWLINE> array = [ ] <NEWLINE> for line in num : <NEWLINE> <INDENT> if line != <STRING> : <NEWLINE> <INDENT> array . append ( line ) <NEWLINE> <NL> <DEDENT> <DEDENT> return array <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = raw_input ( ) <NEWLINE> count = 0 <NEWLINE> array = input_data ( ) <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in reversed ( xrange ( 1 , int ( n ) ) ) : <NEWLINE> <INDENT> if array [ j ] < array [ j - 1 ] : <NEWLINE> <INDENT> v = array [ j ] <NEWLINE> array [ j ] = array [ j - 1 ] <NEWLINE> array [ j - 1 ] = v <NEWLINE> flag = True <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( array ) <NEWLINE> print str ( count ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def bubbleSort ( A , N ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> flag = 1 <COMMENT> <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> c += 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , A ) ) <NEWLINE> print c <NEWLINE> <NL> <NL> <DEDENT> N = int ( raw_input ( ) ) <NEWLINE> L = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> bubbleSort ( L , N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ j - 1 ] > a [ j ] : <NEWLINE> <INDENT> tmp = a [ j - 1 ] <NEWLINE> a [ j - 1 ] = a [ j ] <NEWLINE> a [ j ] = tmp <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( x ) for x in a ] ) <NEWLINE> print ( c ) <NEWLINE>
<COMMENT> <NL> <NL> def bubblesort ( ls ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <NL> for i in range ( 1 , len ( ls ) ) : <NEWLINE> <INDENT> for j in reversed ( range ( i , len ( ls ) ) ) : <NEWLINE> <INDENT> if ls [ j ] < ls [ j - 1 ] : <NEWLINE> <INDENT> ls [ j ] , ls [ j - 1 ] = ls [ j - 1 ] , ls [ j ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> trash = input ( ) <NEWLINE> ls = list ( map ( int , input ) ) <NEWLINE> <NL> i = bubblesort ( ls ) <NEWLINE> <NL> print ( ls ) <NEWLINE> print ( i ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ input ( ) for i in range ( n ) ] <NEWLINE> a_swap = 0 <NEWLINE> <NL> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if int ( a [ j ] ) < int ( a [ j - 1 ] ) : <NEWLINE> <INDENT> a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] <NEWLINE> flag = True <NEWLINE> a_swap += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE> print ( a_swap ) <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> num_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> c = 0 <NEWLINE> flag = 1 <NEWLINE> while flag == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if num_list [ j ] < num_list [ j - 1 ] : <NEWLINE> <INDENT> a = num_list [ j ] <NEWLINE> num_list [ j ] = numlist [ j - 1 ] <NEWLINE> num_list [ j - 1 ] = a <NEWLINE> c += 1 <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , num_list ) ) <NEWLINE> print c <NEWLINE>
n = input ( ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> def trace ( A ) : <NEWLINE> <INDENT> for index , v in enumerate ( A ) : <NEWLINE> <INDENT> print ( v , end = <STRING> ) <NEWLINE> if index != len ( A ) - 1 : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> def bubble_sort ( A , n ) : <NEWLINE> <INDENT> i = n - 1 <NEWLINE> counter = 0 <NEWLINE> while i >= 1 : <NEWLINE> <INDENT> j = i - 1 <NEWLINE> while j >= 0 : <NEWLINE> <INDENT> if A [ i ] < A [ j ] : <NEWLINE> <INDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> counter += 1 <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> i -= 1 <NEWLINE> <DEDENT> trace ( A ) <NEWLINE> print ( counter ) <NEWLINE> <NL> <DEDENT> bubble_sort ( A , n ) <NEWLINE>
<INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <DEDENT> def bubble ( A , N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> flag = True <NEWLINE> while flag == True : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> A [ j - 1 ] , A [ j ] = A [ j ] , A [ j - 1 ] <NEWLINE> count += 1 <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL> <DEDENT> <DEDENT> bubble ( A , N ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = map ( int , input ( ) . split ( ) ) <NEWLINE> flag = True <NEWLINE> c = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( n - 1 , 1 , - 1 ) : <NEWLINE> <INDENT> if ( a [ j ] < a [ j - 1 ] ) : <NEWLINE> <INDENT> a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] <NEWLINE> flag = 1 <NEWLINE> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( c ) <NEWLINE>
def bubble_sort ( A ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( len ( A ) - 1 ) : <NEWLINE> <INDENT> for j in reversed ( range ( i + 1 , len ( A ) ) ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> tmp = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = tmp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> amount = int ( input ( ) ) <NEWLINE> nl = list ( int ( input ( ) ) for i in range ( amount ) ) <NEWLINE> <NL> cnt = bubble_sort ( nl ) <NEWLINE> <NL> for i in range ( amount - 1 ) : <NEWLINE> <INDENT> print ( nl [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( nl [ amount - 1 ] ) <NEWLINE> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def bubble_sort ( a , N ) : <NEWLINE> <INDENT> change = 0 <NEWLINE> for i in xrange ( N - 1 ) : <NEWLINE> <INDENT> for j in xrange ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if a [ j - 1 ] < a [ j ] : <NEWLINE> <INDENT> temp = a [ j - 1 ] <NEWLINE> a [ j - 1 ] = a [ j ] <NEWLINE> a [ j ] = temp <NEWLINE> change += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return ( a , change ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> result , change = bubble_sort ( a , N ) <NEWLINE> print print <STRING> . join ( map ( str , result ) ) <NEWLINE> print change <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> flag = True <NEWLINE> while Flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in range ( N - 1 , 1 ) : <NEWLINE> <INDENT> if ( A [ i ] < A [ i - 1 ] ) : <NEWLINE> <INDENT> A [ i ] , A [ i - 1 ] = A [ i - 1 ] , A [ i ] <NEWLINE> flag = True <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * A ) <NEWLINE> print ( count ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> def bubble_sort ( A , N ) : <NEWLINE> <INDENT> swap_num = 0 <COMMENT> <NEWLINE> <NL> for i in range ( N - 1 ) : <NEWLINE> <INDENT> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ j - 1 ] : <NEWLINE> <COMMENT> <NL> <INDENT> temp = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = temp <NEWLINE> swap_num += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return ( A , swap_num ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> array_sorted , swap_num = bubble_sort ( A , N ) <NEWLINE> print ( <STRING> . join ( map ( str , array_sorted ) ) ) <NEWLINE> print ( swap_num ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> b = 0 <NEWLINE> for _ in a : <NEWLINE> <INDENT> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] < a [ i - 1 ] : <NEWLINE> <INDENT> a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] <NEWLINE> b += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( b ) <NEWLINE>
import sys <NEWLINE> <NL> def bubble_sort ( x ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( 0 , len ( l ) - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( l ) ) : <NEWLINE> <INDENT> if ( x [ i ] > x [ j ] ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> temp = x [ i ] <NEWLINE> x [ i ] = x [ j ] <NEWLINE> x [ j ] = temp <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for data in x : <NEWLINE> <INDENT> print data , <NEWLINE> <DEDENT> print <STRING> , count <NEWLINE> <NL> <NL> <DEDENT> l = [ ] <NEWLINE> for input in sys . stdin : <NEWLINE> <INDENT> l . append ( input ) <NEWLINE> <DEDENT> l = l [ 1 : ] <NEWLINE> l = l [ 0 ] . split ( ) <NEWLINE> for i in range ( 0 , len ( l ) ) : <NEWLINE> <INDENT> l [ i ] = int ( l [ i ] ) <NEWLINE> <DEDENT> bubble_sort ( l ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) ) ) <NEWLINE> c = 0 <NEWLINE> min = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if a [ j ] < a [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if ( i != minj ) : <NEWLINE> <INDENT> a [ i ] , a [ minj ] = a [ minj ] , a [ i ] <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( c ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i + 1 , n - 1 ) : <NEWLINE> <INDENT> if a [ minj ] > a [ j ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if i != minj : <NEWLINE> <INDENT> a [ i ] , a [ minj ] = a [ minj ] , a [ i ] <NEWLINE> <INDENT> b += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( b ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( N ) <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) <NEWLINE> <INDENT> if a [ j ] < a [ minj ] <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if a [ i ] != a [ minj ] <NEWLINE> <INDENT> a [ minj ] , a [ i ] = a [ i ] , a [ minj ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( count ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> def print_list ( A ) : <NEWLINE> <INDENT> for a in A [ : - 1 ] : <NEWLINE> <INDENT> print ( <STRING> % a , end = <STRING> ) <NEWLINE> <DEDENT> print ( A [ - 1 ] ) <NEWLINE> <NL> <DEDENT> def SelectionSort ( A , N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if A [ j ] < A [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != i : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> A [ i ] = A [ minj ] <NEWLINE> A [ minj ] = v <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return A , count <NEWLINE> <NL> <DEDENT> A_sorted , c = BubbleSort ( A , N ) <NEWLINE> <NL> print_list ( A_sorted ) <NEWLINE> print ( c ) <NEWLINE>
def ss ( n , a ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if a [ j ] < a [ mini ] : <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> if i != mini : <NEWLINE> <INDENT> a [ i ] , a [ mini ] = a [ mini ] , a [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , a ) ) <NEWLINE> print count <NEWLINE> <NL> <DEDENT> ss ( int ( raw_input ( ) ) , map ( int , raw_inpu ( ) . split ( ) ) ) <NEWLINE>
N = innt ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( 0 , N - 1 ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N - 1 ) : <NEWLINE> <INDENT> if ( A [ j ] < A [ minj ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ minj ] = A [ minj ] , A [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( * A ) <NEWLINE> print ( count ) <NEWLINE>
def insection_sort ( lst ) : <NEWLINE> <INDENT> lens = len ( lst ) <NEWLINE> ans = 0 <NEWLINE> for i in xrange ( lens ) : <NEWLINE> <INDENT> mn = i <NEWLINE> for j in xrange ( i + 1 , lens ) : <NEWLINE> <INDENT> if ( lst [ j ] < lst [ mn ] ) : <NEWLINE> <INDENT> mn = j <NEWLINE> <DEDENT> <DEDENT> if ( mn != i ) : lens <NEWLINE> <INDENT> tmp = lst [ i ] <NEWLINE> lst [ i ] = lst [ mn ] <NEWLINE> lst [ mn ] = tmp <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> return ans <NEWLINE> <DEDENT> num = int ( raw_input ( ) . strip ( ) ) <NEWLINE> arr = map ( int , raw_input ( ) . strip ( ) . split ( ) ) <NEWLINE> ans = insection_sort ( arr ) <NEWLINE> print <STRING> . join ( str ( pp ) for pp in arr ) <NEWLINE> print ans <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> c = 0 <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in ( i + 1 , n ) : <NEWLINE> <INDENT> if a [ j ] < a [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != i : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> a [ i ] = a [ minj ] <NEWLINE> a [ minj ] = tmp <NEWLINE> c += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( x ) for x in a ] ) ) <NEWLINE> print ( c ) <NEWLINE>
def selectionsort ( l , n ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if int ( l [ i ] ) < int ( l [ minj ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> l [ j ] , l [ minj ] = l [ minj ] , l [ j ] <NEWLINE> if j != minj : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( l ) ) <NEWLINE> print ( c ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( input ( ) ) <NEWLINE> selectionsort ( l , n ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> x = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> mi = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if a [ j ] < a [ mi ] : <NEWLINE> <INDENT> mi = j <NEWLINE> <DEDENT> <DEDENT> if i != mi : <NEWLINE> <INDENT> x += 1 <NEWLINE> a [ i ] , a [ mi ] = a [ mi ] , [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( i ) for i in a ] ) ) <NEWLINE> print ( x ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> exchange_count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if nums [ j ] < nums [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != i : <NEWLINE> <INDENT> exchange_count += 1 <NEWLINE> <DEDENT> nums [ i ] , nums [ minj ] = nums [ minj ] , nums [ i ] <NEWLINE> <NL> <DEDENT> print ( <STRING> . join ( map ( str , nums ) ) ) <NEWLINE> print ( exchage_count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def selection_sort ( A , N ) : <NEWLINE> <INDENT> for i in xrange ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> change = 0 <NEWLINE> for j in xrange ( i , N ) : <NEWLINE> <INDENT> if A [ j ] < A [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> temp = A [ minj ] <NEWLINE> A [ minj ] = A [ j ] <NEWLINE> A [ j ] = temp <NEWLINE> change += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> result , change = selection_sort ( A , N ) <NEWLINE> print <STRING> . join ( map ( str , result ) ) <NEWLINE> print change <NEWLINE> <DEDENT>
ef main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ans = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if a [ j ] < a [ tmp ] : <NEWLINE> <INDENT> tmp = j <NEWLINE> <DEDENT> <DEDENT> if i != tmp : <NEWLINE> <INDENT> a [ i ] , a [ tmp ] = a [ tmp ] , a [ i ] <NEWLINE> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( ans ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def SelectionSort ( A ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , range ( A ) ) : <NEWLINE> <INDENT> if A [ j ] < A [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ minj ] = A [ minj ] , A [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> SelectionSort ( A ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> arr = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> swap_cnt = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i + 1 , N - 1 ) : <NEWLINE> <INDENT> if arr [ j ] < arr [ minj ] <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> arr [ i ] , arr [ minj ] = arr [ minj ] , arr [ i ] <NEWLINE> swap_cnt += 1 if i != minj else 0 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , arr ) ) ) <NEWLINE> print ( swap_cnt ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> nums = list ( map ( int , input ( ) ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if nums [ j ] < nums [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if not i == minj : <NEWLINE> <INDENT> v = nums [ i ] <NEWLINE> nums [ i ] = nums [ minj ] <NEWLINE> nums [ minj ] = v <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> print ( * nums ) <NEWLINE> print ( count ) <NEWLINE>
def selectionSort ( A , N ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if A [ j ] < A [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ minj ] = A [ minj ] , A [ i ] <NEWLINE> s += 1 <NEWLINE> <DEDENT> t = str ( A [ 0 ] ) <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> t = t + <STRING> + str ( A [ i ] ) <NEWLINE> <DEDENT> print ( t ) <NEWLINE> print ( s ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> slectionSort ( a , n ) <NEWLINE>
n = input ( ) <NEWLINE> lst = input ( ) . split ( ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for i in range ( 0 , len ( lst ) ) : <NEWLINE> <INDENT> m = i <NEWLINE> for j in range ( i , len ( lst ) ) : <NEWLINE> <INDENT> if lst [ m ] > lst [ j ] : <NEWLINE> <INDENT> m = j <NEWLINE> <DEDENT> <DEDENT> if m != i : <NEWLINE> <INDENT> lst [ i ] , lst [ m ] = lst [ m ] , lst [ i ] <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , lst ) ) <NEWLINE> print ( cnt ) <NEWLINE>
def show_list ( a ) : <NEWLINE> <INDENT> for x in a : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> print <NEWLINE> <NL> <DEDENT> def selection_sort ( a , n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in xrange ( 1 , 10 ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in xrange ( i , n ) : <NEWLINE> <INDENT> if a [ j ] < a [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> tmp = a [ i ] <NEWLINE> a [ i ] = a [ minj ] <NEWLINE> a [ minj ] = tmp <NEWLINE> count += 1 <NEWLINE> <DEDENT> show_list ( a ) <NEWLINE> print count <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> selection_sort ( a , n ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> A = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> num_c = 0 <NEWLINE> for i in ( 0 , N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in ( i , N ) : <NEWLINE> <INDENT> if A [ j ] < A [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ minj ] = A [ minj ] , A [ i ] <NEWLINE> num_c += 1 <NEWLINE> <NL> <DEDENT> print ( ( <STRING> ) . join ( str ( x ) for x in A ) ) <NEWLINE> print ( num_c ) <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> num_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = 0 <NEWLINE> <NL> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N , 1 ) : <NEWLINE> <INDENT> if num_list [ j ] < num_list [ minj ] : <NEWLINE> minj = j <NEWLINE> <DEDENT> a = num_list [ i ] <NEWLINE> num_list [ i ] = num_list [ minj ] <NEWLINE> num_list [ minj ] = a <NEWLINE> c += 1 <NEWLINE> <DEDENT> print <STRING> . join ( map ( str , num_list ) ) <NEWLINE> print c <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> A = raw_input ( ) . split ( <STRING> ) <NEWLINE> <NL> count = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if int ( A [ j ] ) < int ( A [ minj ) ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <NL> <DEDENT> <DEDENT> if i != minj : <NEWLINE> <INDENT> temp = A [ i ] <NEWLINE> A [ i ] = A [ minj ] <NEWLINE> A [ minj ] = temp <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( A ) <NEWLINE> print count <NEWLINE>
def selectionsort ( A , N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> min_a = min ( A [ i : ] ) <NEWLINE> min_index = A . index ( min_a ) <NEWLINE> A [ i ] , A [ min_index ] = min_a , A [ i ] <NEWLINE> if ( A [ i ] != A [ min_index ] ) : count += 1 <NEWLINE> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> c = selectionsort2 ( data , n ) <NEWLINE> print ( * data ) <NEWLINE> print ( c ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
length = int ( input ( ) ) <NEWLINE> targ = [ int ( n ) for n in input ( ) . split ( <STRING> ) ] <NEWLINE> ans = 0 <NEWLINE> for l in range ( length ) : <NEWLINE> <INDENT> value = l <NEWLINE> for init in range ( l + 1 , length ) : <NEWLINE> <INDENT> if targ [ value ] > targ [ init ] : <NEWLINE> <INDENT> value = init <NEWLINE> <DEDENT> <DEDENT> if value != l : <NEWLINE> <INDENT> disp = targ [ l ] <NEWLINE> targ [ l ] = targ [ value ] <NEWLINE> targ [ value ] = disp <NEWLINE> ans += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ str ( n ) for n in targ ] ) ) <NEWLINE> print ( ans ) <STRING> <NEWLINE>
<COMMENT> <NL> <NL> def selectionSort ( A , N ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in xrange ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in xrange ( i , N ) : <NEWLINE> <INDENT> if A [ j ] < A [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != i : <NEWLINE> <INDENT> A [ i ] , A [ minj ] = A [ minj ] , A [ i ] <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print selectionSort ( A , 6 ) <NEWLINE> print <STRING> . join ( map ( str , A ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = raw_input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> for i in xrange ( len ( A ) - 1 ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in xrange ( i , len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ j ] < A [ mini ] <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ mini ] = A [ mini ] , A [ j ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> for x in A : <NEWLINE> <INDENT> print x , <NEWLINE> <DEDENT> print <NEWLINE> print cnt <NEWLINE>
<COMMENT> <NL> <NL> N = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> swapCount = 0 <NEWLINE> for i in range ( 0 , N ) : <NEWLINE> <INDENT> minIndex = 1 <NEWLINE> for j in range ( 0 , N ) : <NEWLINE> <INDENT> if a [ j ] < a [ minIndex ] : <NEWLINE> <INDENT> minIndex = j <NEWLINE> <NL> <DEDENT> <DEDENT> if i != minIndex : <NEWLINE> <INDENT> tmp = a [ i ] <NEWLINE> a [ i ] = a [ minIdex ] <NEWLINE> a [ minIndex ] = tmp <NEWLINE> swapCount += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> print ( swapCount ) <NEWLINE> <NL>
STABLE = <STRING> <NEWLINE> UNSTABLE = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> card_num = int ( input ( ) ) <NEWLINE> cards = input ( ) . split ( ) <NEWLINE> <NL> bubble_sorted = bubble_sort ( cards , card_num ) <NEWLINE> select_sorted = select_sort ( cards , card_num ) <NEWLINE> <NL> stability = True <NEWLINE> for i , c in enumerate ( select_sorted ) : <NEWLINE> <INDENT> if c != bubble_sorted [ i ] : <NEWLINE> <INDENT> stability = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> stability = STABLE if stability else UNSTABLE <NEWLINE> <NL> print ( bubble_sorted ) <NEWLINE> print ( STABLE ) <NEWLINE> <NL> print ( select_sorted ) <NEWLINE> print ( stability ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <NL> <DEDENT> def order ( card_sym ) : <NEWLINE> <INDENT> return int ( card_sym [ 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> def select_sort ( elements , element_num ) : <NEWLINE> <INDENT> elements = list ( elements ) <NEWLINE> <NL> for i in range ( 0 , element_num - 1 ) : <NEWLINE> <INDENT> min_val = order ( elements [ i + 1 ] ) <NEWLINE> min_index = i + 1 <NEWLINE> for j in range ( i + 1 , element_num ) : <NEWLINE> <INDENT> if order ( elements [ j ] ) < order ( min_val ) : <NEWLINE> <INDENT> min_val = elements [ j ] <NEWLINE> min_index = j <NEWLINE> <DEDENT> <DEDENT> if order ( elements [ i ] ) > order ( elements [ min_index ] ) : <NEWLINE> <INDENT> elements [ i ] , elements [ min_index ] = elements [ min_index ] , elements [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> return elements <NEWLINE> <NL> <NL> <DEDENT> def bubble_sort ( elements , element_num ) : <NEWLINE> <INDENT> elements = list ( elements ) <NEWLINE> <NL> for i in range ( 1 , element_num ) : <NEWLINE> <INDENT> for j in reversed ( range ( i , element_num ) ) : <NEWLINE> <INDENT> if order ( elements [ j - 1 ] ) > order ( elements [ j ] ) : <NEWLINE> <INDENT> elements [ j - 1 ] , elements [ j ] = elements [ j ] , elements [ j - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return elements <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = a <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if int ( a [ j - 1 ] [ 1 ] ) > int ( a [ j ] [ 1 ] ) : <NEWLINE> <INDENT> tmp = a [ j - 1 ] <NEWLINE> a [ j - 1 ] = a [ j ] <NEWLINE> a [ j ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ra = <STRING> . join ( a ) <NEWLINE> <NL> print ( ra ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in ( i + 1 , n ) : <NEWLINE> <INDENT> if int ( b [ j ] [ 1 ] ) < int ( b [ minj ] [ 1 ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != i : <NEWLINE> <INDENT> tmp = b [ i ] <NEWLINE> b [ i ] = b [ minj ] <NEWLINE> b [ minj ] = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> rb = <STRING> . join ( b ) <NEWLINE> print ( rb ) <NEWLINE> <NL> if ra == rb : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> C = input ( ) . split ( ) <NEWLINE> _C = C . copy ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if ( C [ j ] [ 1 ] < C [ j - 1 ] [ 1 ] ) : <NEWLINE> <INDENT> C [ j ] [ 1 ] , C [ j - 1 ] [ 1 ] = C [ j - 1 ] [ 1 ] , C [ j ] [ 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * C ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> for j in range ( N ) : <NEWLINE> <INDENT> m = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if ( _C [ j ] [ 1 ] < _C [ j - 1 ] [ 1 ] ) : <NEWLINE> <INDENT> m = j <NEWLINE> <DEDENT> <DEDENT> _C [ i ] [ 1 ] , _C [ m ] [ 1 ] = _C [ m ] [ 1 ] , _C [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( * _C ) <NEWLINE> if ( C == _C ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def bubble_sort ( cards , num ) : <NEWLINE> <INDENT> for left in range ( num - 1 ) : <NEWLINE> <INDENT> for right in range ( left + 1 , num ) : <NEWLINE> <INDENT> if cards [ right ] [ 1 ] < cards [ left ] [ 1 ] : <NEWLINE> <INDENT> cards [ left ] , cards [ right ] = cards [ right ] , cards [ left ] <NEWLINE> <NL> print ( list_to_str ( cards ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def selection_sort ( cards , num ) : <NEWLINE> <INDENT> for head in range ( num ) : <NEWLINE> <INDENT> min_i = head <NEWLINE> <NL> for target in range ( head + 1 , num ) : <NEWLINE> <INDENT> if cards [ target ] [ 1 ] < cards [ min_i ] [ 1 ] : <NEWLINE> <INDENT> min_i = target <NEWLINE> <DEDENT> <DEDENT> cards [ head ] , cards [ min_i ] = cards [ min_i ] , cards [ head ] <NEWLINE> <NL> <DEDENT> print ( list_to_str ( cards ) ) <NEWLINE> <NL> <NL> <DEDENT> def is_stable ( before , after , num ) : <NEWLINE> <INDENT> for i in range ( num ) : <NEWLINE> <INDENT> for j in range ( i + 1 , num ) : <NEWLINE> <INDENT> for a in range ( num ) : <NEWLINE> <INDENT> for b in range ( a + 1 , num ) : <NEWLINE> <INDENT> if before [ i ] [ 1 ] == before [ j ] [ 1 ] and before [ i ] == after [ b ] and before [ j ] == after [ a ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> def list_to_str ( l , delimiter = <STRING> ) : <NEWLINE> <COMMENT> <NL> <INDENT> return delimiter . join ( [ str ( v ) for v in l ] ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> cards = input ( ) . split ( ) <NEWLINE> cards_for_bubble = cards . copy ( ) <NEWLINE> cards_for_selection = cards . copy ( ) <NEWLINE> <NL> bubble_sort ( cards_for_bubble , num ) <NEWLINE> print ( is_stable ( cards , cards_for_bubble , num ) ) <NEWLINE> <NL> selection_sort ( cards_for_selection , num ) <NEWLINE> print ( is_stable ( cards , cards_for_selection , num ) ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> nums = input ( ) <NEWLINE> nums = nums . split ( ) <NEWLINE> print ( <STRING> . join ( map ( str , nums ) ) ) <NEWLINE> <NL> def bubble_sort ( c , n ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( n - 1 ) : <NEWLINE> <INDENT> if c [ j ] > c [ j + 1 ] : <NEWLINE> <INDENT> c [ j ] , c [ j + 1 ] = c [ j + 1 ] , c [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def selection_sort ( c , n ) : <NEWLINE> <INDENT> for i in range ( ( n ) : <NEWLINE> <INDENT> mink = i <NEWLINE> for v in range ( i , n ) : <NEWLINE> <INDENT> if c [ v ] < c [ mink ] : <NEWLINE> <INDENT> mink = v <NEWLINE> <DEDENT> <DEDENT> if mink != i : <NEWLINE> <INDENT> c [ i ] , c [ mink ] = c [ mink ] , c [ i ] <NEWLINE> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def is_stable ( bs , ss ) : <NEWLINE> <INDENT> if bs == ss : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> bs = bubble_sort ( nums , int ( n ) ) <NEWLINE> print ( <STRING> . join ( bs ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> ss = selection_sort ( nums , int ( n ) ) <NEWLINE> print ( <STRING> . join ( ss ) ) <NEWLINE> print ( is_stable ( bs , ss ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( input ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> A1 = [ ] <NEWLINE> A2 = [ ] <NEWLINE> for i in a : <NEWLINE> <INDENT> A . append ( list ( i ) ) <NEWLINE> A1 . append ( list ( i ) ) <NEWLINE> A2 . append ( list ( i ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def is_stable ( A3 ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if int ( A3 [ i - 1 ] [ 1 ] ) == int ( A3 [ i ] [ 1 ] ) : <NEWLINE> <INDENT> sm = i - 1 <NEWLINE> bg = i <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if ( A [ j ] [ 0 ] == A3 [ sm ] [ 0 ] ) & ( A [ j ] [ 1 ] == A3 [ sm ] [ 1 ] ) : <NEWLINE> <INDENT> t1 = j <NEWLINE> <DEDENT> if ( A [ j ] [ 0 ] == A3 [ bg ] [ 0 ] ) & ( A [ j ] [ 1 ] == A3 [ bg ] [ 1 ] ) : <NEWLINE> <INDENT> t2 = j <NEWLINE> <DEDENT> <DEDENT> print ( t1 ) <NEWLINE> print ( t2 ) <NEWLINE> if t1 > t2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if int ( A1 [ j ] [ 1 ] ) < int ( A1 [ j - 1 ] [ 1 ] ) : <NEWLINE> <INDENT> t = A1 [ j - 1 ] <NEWLINE> A1 [ j - 1 ] = A1 [ j ] <NEWLINE> A1 [ j ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s = is_stable ( A1 ) <NEWLINE> print ( <STRING> . join ( A1 ) ) <NEWLINE> print ( s ) <NEWLINE> <NL> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if int ( A2 [ j ] [ 1 ] ) < int ( A2 [ minj ] [ 1 ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != i : <NEWLINE> <INDENT> t = A2 [ i ] <NEWLINE> A2 [ i ] = A2 [ minj ] <NEWLINE> A2 [ minj ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> s = is_stable ( A2 ) <NEWLINE> print ( <STRING> . join ( A2 ) ) <NEWLINE> print ( s ) <NEWLINE>
<NL> def BubbleSort ( N , C ) : <NEWLINE> <INDENT> C = [ ] + C <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if C [ j ] [ 1 ] < C [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> C [ j ] , C [ j - 1 ] = C [ j - 1 ] , C [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return C <NEWLINE> <NL> <DEDENT> def SelectionSort ( N , C ) : <NEWLINE> <INDENT> C = [ ] + C <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if C [ minj ] [ 1 ] > C [ j ] [ 1 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> C [ i ] , C [ minj ] = C [ minj ] , C [ i ] <NEWLINE> <DEDENT> return C <NEWLINE> <NL> <DEDENT> def CompareSuit ( L1 , L2 ) : <NEWLINE> <INDENT> suit1 , suit2 = <STRING> , <STRING> <NEWLINE> for i in range ( len ( L1 ) ) : <NEWLINE> <INDENT> suit1 = suit1 + L1 [ i ] <NEWLINE> suit2 = suit2 + L2 [ i ] <NEWLINE> <DEDENT> if suit1 == suit2 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> C = input . split ( ) <NEWLINE> <NL> C1 = BubbleSort ( N , C ) <NEWLINE> C2 = SelectionSort ( N , C ) <NEWLINE> <NL> print ( <STRING> . join ( C1 ) ) <NEWLINE> print ( CompareSuit ( C1 , C1 ) ) <NEWLINE> print ( <STRING> . join ( C2 ) ) <NEWLINE> print ( CompareSuit ( C1 , C2 ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> class Card ( object ) : <NEWLINE> <INDENT> def __init__ ( self , card ) : <NEWLINE> <INDENT> self . value = int ( card [ 1 ] ) <NEWLINE> self . card = card <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return self . card <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def BubbleSort ( C , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in reversed ( range ( i + 1 , N ) ) : <NEWLINE> <INDENT> if C [ j ] . value < C [ j - 1 ] . value : <NEWLINE> <INDENT> C [ j ] , C [ j - 1 ] = C [ j - 1 ] , C [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return C <NEWLINE> <NL> <NL> <DEDENT> def SelectionSort ( C , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if C [ j ] . value < C [ minj ] . value : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> C [ i ] , C [ minj ] = C [ minj ] , C [ i ] <NEWLINE> <DEDENT> return C <NEWLINE> <NL> <NL> <DEDENT> def isStable ( inl , out ) : <NEWLINE> <INDENT> n = len ( inl ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> if inl [ i ] . value == inl [ j ] . value and inl [ i ] == out [ b ] and inl [ j ] == out [ a ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> def print_stable ( inl , out ) : <NEWLINE> <INDENT> if isStable ( inl , out ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( raw_input ( ) ) <NEWLINE> inputs = raw_input ( ) . split ( ) <NEWLINE> C = [ ] <NEWLINE> for i in inputs : <NEWLINE> <INDENT> C . append ( Card ( i ) ) <NEWLINE> <DEDENT> Cb = BubbleSort ( list ( C ) , N ) <NEWLINE> for i in Cb : print i , <NEWLINE> print <STRING> <NEWLINE> print_stable ( C , Cb ) <NEWLINE> Cs = SelectionSort ( list ( C ) , N ) <NEWLINE> for i in Cs : print i , <NEWLINE> print <STRING> <NEWLINE> print_stable ( C , Cs ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> lst = input ( ) . split ( ) <NEWLINE> bub , sel = [ lst ] * 2 <NEWLINE> sls = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m = i <NEWLINE> li = lst [ i ] [ 0 ] <NEWLINE> if not li in sls : <NEWLINE> <INDENT> sls . append ( li ) <NEWLINE> <DEDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if bub [ j ] < bub [ j - 1 ] : <NEWLINE> <INDENT> bub [ j - 1 : j + 1 ] = bub [ j ] , bub [ j - 1 ] <NEWLINE> <DEDENT> <DEDENT> for k in range ( i , n ) : <NEWLINE> <INDENT> if sel [ k ] [ 1 ] < sel [ k ] [ 1 ] : <NEWLINE> <INDENT> m = k <NEWLINE> <DEDENT> <DEDENT> if m != i : <NEWLINE> <INDENT> sel [ i ] , sel [ m ] = sel [ m ] , sel [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def stable ( sort ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if sort [ i ] [ 1 ] == sort [ i - 1 ] [ 1 ] & sls . index ( sort [ i ] [ 0 ] ) < sls . index ( sort [ i - 1 ] [ 0 ] ) : <NEWLINE> <INDENT> s += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> if s else <STRING> ) <NEWLINE> <NL> <DEDENT> print ( * bub ) <NEWLINE> stable ( bub ) <NEWLINE> print ( * sel ) <NEWLINE> stable ( sel ) <NEWLINE>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def bubble ( cards ) : <NEWLINE> <INDENT> for i in range ( len ( cards ) ) : <NEWLINE> <INDENT> for j in range ( len ( cards ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if cards [ j ] [ 1 ] < cards [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> cards [ j ] , cards [ j - 1 ] = cards [ j - 1 ] , cards [ j ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def selection ( cards ) : <NEWLINE> <INDENT> for i in range ( len ( cards ) ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in range ( i , len ( cards ) ) : <NEWLINE> <INDENT> if cards [ j ] [ 1 ] < cards [ mini ] [ 1 ] : <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> cards [ i ] , cards [ mini ] = cards [ mini ] , cards [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def stable_test ( orders , crads ) : <NEWLINE> <INDENT> for order in orders : <NEWLINE> <INDENT> n = - 1 <NEWLINE> for c in order : <NEWLINE> <INDENT> p = n <NEWLINE> n = cards . index ( c ) <NEWLINE> if p > n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> stdin . readline ( ) <NEWLINE> data1 = stdin . readline ( ) . split ( ) <NEWLINE> data2 = data1 [ : ] <NEWLINE> orders = [ [ c for c in data1 if s . endswith ( str ( i ) ) ] for i in range ( 1 , 10 ) ] <NEWLINE> orders = [ o for o in orders if len ( s ) > 1 ] <NEWLINE> <NL> bubble ( data1 ) <NEWLINE> print ( * data1 ) <NEWLINE> print ( <STRING> if stable_test ( orders , data1 ) else <STRING> ) <NEWLINE> <NL> selection ( data2 ) <NEWLINE> print ( * data2 ) <NEWLINE> print ( <STRING> if stable_test ( orders , data2 ) else <STRING> ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> r = raw_input ( ) . split ( ) <NEWLINE> <NL> def BubbleSort ( c , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if int ( c [ j ] [ - 1 ] ) < int ( c [ j - 1 ] [ - 1 ] ) : <NEWLINE> <INDENT> c [ j ] , c [ j - 1 ] = c [ j - 1 ] , c [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def SelectionSort ( c , n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> m = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if int ( c [ j ] [ - 1 ] ) < int ( c [ m ] [ - 1 ] ) : <NEWLINE> <INDENT> m = j <NEWLINE> <DEDENT> <DEDENT> c [ i ] , c [ m ] = c [ m ] , c [ i ] <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> l = list ( r ) <NEWLINE> a = BubbleSort ( l , n ) <NEWLINE> print * a <NEWLINE> print <STRING> <NEWLINE> l = list ( r ) <NEWLINE> b = SelectionSort ( l , n ) <NEWLINE> print * b <NEWLINE> if a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> <NL> C = input ( ) . split ( ) <NEWLINE> <NL> B = C [ : ] <NEWLINE> S = C [ : ] <NEWLINE> <NL> <COMMENT> <NL> flag = 1 <NEWLINE> while ( flag ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for x in ( 1 , N ) : <NEWLINE> <INDENT> if C [ x ] [ 1 : ] < C [ x - 1 ] [ 1 : ] : <NEWLINE> <INDENT> C [ x ] , C [ x - 1 ] = C [ x - 1 ] , C [ x ] <NEWLINE> flag = 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for x in range ( 0 , N ) : <NEWLINE> <INDENT> minj = x <NEWLINE> for j in ( x , n ) : <NEWLINE> <INDENT> if S [ j ] [ 1 : ] < S [ minj ] [ 1 : ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if minj != x : <NEWLINE> <INDENT> S [ x ] , S [ j ] = S [ j ] , S [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( 1 , N ) : <NEWLINE> <INDENT> v = C [ i ] <NEWLINE> j = i - 1 <NEWLINE> while ( j >= 0 and C [ j ] > v ) : <NEWLINE> <INDENT> C [ j + 1 ] = C [ j ] <NEWLINE> j -= 1 <NEWLINE> <DEDENT> C [ j + 1 ] = v <NEWLINE> <NL> <DEDENT> if ( C == B ) : <NEWLINE> <INDENT> print ( <STRING> . join ( b for b in B ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( b for b in B ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> if ( C == S ) : <NEWLINE> <INDENT> print ( <STRING> . join ( b for b in S ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . join ( b for b in S ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import print_function <NEWLINE> import time <NEWLINE> import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> import math <NEWLINE> start = time . clock ( ) <NEWLINE> <NL> def bubble ( cards ) : <NEWLINE> <INDENT> for i in range ( len ( cards ) ) : <NEWLINE> <INDENT> for j in range ( len ( cards ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if cards [ j ] [ 1 ] < cards [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> cards [ j ] , cards [ j - 1 ] = cards [ j - 1 ] , cards [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def selection ( cards ) : <NEWLINE> <INDENT> for i in range ( len ( cards ) ) : <NEWLINE> <INDENT> mini = i <NEWLINE> for j in range ( i , len ( cards ) ) : <NEWLINE> <INDENT> if cards [ j ] [ 1 ] < cards [ mini ] [ 1 ] : <NEWLINE> <INDENT> mini = j <NEWLINE> <DEDENT> <DEDENT> cards [ i ] , cards [ mini ] = cards [ mini ] , cards [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def stabel_test ( orders , cards ) : <NEWLINE> <INDENT> for order in orders : <NEWLINE> <INDENT> n = - 1 <NEWLINE> for c in order : <NEWLINE> <INDENT> p = n <NEWLINE> n = cards . index ( c ) <NEWLINE> if p > n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> sys . stdin . readline ( ) <NEWLINE> data1 = sys . stdin . readline ( ) . split ( ) <NEWLINE> data2 = data1 [ : ] <NEWLINE> orders = [ [ c for c in data1 if c . endswitch ( str ( i ) ) ] for i in range ( 1 , 10 ) ] <NEWLINE> orders = [ o for o in orders if len ( c ) > 1 ] <NEWLINE> <NL> bubble ( data1 ) <NEWLINE> print ( * data1 ) <NEWLINE> print ( <STRING> if stabel_test ( orders , data1 ) else <STRING> ) <NEWLINE> <NL> selection ( data2 ) <NEWLINE> print ( * data2 ) <NEWLINE> print ( <STRING> if stable_test ( orders , data2 ) else <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = input ( ) . split ( ) <NEWLINE> b = a [ : ] <NEWLINE> <NL> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] > a [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> a [ i ] [ 1 ] , a [ i + 1 ] [ 1 ] = a [ i + 1 ] [ 1 ] , a [ i ] [ 1 ] <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * a ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> min_j = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if b [ j ] [ 1 ] < b [ min_j ] [ 1 ] : <NEWLINE> <INDENT> min_j = j <NEWLINE> <DEDENT> <DEDENT> b [ i ] [ 1 ] , b [ min_j ] [ 1 ] = b [ min_j ] [ 1 ] , b [ i ] [ 1 ] <NEWLINE> <DEDENT> print ( * b ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input_line = int ( input ( ) ) <NEWLINE> out_selection = input ( ) . split ( ) <NEWLINE> out_bubble = out_bubble [ : ] <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if out_bubble [ j ] [ 1 ] < out_bubble [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> out_bubble [ j ] , out_bubble [ j - 1 ] = out_bubble [ j - 1 ] , out_bubble [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * out_bubble ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if out_selection [ j ] [ 1 ] < out_selection [ minj ] [ 1 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> out_selection [ i ] , out_selection [ minj ] = out_selection [ minj ] , out_selection [ i ] <NEWLINE> <NL> <DEDENT> print ( * out_selection ) <NEWLINE> print ( <STRING> if out_bubble == out_selection else <STRING> ) <NEWLINE> <NL>
def str_selection_sort ( a , n ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if ( int ( a [ minj ] [ 1 : ] ) > int ( a [ j ] [ 1 : ] ) ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if ( minj != i ) : <NEWLINE> <INDENT> m += 1 <NEWLINE> a [ minj ] , a [ i ] = a [ i ] , a [ minj ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def bubble_sort ( a , n ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> flag = True <NEWLINE> while ( flag ) : <NEWLINE> <INDENT> flag = False <NEWLINE> for i in range ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ( a [ i - 1 ] [ 1 : ] > a [ i ] [ 1 : ] ) : <NEWLINE> <INDENT> tmp = a [ i - 1 ] <NEWLINE> a [ i - 1 ] = a [ i ] <NEWLINE> m += 1 <NEWLINE> a [ i ] = tmp <NEWLINE> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <NL> <DEDENT> def is_stable ( a , b , n ) : <NEWLINE> <INDENT> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if ( b [ i - 1 ] [ 1 : ] != b [ i ] [ 1 : ] ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> flag = False <NEWLINE> for j in a : <NEWLINE> <INDENT> if ( j [ : 1 ] == b [ i - 1 ] [ : 1 ] and ( not flag ) ) : <NEWLINE> <INDENT> flag = True <NEWLINE> continue <NEWLINE> <DEDENT> if ( j [ : 1 ] == b [ i ] [ : 1 ] ) : <NEWLINE> <INDENT> if ( not flag ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if ( flag ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = s . split ( ) <NEWLINE> b = str_bubble_sort ( list ( a ) , n ) <NEWLINE> if ( is_stable ( a , b , n ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> b = str_selection_sort ( list ( a ) , n ) <NEWLINE> if ( is_stable ( a , b , n ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def buble ( lst ) : <NEWLINE> <NL> <INDENT> src_list = list ( lst ) <NEWLINE> flag = True <NEWLINE> while flag : <NEWLINE> <INDENT> flag = False <NEWLINE> for idx in range ( len ( lst ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if int ( lst [ idx ] [ 1 ] ) < int ( lst [ idx - 1 ] [ 1 ] ) : <NEWLINE> <DEDENT> <DEDENT> flag_stable = True <NEWLINE> for num in range ( 0 , 9 ) : <NEWLINE> <INDENT> tmp1 = [ ] <NEWLINE> tmp2 = [ ] <NEWLINE> for i in range ( 0 , len ( lst ) ) : <NEWLINE> <INDENT> if int ( lst [ i ] [ 1 ] ) == num : <NEWLINE> <INDENT> tmp1 . append ( lst [ i ] ) <NEWLINE> <DEDENT> if int ( src_list [ i ] [ 1 ] ) == num : <NEWLINE> <INDENT> tmp2 . append ( src_list [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp1 != tmp2 : <NEWLINE> <INDENT> flag_stable = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( lst ) <NEWLINE> <NL> if flag_stable : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def selection ( lst ) : <NEWLINE> <NL> <INDENT> src_list = list ( lst ) <NEWLINE> for i in range ( len ( lst ) ) : <NEWLINE> <INDENT> m = i <NEWLINE> for j in range ( i , len ( lst ) ) : <NEWLINE> <INDENT> if int ( lst [ m ] [ 1 ] ) > int ( lst [ j ] [ 1 ] ) : <NEWLINE> <INDENT> m = j <NEWLINE> <DEDENT> <DEDENT> tmp = lst [ i ] <NEWLINE> lst [ i ] = lst [ m ] <NEWLINE> lst [ m ] = tmp <NEWLINE> <NL> <DEDENT> flag_stable = True <NEWLINE> for num in range ( 0 , 9 ) : <NEWLINE> <INDENT> tmp1 = [ ] <NEWLINE> tmp2 = [ ] <NEWLINE> for i in range ( 0 , len ( lst ) ) : <NEWLINE> <INDENT> if int ( lst [ i ] [ 1 ] ) == num : <NEWLINE> <INDENT> tmp1 . append ( lst [ i ] ) <NEWLINE> <DEDENT> if int ( src_list [ i ] [ 1 ] ) == num : <NEWLINE> <INDENT> tmp2 . append ( src_list [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if tmp1 != tmp2 : <NEWLINE> <INDENT> flag_stable = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( lst ) <NEWLINE> if flag_stable : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = raw_input ( ) <NEWLINE> lst1 = raw_input ( ) . split ( ) <NEWLINE> lst2 = list ( lst1 ) <NEWLINE> <NL> buble ( lst1 ) <NEWLINE> selection ( lst2 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> l = input ( ) . split ( ) <NEWLINE> <NL> def BubbleSort ( c ) : <NEWLINE> <INDENT> for i in range ( len ( c ) - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( c ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if int ( c [ j ] [ - 1 ] ) < int ( c [ j - 1 ] [ - 1 ] ) : <NEWLINE> <INDENT> c [ j ] , c [ j - 1 ] = c [ j - 1 ] , c [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> def SelectionSort ( C ) : <NEWLINE> <INDENT> for i in range ( len ( c ) - 1 ) : <NEWLINE> <INDENT> m = i <NEWLINE> for j in range ( i , len ( c ) - 1 ) : <NEWLINE> <INDENT> if int ( c [ j ] [ - 1 ] ) < int ( c [ m ] [ - 1 ] ) : <NEWLINE> <INDENT> c [ j ] , c [ m ] = c [ m ] , c [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return c <NEWLINE> <NL> <DEDENT> print ( BubbleSort ( l ) ) <NEWLINE> print ( SelectionSort ( l ) ) <NEWLINE>
<COMMENT> <NL> N = int ( raw_input ( ) ) <NEWLINE> num_list1 = raw_input ( ) . split ( ) <NEWLINE> <NL> num_list2 = num_list1 <NEWLINE> <NL> <NL> flag = 1 <NEWLINE> while flag == 1 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if int ( num_list1 [ j ] [ 1 : ] ) < int ( num_list1 [ j - 1 ] [ 1 : ] ) : <NEWLINE> <INDENT> a = num_list1 [ j ] <NEWLINE> num_list1 [ j ] = num_list1 [ j - 1 ] <NEWLINE> num_list1 [ j - 1 ] = a <NEWLINE> <NL> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( num_list1 ) <NEWLINE> print <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> for i in range ( 0 , N , 1 ) : <NEWLINE> <NL> <INDENT> minj = i <NEWLINE> for j in range ( i , N , 1 ) : <NEWLINE> <INDENT> if int ( num_list2 [ j ] [ 1 : ] ) < int ( num_list2 [ minj ] [ 1 : ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <NL> <DEDENT> <DEDENT> num_list2 [ i ] , num_list2 [ minj ] = num_list2 [ minj ] , num_list2 [ i ] <NEWLINE> <DEDENT> print <STRING> . join ( num_list2 ) <NEWLINE> <NL> <NL> if num_list1 == num_list2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> c = input ( ) . split ( ) ; d = c [ : ] <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> for j in range ( 0 , n - i - 1 ) : <NEWLINE> <INDENT> if c [ j ] [ 1 ] > c [ j + 1 ] [ 1 ] : c [ j ] , c [ j + 1 ] = c [ j + 1 ] , c [ j ] <NEWLINE> <DEDENT> m = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if d [ m ] [ 1 ] > d [ j ] [ 1 ] : m = j <NEWLINE> <DEDENT> d [ i ] , d [ m ] = d [ m ] , d [ i ] <NEWLINE> <DEDENT> print ( * c ) ; print ( <STRING> ) <NEWLINE> print ( * d ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ b == s ] + <STRING> ) <NEWLINE>
_ = int ( input ( ) ) <NEWLINE> l2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> class Card ( ) : <NEWLINE> <INDENT> def __init__ ( self , card ) : <NEWLINE> <INDENT> self . card = card <NEWLINE> self . mark = card [ 0 ] <NEWLINE> self . number = card [ 1 ] <NEWLINE> <NL> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> if not isinstance ( other , Card ) : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <DEDENT> return self . number < other . number <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> if not isinstance ( other , Card ) : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <DEDENT> return self . mark == other . mark and self . number == other . number <NEWLINE> <NL> <DEDENT> def __repr__ ( self ) : <NEWLINE> <INDENT> return <STRING> . format ( self . mark , self . number ) <NEWLINE> <NL> <DEDENT> def ls_sort ( self ) : <NEWLINE> <INDENT> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def BubbleSort ( target ) : <NEWLINE> <INDENT> ls = target . copy ( ) <NEWLINE> flag = 1 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( len ( ls ) - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if ls [ i ] < ls [ i - 1 ] : <NEWLINE> <INDENT> ls [ i ] , ls [ i - 1 ] = ls [ i - 1 ] , ls [ i ] <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ls ) ) ) <NEWLINE> return sorted ( ls ) <NEWLINE> <NL> <NL> <DEDENT> def SelectSort ( target ) : <NEWLINE> <INDENT> ls = target . copy ( ) <NEWLINE> for i in range ( len ( ls ) ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i + 1 , len ( ls ) ) : <NEWLINE> <INDENT> if ls [ j ] < ls [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if ls [ i ] != ls [ minj ] : <NEWLINE> <INDENT> ls [ i ] , ls [ minj ] = ls [ minj ] , ls [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , ls ) ) ) <NEWLINE> return sorted ( ls ) <NEWLINE> <NL> <DEDENT> l2 = [ Card ( i ) for i in l2 ] <NEWLINE> l2_sort = sorted ( l2 ) <NEWLINE> print ( l2_sort ) <NEWLINE> <NL> <NL> bubble = BubbleSort ( l2 ) <NEWLINE> if bubble == l2_sort : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> select = SelectSort ( l2 ) <NEWLINE> if select == l2_sort : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def bubbleSort ( o_nums , n ) : <NEWLINE> <INDENT> nums = o_nums [ : ] <NEWLINE> for i in range ( len ( nums ) - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( nums ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if nums [ j ] [ 1 ] < nums [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> nums [ j ] , nums [ j - 1 ] = nums [ j - 1 ] , nums [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return nums <NEWLINE> <NL> <DEDENT> def bubbleSort ( o_nums , n ) : <NEWLINE> <INDENT> nums = o_nums [ : ] <NEWLINE> for i in range ( len ( nums ) - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( nums ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if nums [ j ] [ 1 ] < nums [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> nums [ j ] , nums [ j - 1 ] = nums [ j - 1 ] , nums [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return nums <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cards = list ( input ( ) . split ( ) ) <NEWLINE> <NL> b = bubbleSort ( cards , n ) <NEWLINE> s = selectionSort ( cards , n ) <NEWLINE> print ( <STRING> . join ( b ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> . join ( s ) ) <NEWLINE> if bubbleSort ( cards , n ) == selectionSort ( cards , n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def bubble_sort ( num_list ) : <NEWLINE> <INDENT> list_b = num_list [ : ] <NEWLINE> for i in range ( len ( list_b ) - 1 ) : <NEWLINE> <INDENT> for j in range ( len ( list_b ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if list_b [ j ] [ 1 ] < list_b [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> list_b [ j ] , list_b [ j - 1 ] = list_b [ j - 1 ] , list_b [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return list_b <NEWLINE> <NL> <NL> <DEDENT> def selection_sort ( num_list ) : <NEWLINE> <INDENT> list_s = num_list [ : ] <NEWLINE> for i in range ( len ( list_s ) ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , len ( list_s ) ) : <NEWLINE> <INDENT> if list_s [ minj ] [ 1 ] > list_s [ j ] [ 1 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> list_s [ i ] , list_s [ minj ] = list_s [ minj ] , list_s [ i ] <NEWLINE> <DEDENT> return list_s <NEWLINE> <NL> <NL> <DEDENT> def isStable ( list_x , list_y ) : <NEWLINE> <INDENT> leng = int ( len ( list_x ) ) <NEWLINE> for i in range ( leng - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , leng ) : <NEWLINE> <INDENT> for x in range ( leng - 1 ) : <NEWLINE> <INDENT> for y in range ( x + 1 , leng ) : <NEWLINE> <INDENT> if list_x [ i ] [ 1 ] == list_x [ j ] [ 1 ] and list_x [ i ] == list_y [ y ] and list_x [ j ] == list_y [ x ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> qnt = int ( input ( ) ) <NEWLINE> num_list = input ( ) . split ( ) <NEWLINE> <NL> bs = bubble_sort ( num_list ) <NEWLINE> ss = selection_sort ( num_list ) <NEWLINE> print ( <STRING> . join ( bs ) ) <NEWLINE> print ( isStable ( num_list , bs ) ) <NEWLINE> print ( <STRING> . join ( ss ) ) <NEWLINE> print ( isStable ( num_list , ss ) <NEWLINE>
def bubble ( A ) : <NEWLINE> <INDENT> flag = True ; <NEWLINE> n = len ( A ) <NEWLINE> i = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] < A [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> flag = True <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def selection ( A ) : <NEWLINE> <INDENT> n = len ( A ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] < A [ minj ] [ 1 ] : <NEWLINE> <DEDENT> if i != minj : <NEWLINE> <INDENT> A [ i ] , A [ minj ] = A [ minj ] , A [ i ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ss = [ x for x in input ( ) . split ( ) ] <NEWLINE> ss2 = ss . copy ( ) <NEWLINE> <NL> bubble ( ss ) <NEWLINE> for i in range ( len ( ss ) - 1 ) : <NEWLINE> <INDENT> print ( ss [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ss [ - 1 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> selection ( ss2 ) <NEWLINE> for i in range ( len ( ss2 ) - 1 ) : <NEWLINE> <INDENT> print ( ss2 [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( ss2 [ - 1 ] ) <NEWLINE> if ss = ss2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
length = int ( input ( ) ) <NEWLINE> eles = [ int ( l ) for l in input ( ) . split ( ) ] <NEWLINE> is_stable = <STRING> <NEWLINE> <NL> import copy <NEWLINE> _copy = copy . deepcopy ( eles ) <NEWLINE> <NL> for i in range ( length ) : <NEWLINE> <INDENT> for j in range ( length - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if _copy [ j ] [ 1 ] < _copy [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> _copy [ j ] , _copy [ j - 1 ] = _copy [ j - 1 ] , _copy [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( * _copy ) <NEWLINE> print ( is_stable ) <NEWLINE> <NL> __copy = copy . deepcopy ( eles ) <NEWLINE> <NL> for i in range ( length - 1 ) : <NEWLINE> <INDENT> _min = i <NEWLINE> for l in range ( i , length ) : <NEWLINE> <INDENT> if __copy [ l ] [ 1 ] < __copy [ _min ] [ 1 ] : <NEWLINE> <INDENT> _min = l <NEWLINE> is_stable = <STRING> <NEWLINE> <DEDENT> <DEDENT> __copy [ i ] , __copy [ _min ] = __copy [ _min ] , __copy [ i ] <NEWLINE> <NL> <DEDENT> print ( * __copy ) <NEWLINE> print ( is_stable ) <NEWLINE>
import re <NEWLINE> import copy <NEWLINE> pattern = <STRING> <NEWLINE> repatter = re . compile ( pattern ) <NEWLINE> <NL> n = str ( input ( ) ) <NEWLINE> text = input ( ) <NEWLINE> <NL> * lists , = text . split ( <STRING> ) <NEWLINE> lists2 = copy . copy ( lists ) <NEWLINE> lists3 = copy . copy ( lists ) <NEWLINE> <NL> <NL> <COMMENT> <NL> def bubble_sort ( a ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> i = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> x = repatter . findall ( a [ j ] ) <NEWLINE> y = repatter . findall ( a [ j - 1 ] ) <NEWLINE> if x < y : <NEWLINE> <INDENT> a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> def select_sort ( a ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> min_j = i <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> x = repatter . findall ( a [ j ] ) <NEWLINE> y = repatter . findall ( a [ min_j ] ) <NEWLINE> if x < y : <NEWLINE> <INDENT> min_j = j <NEWLINE> <DEDENT> <DEDENT> a [ i ] , a [ min_j ] = a [ min_j ] , a [ i ] <NEWLINE> <DEDENT> print ( * a ) <NEWLINE> <NL> <NL> <DEDENT> def isStable ( before , after ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for a in range ( n ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> x = repatter . findall ( before [ i ] ) <NEWLINE> y = repatter . findall ( before [ j ] ) <NEWLINE> if x == y and before [ i ] == after [ b ] and before [ j ] == after [ a ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> bubble_sort ( lists ) <NEWLINE> select_sort ( lists2 ) <NEWLINE> isStable ( lists3 , lists2 ) <NEWLINE>
import sys <NEWLINE> <NL> def bubble_sort ( C , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( N - 1 , i , - 1 ) : <NEWLINE> <INDENT> if C [ j ] [ 1 ] < C [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> C [ j ] , C [ j - 1 ] = C [ j - 1 ] , C [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return C <NEWLINE> <NL> <DEDENT> def selection_sort ( C , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if C [ j ] [ 1 ] < C [ minj ] [ 1 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <NL> <DEDENT> <DEDENT> C [ i ] , C [ minj ] = C [ minj ] , C [ i ] <NEWLINE> <NL> <DEDENT> return C <NEWLINE> <NL> <DEDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> N = int ( fin . readline ( ) ) <NEWLINE> A = fin . readline ( ) . split ( ) <NEWLINE> B = A [ : ] <NEWLINE> <NL> A = bubble_sort ( A , N ) <NEWLINE> B = selection_sort ( B , N ) <NEWLINE> <NL> print ( <STRING> . join ( A ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> print ( <STRING> . join ( B ) ) <NEWLINE> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import copy <NEWLINE> N = int ( input ( ) ) <NEWLINE> bscs = [ ( int ( c [ - 1 ] ) , c ) for c in input ( ) . split ( <STRING> ) ] <NEWLINE> sscs = copy . copy ( bscs ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> j = N - 1 <NEWLINE> while j > i : <NEWLINE> <INDENT> if bscs [ j ] [ 0 ] < bscs [ j - 1 ] [ 0 ] : <NEWLINE> <INDENT> tmp = bscs [ j ] <NEWLINE> bscs [ j ] = bscs [ j - 1 ] <NEWLINE> bscs [ j - 1 ] = tmp <NEWLINE> <DEDENT> j -= 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( [ c [ 1 ] for c in bscs ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if sscs [ j ] [ 0 ] < sscs [ minj ] [ 0 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> tmp = sscs [ i ] <NEWLINE> sscs [ i ] = sscs [ minj ] <NEWLINE> sscs [ minj ] = tmp <NEWLINE> <DEDENT> print ( <STRING> . join ( [ c [ 1 ] for c in sscs ] ) ) <NEWLINE> print ( <STRING> if bscs == sscs else <STRING> ) <NEWLINE>
N = input ( ) <NEWLINE> A = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> Ab = A [ : ] <NEWLINE> As = A [ : ] <NEWLINE> <NL> def BubbleSort ( A , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in range ( 1 , N ) : <NEWLINE> <INDENT> j = N - i <NEWLINE> if A [ j ] [ 1 ] < A [ j - 1 ] [ 1 ] : <NEWLINE> <INDENT> v = A [ j ] <NEWLINE> A [ j ] = A [ j - 1 ] <NEWLINE> A [ j - 1 ] = v <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def SelectionSort ( A , N ) : <NEWLINE> <INDENT> for i in range ( N ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] < A [ minj ] [ 1 ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> v = A [ i ] <NEWLINE> A [ i ] = A [ minj ] <NEWLINE> A [ minj ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def Output ( A ) : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> print A [ i ] , <NEWLINE> <DEDENT> print A [ - 1 ] <NEWLINE> <NL> <DEDENT> def Stable ( AA ) : <NEWLINE> <INDENT> l = [ AA [ i ] for i in range ( N - 1 ) if AA [ i ] [ 1 ] == AA [ i + 1 ] [ 1 ] ] <NEWLINE> for item in l : <NEWLINE> <INDENT> for i in range ( N - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == item [ 1 ] : <NEWLINE> <INDENT> if A [ i ] == item : <NEWLINE> <INDENT> msg = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> msg = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print msg <NEWLINE> <NL> <DEDENT> SelectionSort ( As , N ) <NEWLINE> BubbleSort ( Ab , N ) <NEWLINE> <NL> Output ( Ab ) <NEWLINE> Stable ( Ab ) <NEWLINE> Output ( As ) <NEWLINE> Stable ( As ) <NEWLINE>
<COMMENT> <NL> def BubbleSort ( C , N ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for j in range ( N - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if int ( C [ j ] [ 1 : 2 ] ) < int ( C [ j - 1 ] [ 1 : 2 ] ) : <NEWLINE> <INDENT> tmp = C [ j ] <NEWLINE> C [ j ] = C [ j - 1 ] <NEWLINE> C [ j - 1 ] = tmp <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( C ) ) <NEWLINE> <NL> <NL> <NL> <NL> <COMMENT> <NL> <DEDENT> def SelectionSort ( C , N ) : <NEWLINE> <INDENT> for i in range ( 0 , N , 1 ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N , 1 ) : <NEWLINE> <INDENT> if int ( C [ j ] [ 1 : 2 ] ) < int ( C [ minj ] [ 1 : 2 ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> tmp = C [ i ] <NEWLINE> C [ i ] = C [ minj ] <NEWLINE> C [ minj ] = tmp <NEWLINE> <DEDENT> print ( <STRING> . join ( C ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def isStable ( inp , out , N ) : <NEWLINE> <INDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for a in range ( 0 , N ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N ) : <NEWLINE> <COMMENT> <NL> <INDENT> if int ( inp [ i ] [ 1 ] ) == int ( inp [ j ] [ 1 ] ) and inp [ i ] == out [ b ] and inp [ j ] == out [ a ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> 愚直に調べるパターン <NEWLINE> N = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> Bubble_A = A . copy ( ) <NEWLINE> Selection_A = A . copy ( ) <NEWLINE> <NL> BubbleSort ( Bubble_A , N ) <NEWLINE> isStable ( A , Bubble_A , N ) <NEWLINE> SelectionSort ( Selection_A , N ) <NEWLINE> isStable ( A , Selection_A , N ) <NEWLINE> <NL>
def isStable ( inlist , outlist ) : <NEWLINE> <INDENT> for i in range ( 0 , N ) : <NEWLINE> <INDENT> for j in range ( i + 1 , N ) : <NEWLINE> <INDENT> for a in range ( 0 , N ) : <NEWLINE> <INDENT> for b in range ( a + 1 , N ) : <NEWLINE> <INDENT> if int ( inlist [ i ] [ 1 : ] ) == int ( inlist [ j ] [ 1 : ] ) & & inlist [ i ] == outlist [ b ] & & inlist [ j ] == outlist [ a ] : <NEWLINE> <INDENT> return FALSE <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return TRUE <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = input ( ) . split ( ) <NEWLINE> B = A <NEWLINE> C = A <NEWLINE> <NL> flag = 1 <NEWLINE> counter = 0 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> for i in reversed ( range ( 1 , N ) ) : <NEWLINE> <INDENT> if int ( C [ i ] [ 1 : ] ) < int ( C [ i - 1 ] [ 1 : ] ) : <NEWLINE> <INDENT> C [ i ] , C [ i - 1 ] = C [ i - 1 ] , C [ i ] <NEWLINE> counter += 1 <NEWLINE> flag = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , C ) ) ) <NEWLINE> <NL> if ( isStable ( A , C ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> counter = 0 <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> Br = B [ i : ] <NEWLINE> Brr = [ int ( Br [ j ] [ 1 : ] ) for j in range ( N - i + 1 ) ] <NEWLINE> num = Brr . index ( min ( Brr ) ) <NEWLINE> if num != 0 : <NEWLINE> <INDENT> B [ i ] , B [ ( i + num ) ] = B [ ( i + num ) ] , B [ i ] <NEWLINE> counter += 1 <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , B ) ) ) <NEWLINE> if ( isStable ( A , B ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import copy <NEWLINE> <NL> def print_list ( A ) : <NEWLINE> <INDENT> print ( * A , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> def swap ( a , b ) : <NEWLINE> <INDENT> return b , a <NEWLINE> <NL> <DEDENT> def val ( str ) : <NEWLINE> <INDENT> return int ( str [ 1 ] ) <NEWLINE> <NL> <DEDENT> def is_stable ( _in , _out , n ) : <NEWLINE> <INDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> for a in range ( 0 , n ) : <NEWLINE> <INDENT> for b in range ( a + 1 , n ) : <NEWLINE> <INDENT> if val ( _in [ i ] ) == val ( _in [ j ] ) and _in [ i ] == _out [ b ] and _in [ j ] == _out [ a ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def print_stable ( _in , _out , n ) : <NEWLINE> <INDENT> if is_stable ( _in , _out , n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find_minj ( A , i , n ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , n ) : <NEWLINE> <INDENT> if val ( A [ j ] ) < val ( A [ minj ] ) : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> return minj <NEWLINE> <NL> <DEDENT> def bubble_sort ( A , n ) : <NEWLINE> <INDENT> A0 = copy . copy ( A ) <NEWLINE> flg = 1 <COMMENT> <NEWLINE> i = 0 <NEWLINE> while flg : <NEWLINE> <INDENT> flg = 0 <NEWLINE> for j in range ( n - 1 , i , - 1 ) : <NEWLINE> <INDENT> if val ( A [ j - 1 ] ) > val ( A [ j ] ) : <NEWLINE> <INDENT> A [ j - 1 ] , A [ j ] = swap ( A [ j - 1 ] , A [ j ] ) <NEWLINE> flg = 1 <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> print_list ( A ) <NEWLINE> print_stable ( A0 , A , n ) <NEWLINE> <NL> <DEDENT> def selection_sort ( A , n ) : <NEWLINE> <INDENT> A0 = copy . copy ( A ) <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> minj = find_minj ( A , i , n ) <NEWLINE> if val ( A [ i ] ) > val ( A [ minj ] ) : <NEWLINE> <INDENT> A [ i ] , A [ minj ] = swap ( A [ i ] , A [ minj ] ) <NEWLINE> <DEDENT> <DEDENT> print_list ( A ) <NEWLINE> print_stable ( A0 , A , n ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = copy . copy ( A ) <NEWLINE> <NL> bubble_sort ( A , n ) <NEWLINE> selection_sort ( B , n ) <NEWLINE>
import sys <NEWLINE> <NL> class Card : <NEWLINE> <INDENT> def __init__ ( self , kind , num ) : <NEWLINE> <INDENT> self . kind = kind <NEWLINE> self . num = num <NEWLINE> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> return ( self . kind == other . kind ) and ( self . num == other . num ) <NEWLINE> <DEDENT> def __ne__ ( self , other ) : <NEWLINE> <INDENT> return not ( ( self . kind == other . kind ) and ( self . num == other . num ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def list_to_string ( array ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> for n in array : <NEWLINE> <INDENT> s += str ( n ) + <STRING> <NEWLINE> <DEDENT> return s . strip ( ) <NEWLINE> <NL> <DEDENT> def swap ( array , i , j ) : <NEWLINE> <INDENT> tmp = array [ i ] <NEWLINE> array [ i ] = array [ j ] <NEWLINE> array [ j ] = tmp <NEWLINE> <NL> <DEDENT> def is_stable ( array1 , array2 ) : <NEWLINE> <INDENT> if reduce ( lambda x , y : x and y , map ( lambda x : x [ 0 ] == x [ 1 ] , zip ( array1 , array2 ) ) ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def bubble_sort ( array ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( array ) ) : <NEWLINE> <INDENT> for j in reversed ( range ( i + 1 , len ( array ) ) ) : <NEWLINE> <INDENT> if array [ j ] . num < array [ j - 1 ] . num : <NEWLINE> <INDENT> swap ( array , j , j - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def selection_sort ( array ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( array ) ) : <NEWLINE> <INDENT> min_index = i <NEWLINE> for j in range ( i , len ( array ) ) : <NEWLINE> <INDENT> if array [ min_index ] . num > array [ j ] . num : <NEWLINE> <INDENT> min_index = j <NEWLINE> <DEDENT> <DEDENT> swap ( array , i , min_index ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> num = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> array = map ( lambda x : Card ( x [ 0 ] , x [ 1 ] ) , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> a = list ( array ) <NEWLINE> b = list ( array ) <NEWLINE> <NL> print list_to_string ( bubble_sort ( a ) ) <NEWLINE> print is_stable ( a , array ) <NEWLINE> print list_to_string ( selection_sort ( b ) ) <NEWLINE> print is_stable ( b , array ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Card : <NEWLINE> <INDENT> def __init__ ( self , mark , value ) : <NEWLINE> <INDENT> self . mark = mark <NEWLINE> self . value = value <NEWLINE> <NL> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <INDENT> if not isinstance ( other , Card ) : <NEWLINE> <INDENT> return NotImplemented <NEWLINE> <DEDENT> return self . value == other . value and self . mark == other . mark <NEWLINE> <NL> <DEDENT> def __lt__ ( self , other ) : <NEWLINE> <INDENT> return self . value < other . value <NEWLINE> <NL> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return self . mark + str ( self . value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def BubbleSort ( arr ) : <NEWLINE> <INDENT> res = [ Card ( c . mark , c . value ) for c in arr ] <NEWLINE> swap_flg = True <NEWLINE> i = 0 <NEWLINE> while swap_flg : <NEWLINE> <INDENT> swap_flg = False <NEWLINE> for j in range ( len ( res ) - 1 , i , - 1 ) : <NEWLINE> <INDENT> if ( res [ j ] < res [ j - 1 ] ) : <NEWLINE> <INDENT> res [ j ] , res [ j - 1 ] = res [ j - 1 ] , res [ j ] <NEWLINE> swap_flg = True <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def SelectionSort ( arr ) : <NEWLINE> <INDENT> res = [ Card ( c . mark , c . value ) for c in arr ] <NEWLINE> for i in range ( 0 , len ( res ) ) : <NEWLINE> <INDENT> minj = i <NEWLINE> for j in range ( i , N ) : <NEWLINE> <INDENT> if res [ j ] < res [ minj ] : <NEWLINE> <INDENT> minj = j <NEWLINE> <DEDENT> <DEDENT> if ( i != minj ) : <NEWLINE> <INDENT> res [ i ] , res [ minj ] = res [ minj ] , res [ i ] <NEWLINE> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def isStable ( in_arr , out_arr ) : <NEWLINE> <INDENT> stable_arr = BubbleSort ( in_arr ) <NEWLINE> return all ( out_arr [ i ] == stable_arr [ i ] for i in range ( 0 , len ( out_arr ) ) ) <NEWLINE> <NL> <NL> <DEDENT> def printJudgeStable ( in_arr , out_arr ) : <NEWLINE> <INDENT> print ( <STRING> if isStable ( in_arr , out_arr ) else <STRING> ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> arr = [ Card ( s [ 0 ] , int ( s [ 1 ] ) ) for s in input ( ) . split ( ) ] <NEWLINE> b_arr = BubbleSort ( arr ) <NEWLINE> print ( <STRING> . join ( map ( str , b_arr ) ) ) <NEWLINE> printJudgeStable ( arr , b_arr ) : <NEWLINE> s_arr = SelectionSort ( arr ) <NEWLINE> print ( <STRING> . join ( map ( str , s_arr ) ) ) <NEWLINE> printJudgeStable ( arr , s_arr ) : <NEWLINE> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> class Solution : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . count = 0 <NEWLINE> <NL> <DEDENT> def shell_sort ( self ) : <NEWLINE> <INDENT> array_length = int ( input ( ) ) <NEWLINE> array = [ ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> for m in range ( array_length ) : <NEWLINE> <INDENT> array . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> G = [ 1 ] <NEWLINE> while True : <NEWLINE> <INDENT> g = G [ 0 ] * 3 + 1 <NEWLINE> if g > array_length : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( g ) <NEWLINE> <NL> <DEDENT> g_length = len ( G ) <NEWLINE> G = G [ : : - 1 ] <NEWLINE> result = [ ] <NEWLINE> for j in range ( g_length ) : <NEWLINE> <INDENT> result = self . insertion_sort ( array = array , array_length = array_length , g = G [ j ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print ( g_length ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( self . count ) <NEWLINE> for k in range ( array_length ) : <NEWLINE> <INDENT> print ( result [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def insertion_sort ( self , array , array_length , g ) : <NEWLINE> <COMMENT> <NL> <NL> <INDENT> for i in range ( g , array_length ) : <NEWLINE> <INDENT> v = array [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and array [ j ] > v : <NEWLINE> <INDENT> array [ j + g ] = array [ j ] <NEWLINE> j -= g <NEWLINE> self . count += 1 <NEWLINE> <DEDENT> array [ j + g ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return array <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . shell_sort ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> count = 0 <NEWLINE> <NL> <NL> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global count <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> <NL> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> count += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> global count <NEWLINE> G = [ i for i in range ( 1 , n ) if i % 3 == 1 ] <NEWLINE> m = len ( G ) <NEWLINE> G = G [ : : - 1 ] <NEWLINE> for i in G : <NEWLINE> <INDENT> insertionSort ( A , n , i ) <NEWLINE> <DEDENT> return A , G , m <NEWLINE> <NL> <NL> <DEDENT> A , G , m = shellSort ( A , n ) <NEWLINE> print ( m ) <NEWLINE> print ( G ) <NEWLINE> print ( cnt ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import math <NEWLINE> <NL> ct = 0 <NEWLINE> def insertion_sort ( a , n , g ) : <NEWLINE> <INDENT> for j in range ( 0 , n - g ) : <NEWLINE> <INDENT> v = a [ j + g ] <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j = j - g <NEWLINE> ct += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readlines ( ) ) ) <NEWLINE> b = 701 <NEWLINE> g = [ x for x in [ 1 , 4 , 10 , 23 , 57 , 132 , 301 , 701 ] if x <= n ] <NEWLINE> while True : <NEWLINE> <INDENT> b = math . floor ( 2.25 * b ) <NEWLINE> if b > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> g . append ( b ) <NEWLINE> <DEDENT> g = g [ : : - 1 ] <NEWLINE> <NL> for i in g : <NEWLINE> <INDENT> insertion_sort ( a , n , i ) <NEWLINE> <NL> <DEDENT> print ( len ( g ) ) <NEWLINE> print ( * g , sep = <STRING> ) <NEWLINE> print ( ct ) <NEWLINE> print ( * a , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> def print_arr ( arr ) : <NEWLINE> <INDENT> for i in range ( len ( arr ) ) : <NEWLINE> <INDENT> sys . stdout . write ( str ( arr [ i ] ) ) <NEWLINE> if i != len ( arr ) - 1 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> def insertion_sort ( arr , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = arr [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and arr [ j ] > v : <NEWLINE> <INDENT> arr [ j + g ] = arr [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> arr [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shell_sort ( arr , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( len ( g ) ) : <NEWLINE> <INDENT> cnt += insertion_sort ( arr , len ( arr ) , g [ i ] ) <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def get_gap ( n ) : <NEWLINE> <INDENT> lst = [ ] <NEWLINE> v = 1 <NEWLINE> while v <= n : <NEWLINE> <INDENT> lst . append ( v ) <NEWLINE> v += 3 ** cnt <NEWLINE> <DEDENT> if len ( lst ) == 0 : lst . append ( 1 ) <NEWLINE> return list ( reversed ( lst ) ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> arr = [ 0 ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> arr [ i ] = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> g = get_gap ( n ) <NEWLINE> m = len ( g ) <NEWLINE> cnt = shell_sort ( arr , g ) <NEWLINE> <NL> print ( m ) <NEWLINE> print_arr ( g ) <NEWLINE> print ( cnt ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( arr [ i ] ) <NEWLINE> <NL> <DEDENT>
swap_count = 0 <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> elements = [ ] <NEWLINE> for i in range ( 0 , num ) : <NEWLINE> <INDENT> elements . append ( int ( input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> interval = 1 <NEWLINE> intervals = [ interval ] <NEWLINE> while True : <NEWLINE> <INDENT> interval = int_f ( interval ) <NEWLINE> if interval > num : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> intervals . insert ( 0 , interval ) <NEWLINE> <NL> <DEDENT> for interval in intervals : <NEWLINE> <INDENT> insertion_sort ( elements , num , interval ) <NEWLINE> <NL> <DEDENT> print ( len ( intervals ) ) <NEWLINE> print ( <STRING> . join ( [ str ( interval ) for interval in intervals ] ) ) <NEWLINE> print ( swap_count ) <NEWLINE> for val in elements : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def int_f ( x ) : <NEWLINE> <INDENT> return 2.25 * x + 1 <NEWLINE> <NL> <NL> <DEDENT> def insertion_sort ( elements , num , interval = 1 ) : <NEWLINE> <INDENT> global swap_count <NEWLINE> <NL> i = interval <NEWLINE> while i < num : <NEWLINE> <INDENT> j = i <NEWLINE> while interval <= j : <NEWLINE> <INDENT> if elements [ j - interval ] <= elements [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> elements [ j - interval ] , elements [ j ] = elements [ j ] , elements [ j - interval ] <NEWLINE> swap_count += 1 <NEWLINE> j -= interval <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> <NL> def insertion_sort ( A , N , g ) : <NEWLINE> <INDENT> for i in range ( g , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <COMMENT> <NL> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> print ( * A ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def shell_sort ( a , n ) : <NEWLINE> <INDENT> g = [ ] <NEWLINE> gap = 1 <NEWLINE> while gap <= math . ceil ( n / 3 ) : <NEWLINE> <INDENT> g . append ( gap ) <NEWLINE> gap = 3 * gap + 1 <NEWLINE> <DEDENT> g = g [ : : - 1 ] <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( * g ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += insertion_sort ( a , n , g [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shell_sort ( a , n ) <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
import System <NEWLINE> if sys . version_info [ 0 ] >= 3 : raw_input = InputStream <NEWLINE> <NL> def insertionSort ( a , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , len ( a ) ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def shellSort ( a ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> g = [ ] <NEWLINE> h = 1 <NEWLINE> while h <= len ( a ) : <NEWLINE> <INDENT> g . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( a , g [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ int ( raw_input ( ) ) for i in range ( int ( raw_input ( ) ) ) ] <NEWLINE> shellSort ( a ) <NEWLINE> print ( cnt ) <NEWLINE> for e in a : print ( e ) <NEWLINE>
def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> h = 1 <NEWLINE> G = [ ] <NEWLINE> while h < n : <NEWLINE> <INDENT> G += [ h ] <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> for i in range ( m - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> cnt = insertionSort ( A , n , G [ i ] , cnt ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> print ( * G [ : : - 1 ] ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( readline ( ) ) for _ in range ( n ) ] <NEWLINE> shellSort ( A , n ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( e ) for e in sys . stdin ] <NEWLINE> cnt = 0 <NEWLINE> G = [ 797161 , 265720 , 88573 , 29524 , 9841 , 3280 , 1093 , 364 , 121 , 40 , 13 , 4 , 1 ] <NEWLINE> G = [ v for v in G if v <= n ] <NEWLINE> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> for g in G : <NEWLINE> <INDENT> insertionSort ( A , n , g ) <NEWLINE> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> if n == 1 : <NEWLINE> <INDENT> G = [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> G = [ g for g in [ 1 , 4 , 10 , 23 , 57 , 132 , 301 , 701 ] if g < n ] <NEWLINE> while True : <NEWLINE> <INDENT> g = int ( 2.25 * G [ - 1 ] ) <NEWLINE> if g > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( g ) <NEWLINE> <DEDENT> G . reverse ( ) <NEWLINE> <NL> <DEDENT> A = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> cnt = 0 <NEWLINE> for g in G : <NEWLINE> <INDENT> for j , v in enumerate ( A [ g : ] ) : <NEWLINE> <INDENT> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt , * a , sep = <STRING> ) <NEWLINE>
def insertionSort ( a , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , len ( a ) ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> a [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def shellSort ( a ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> g = [ ] <NEWLINE> h = 1 <NEWLINE> while h <= len ( a ) : <NEWLINE> <INDENT> g . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( a , g [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> a = [ int ( raw_input ( ) ) for i in range ( int ( raw_input ( ) ) ) ] <NEWLINE> shellSort ( a ) <NEWLINE> print ( cnt ) <NEWLINE> for e in a : print ( e ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> import sys <NEWLINE> <NL> def insertionSort ( a , n , g ) : <NEWLINE> <INDENT> ct = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> ct += 1 <NEWLINE> a [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> return ct <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , sys . stdin . readlines ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> m = 0 <NEWLINE> h = 0 <NEWLINE> g = [ ] <NEWLINE> <NL> while True : <NEWLINE> <INDENT> h = 3 * h + 1 <NEWLINE> if h > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> g . insert ( 0 , h ) <NEWLINE> <NL> <DEDENT> for i in g : <NEWLINE> <INDENT> cnt += insertionSort ( a , n , i ) <NEWLINE> <NL> <DEDENT> print ( len ( g ) ) <NEWLINE> print ( * g , sep = <STRING> ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * a , sep = <STRING> ) <NEWLINE>
def insertion_sort ( a , n , g ) : <NEWLINE> <INDENT> ct = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j -= g <NEWLINE> ct += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <DEDENT> return ct <NEWLINE> <NL> <DEDENT> def interval_list ( n ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> gi = 1 <NEWLINE> g = [ ] <NEWLINE> while b <= n : <NEWLINE> <INDENT> m += 1 <NEWLINE> g . append ( gi ) <NEWLINE> b = 4 ** m + 3 * 2 ** ( m - 1 ) + 1 <NEWLINE> <DEDENT> return g . reverse ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( int ( input ( ) ) for _ in range ( n ) ) <NEWLINE> G = interval_list ( n ) <NEWLINE> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> <NL> ct = 0 <NEWLINE> for i in G : <NEWLINE> <INDENT> ct += insertion_sort ( A , n , i ) <NEWLINE> <DEDENT> print ( ct ) <NEWLINE> print ( * A , sep = <STRING> ) <NEWLINE> <DEDENT>
def insertion_sort ( A , N , g ) : <NEWLINE> <INDENT> grobal cnt <NEWLINE> for i in range ( g , N ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> A [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def shell_sort ( A , N ) : <NEWLINE> <INDENT> grobal cnt <NEWLINE> cnt = 0 <NEWLINE> G = [ ] <NEWLINE> h = 1 <NEWLINE> while h <= len ( A ) : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> G . reverse ( ) <NEWLINE> m = len ( G ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> for g in G : <NEWLINE> <INDENT> insertion_sort ( A , N , g ) <NEWLINE> <DEDENT> return m , G <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> shell_sort ( A , N ) <NEWLINE> print ( cnt ) <NEWLINE> for a in A : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <DEDENT>
def insertionSort ( arr , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , len ( arr ) ) : <NEWLINE> <INDENT> tmp = arr [ i ] <NEWLINE> j = i - g <NEWLINE> while ( j >= 0 and arr [ j ] > tmp ) : <NEWLINE> <INDENT> arr [ j + g ] = arr [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> arr [ j + 1 ] = tmp <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( arr ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> g = [ ] <NEWLINE> h = 0 <NEWLINE> while h <= len ( arr ) / 9 : <NEWLINE> <INDENT> h = 3 * h + 1 <NEWLINE> g . append ( h ) <NEWLINE> <DEDENT> g = g [ : : - 1 ] <NEWLINE> <NL> for i in range ( 0 , m ) : <NEWLINE> <INDENT> cnt += insertionSort ( arr , g [ i ] ) <NEWLINE> <DEDENT> return ( cnt , g ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> ( cnt , g ) = shellSort ( arr ) <NEWLINE> print ( len ( g ) ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> print ( <STRING> . join ( map ( str , arr ) ) ) <NEWLINE> <NL>
n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> num = 1 <NEWLINE> G = [ 1 ] <NEWLINE> while 1 : <NEWLINE> <INDENT> if num * 3 + 1 > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . insert ( 0 , num * 3 + 1 ) <NEWLINE> num = num * 3 + 1 <NEWLINE> <DEDENT> m = num <NEWLINE> <NL> def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> print m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i == m - 1 : <NEWLINE> <INDENT> print G [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print G [ i ] , <NEWLINE> <NL> <DEDENT> <DEDENT> print cnt <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print a [ i ] <NEWLINE> <DEDENT>
def isort ( a , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> g = [ 1 ] <NEWLINE> m = 1 <NEWLINE> while True : <NEWLINE> <INDENT> x = 3 * g [ m - 1 ] + 1 <NEWLINE> if x >= n : break <NEWLINE> g . append ( x ) <NEWLINE> m += 1 <NEWLINE> <DEDENT> g = g [ : : - 1 ] <NEWLINE> <NL> <COMMENT> <NL> print ( m ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> <NL> <COMMENT> <NL> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> isort ( a , n , g [ i ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print ( cnt ) <NEWLINE> <COMMENT> <NL> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE>
import math <NEWLINE> <NL> <NL> def insertionsort ( A , n , g ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shellsort ( A , n ) : <NEWLINE> <INDENT> G = [ ] <COMMENT> <NEWLINE> gap = 1 <NEWLINE> while gap <= math . ceil ( n / 3 ) : <NEWLINE> <INDENT> G . append ( gap ) <NEWLINE> gap = gap * 3 + 1 <NEWLINE> <DEDENT> G = G [ : : - 1 ] <NEWLINE> m = len ( G ) <NEWLINE> print ( m ) <NEWLINE> print ( * G ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertionsort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shellsort ( A , n ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <COMMENT> <NEWLINE>
def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in xrange ( 1 , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return A , cnt <NEWLINE> <NL> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ 1 ] <NEWLINE> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> if 3 * G [ i - 1 ] + 1 < len ( A ) : <NEWLINE> <INDENT> G . append ( 3 * G [ i - 1 ] + 1 ) <NEWLINE> <DEDENT> <DEDENT> G = list ( reversed ( G [ : ] ) ) <NEWLINE> <COMMENT> <NL> m = len ( G ) <NEWLINE> print m <NEWLINE> print <STRING> . join ( map ( str , G ) ) <NEWLINE> newA = A [ : ] <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> newA , cnt = insertionSort ( newA [ : ] , len ( A ) , G [ i ] , cnt ) <NEWLINE> <DEDENT> return newA , cnt <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in xrange ( n ) ] <NEWLINE> newA , cnt = shellSort ( A , n ) <NEWLINE> print cnt <NEWLINE> for i in range ( len ( newA ) ) : <NEWLINE> <INDENT> print newA [ i ] <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
ef insert_sort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ ] ; h = 0 <NEWLINE> while h <= n : <NEWLINE> <INDENT> if 3 * h + 1 <= n : <NEWLINE> <INDENT> h = 3 * h + 1 <NEWLINE> G . append ( h ) <NEWLINE> <DEDENT> else : break <NEWLINE> <DEDENT> G = sorted ( G , reverse = True ) <NEWLINE> m = len ( G ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt = insert_sort ( A , n , G [ i ] , cnt ) <NEWLINE> <DEDENT> return m , cnt , G <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> m , cnt , G = shellSort ( A , n ) <NEWLINE> print ( m ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if i == m - 1 : <NEWLINE> <INDENT> print ( G [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( G [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> for i in A : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def insertionSort ( arr , N , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , N ) : <NEWLINE> <INDENT> tmp = arr [ i ] <NEWLINE> j = i - g <NEWLINE> while ( j >= 0 and arr [ j ] > tmp ) : <NEWLINE> <INDENT> arr [ j + g ] = arr [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> arr [ j + g ] = tmp <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( arr , N ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> G = [ ] <NEWLINE> h = 0 <NEWLINE> m = 0 <NEWLINE> while h <= N / 9 : <NEWLINE> <INDENT> h = 3 * h + 1 <NEWLINE> G . append ( h ) <NEWLINE> m += 1 <NEWLINE> <DEDENT> G = G [ : : - 1 ] <NEWLINE> <NL> cnt = sum ( [ insertionSort ( arr , N , g ) for g in G ] ) <NEWLINE> return ( cnt , g ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> ( cnt , G ) = shellSort ( arr , N ) <NEWLINE> print ( len ( G ) , <STRING> . join ( map ( str , G ) ) , cnt , <STRING> . join ( map ( str , arr ) ) , end = <STRING> ) <NEWLINE> <NL>
def insertionSort ( a , n , g ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j = j - g <NEWLINE> global cnt += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> i = 0 <NEWLINE> g = [ 1 ] <NEWLINE> while 3 * g [ i ] + 1 < n : <NEWLINE> <INDENT> g . append ( 3 * g [ i ] + 1 ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> m = len ( g ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( a , n , g [ i ] ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE> print ( * g ) <NEWLINE> print ( cnt ) <NEWLINE> print ( * a , sep = <STRING> ) <NEWLINE>
def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> A [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <DEDENT> def shellsort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> h = 1 <NEWLINE> G = [ ] <NEWLINE> while h <= 1 : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> G . reverse ( ) <NEWLINE> m = len ( G ) <NEWLINE> print ( m <NEWLINE> <NL> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> cnt += insertionSort ( A , n , G [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> for i in A : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shellsort ( A , n ) <NEWLINE> <NL> <NL>
def insertionSort ( nums , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> i = g <NEWLINE> n = len ( nums ) <NEWLINE> while i < n : <NEWLINE> <INDENT> v = nums [ i ] <NEWLINE> j = i - g <NEWLINE> while 0 <= j and v < nums [ j ] and j + g < n : <NEWLINE> <INDENT> nums [ j + g ] = nums [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> nums [ j + g ] = v <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( nums , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> g = [ ] <NEWLINE> val = 0 <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> val = 3 * val + 1 <NEWLINE> if n < val : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> g . append ( val ) <NEWLINE> <NL> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> cnt += insertionSort ( nums , n , g [ i ] ) <NEWLINE> <DEDENT> print ( cnt ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> nums = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> nums . append ( int ( raw_input ( ) ) ) <NEWLINE> <NL> <DEDENT> shellSort ( nums , n ) <NEWLINE> for val in nums : <NEWLINE> <INDENT> print ( val ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> using namespace std ; <NEWLINE> <NL> long long cnt ; <NEWLINE> int l ; <NEWLINE> int A [ 1000000 ] ; <NEWLINE> int n ; <NEWLINE> vector < int > G ; <NEWLINE> <NL> void insertionSort ( int A [ ] , int n , int g ) { <NEWLINE> <INDENT> for ( int i = g ; i < n ; i + + ) { <NEWLINE> <INDENT> int v = A [ i ] ; <NEWLINE> int j = i - g ; <NEWLINE> while ( j >= 0 & & A [ j ] > v ) { <NEWLINE> <INDENT> A [ j + g ] = A [ j ] ; <NEWLINE> j -= g ; <NEWLINE> cnt + + ; <NEWLINE> <DEDENT> } <NEWLINE> A [ j + g ] = v ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> void shellSort ( int A [ ] , int n ) { <NEWLINE> <INDENT> for ( int h = 1 ; ; ) { <NEWLINE> <INDENT> if ( h > n ) break ; <NEWLINE> G . push_back ( h ) ; <NEWLINE> h = 3 * h + 1 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> for ( int i = G . size ( ) - 1 ; i >= 0 ; i - - ) { <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> cin >> n ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) scanf ( <STRING> , & A [ i ] ) ; <NEWLINE> cnt = 0 ; <NEWLINE> <NL> shellSort ( A , n ) ; <NEWLINE> cout << G . size ( ) << endl ; <NEWLINE> for ( int i = G . size ( ) - 1 ; i >= 0 ; i - - ) { <NEWLINE> <INDENT> printf ( <STRING> , G [ i ] ) ; <NEWLINE> if ( i ) printf ( <STRING> ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> printf ( <STRING> ) ; <NEWLINE> printf ( <STRING> , cnt ) ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) printf ( <STRING> , A [ i ] ) ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> if sys . version_info [ 0 ] >= 3 : raw_input = input <NEWLINE> <NL> def insertion_sort ( a , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , len ( a ) ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def shell_sort ( a ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> g = [ ] <NEWLINE> h = 1 <NEWLINE> while h <= len ( a ) : <NEWLINE> <INDENT> g . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> g . reverse ( ) <NEWLINE> m = len ( g ) <NEWLINE> print ( m ) <NEWLINE> print ( <STRING> . join ( map ( str , g ) ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> insertion_sort ( a , g [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ int ( raw_input ( ) ) for i in range ( raw_input ( ) ) ] <NEWLINE> shell_sort ( a ) <NEWLINE> print ( cnt ) <NEWLINE> for e in a : print ( e ) <NEWLINE>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> def insertion_sort ( L , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = L [ i ] <NEWLINE> j = i - g <NEWLINE> while 0 <= j and v < L [ j ] : <NEWLINE> <INDENT> L [ j + g ] = L [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> L [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def shell_sort ( L , n ) : <NEWLINE> <INDENT> global G <NEWLINE> for i in G : <NEWLINE> <INDENT> insertion_sort ( L , n , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> G = [ i for i in [ 262913 , 65921 , 16577 , 4193 , 1073 , 281 , 77 , 23 , 8 , 1 ] if i <= n ] <NEWLINE> shell_sort ( A , n ) <NEWLINE> <NL> print ( len ( G ) ) <NEWLINE> print ( <STRING> . join ( str ( x ) for x in G ) ) <NEWLINE> print ( cnt ) <NEWLINE> for i in B : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> A = [ input ( ) for i in range ( n ) ] <NEWLINE> <NL> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> m = int ( ( n - 1 ) / 3 ) <NEWLINE> G = [ 1 ] <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> g = 3 ** i <NEWLINE> if g > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> G . append ( G [ i - 1 ] + g ) <NEWLINE> <DEDENT> m = len ( G ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> j = ( m - 1 ) - i <NEWLINE> cnt = insertionSort ( A , n , G [ j ] ) <NEWLINE> <NL> <DEDENT> return m , G , cnt <NEWLINE> <NL> <DEDENT> m , G , cnt = shellSort ( A , n ) <NEWLINE> <NL> print m <NEWLINE> for i in range ( m - 1 ) : <NEWLINE> <INDENT> j = m - i <NEWLINE> print G [ j ] , <NEWLINE> <DEDENT> print G [ 0 ] <NEWLINE> <NL> for item in A : <NEWLINE> <INDENT> print item <NEWLINE> <DEDENT>
cnt = 0 <NEWLINE> <NL> <NL> def insertionSort ( arr , N , g ) : <NEWLINE> <INDENT> for i in range ( g , N ) : <NEWLINE> <INDENT> tmp = arr [ i ] <NEWLINE> j = i - g <NEWLINE> while ( j >= 0 and arr [ j ] > tmp ) : <NEWLINE> <INDENT> arr [ j + g ] = arr [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> arr [ j + g ] = tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def shellSort ( arr , N ) : <NEWLINE> <INDENT> G = [ ] <NEWLINE> h = 0 <NEWLINE> m = 0 <NEWLINE> while h <= N / 9 : <NEWLINE> <INDENT> h = 3 * h + 1 <NEWLINE> m += 1 <NEWLINE> G . append ( h ) <NEWLINE> <DEDENT> G = G [ : : - 1 ] <NEWLINE> for g in G : <NEWLINE> <INDENT> insertionSort ( arr , N , g ) <NEWLINE> <DEDENT> return G <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> arr = [ int ( input ( ) ) for i in range ( N ) ] <NEWLINE> <NL> G = shellSort ( arr , N ) <NEWLINE> print ( len ( G ) , <STRING> . join ( map ( str , G ) ) , cnt , <STRING> . join ( map ( str , arr ) ) , end = <STRING> ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> <NL> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> <NL> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <DEDENT> print_line ( A , cnt ) <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <INDENT> m = 0 <NEWLINE> G = [ ] <NEWLINE> while n >= ( 3 ** m - 1 ) / 2 : <NEWLINE> <INDENT> m += 1 <NEWLINE> G . append ( ( 3 ** m - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE> for i in range ( len ( G ) ) : <NEWLINE> <INDENT> if i == len ( G ) - 1 : <NEWLINE> <INDENT> print ( G [ i ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> . format ( G [ i ] ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> insertionSort ( A , n , G [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def print_line ( A , cnt ) : <NEWLINE> <INDENT> print ( cnt ) <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> A = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> shellSort ( A , n ) <NEWLINE>
def printing ( m , G , cnt , A ) : <NEWLINE> <INDENT> print ( m ) <NEWLINE> for i in range ( len ( G ) ) : <NEWLINE> <INDENT> if i != len ( G ) - 1 : <NEWLINE> <INDENT> print ( G [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( G [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> for i in A : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def insertionSort ( A , n , g , cnt ) : <NEWLINE> <INDENT> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shellSort ( A , n , cnt ) : <NEWLINE> <NL> <INDENT> m = 2 <NEWLINE> G = [ 4 , 1 ] <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> cnt = insertionSort ( A , n , G [ i ] , cnt ) <NEWLINE> <NL> <DEDENT> printing ( m , G , cnt , A ) <NEWLINE> <NL> <NL> <DEDENT> N = int ( input ( ) ) <NEWLINE> inputList = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> shellSort ( inputList , N , cnt ) <NEWLINE>
<COMMENT> <NL> <NL> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def shellSort ( A , n ) : <NEWLINE> <NL> <INDENT> G = [ ] <NEWLINE> i = 0 <NEWLINE> g = 1 <NEWLINE> <NL> while g <= len ( A ) : <NEWLINE> <INDENT> G . append ( g ) <NEWLINE> g = 3 * g + 1 <NEWLINE> <DEDENT> G = G . reverse ( ) <NEWLINE> <NL> for g in G : <NEWLINE> <INDENT> insertionSort ( A , n , g ) <NEWLINE> <NL> <DEDENT> return A , G <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> A , G = shellSort ( A , n ) <NEWLINE> <NL> print ( len ( G ) ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> print ( A [ i ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( e ) for e in sys . stdin ] <NEWLINE> cnt = 0 <NEWLINE> G = [ int ( ( 2.25 ** i - 1 ) / 1.25 ) for i in range ( 17 , 0 , - 1 ) ] <NEWLINE> G = [ v for v in G if v <= n ] <NEWLINE> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> for g in G : <NEWLINE> <INDENT> insertionSort ( A , n , g ) <NEWLINE> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( <STRING> . join ( A ) ) <NEWLINE>
import sys <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , sys . stdin ) ) <NEWLINE> cnt = 0 <NEWLINE> G = [ int ( ( 2.25 ** i - 1 ) / 1.25 ) for i in range ( 17 , 0 , - 1 ) ] <NEWLINE> G = [ v for v in G if v <= n ] <NEWLINE> def insertionSort ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> v = A [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and A [ j ] > v : <NEWLINE> <INDENT> A [ j + g ] = A [ j ] <NEWLINE> j = j - g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> A [ j + g ] = v <NEWLINE> <DEDENT> <DEDENT> for g in G : <NEWLINE> <INDENT> insertionSort ( A , n , g ) <NEWLINE> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( * G ) <NEWLINE> print ( cnt ) <NEWLINE> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> cnt = 0 <NEWLINE> def insection_sort ( a , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , len ( a ) ) : <NEWLINE> <INDENT> v = a [ i ] <NEWLINE> j = i - g <NEWLINE> while j >= 0 and a [ j ] > v : <NEWLINE> <INDENT> a [ j + g ] = a [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> a [ j + g ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> def shell_sort ( a ) : <NEWLINE> <INDENT> g = list ( 1 ) <NEWLINE> temp = 4 <NEWLINE> while temp < len ( a ) : <NEWLINE> <INDENT> g . append ( temp ) <NEWLINE> temp = 3 * temp + 1 <NEWLINE> <NL> <DEDENT> print ( len ( g ) ) <NEWLINE> for youso in reversed ( g ) : <NEWLINE> <INDENT> if youso != 1 : <NEWLINE> <INDENT> print ( youso , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( youso ) <NEWLINE> <DEDENT> insection_sort ( a , youso ) <NEWLINE> <NL> <DEDENT> <DEDENT> inp_num = int ( input ( ) ) <NEWLINE> a = list ( ) <NEWLINE> for i in range ( inp_num ) : <NEWLINE> <INDENT> a . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> shell_sort ( a ) <NEWLINE> print ( cnt ) <NEWLINE> for i in a : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
N = int ( input ( ) ) <NEWLINE> ary = [ int ( input ( ) ) for _ in range ( N ) ] <NEWLINE> <NL> <NL> def insertion_sort ( ary , g ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> <NL> for i in range ( g , N ) : <NEWLINE> <INDENT> v = ary [ i ] <NEWLINE> j = i - g <NEWLINE> <NL> while j >= 0 and ary [ j ] > v : <NEWLINE> <INDENT> ary [ j + g ] = ary [ j ] <NEWLINE> j -= g <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> ary [ j + g ] = v <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> def shell_sort ( ary ) : <NEWLINE> <NL> <INDENT> g = [ ] <NEWLINE> gn = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if gn + 3 < N : <NEWLINE> <INDENT> gn += 3 <NEWLINE> g . append ( gn ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> m = len ( gn ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( 0 , m ) : <NEWLINE> <INDENT> cnt += insertion_sort ( ary , g [ i ] ) <NEWLINE> <NL> <DEDENT> print ( m ) <NEWLINE> print ( <STRING> . join ( [ str ( _ ) for _ in g ] ) ) <NEWLINE> print ( cnt ) <NEWLINE> [ print ( _ ) for _ in ary ] <NEWLINE> <NL> <NL> <DEDENT> shell_sort ( ary ) <NEWLINE> <NL>
def insertion ( A , n , g ) : <NEWLINE> <INDENT> global cnt <NEWLINE> for i in range ( g , n ) : <NEWLINE> <INDENT> while i >= g and A [ i - g ] > A [ i ] : <NEWLINE> <INDENT> A [ i ] , A [ i - g ] = A [ i - g ] , A [ i ] <NEWLINE> i -= g <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> global cnt <NEWLINE> cnt = 0 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> A = [ int ( raw_input ( ) ) for i in range ( n ) ] <NEWLINE> <NL> G = list ( ) <NEWLINE> h = 1 <NEWLINE> while h <= n : <NEWLINE> <INDENT> G . append ( h ) <NEWLINE> h = 3 * h + 1 <NEWLINE> <DEDENT> G = G [ : : - 1 ] <NEWLINE> <NL> for i in G : <NEWLINE> <INDENT> insertion ( A , n , i ) <NEWLINE> <NL> <DEDENT> print ( len ( G ) ) <NEWLINE> print ( <STRING> . join ( map ( str , G ) ) ) <NEWLINE> print ( cnt ) <NEWLINE> for j in A : print ( j ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
inl = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> stack = [ ] <NEWLINE> for n in inl : <NEWLINE> <INDENT> if n == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( ) + stack . pop ( ) ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> a = stack . pop ( ) <NEWLINE> b = stack . pop ( ) <NEWLINE> stack . append ( b - a ) <NEWLINE> <DEDENT> elif n == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( ) * stack . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( int ( n ) ) <NEWLINE> <DEDENT> <DEDENT> print ( stack . pop ( ) ) u <NEWLINE>
arr = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> <NL> i = 0 <NEWLINE> <NL> operand = [ ] <NEWLINE> <NL> while i < len ( arr ) : <NEWLINE> <INDENT> if arr [ i ] == <STRING> : <NEWLINE> <INDENT> a = operand . pop ( - 1 ) <NEWLINE> b = operand . pop ( - 1 ) <NEWLINE> operand . append ( b + a ) <NEWLINE> <DEDENT> elif arr [ i ] == <STRING> : <NEWLINE> <INDENT> a = operand . pop ( - 1 ) <NEWLINE> b = operand . pop ( - 1 ) <NEWLINE> operand . append ( b - a ) <NEWLINE> <DEDENT> elif arr [ i ] == <STRING> : <NEWLINE> <INDENT> a = operand . pop ( - 1 ) <NEWLINE> b = operand . pop ( - 1 ) <NEWLINE> operand . append ( b * a ) <NEWLINE> else : <NEWLINE> operand . append ( int ( arr [ i ] ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> print ( operand [ 0 ] ) <NEWLINE> <NL>
class MyStack ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . stack = [ ] <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . stack . pop ( ) <NEWLINE> <NL> <DEDENT> def push ( self , value ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . stack . append ( value ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> sequence = raw_input ( ) . split ( ) <NEWLINE> operators = { <STRING> : <STRING> , <STRING> : <STRING> , <STRING> : <STRING> } <NEWLINE> stack = MyStack ( ) <NEWLINE> for s in sequence : <NEWLINE> <INDENT> if s in operators : <NEWLINE> <INDENT> value1 = stack . pop ( ) <NEWLINE> value2 = stack . pop ( ) <NEWLINE> stack . push ( eval ( value1 + operators [ s ] + value2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . push ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack . pop ( ) ) <NEWLINE>
stk = [ ] <NEWLINE> for c in input ( ) . split ( ) : <NEWLINE> <INDENT> if c in <STRING> : <NEWLINE> <INDENT> a = stk . pop ( ) <NEWLINE> b = stk . pop ( ) <NEWLINE> stk . append ( str ( eval ( b + c + a ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stk . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( stk . pop ( <NEWLINE>
l = [ ] <NEWLINE> c = 0 <NEWLINE> s = input ( ) . split ( ) <NEWLINE> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> l [ c - 2 ] = l [ c - 2 ] + l [ c - 1 ] <NEWLINE> c = c - 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> l [ c - 2 ] = l [ c - 2 ] - l [ c - 1 ] <NEWLINE> c = c - 1 <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> l [ c - 2 ] = l [ c - 2 ] * l [ c - 1 ] <NEWLINE> c = c - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l [ c ] = int ( i ) <NEWLINE> c = c + 1 <NEWLINE> <DEDENT> <DEDENT> printl [ 0 ] <NEWLINE>
s = input ( ) <NEWLINE> <NL> def r_poland ( s ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> <NL> for d in s : <NEWLINE> <INDENT> if d . isdigit ( ) : <NEWLINE> <INDENT> stack . append ( int ( d ) ) <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> stack [ - 1 ] += stack . pop ( - 2 ) <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> stack [ - 1 ] = stack . pop ( - 2 ) - stack [ - 1 ] <NEWLINE> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> stack [ - 1 ] *= stack . pop ( - 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> return stack <NEWLINE> <NL> <DEDENT> s = input ( ) <NEWLINE> <NL> print ( * r_poland ( s ) ) <NEWLINE> <NL>
<COMMENT> <NL> tmp = input ( ) . strip ( ) . split ( ) <NEWLINE> stack = [ ] <NEWLINE> for i in tmp : <NEWLINE> <INDENT> l -= 1 <NEWLINE> if stack . pop ( ) == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( ) + stack . pop ( ) ) <NEWLINE> <DEDENT> elif stack . pop ( ) == <STRING> : <NEWLINE> <INDENT> stack . append ( - stack . pop ( ) + stack . pop ( ) ) <NEWLINE> <DEDENT> elif stack . pop ( ) == <STRING> : <NEWLINE> <INDENT> stack . append ( stack . pop ( ) * stack . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack [ 0 ] ) <NEWLINE>
import sys <NEWLINE> <NL> stack = [ ] <NEWLINE> <NL> array = sys , stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> <NL> for op in array : <NEWLINE> <INDENT> if op . isdigit ( ) : <NEWLINE> <INDENT> stack . append ( int ( op ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp1 = stack . pop ( ) <NEWLINE> tmp2 = stack . pop ( ) <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> stack . append ( tmp1 + tmp2 ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> stack . append ( tmp2 - tmp1 ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> stack . append ( tmp1 * tmp2 ) <NEWLINE> <DEDENT> elif op == <STRING> : <NEWLINE> <INDENT> stack . append ( float ( tmp2 ) / tmp1 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> res = stack . pop ( ) <NEWLINE> print str ( int ( res ) ) <NEWLINE>
class Stack ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . top = 0 <NEWLINE> self . data = [ ] <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . top == 0 <NEWLINE> <NL> <DEDENT> def push ( self , x ) : <NEWLINE> <INDENT> self . top += 1 <NEWLINE> self . data . append ( x ) <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> self . top -= 1 <NEWLINE> item = self . data [ - 1 ] <NEWLINE> del self . data [ - 1 ] <NEWLINE> return item <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def do_calc ( data ) : <NEWLINE> <INDENT> s = Stack ( ) <COMMENT> <NEWLINE> while data : <NEWLINE> <INDENT> elem = data [ 0 ] <NEWLINE> data = data [ 1 : ] <NEWLINE> if elem == <STRING> or elem == <STRING> or elem == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = s . pop ( ) <NEWLINE> b = s . pop ( ) <NEWLINE> if elem == <STRING> : <NEWLINE> <INDENT> s . push ( b + a ) <NEWLINE> <DEDENT> elif elem == <STRING> : <NEWLINE> <INDENT> s . push ( b - a ) <NEWLINE> <DEDENT> elif elem == <STRING> : <NEWLINE> <INDENT> s . push ( b * a ) <NEWLINE> <DEDENT> <DEDENT> except IndexError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> s . push ( int ( elem ) ) <NEWLINE> <DEDENT> <DEDENT> try : <NEWLINE> <INDENT> result = s . pop ( ) <NEWLINE> <DEDENT> except IndexError : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return result <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> data = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> result = do_calc ( data ) <NEWLINE> <NL> <COMMENT> <NL> print ( result ) <NEWLINE> <DEDENT>
f = input ( ) . strip ( ) . split ( ) <NEWLINE> q = [ ] <NEWLINE> for e in f : <NEWLINE> <INDENT> if e == <STRING> : <NEWLINE> <INDENT> q . append ( q . pop ( ) + q . pop ( ) ) <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> q . append ( - q . pop ( ) + q . pop ( ) ) <NEWLINE> <DEDENT> elif e == <STRING> : <NEWLINE> <INDENT> q . append ( q . pop ( ) * q . pop ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . append ( int ( q ) ) <NEWLINE> <DEDENT> <DEDENT> print ( q [ 0 ] ) <NEWLINE>
A = input ( ) . split ( ) <NEWLINE> S = [ ] <NEWLINE> <NL> <NL> for i in A : <NEWLINE> <INDENT> if i == <STRING> or i == <STRING> or i == <STRING> : <NEWLINE> <INDENT> a = pop ( ) <NEWLINE> b = pop ( ) <NEWLINE> if i == <STRING> : S . append ( a + b ) <NEWLINE> elif i == <STRING> : S . append ( a - b ) <NEWLINE> else : S . append ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = int ( i ) <NEWLINE> S . append ( x ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( S [ 0 ] ) <NEWLINE> <NL>
from collections import deque <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> S = input ( ) . split ( ) <NEWLINE> D = deque ( [ ] ) <NEWLINE> for s in S : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> b = D . pop ( ) <NEWLINE> a = D . pop ( ) <NEWLINE> D . append ( a + b ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> b = D . pop ( ) <NEWLINE> a = D . pop ( ) <NEWLINE> D . append ( a - b ) <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> b = D . pop ( ) <NEWLINE> a = D . pop ( ) <NEWLINE> D . append ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> D . append ( int ( s ) ) <NEWLINE> <DEDENT> print D <NEWLINE> <DEDENT> print D . pop ( ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
s = [ ] <NEWLINE> for p in input ( ) . split ( ) : <NEWLINE> <INDENT> if p in <STRING> : <NEWLINE> <INDENT> b = s . pop ( ) <NEWLINE> a = s . pop ( ) <NEWLINE> s . append ( str ( eval ( a + p + b ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( c ) <NEWLINE> <DEDENT> <DEDENT> print ( * s ) <NEWLINE>
class Stack : <NEWLINE> <INDENT> MAX = 101 <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . S = [ None ] * self . __class__ . MAX <NEWLINE> self . top = 0 <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . top == 0 <NEWLINE> <NL> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> return self . top >= self . __class__ . MAX - 1 <NEWLINE> <NL> <DEDENT> def push ( self , x ) : <NEWLINE> <INDENT> self . top += 1 <NEWLINE> self . S [ self . top ] = x <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> self . top -= 1 <NEWLINE> return self . S [ self . top + 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> stack = Stack ( ) <NEWLINE> [ stack . push ( eval ( <STRING> . join ( map ( str , [ stack . pop ( ) , s , stack . pop ( ) ] [ : : - 1 ] ) ) ) ) <NEWLINE> <INDENT> if s in [ <STRING> , <STRING> , <STRING> ] else stack . push ( int ( s ) ) for s in str ( s ) for s in [ str ( s ) for s in input ( ) . split ( ) ] ] <NEWLINE> <DEDENT> print ( stack . pop ( ) ) <NEWLINE> <NL>
lis = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> st = [ ] <NEWLINE> for i in lis : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> x = st . pop ( ) <NEWLINE> y = st . pop ( ) <NEWLINE> st . append ( x + y ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> x = st . pop ( ) <NEWLINE> y = st . pop ( ) <NEWLINE> st . append ( y - x ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> x = st . pop ( ) <NEWLINE> y = st . pop ( ) <NEWLINE> st . append ( x * y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> st . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ( st [ 0 ] ) <NEWLINE>
s = [ ] <NEWLINE> for i in raw_input ( ) . split ( ) : <NEWLINE> <INDENT> if i < <STRING> : <NEWLINE> <INDENT> t = s . pop ( ) <NEWLINE> s . append ( <STRING> + s . pop ( ) + i + t + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print eval ( s [ 0 ] ) <NEWLINE>
operand = [ ] <NEWLINE> for x in raw_input ( ) . split ( ) : <NEWLINE> <INDENT> if x . isdigit ( ) : <NEWLINE> <INDENT> operand . append ( int ( x ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a1 = operand [ len ( operand ) - 1 ] <NEWLINE> operand . pop ( ) <NEWLINE> a2 = operand [ len ( operand ) - 1 ] <NEWLINE> operand . pop ( ) <NEWLINE> <INDENT> if x == <STRING> : <NEWLINE> <INDENT> operand . append ( a2 + a1 ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> operand . append ( a2 - a1 ) <NEWLINE> <DEDENT> elif x == <STRING> : <NEWLINE> <INDENT> operand . append ( a2 * a1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print operand [ 0 ] <NEWLINE>
poland = input ( ) . split ( ) <NEWLINE> <NL> num = [ ] <NEWLINE> for p in poland : <NEWLINE> <INDENT> if p . isdisit ( ) : <NEWLINE> <INDENT> num . append ( int ( p ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b = num . pop ( ) <NEWLINE> a = num . pop ( ) <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> num . append ( a * b ) <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> num . append ( a + b ) <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> num . append ( a - b ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( num . pop ( ) ) <NEWLINE>
import sys <NEWLINE> <NL> ERROR_INPUT = <STRING> <NEWLINE> OPECODE = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> STACK = [ ] <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> inp = get_input ( ) <NEWLINE> print ( calc_stack ( li = inp ) ) <NEWLINE> <NL> <NL> <DEDENT> def calc_stack ( li ) : <NEWLINE> <INDENT> for l in li : <NEWLINE> <INDENT> if li [ 0 ] in OPECODE : <NEWLINE> <INDENT> STACK . append ( calc ( right = STACK . pop ( ) , left = STACK . pop ( ) , ope = li [ 0 ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> STACK . append ( int ( l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> return STACK [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> def calc ( left , right , ope ) : <NEWLINE> <INDENT> if ope == <STRING> : <NEWLINE> <INDENT> return left + right <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> return left - right <NEWLINE> <DEDENT> elif ope == <STRING> : <NEWLINE> <INDENT> return left * right <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_input ( ) : <NEWLINE> <INDENT> inp = input ( ) . split ( <STRING> ) <NEWLINE> opecode_count = 0 <NEWLINE> operand_count = 0 <NEWLINE> <NL> for i in inp : <NEWLINE> <INDENT> if i in OPECODE : <NEWLINE> <INDENT> opecode_count += 1 <NEWLINE> <DEDENT> elif int ( i ) < 0 or int ( i ) > 10 ** 6 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> operand_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if opecode_count < 1 or opecode_count > 100 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> if operand_count < 2 or operand_count > 100 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> return inp <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> lst = input ( ) . split ( ) <NEWLINE> stack = [ ] <NEWLINE> for i in lst : <NEWLINE> <INDENT> if i == <STRING> + <STRING> : <NEWLINE> <INDENT> x = stack . pop ( ) <NEWLINE> y = stack . pop ( ) <NEWLINE> stack . append ( x + y ) <NEWLINE> <NL> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> x = stack . pop ( ) <NEWLINE> y = stack . pop ( ) <NEWLINE> stack . append ( y - x ) <NEWLINE> <NL> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> x = stack . pop ( ) <NEWLINE> y = stack . pop ( ) <NEWLINE> stack . append ( x * y ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack . pop ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import sys <NEWLINE> <NL> <NL> class Stack : <NEWLINE> <INDENT> def __init__ ( self , lst ) : <NEWLINE> <INDENT> self . lst = lst <NEWLINE> <NL> <DEDENT> def push ( x ) : <NEWLINE> <INDENT> lst . append ( x ) <NEWLINE> <DEDENT> def pop ( ) : <NEWLINE> <INDENT> lst . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def cul ( exp ) : <NEWLINE> <NL> <INDENT> S = Stack ( exp ) <NEWLINE> <NL> for val in exp : <NEWLINE> <INDENT> if val in [ <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> if val == <STRING> : <NEWLINE> <INDENT> x = reduce ( lambda a , b : int ( a ) + int ( b ) , S [ - 2 : ] ) <NEWLINE> <DEDENT> elif val == <STRING> : <NEWLINE> <INDENT> x = reduce ( lambda a , b : int ( a ) - int ( b ) , S [ - 2 : ] ) <NEWLINE> <DEDENT> elif val == <STRING> : <NEWLINE> <INDENT> x = reduce ( lambda a , b : int ( a ) * int ( b ) , S [ - 2 : ] ) <NEWLINE> <DEDENT> for i in range ( 2 ) : <NEWLINE> <INDENT> S . pop ( ) <NEWLINE> <DEDENT> S . push ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . push ( val ) <NEWLINE> <NL> <DEDENT> <DEDENT> return S [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> exp = sys . stdin . read ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> ans = cul ( exp ) <NEWLINE> print ans <NEWLINE> <DEDENT>
stack = [ ] <NEWLINE> for item in raw_input ( ) . split ( ) : <NEWLINE> <INDENT> stack . append ( item ) <NEWLINE> <NL> <NL> <DEDENT> def Cal ( sym , n1 , n2 ) : <NEWLINE> <INDENT> n1 = int ( n1 ) <NEWLINE> n2 = int ( n2 ) <NEWLINE> if sym == <STRING> : <NEWLINE> <INDENT> ans = n1 + n2 <NEWLINE> <DEDENT> elif sym == <STRING> : <NEWLINE> <INDENT> ans = n1 - n2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans = n1 * n2 <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> sym_stack = [ ] <NEWLINE> ans_stack = [ ] <NEWLINE> <NL> while len ( stack ) > 0 : <NEWLINE> <INDENT> m = stack . pop ( ) <NEWLINE> if not m . isdigit ( ) : <NEWLINE> <INDENT> sym_stack . append ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n2 = m <NEWLINE> n1 = stack . pop ( ) <NEWLINE> sym = sym_stack . pop ( ) <NEWLINE> ans = Cal ( sym , n1 , n2 ) <NEWLINE> ans_stack . append ( ans ) <NEWLINE> <NL> <DEDENT> <DEDENT> while len ( sym_stack ) > 0 : <NEWLINE> <INDENT> n2 = ans_stack . pop ( ) <NEWLINE> n1 = ans_stack . pop ( ) <NEWLINE> sym = sym_stack . pop ( ) <NEWLINE> ans = Cal ( sym , n1 , n2 ) <NEWLINE> ans_stack . append ( ans ) <NEWLINE> <DEDENT> Ans = ans_stack . pop ( ) <NEWLINE> <NL> print Ans <NEWLINE>
import re <NEWLINE> <NL> stack = [ ] <NEWLINE> _l = input ( ) . split ( <STRING> ) <NEWLINE> <NL> for c in _l : <NEWLINE> <INDENT> stack += [ c ] <NEWLINE> if re . match ( <STRING> , c ) : <NEWLINE> <INDENT> f = stack . pop ( ) <NEWLINE> z = stack . pop ( ) <NEWLINE> stack . append ( eval ( <STRING> . format ( z , c , f ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( stack [ 0 ] ) <NEWLINE>
def RPN ( states ) : <NEWLINE> <NL> <INDENT> operator = { <NEWLINE> <INDENT> <STRING> : ( lambda x , y : x + y ) , <NEWLINE> <STRING> : ( lambda x , y : x - y ) , <NEWLINE> <STRING> : ( lambda x , y : x * y ) , <NEWLINE> <STRING> : ( lambda x , y : float ( x ) / y ) <NEWLINE> <DEDENT> } <NEWLINE> stack = [ ] <NEWLINE> print ( <STRING> % states ) <NEWLINE> for index , z in enumerate ( states ) : <NEWLINE> <INDENT> if index > 0 : <NEWLINE> <INDENT> print stack <NEWLINE> <DEDENT> if z not in operator . keys ( ) : <NEWLINE> <INDENT> stack . append ( int ( z ) ) <NEWLINE> continue <NEWLINE> <DEDENT> y = stack . pop ( ) <NEWLINE> x = stack . pop ( ) <NEWLINE> stack . append ( operator [ z ] ( x , y ) ) <NEWLINE> print ( <STRING> % ( x , z , y ) ) <NEWLINE> <DEDENT> print ( stack [ 0 ] ) <NEWLINE> return ( stack [ 0 ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> RPN ( input ( ) . split ( <STRING> ) ) <NEWLINE> <DEDENT>
stack = [ ] <NEWLINE> store_num = [ ] <NEWLINE> store_result = [ ] <NEWLINE> <NL> for i , c in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <NL> <INDENT> def pop_and_stack ( list_ , num ) : <NEWLINE> <NL> <INDENT> list_ . pop ( ) <NEWLINE> list_ . pop ( ) <NEWLINE> list_ . append ( num ) <NEWLINE> <NL> return list_ <NEWLINE> <NL> <NL> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> a = stack [ - 2 ] <NEWLINE> b = stack [ - 1 ] <NEWLINE> num = a + b <NEWLINE> pop_and_stack ( stack , num ) <NEWLINE> <NL> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> a = stack [ - 2 ] <NEWLINE> b = stack [ - 1 ] <NEWLINE> num = a - b <NEWLINE> pop_and_stack ( stack , num ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> a = stack [ - 2 ] <NEWLINE> b = stack [ - 1 ] <NEWLINE> num = a * b <NEWLINE> pop_and_stack ( stack , num ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> a = stack [ - 2 ] <NEWLINE> b = stack [ - 1 ] <NEWLINE> num = a / b <NEWLINE> pop_and_stack ( stack , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . append ( int ( c ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( input ( ) ) <NEWLINE> <COMMENT> <NL>
list = [ ] <NEWLINE> for i in input . split ( ) : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> list [ len ( list ) - 1 ] = list [ len ( list ) - 1 ] + list [ len ( list ) ] <NEWLINE> list . pop ( ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> list [ len ( list ) - 1 ] = [ len ( list ) - 1 ] - list [ len ( list ) ] <NEWLINE> list . pop ( ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> list [ len ( list ) - 1 ] = [ len ( list ) - 1 ] * list [ len ( list ) ] <NEWLINE> list . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> list . append ( ) <NEWLINE> <DEDENT> <DEDENT> print ( list [ 0 ] ) <NEWLINE> <NL>
class Trio : <NEWLINE> <INDENT> __pre = None <NEWLINE> __val = None <NEWLINE> __nex = None <NEWLINE> def __init__ ( self , val , p = None , n = None ) : <NEWLINE> <INDENT> self . __pre = p <NEWLINE> self . __val = val <NEWLINE> self . __nex = n <NEWLINE> <NL> <DEDENT> def get_pre ( self ) : return self . __pre <NEWLINE> <NL> def get_nex ( self ) : return self . __nex <NEWLINE> <NL> def set_nex ( self , n ) : self . __nex = n <NEWLINE> <NL> def set_val ( self , n ) : self . __val = n <NEWLINE> <NL> def get_val ( self ) : return self . __val <NEWLINE> <NL> <DEDENT> class Stack : <NEWLINE> <INDENT> member = Trio ( None ) <NEWLINE> def __init__ ( self , stri ) : <NEWLINE> <INDENT> if ( isinstance ( stri , str ) ) : <NEWLINE> <INDENT> for i , e in enumerate ( stri ) : <NEWLINE> <INDENT> if ( i == 0 ) : <NEWLINE> <INDENT> self . member . set_val ( e ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . push ( e ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def push ( self , n ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . member . set_nex ( Trio ( n , self . member , None ) ) <NEWLINE> self . member = self . member . get_nex ( ) <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( self . member == None ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> d = self . member . get_val ( ) <NEWLINE> self . member = self . member . get_pre ( ) <NEWLINE> return d <NEWLINE> <NL> <DEDENT> <DEDENT> s = input ( ) <NEWLINE> stk = Stack ( None ) <NEWLINE> stri = <STRING> <NEWLINE> for i in s : <NEWLINE> <INDENT> if ( i == <STRING> ) : <NEWLINE> <INDENT> stk . push ( stri ) <NEWLINE> stri = <STRING> <NEWLINE> <DEDENT> elif ( i . isdigit ( ) ) : <NEWLINE> <INDENT> stri = <STRING> . join ( [ stri , i ] ) <NEWLINE> <DEDENT> elif ( i == <STRING> or i == <STRING> or i == <STRING> ) : <NEWLINE> <INDENT> b = stk . pop ( ) <NEWLINE> b = int ( b ) <NEWLINE> a = int ( stk . pop ( ) ) <NEWLINE> if ( i == <STRING> ) : <NEWLINE> <INDENT> stri = ( str ( a + b ) ) <NEWLINE> <DEDENT> elif ( i == <STRING> ) : <NEWLINE> <INDENT> stri = ( str ( a - b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stri = ( str ( a * b ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> p <NEWLINE>
class Stack : <NEWLINE> <INDENT> MAX = 101 <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> self . S = [ None ] * self . __class__ . MAX <NEWLINE> self . top = 0 <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . top == 0 <NEWLINE> <NL> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> return self . top >= self . __class__ . MAX - 1 <NEWLINE> <NL> <DEDENT> def push ( self , x ) : <NEWLINE> <INDENT> self . top += 1 <NEWLINE> self . S [ self . top ] = x <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> self . top -= 1 <NEWLINE> return self . S [ self . top + 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> arr = [ str ( s ) for s in input ( ) . split ( ) ] <NEWLINE> stack = Stack ( ) <NEWLINE> stack . push ( eval ( <STRING> . join ( map ( str , [ stack . pop ( ) , s , stack . pop ( ) ] [ : : - 1 ] ) ) ) ) <NEWLINE> <INDENT> if s in [ <STRING> , <STRING> , <STRING> ] else stack . push ( int ( s ) ) for s in arr <NEWLINE> <DEDENT> print ( stack . pop ( ) ) <NEWLINE> <NL>
<NL> Stack = [ ] <NEWLINE> def push ( x ) : <NEWLINE> <INDENT> Stack . append ( x ) <NEWLINE> <NL> <DEDENT> def pop ( ) : <NEWLINE> <INDENT> return Stack . pop ( ) <NEWLINE> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> s_list = raw_input ( ) . split ( ) <NEWLINE> for i in range ( len ( s_list ) ) : <NEWLINE> <INDENT> if s_list [ i ] == <STRING> : <NEWLINE> <INDENT> b = pop ( ) <NEWLINE> a = pop ( ) <NEWLINE> push ( a + b ) <NEWLINE> <DEDENT> elif s_list [ i ] == <STRING> : <NEWLINE> <INDENT> b = pop ( ) <NEWLINE> a = pop ( ) <NEWLINE> push ( a - b ) <NEWLINE> <DEDENT> elif s_list [ i ] == <STRING> : <NEWLINE> <INDENT> b = pop ( ) <NEWLINE> a = pop ( ) <NEWLINE> push ( a * b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> push ( int ( s_list [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( pop ( ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solve ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
class Stack ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . stack = [ 0 for _ in range ( 10 ) ] <NEWLINE> self . top = 0 <NEWLINE> <NL> <DEDENT> def push ( self , n ) : <NEWLINE> <INDENT> self . top += 1 <NEWLINE> self . stack [ self . top ] = n <NEWLINE> <NL> <DEDENT> def pop ( self ) : <NEWLINE> <INDENT> a = self . stack [ self . top ] <NEWLINE> del self . stack [ self . top ] <NEWLINE> self . top -= 1 <NEWLINE> return a <NEWLINE> <NL> <DEDENT> def lol ( self ) : <NEWLINE> <INDENT> return self . stack [ self . top ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input_data = raw_input ( ) <NEWLINE> data = input_data . strip ( ) . split ( <STRING> ) <NEWLINE> st = Stack ( ) <NEWLINE> for l in data : <NEWLINE> <INDENT> if l == <STRING> : <NEWLINE> <INDENT> a = st . pop ( ) <NEWLINE> b = st . pop ( ) <NEWLINE> st . push ( a + b ) <NEWLINE> <NL> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> a = st . pop ( ) <NEWLINE> b = st . pop ( ) <NEWLINE> st . push ( b - a ) <NEWLINE> <NL> <DEDENT> elif l == <STRING> : <NEWLINE> <INDENT> a = st . pop ( ) <NEWLINE> b = st . pop ( ) <NEWLINE> st . push ( a * b ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> st . push ( int ( l ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> print st . lol ( ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
S = [ ] <NEWLINE> <NL> try : <NEWLINE> <INDENT> word = raw_input ( ) <NEWLINE> <NL> while 1 : <NEWLINE> <INDENT> if word == <STRING> : <NEWLINE> <INDENT> s1 = S . pop ( ) <NEWLINE> s2 = S . pop ( ) <NEWLINE> S . append ( s1 + s2 ) <NEWLINE> <DEDENT> elif word == <STRING> : <NEWLINE> <INDENT> s1 = S . pop ( ) <NEWLINE> s2 = S . pop ( ) <NEWLINE> S . append ( s2 - s1 ) <NEWLINE> <DEDENT> elif word == <STRING> : <NEWLINE> <INDENT> s1 = S . pop ( ) <NEWLINE> s2 = S . pop ( ) <NEWLINE> S . append ( s2 * s1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S . append ( int ( word ) ) <NEWLINE> <DEDENT> word = raw_input ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> print S . pop ( ) <NEWLINE> <DEDENT>
ts = input ( ) . split ( <STRING> ) <NEWLINE> stack = [ ] <NEWLINE> for t in ts : <NEWLINE> <INDENT> if t not in ( <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> stack . push ( int ( t ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n2 = stack . pop ( ) <NEWLINE> n1 = stack . pop ( ) <NEWLINE> if t == <STRING> : <NEWLINE> <INDENT> stack . push ( n1 - n2 ) <NEWLINE> <DEDENT> elif t == <STRING> : <NEWLINE> <INDENT> stack . push ( n1 + n2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stack . push ( n1 * n2 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( stack . pop ( ) ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> queue . append ( ( name , int ( time ) ) ) <NEWLINE> <NL> <DEDENT> t = 0 <NEWLINE> i = 0 <NEWLINE> while queue : <NEWLINE> <INDENT> i %= len ( queue ) <NEWLINE> p = queue [ i ] <NEWLINE> t += min ( q , p [ 1 ] ) <NEWLINE> if p [ 1 ] > q : <NEWLINE> <INDENT> p [ 1 ] -= q <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( p [ 0 ] , t ) <NEWLINE> queue . pop ( i ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <NL> def simu ( pro , q ) : <NEWLINE> <INDENT> end_time = 0 <NEWLINE> <NL> while bool ( pro ) : <NEWLINE> <INDENT> if pro [ 1 ] > q : <NEWLINE> <INDENT> end_time += q <NEWLINE> pro . append ( pro [ 0 ] ) <NEWLINE> pro . append ( pro [ 1 ] - q ) <NEWLINE> pro . pop ( 0 ) * 2 <NEWLINE> <NL> <DEDENT> elif pro [ 1 ] <= q : <NEWLINE> <INDENT> end_time += pro [ 1 ] <NEWLINE> print ( <STRING> . format ( pro [ 0 ] , end_time ) ) <NEWLINE> pro . pop ( 0 ) * 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> pro = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = list ( input ( ) . split ( ) ) <NEWLINE> pro . append ( name ) <NEWLINE> pro . append ( int ( time ) ) <NEWLINE> <NL> <DEDENT> simu ( pro , q ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> def isEmpty ( S ) : <NEWLINE> <INDENT> if len ( S ) == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def isFull ( S ) : <NEWLINE> <INDENT> if len ( S ) >= 100000 : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def enqueue ( x ) : <NEWLINE> <INDENT> if isFull ( x_list_list ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> x_list_list . append ( x ) <NEWLINE> <NL> <DEDENT> def dequeue ( x_list_list ) : <NEWLINE> <INDENT> if isEmpty ( x_list_list ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> del_list = x_list_list [ 0 ] <NEWLINE> x_list_list . pop ( 0 ) <NEWLINE> return ( del_list ) <NEWLINE> <NL> <DEDENT> y = sys . stdin . readline ( ) <NEWLINE> a , b = y . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> S = [ ] <NEWLINE> x_list_list = [ ] <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> text = raw_input ( ) <NEWLINE> x_list = text . split ( ) <NEWLINE> x_list [ 1 ] = int ( x_list [ 1 ] ) <NEWLINE> x_list . append ( 0 ) <NEWLINE> x_list_list . append ( x_list ) <NEWLINE> <NL> <DEDENT> flag = a <NEWLINE> while flag != 0 : <NEWLINE> <INDENT> if x_list_list [ 0 ] [ 1 ] > b : <NEWLINE> <INDENT> x_list_list [ 0 ] [ 1 ] -= int ( b ) <NEWLINE> for j in range ( flag ) : <NEWLINE> <INDENT> x_list_list [ j ] [ 2 ] += b <NEWLINE> <DEDENT> del_list = dequeue ( x_list_list ) <NEWLINE> enqueue ( del_list ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( flag ) : <NEWLINE> <INDENT> x_list_list [ j ] [ 2 ] += x_list_list [ 0 ] [ 1 ] <NEWLINE> <DEDENT> x_list_list [ 0 ] [ 1 ] = 0 <NEWLINE> flag -= 1 <NEWLINE> print x_list_list [ 0 ] [ 0 ] , x_list_list [ 0 ] [ 2 ] <NEWLINE> dequeue ( x_list_list ) <NEWLINE> <DEDENT> <DEDENT>
import Queue <NEWLINE> import sys <NEWLINE> <NL> class Proc : <NEWLINE> <INDENT> def __init__ ( self , name , time ) : <NEWLINE> <INDENT> self . time = time <NEWLINE> self . name = name <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> array = map ( lambda x : int ( x ) , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> p_num = array [ 0 ] <NEWLINE> q_time = array [ 1 ] <NEWLINE> p_queue = Queue . Queue ( ) <NEWLINE> for i in range ( 0 , p_num ) : <NEWLINE> <INDENT> array = sys . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> p_queue . put ( Proc ( array [ 0 ] , int ( array [ 1 ] ) ) ) <NEWLINE> <DEDENT> t = 0 <NEWLINE> while not p_queue . empty ( ) : <NEWLINE> <INDENT> p = p_queue . get ( ) <NEWLINE> if p . time > q_time : <NEWLINE> <INDENT> p . time = p . time - q_time <NEWLINE> p_queue . put ( p ) <NEWLINE> t += q_time <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += p . time <NEWLINE> print p . name + <STRING> + str ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> que = [ map ( str , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : que [ i ] [ 1 ] = int ( que [ i ] [ 1 ] ) <NEWLINE> mxt = sum ( [ y for x , y in que ] ) <NEWLINE> t = 0 <NEWLINE> i = 0 <NEWLINE> while t < mxt : <NEWLINE> <INDENT> i %= n <NEWLINE> c = que [ i ] [ 1 ] <NEWLINE> if c <= q : <NEWLINE> <INDENT> t += c <NEWLINE> que . pop ( i ) <NEWLINE> n -= 1 <NEWLINE> print a [ 0 ] , t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += q <NEWLINE> que [ i ] [ 1 ] = c - q <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
N , Q = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> <NL> A = [ ] <NEWLINE> D = { } <NEWLINE> for l in range ( N ) : <NEWLINE> <INDENT> n , t = input ( ) . strip ( ) . split ( ) <NEWLINE> D [ n ] = int ( t ) <NEWLINE> A . append ( n ) <NEWLINE> <NL> <DEDENT> print ( A ) <NEWLINE> T = 0 <NEWLINE> d = 0 <NEWLINE> while True : <NEWLINE> <INDENT> n = A . pop ( 0 ) <NEWLINE> if D [ n ] > Q : <NEWLINE> <INDENT> D [ n ] -= Q <NEWLINE> T += Q <NEWLINE> A . append ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T += D [ n ] <NEWLINE> print ( str ( n ) + <STRING> + atr ( T ) ) <NEWLINE> d += 1 <NEWLINE> if d == N : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> line = input ( ) . split ( ) <NEWLINE> queue . append ( [ line [ 0 ] , int ( line [ 1 ] ) ] ) <NEWLINE> <NL> <DEDENT> class my_queue : <NEWLINE> <INDENT> def __init__ ( self , queue ) : <NEWLINE> <INDENT> self . queue = queue <NEWLINE> <DEDENT> def enqueue ( self , item ) : <NEWLINE> <INDENT> self . queue = self . queue + [ item ] <NEWLINE> self . queue . append ( item ) <NEWLINE> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if len ( self . queue ) != 0 : <NEWLINE> <INDENT> item = self . queue [ 0 ] <NEWLINE> self . queue = self . queue [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> item = None <NEWLINE> <DEDENT> return item <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> time = 0 <NEWLINE> finish_task = [ ] <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> item = queue . pop ( ) <NEWLINE> if item == None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif item [ 1 ] <= q : <NEWLINE> <INDENT> time += item [ 1 ] <NEWLINE> finish_task . append ( [ item [ 0 ] , time ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time += q <NEWLINE> queue . append ( [ item [ 0 ] , item [ 1 ] - q ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for item in finish_task : <NEWLINE> <INDENT> print ( item [ 0 ] , item [ 1 ] ) <NEWLINE> <DEDENT>
class queue : <NEWLINE> <INDENT> head = tail = None <NEWLINE> size = 0 <NEWLINE> def enqueue ( self , x ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> self . head = self . tail = ( x , None ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . tail [ 1 ] = ( x , None ) <NEWLINE> self . tail = self . tail [ 1 ] <NEWLINE> <DEDENT> self . size += 1 <NEWLINE> <NL> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if not self . is_empty ( ) : <NEWLINE> <INDENT> self . head = self . head [ 1 ] <NEWLINE> self . size -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . size == 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = queue ( ) <NEWLINE> t = list ( ) <NEWLINE> process = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = map ( str , input ( ) . split ( ) ) <NEWLINE> s . enqueue ( [ name , int ( time ) ] ) <NEWLINE> <NL> <DEDENT> while s . is_empty ( ) : <NEWLINE> <INDENT> diff = s [ 0 ] [ 1 ] - q <NEWLINE> if diff <= 0 : <NEWLINE> <INDENT> process += s [ 0 ] [ 1 ] <NEWLINE> t . append ( [ s [ 0 ] [ 0 ] , process ] ) <NEWLINE> s . dequeue ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> process += q <NEWLINE> s . enqueue ( [ s [ 0 ] [ 0 ] , diff ] ) <NEWLINE> s . dequeue ( ) <NEWLINE> <DEDENT> <DEDENT> for i in t : <NEWLINE> <INDENT> print ( i [ 0 ] , i [ 1 ] ) <NEWLINE> <DEDENT>
process_num , qms = map ( int , input ( ) . split ( ) ) <NEWLINE> raw_procs = [ input ( ) for i in range ( process_num ) ] <NEWLINE> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> procs = [ ] <NEWLINE> for row in raw_procs : <NEWLINE> <INDENT> name , time = row . split ( ) <NEWLINE> procs . push = { <NEWLINE> <INDENT> <STRING> : name , <NEWLINE> <STRING> : int ( time ) , <NEWLINE> <DEDENT> } <NEWLINE> <NL> <DEDENT> total_time = 0 <NEWLINE> current_proc = 0 <NEWLINE> while len ( procs ) > 0 : <NEWLINE> <INDENT> if procs [ current_proc ] [ <STRING> ] > 100 : <NEWLINE> <INDENT> procs [ current_proc ] [ <STRING> ] = procs [ current_proc ] [ <STRING> ] - qms <NEWLINE> total_time += qms <NEWLINE> if current_proc == len ( procs ) - 1 : <NEWLINE> <INDENT> current_proc = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> current_proc += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> total_time += procs [ current_proc ] [ <STRING> ] <NEWLINE> print ( <STRING> . format ( procs [ current_proc ] [ <STRING> ] , total_time ) ) <NEWLINE> del procs [ current_proc ] <NEWLINE> if current_proc >= len ( procs ) - 1 : <NEWLINE> <INDENT> current_proc = 0 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
class MyQueue ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . length = 1000100 <NEWLINE> self . queue = [ ] <NEWLINE> counter = 0 <NEWLINE> while counter < self . length : <NEWLINE> <INDENT> self . queue . append ( Process ( ) ) <NEWLINE> counter += 1 <NEWLINE> <DEDENT> self . head = 0 <NEWLINE> self . tail = 0 <NEWLINE> <NL> <DEDENT> def enqueue ( self , name , time ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_full ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . queue [ self . tail % self . length ] . name = name <NEWLINE> self . queue [ self . tail % self . length ] . time = time <NEWLINE> self . tail += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . is_empty ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . queue [ self . head % self . length ] . name = <STRING> <NEWLINE> self . queue [ self . head % self . length ] . time = 0 <NEWLINE> self . head += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . head == self . tail : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . tail - self . head >= len ( self . queue ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Process ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , name = <STRING> , time = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . name = name <NEWLINE> self . time = time <NEWLINE> <NL> <DEDENT> def forward_time ( self , time ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . time -= time <NEWLINE> return self . time <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def time_forward ( my_queue , interval , current_time ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> value = my_queue . queue [ my_queue . head % my_queue . length ] . forward_time ( interval ) <NEWLINE> if value < 0 : <NEWLINE> <INDENT> current_time += ( interval + value ) <NEWLINE> print my_queue . queue [ my_queue . head % my_queue . length ] . name , current_time <NEWLINE> my_queue . dequeue ( ) <NEWLINE> return current_time <NEWLINE> <NL> <DEDENT> elif value == 0 : <NEWLINE> <INDENT> current_time += interval <NEWLINE> print my_queue . queue [ my_queue . head % my_queue . length ] . name , current_time <NEWLINE> my_queue . dequeue ( ) <NEWLINE> return current_time <NEWLINE> <NL> <DEDENT> elif value > 0 : <NEWLINE> <INDENT> current_time += interval <NEWLINE> copied_process = my_queue . queue [ my_queue . head % my_queue . length ] <NEWLINE> name , time = copied_process . name , copied_process . time <NEWLINE> my_queue . dequeue ( ) <NEWLINE> my_queue . enqueue ( name , time ) <NEWLINE> return current_time <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> my_queue = MyQueue ( ) <NEWLINE> n , q = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> counter = 0 <NEWLINE> while counter < n : <NEWLINE> <INDENT> name , time = raw_input ( ) . split ( ) <NEWLINE> my_queue . enqueue ( name , int ( time ) ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> current_time = 0 <NEWLINE> while not my_queue . is_empty ( ) : <NEWLINE> <INDENT> current_time = time_forward ( my_queue , q , current_time ) <NEWLINE> <DEDENT>
import collections <NEWLINE> <NL> dq = collections . deque ( ) <NEWLINE> N , Q = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> dq . append ( ( name , int ( time ) ) ) <NEWLINE> <DEDENT> total_time = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> name , time = dq . popleft ( ) <NEWLINE> total_time += min ( Q , time ) <NEWLINE> if time <= Q : <NEWLINE> <INDENT> print ( name , total_time ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dq . append ( ( name , time ) ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> p = [ input ( ) . split ( ) for _ in range ( n ) ] <NEWLINE> t = i = 0 <NEWLINE> while n : <NEWLINE> <INDENT> i = i % n <NEWLINE> if int ( p [ i ] [ 1 ] ) <= q : <NEWLINE> <INDENT> t += int ( p [ i ] [ 1 ] ) <NEWLINE> print ( p [ i ] [ 0 ] , t ) <NEWLINE> del p [ i ] <NEWLINE> n -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ i ] [ 1 ] -= int ( p [ i ] [ 1 ] ) - q <NEWLINE> t += q <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> que = [ map ( str , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : que [ i ] [ 1 ] = int ( que [ i ] [ 1 ] ) <NEWLINE> mxt = sum ( [ y for x , y in que ] ) <NEWLINE> t = 0 <NEWLINE> i = 0 <NEWLINE> while t < mxt : <NEWLINE> <INDENT> if que [ i ] [ 1 ] <= q : <NEWLINE> <INDENT> t += que [ i ] [ 1 ] <NEWLINE> que . pop ( i ) <NEWLINE> n -= 1 <NEWLINE> print que [ i ] [ 0 ] , t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += q <NEWLINE> que [ i ] [ 1 ] = que [ i ] [ 1 ] - q <NEWLINE> i = ( i + 1 ) % n <NEWLINE> <DEDENT> <DEDENT>
def parse ( l ) : <NEWLINE> <INDENT> name , time = l . split ( ) <NEWLINE> return name , int ( time ) <NEWLINE> <NL> <NL> <DEDENT> n , quantum = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = list ( parse ( input ( ) ) for _ in range ( n ) ) <NEWLINE> head = 0 <NEWLINE> <NL> <NL> def enqueue ( x ) : <NEWLINE> <INDENT> global queue <NEWLINE> queue . append ( x ) <NEWLINE> <NL> <NL> <DEDENT> def dequeue ( ) : <NEWLINE> <INDENT> global head <NEWLINE> head += 1 <NEWLINE> <NL> <NL> <DEDENT> total_time , count = 0 , 0 <NEWLINE> while count < n : <NEWLINE> <INDENT> y = queue [ head ] [ 1 ] - quantum <NEWLINE> if y <= 0 : <NEWLINE> <INDENT> print ( str ( queue [ head ] [ 0 ] ) + <STRING> + str ( total_time + queue [ head ] [ 1 ] ) ) <NEWLINE> dequeue ( ) <NEWLINE> total_time += y <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> queue [ head ] [ 1 ] -= quantum <NEWLINE> enqueue ( queue [ head ] ) <NEWLINE> dequeue ( ) <NEWLINE> <NL> <DEDENT> total_time += quantum <NEWLINE> <NL> <DEDENT>
<NL> <NL> class Process : <NEWLINE> <INDENT> def __init__ ( self , n , head , tail ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . head = head <NEWLINE> self . tail = tail <NEWLINE> self . name = [ ] <NEWLINE> self . time = [ ] <NEWLINE> <NL> <DEDENT> <DEDENT> def void enqueue ( self , x ) : <NEWLINE> <INDENT> self . data = x <NEWLINE> tail = ( tail + 1 ) % n <NEWLINE> <NL> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> self . x = self . [ head ] <NEWLINE> head = ( head + 1 ) % n <NEWLINE> return x <NEWLINE> <NL> <DEDENT> process = Process ( ) <NEWLINE> <NL> n , q = map ( int , input ( ) , split ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> name [ i ] , time [ i ] = map ( input ( ) , split ( ) ) <NEWLINE> <DEDENT> list ( map ( int , time ) ) <NEWLINE> elaps = 0 <NEWLINE> head = 1 <NEWLINE> tail = n + 1 <NEWLINE> process = Process ( n , head , tail ) <NEWLINE> <NL> while head != tail : <NEWLINE> <INDENT> process . name = dequeue ( ) <NEWLINE> process . time = dequeue ( ) <NEWLINE> c = min ( q , process . time ) <NEWLINE> process . time -= c <NEWLINE> elaps += c <NEWLINE> if process . time > 0 : <NEWLINE> <INDENT> enqueue ( process . time ) <NEWLINE> enqueue ( process . name ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( process . name , elaps ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> from collections import deque <NEWLINE> def m ( ) : <NEWLINE> <INDENT> s = sys . stdin . readlines ( ) <NEWLINE> q = int ( s [ 0 ] . split ( ) [ 1 ] ) <NEWLINE> f = lambda x , y : ( x , int ( y ) ) <NEWLINE> d = deque ( map ( * e . split ( ) ) for e in s [ 1 : ] ) <NEWLINE> t , a = 0 , [ ] <NEWLINE> while d : <NEWLINE> <INDENT> k , v = d . popleft ( ) <NEWLINE> if v > q : v -= q ; t += q ; d . append ( [ k , v ] ) <NEWLINE> else : t += v ; a += [ <STRING> ] <NEWLINE> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE> <DEDENT> if <STRING> == __name__ : m ( ) <NEWLINE>
import sys <NEWLINE> from collections import deque <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> d = deque ( map ( lambda x , y : [ x , int ( y ) ] , sys . stdin ) ) <NEWLINE> t = 0 <NEWLINE> while d : <NEWLINE> <INDENT> k , v = d . popleft ( ) <NEWLINE> v = int ( v ) <NEWLINE> if v > q : <NEWLINE> <INDENT> v -= q <NEWLINE> t += q <NEWLINE> d . append ( [ k , v ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += v <NEWLINE> print ( k , t ) <NEWLINE> <DEDENT> <DEDENT>
ef ALDS1_3B ( ) : <NEWLINE> <INDENT> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> PQ = [ [ l [ 0 ] , int ( l [ 1 ] ) ] for l in [ input ( ) . split ( ) for i in range ( n ) ] ] <NEWLINE> times = 0 <NEWLINE> while PQ : <NEWLINE> <INDENT> p = PQ . pop ( 0 ) <NEWLINE> if p [ 1 ] <= q : <NEWLINE> <INDENT> times += p [ 1 ] <NEWLINE> print ( <STRING> % ( p [ 0 ] , times ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times += q <NEWLINE> PQ . append ( [ p [ 0 ] , p [ 1 ] - q ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> ALDS1_3B ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> <NL> class Queue : <NEWLINE> <INDENT> class Cell : <NEWLINE> <INDENT> def __init__ ( self , x , y = None ) : <NEWLINE> <INDENT> self . data = x <NEWLINE> self . next = y <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . size = 0 <NEWLINE> self . rear = None <NEWLINE> <NL> <DEDENT> def enqueue ( self , x ) : <NEWLINE> <INDENT> if self . size == 0 : <NEWLINE> <INDENT> self . rear = Queue . Cell ( x ) <NEWLINE> self . rear . next = self . rear <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_cell = Queue . Cell ( x , self . rear . next ) <NEWLINE> self . rear . next = new_cell <NEWLINE> self . rear = new_cell <NEWLINE> <DEDENT> self . size += 1 <NEWLINE> <NL> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if self . size == 0 : raise IndexError <NEWLINE> front = self . rear . next <NEWLINE> self . rear . next = front . next <NEWLINE> self . size -= 1 <NEWLINE> if self . size == 0 : self . rear = None <NEWLINE> return front . data <NEWLINE> <NL> <DEDENT> def isEmpty ( self ) : <NEWLINE> <INDENT> return self . size == 0 <NEWLINE> <NL> <DEDENT> <DEDENT> def generator ( n1 , n2 , step = 1 ) : <NEWLINE> <INDENT> n = n1 <NEWLINE> while n < n2 : <NEWLINE> <INDENT> yield n <NEWLINE> n += step <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> A = Queue ( ) <NEWLINE> for i in generator ( 0 , n ) : <NEWLINE> <INDENT> name , time = raw_input ( ) . split ( ) <NEWLINE> A . enqueue ( [ name , int ( time ) ] ) <NEWLINE> <NL> <DEDENT> stime = 0 <NEWLINE> while not A . isEmpty ( ) : <NEWLINE> <INDENT> job = A . dequeue ( ) <NEWLINE> if q >= job [ 1 ] : <NEWLINE> <INDENT> stime += job [ 1 ] <NEWLINE> print job [ 0 ] , stime <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stime += q <NEWLINE> job [ 1 ] -= tmp <NEWLINE> A . enqueue ( job ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> def print_array ( g ) : <NEWLINE> <INDENT> ans = str ( g [ 0 ] ) <NEWLINE> if len ( g ) > 1 : <NEWLINE> <INDENT> for i in range ( 1 , len ( g ) ) : <NEWLINE> <INDENT> ans += <STRING> + str ( g [ i ] ) <NEWLINE> <DEDENT> <DEDENT> print ( ans ) <NEWLINE> <NL> <DEDENT> name = [ ] <NEWLINE> time = [ ] <NEWLINE> current_time = 0 <NEWLINE> <NL> n , q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> name . append ( s [ 0 ] ) <NEWLINE> time . append ( int ( s [ 1 ] ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> finished = [ ] <NEWLINE> fin_time = [ ] <NEWLINE> i = 0 <NEWLINE> remain = n <NEWLINE> while True : <NEWLINE> <INDENT> if time [ i ] <= q : <NEWLINE> <INDENT> current_time += time . pop ( i ) <NEWLINE> finished . append ( name . pop ( i ) ) <NEWLINE> fin_time . append ( current_time ) <NEWLINE> remain -= 1 <NEWLINE> i = i % remain <NEWLINE> if remain == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> time [ i ] -= q <NEWLINE> current_time += q <NEWLINE> i = ( i + 1 ) % remain <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> print ( <STRING> . format ( finished [ i ] , fin_time [ i ] ) ) <NEWLINE> <NL> <NL> <DEDENT>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> que = [ map ( str , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : que [ i ] [ 1 ] = int ( que [ i ] [ 1 ] ) <NEWLINE> mxt = sum ( [ y for x , y in que ] ) <NEWLINE> t = 0 <NEWLINE> i = 0 <NEWLINE> while t < mxt : <NEWLINE> <INDENT> if i = n : i = 0 <NEWLINE> if que [ i ] [ 1 ] <= q : <NEWLINE> <INDENT> t += que [ i ] [ 1 ] <NEWLINE> print que [ i ] [ 0 ] , t <NEWLINE> que . pop ( i ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += q <NEWLINE> que [ i ] [ 1 ] -= q <NEWLINE> i += 1 <NEWLINE> <DEDENT> <DEDENT>
s = raw_input ( ) . split ( ) <NEWLINE> n = int ( s [ 0 ] ) <NEWLINE> q = int ( s [ 1 ] ) <NEWLINE> <NL> process_name = [ ] <NEWLINE> process_time = [ ] <NEWLINE> for x in xrange ( n ) : <NEWLINE> <INDENT> ps = raw_input ( ) . split ( ) <NEWLINE> process_name . append ( ps [ 0 ] ) <NEWLINE> process_time . append ( ps [ 1 ] ) <NEWLINE> <NL> <DEDENT> total_time = 0 <NEWLINE> while process_name != [ ] : <NEWLINE> <INDENT> pn = process_name . pop ( 0 ) <NEWLINE> pt = process_time . pop ( 0 ) <NEWLINE> if pt <= q : <NEWLINE> <INDENT> total_time += pt <NEWLINE> print pn , pt <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total_time += q <NEWLINE> process_name . append ( pn ) <NEWLINE> process_time . append ( pt ) <NEWLINE> <NL> <DEDENT> <DEDENT> print total_time <NEWLINE>
n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> que = [ map ( str , raw_input ( ) . split ( ) ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : que [ i ] [ 1 ] = int ( que [ i ] [ 1 ] ) <NEWLINE> mxt = sum ( [ y for x , y in que ] ) <NEWLINE> t = 0 <NEWLINE> i = 0 <NEWLINE> while t < mxt : <NEWLINE> <INDENT> i %= n <NEWLINE> a = que [ i ] <NEWLINE> if 0 < a [ 1 ] <= q : <NEWLINE> <INDENT> t += a [ 1 ] <NEWLINE> que [ i ] [ 1 ] = 0 <NEWLINE> print a [ 0 ] , t <NEWLINE> <DEDENT> elif q < a [ 1 ] : <NEWLINE> <INDENT> t += q <NEWLINE> que [ i ] [ 1 ] = a [ 1 ] - q <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
s = 0 <NEWLINE> A = input ( ) . split ( ) <NEWLINE> n = ( int ) ( A [ 0 ] ) <NEWLINE> t = ( int ) ( A [ 1 ] ) <NEWLINE> x = [ 0 for i in range ( 2 * n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B = input ( ) . split ( ) <NEWLINE> k = 2 * i <NEWLINE> x [ k ] = ( B [ 0 ] ) <NEWLINE> x [ k + 1 ] = ( int ) ( B [ 1 ] ) <NEWLINE> <DEDENT> while len ( x ) > 0 : <NEWLINE> <INDENT> s = x [ 1 ] - t <NEWLINE> if s > 0 : <NEWLINE> <INDENT> sum += t <NEWLINE> x . append ( x [ 0 ] ) <NEWLINE> x . append ( s ) <NEWLINE> del x [ 0 ] <NEWLINE> del x [ 0 ] <NEWLINE> <DEDENT> if s <= 0 : <NEWLINE> <INDENT> sum += x [ 1 ] <NEWLINE> print ( x [ 0 ] , sum ) <NEWLINE> del x [ 0 ] <NEWLINE> del x [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT>
import time as ti <NEWLINE> <NL> <NL> class MyQueue ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . length = 50005 <NEWLINE> self . queue = [ 0 ] * self . length <NEWLINE> self . head = 0 <NEWLINE> self . tail = 0 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def enqueue ( self , process ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . queue [ self . tail ] = process <NEWLINE> self . tail = ( self . tail + 1 ) % self . length <NEWLINE> <NL> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . queue [ self . head ] = 0 <NEWLINE> self . head = ( self . head + 1 ) % self . length <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . head == self . tail : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if self . tail - self . head >= len ( self . queue ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class Process ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , name = <STRING> , time = 0 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . name = name <NEWLINE> self . time = time <NEWLINE> <NL> <DEDENT> def forward_time ( self , time ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . time -= time <NEWLINE> return self . time <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def time_forward ( my_queue , interval , current_time , ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> value = my_queue . queue [ my_queue . head ] . time - interval <NEWLINE> if value <= 0 : <NEWLINE> <INDENT> current_time += ( interval + value ) <NEWLINE> print my_queue . queue [ my_queue . head ] . name , current_time <NEWLINE> my_queue . dequeue ( ) <NEWLINE> <NL> <DEDENT> elif value > 0 : <NEWLINE> <INDENT> current_time += interval <NEWLINE> my_queue . enqueue ( my_queue . queue [ my_queue . head ] ) <NEWLINE> my_queue . dequeue ( ) <NEWLINE> <NL> <DEDENT> return current_time <NEWLINE> <NL> <NL> <DEDENT> my_queue = MyQueue ( ) <NEWLINE> n , q = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> <NL> counter = 0 <NEWLINE> while counter < n : <NEWLINE> <INDENT> name , time = raw_input ( ) . split ( ) <NEWLINE> my_queue . enqueue ( Process ( name , int ( time ) ) ) <NEWLINE> counter += 1 <NEWLINE> <NL> <DEDENT> current_time = 0 <NEWLINE> while not my_queue . is_empty ( ) : <NEWLINE> <INDENT> current_time = time_forward ( my_queue , q , current_time ) <NEWLINE> <DEDENT>
import sys <NEWLINE> n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> queue = list ( map ( lambda x : x . strip ( ) . split ( ) , sys . stdin . readlines ( ) ) ) <NEWLINE> i = 0 <NEWLINE> while len ( queue ) > 0 : <NEWLINE> <INDENT> if queue [ i % len ( queue ) ] [ 1 ] -= q < 0 : <NEWLINE> <INDENT> print ( <STRING> . format ( q [ i % len ( queue ) ] [ 0 ] , i * q + q + q [ i % len ( queue ) ] [ 1 ] ) ) <NEWLINE> q . pop ( i % len ( queue ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <NL> <DEDENT>
a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> queuekey = [ ] <NEWLINE> queuetime = [ ] <NEWLINE> <NL> for i in range ( 0 , a [ 0 ] ) : <NEWLINE> <INDENT> tmp = list ( input ( ) . split ( ) ) <NEWLINE> queuekey . append ( tmp [ 0 ] ) <NEWLINE> queuetime . append ( int ( tmp [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> spentTime = 0 <NEWLINE> while len ( queuetime ) > 0 : <NEWLINE> <INDENT> if queuetime [ 0 ] < a [ 1 ] : <NEWLINE> <INDENT> spentTime += queuetime [ 0 ] <NEWLINE> print ( queuekey [ 0 ] , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( spentTime ) <NEWLINE> queuekey . pop ( 0 ) <NEWLINE> queuetime . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> spentTime += a [ 1 ] <NEWLINE> queuetime [ 0 ] -= a [ 1 ] <NEWLINE> queuetime . append ( queletime [ 0 ] ) <NEWLINE> queuekey . append ( quelekey [ 0 ] ) <NEWLINE> queuetime . pop ( 0 ) <NEWLINE> queuekey . pop ( 0 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> q_list = collections . deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> q_list . append ( [ name , int ( time ) ] ) <NEWLINE> <NL> <DEDENT> time = 0 <NEWLINE> while q_list : <NEWLINE> <INDENT> if q_list [ 0 ] [ 1 ] == 0 : <NEWLINE> <INDENT> q_list . popleft ( ) <NEWLINE> <DEDENT> elif q_list [ 0 ] [ 1 ] == 100 : <NEWLINE> <INDENT> time += 100 <NEWLINE> print ( q_list [ 0 ] [ 0 ] , time ) <NEWLINE> q_list [ 0 ] [ 1 ] = 0 <NEWLINE> q_list . rotate ( - 1 ) <NEWLINE> <DEDENT> elif q_list [ 0 ] [ 1 ] < 100 : <NEWLINE> <INDENT> time += q_list [ 0 ] [ 1 ] <NEWLINE> q_list [ 0 ] [ 1 ] = 0 <NEWLINE> print ( q_list [ 0 ] [ 0 ] , time ) <NEWLINE> q_list . rotate ( - 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q_list [ 0 ] [ 1 ] -= 100 <NEWLINE> time += 100 <NEWLINE> q_list . rotate ( - 1 ) <NEWLINE> <DEDENT> <DEDENT>
<NL> from __future__ import print_function <NEWLINE> import Queue <NEWLINE> n , q = map ( int , raw_input ( ) . strip ( ) . split ( ) ) <NEWLINE> name = [ ] <NEWLINE> time = [ ] <NEWLINE> qu = Queue . Queue ( ) <NEWLINE> class task : <NEWLINE> <INDENT> def __init__ ( self , name , time ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . time = time <NEWLINE> self . total = 0 <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> inp = raw_input ( ) . strip ( ) . split ( ) <NEWLINE> qu . put ( task ( inp [ 0 ] , int ( inp [ 1 ] ) ) ) <NEWLINE> <DEDENT> curtime = 0 <NEWLINE> <NL> while not qu . empty ( ) : <NEWLINE> <INDENT> tmp = qu . get ( ) <NEWLINE> if tmp . time > q : <NEWLINE> <INDENT> tmp . time -= q <NEWLINE> curtime += q <NEWLINE> qu . put ( tmp ) <NEWLINE> <DEDENT> else : <NEWLINE> <NL> <INDENT> curtime += tmp . time <NEWLINE> ed = <STRING> if qu . qsize ( ) == 0 else <STRING> <NEWLINE> print ( tmp . name , curtime , end = ed ) <NEWLINE> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 10000000000 ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> process_count , process_time , processes = get_input ( ) <NEWLINE> result = run_roundrobin ( processes = processes , time = process_time ) <NEWLINE> for r in result : <NEWLINE> <INDENT> print ( r . name , r . time ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def run_roundrobin ( processes , time , total_time = 0 , result = [ ] ) : <NEWLINE> <INDENT> if not processes : <NEWLINE> <INDENT> return result <NEWLINE> <NL> <DEDENT> p = processes . popleft ( ) <NEWLINE> if p . time <= time : <NEWLINE> <INDENT> total_time += p . time <NEWLINE> p . time = total_time <NEWLINE> result . append ( p ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total_time += time <NEWLINE> p . time -= time <NEWLINE> processes . append ( p ) <NEWLINE> <NL> <DEDENT> return run_roundrobin ( processes , time , total_time , result ) <NEWLINE> <NL> <NL> <NL> <DEDENT> def get_input ( ) : <NEWLINE> <INDENT> count , time = list ( map ( lambda x : int ( x ) , input ( ) . split ( <STRING> ) ) ) <NEWLINE> <NL> processes = deque ( [ ] ) <NEWLINE> for _ in range ( count ) : <NEWLINE> <INDENT> im = input ( ) . split ( <STRING> ) <NEWLINE> p = Process ( im [ 0 ] , int ( im [ 1 ] ) ) <NEWLINE> processes . append ( p ) <NEWLINE> <NL> <DEDENT> return count , time , processes <NEWLINE> <NL> <NL> <DEDENT> class Process ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , name , time ) : <NEWLINE> <INDENT> self . name = name <NEWLINE> self . time = time <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
class queue ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . head = 0 <NEWLINE> self . tail = 0 <NEWLINE> self . MAX = 100000 <NEWLINE> self . Q = [ [ 0 ] for i in range ( self . MAX - 1 ) ] <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . head == self . tail <NEWLINE> <NL> <DEDENT> def is_full ( self ) : <NEWLINE> <INDENT> return self . head == ( self . tail + 1 ) % self . MAX <NEWLINE> <NL> <DEDENT> def enqueue ( self , x ) : <NEWLINE> <INDENT> if self . is_full ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> self . Q [ self . tail ] = x <NEWLINE> if self . tail + 1 == self . MAX : <NEWLINE> <INDENT> self . tail = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . tail += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> x = self . Q [ self . head ] <NEWLINE> if self . head + 1 == self . MAX : <NEWLINE> <INDENT> self . head = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . head += 1 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = input ( ) . split ( <STRING> ) <NEWLINE> n = int ( n ) <NEWLINE> q = int ( q ) <NEWLINE> q_name = queue ( ) <NEWLINE> q_val = queue ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , t = input ( ) . split ( <STRING> ) <NEWLINE> t = long ( t ) <NEWLINE> q_name . enqueue ( name ) <NEWLINE> q_val . enqueue ( t ) <NEWLINE> <NL> <DEDENT> results = [ ] <NEWLINE> end_time = 0 <NEWLINE> while True : <NEWLINE> <INDENT> process_val = q_val . dequeue ( ) <NEWLINE> process_name = q_name . dequeue ( ) <NEWLINE> if process_val <= q : <NEWLINE> <INDENT> end_time += process_val <NEWLINE> results . append ( [ process_name , end_time ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> end_time += q <NEWLINE> rest_val = process_val - q <NEWLINE> q_name . enqueue ( process_name ) <NEWLINE> q_val . enqueue ( rest_val ) <NEWLINE> <NL> <DEDENT> if q_val . head == q_val . tail : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for v in results : <NEWLINE> <INDENT> print ( <STRING> . format ( v [ 0 ] , v [ 1 ] ) ) <NEWLINE> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> tmp = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> a = [ [ name , int ( time ) ] for name , time in tmp ] <NEWLINE> <NL> total_time = 0 <NEWLINE> <NL> count = 0 <NEWLINE> while ( a ) : <NEWLINE> <INDENT> current = a . pop <NEWLINE> if ( current [ 1 ] > q ) : <NEWLINE> <INDENT> current [ 1 ] -= q <NEWLINE> a . append ( current ) <NEWLINE> total_time += q <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> total_time += current [ 1 ] <NEWLINE> print ( current [ 0 ] , total_time , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
N_str , q_str = raw_input ( ) . split ( ) <NEWLINE> N = int ( N_str ) <NEWLINE> q = int ( q_str ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> total = 0 <NEWLINE> <NL> for i in N : <NEWLINE> <INDENT> t = raw_input ( ) . split ( ) <NEWLINE> A . append ( [ t [ 0 ] , int ( t [ 1 ] ) ] ) <NEWLINE> <NL> <DEDENT> while A : <NEWLINE> <INDENT> name , time = A . pop ( 0 ) <NEWLINE> if time <= q : <NEWLINE> <INDENT> total += time <NEWLINE> B . append ( name + <STRING> + str ( total ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> time -= q <NEWLINE> total += q <NEWLINE> A . append ( [ name , time ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( B ) <NEWLINE>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> A = [ list ( map ( str , input ( ) . split ( ) ) ) for i in range ( n ) ] <NEWLINE> time = 0 <NEWLINE> flag = 1 <NEWLINE> while flag == 1 : <NEWLINE> <INDENT> if int ( A [ 0 ] [ 1 ] ) <= q : <COMMENT> <NEWLINE> <INDENT> time += int ( A [ 0 ] [ 1 ] ) <NEWLINE> print ( A [ 0 ] [ 1 ] , time ) <NEWLINE> del A [ 0 ] <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> time += q <NEWLINE> A . append ( A [ 0 ] ) <NEWLINE> del A [ 0 ] <NEWLINE> <DEDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> flag = 0 <NEWLINE> <DEDENT> <DEDENT>
class a ( object ) : <NEWLINE> <INDENT> def __init__ ( self , buf_size = 10000 ) : <NEWLINE> <INDENT> self . m = [ None for _ in range ( buf_size ) ] <NEWLINE> self . ind = 0 <NEWLINE> self . cur = 0 <NEWLINE> <NL> <DEDENT> def enqueue ( self , elem ) : <NEWLINE> <INDENT> self . m [ self . ind ] = elem <NEWLINE> self . ind += 1 <NEWLINE> <NL> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if self . is_empty ( ) : raise EOFError ( <STRING> ) <NEWLINE> result = self . m [ self . cur ] <NEWLINE> self . cur += 1 <NEWLINE> return result <NEWLINE> <NL> <DEDENT> def is_empty ( self ) : <NEWLINE> <INDENT> return self . ind <= self . cur <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = input ( ) . split ( ) <NEWLINE> qe = a ( n ) <NEWLINE> cur_time = 0 <NEWLINE> <NL> for _ in range ( int ( n ) ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( ) <NEWLINE> qe . enqueue ( ( name , int ( time ) ) ) <NEWLINE> <NL> <DEDENT> while not qe . is_empty ( ) : <NEWLINE> <INDENT> name , time = qe . dequeue ( ) <NEWLINE> if time > int ( q ) : <NEWLINE> <INDENT> cur_time += int ( q ) <NEWLINE> time -= int ( q ) <NEWLINE> qe . enqueue ( ( name , time ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cur_time += int ( time ) <NEWLINE> print ( <STRING> . format ( name , cur_time ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
class Trio : <NEWLINE> <INDENT> __pre = None <NEWLINE> __val = None <NEWLINE> __nex = None <NEWLINE> def __init__ ( self , val , p = None , n = None ) : <NEWLINE> <INDENT> self . __pre = p <NEWLINE> self . __val = val <NEWLINE> self . __nex = n <NEWLINE> <NL> <DEDENT> def get_pre ( self ) : return self . __pre <NEWLINE> <NL> def get_nex ( self ) : return self . __nex <NEWLINE> <NL> def set_pre ( self , n ) : self . __pre = n <NEWLINE> <NL> def set_nex ( self , n ) : self . __nex = n <NEWLINE> <NL> def set_val ( self , n ) : self . __val = n <NEWLINE> <NL> def get_val ( self ) : return self . __val <NEWLINE> <NL> <DEDENT> class Queue : <NEWLINE> <INDENT> top = back = None <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> def enqueue ( self , n ) : <NEWLINE> <INDENT> if ( self . top == None ) : <NEWLINE> <INDENT> self . top = self . back = Trio ( n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . back . set_nex ( Trio ( n , p = self . back ) ) <NEWLINE> self . back = self . back . get_nex ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def dequeue ( self ) : <NEWLINE> <INDENT> if ( self . top == self . back ) : <NEWLINE> <INDENT> a , self . top , self . back = self . top . get_val ( ) , None , None <NEWLINE> return a <NEWLINE> <DEDENT> elif ( self . top == None ) : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . top = self . top . get_nex ( ) <NEWLINE> oldtop = self . top . get_pre ( ) <NEWLINE> self . top . set_pre ( None ) <NEWLINE> return oldtop . get_val ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> s = input ( ) <NEWLINE> n , limit = map ( int , s . split ( ) ) <NEWLINE> que = Queue ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> lis = input ( ) . split ( ) <NEWLINE> que . enqueue ( ( lis [ 0 ] , int ( lis [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> time = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> elm = que . dequeue ( ) <NEWLINE> if ( elm == None ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif ( elm [ 1 ] > limit ) : <NEWLINE> <INDENT> que . enqueue ( ( elm [ 0 ] , elm [ 1 ] - limit ) ) <NEWLINE> time += 100 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> time += elm [ 1 ] <NEWLINE> print ( elm [ 0 ] , time ) <NEWLINE> <DEDENT> <DEDENT>
from Queue import Queue <NEWLINE> <NL> n , q = [ int ( val ) for val in input ( ) . split ( <STRING> ) ] <NEWLINE> names = Queue ( ) <NEWLINE> times = Queue ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> name , time = input ( ) . split ( <STRING> ) <NEWLINE> names . put ( name ) <NEWLINE> times . put ( int ( time ) ) <NEWLINE> <NL> <DEDENT> qsum = 0 <NEWLINE> output = [ ] <NEWLINE> while not times . empty ( ) : <NEWLINE> <INDENT> name = names . get ( ) <NEWLINE> time = times . get ( ) <NEWLINE> if time <= q : <NEWLINE> <INDENT> qsum += time <NEWLINE> output . append ( <STRING> . format ( name , qsum ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> times . put ( time - q ) <NEWLINE> names . put ( name ) <NEWLINE> qsum += q <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( output ) ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> class Solution : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def message_queue ( ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> task_num , task_time = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> _input = sys . stdin . readlines ( ) <NEWLINE> <NL> <NL> <COMMENT> <NL> task_deque = deque ( map ( lambda x : dict ( name = x . split ( ) [ 0 ] , time = x . split ( ) [ - 1 ] ) , _input ) ) <NEWLINE> total_time = 0 <NEWLINE> <NL> while task_deque : <NEWLINE> <INDENT> item = task_deque . popleft ( ) <NEWLINE> if item [ <STRING> ] <= task_time : <NEWLINE> <INDENT> total_time += item [ <STRING> ] <NEWLINE> print ( item [ <STRING> ] , total_time ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> item [ <STRING> ] -= task_time <NEWLINE> total_time += task_time <NEWLINE> task_deque . append ( item ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . message_queue ( ) <NEWLINE> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> n = int ( a [ 0 ] ) <NEWLINE> q = int ( a [ 1 ] ) <NEWLINE> b = [ 0 for i in range ( 2 * n ) ] <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B = input ( ) . split ( ) <NEWLINE> b [ 2 * i ] = B [ 0 ] <NEWLINE> b [ 2 * i + 1 ] = int ( B [ 1 ] ) <NEWLINE> <DEDENT> while len ( b ) > 0 : <NEWLINE> <INDENT> if b [ 1 ] - 100 > 0 : <NEWLINE> <INDENT> tmp1 = b [ 0 ] <NEWLINE> tmp2 = b [ 1 ] - 100 <NEWLINE> del b [ 0 ] <NEWLINE> del b [ 0 ] <NEWLINE> b . append ( tmp1 ) <NEWLINE> b . append ( tmp2 ) <NEWLINE> cnt = cnt + 100 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt = cnt + b [ 1 ] <NEWLINE> print ( b [ 0 ] , cnt ) <NEWLINE> del b [ 0 ] <NEWLINE> del b [ 0 <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> procs = [ raw_input ( ) . split ( ) for i in xrange ( n ) ] <NEWLINE> <NL> <COMMENT> <NL> cnt , lack = 0 , 1 <NEWLINE> while lack > 0 : <NEWLINE> <INDENT> lack = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> t = int ( procs [ i ] [ 1 ] ) <NEWLINE> if t == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if t <= q : <NEWLINE> <INDENT> cnt += t <NEWLINE> t = 0 <NEWLINE> print procs [ i ] [ 0 ] , cnt <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> cnt += q <NEWLINE> t = t - q <NEWLINE> lack += t <NEWLINE> <DEDENT> procs [ i ] [ 1 ] = str ( t ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> ls = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = raw_input ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> ls . insert ( 0 , cmd [ 7 : ] ) <NEWLINE> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> ls . remove ( cmd [ 7 : ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> ls . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , ls ) ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . prev = None <NEWLINE> self . next_node = None <NEWLINE> self . num = num <NEWLINE> <DEDENT> def delete ( self ) : <NEWLINE> <INDENT> if self . prev is not None : <NEWLINE> <INDENT> self . prev . next_node = self . next_node <NEWLINE> <DEDENT> if self . next_node is not None : <NEWLINE> <INDENT> self . next_node . prev = self . prev <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class LinkedList : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . start_node = None <NEWLINE> self . last_node = None <NEWLINE> <DEDENT> def add ( self , num ) : <NEWLINE> <INDENT> node = Node ( num ) <NEWLINE> if self . start_node is None : <NEWLINE> <INDENT> self . start_node = node <NEWLINE> self . last_node = node <NEWLINE> <DEDENT> elif self . last_node is None : <NEWLINE> <INDENT> self . last_node = self . start_node <NEWLINE> node . next_node = self . last_node <NEWLINE> self . last_node . prev = node <NEWLINE> self . start_node = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start_node . prev = node <NEWLINE> node . next_node = self . start_node <NEWLINE> self . start_node = node <NEWLINE> <DEDENT> <DEDENT> def delete ( self , num ) : <NEWLINE> <INDENT> node = self . start_node <NEWLINE> while node is not None : <NEWLINE> <INDENT> if node . num == num : <NEWLINE> <INDENT> if node == self . start_node : <NEWLINE> <INDENT> self . delete_first ( ) <NEWLINE> <DEDENT> elif node == self . last_node : <NEWLINE> <INDENT> self . delete_last ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . delete ( ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> node = node . next_node <NEWLINE> <DEDENT> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> if self . start_node == self . last_node : <NEWLINE> <INDENT> self . start_node = None <NEWLINE> self . last_node = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = self . last_node <NEWLINE> self . last_node = self . last_node . prev <NEWLINE> node . delete ( ) <NEWLINE> <DEDENT> <DEDENT> def delete_first ( self ) : <NEWLINE> <INDENT> if self . start_node == self . last_node : <NEWLINE> <INDENT> self . start_node = None <NEWLINE> self . last_node = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = self . start_node <NEWLINE> self . start_node = self . start_node . next_node <NEWLINE> node . delete ( ) <NEWLINE> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> s = [ ] <NEWLINE> node = self . start_node <NEWLINE> while node is not None : <NEWLINE> <INDENT> s . append ( node . num ) <NEWLINE> node = node . next_node <NEWLINE> <DEDENT> return <STRING> . join ( s ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> linked_list = LinkedList ( ) <NEWLINE> c_num = int ( stdin . readline ( ) . strip ( ) ) <NEWLINE> for i in range ( 0 , c_num ) : <NEWLINE> <INDENT> line = stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> op = line [ 0 ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> linked_list . add ( line [ 1 ] ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> linked_list . delete ( line [ 1 ] ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> linked_list . delete_first ( ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> linked_list . delete_last ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print str ( linked_list ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command , num = input ( ) . split ( ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> q . appendleft ( n ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( num ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) ) <NEWLINE>
import sys <NEWLINE> import collections <NEWLINE> n = int ( input ( ) ) <NEWLINE> que = collections . deque ( ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> command = sys . stdin . readline ( ) . strip ( ) <NEWLINE> if <STRING> == command [ 0 ] : <NEWLINE> <INDENT> command , num = command <NEWLINE> que . appendleft ( num ) <NEWLINE> <DEDENT> elif <STRING> == command : <NEWLINE> <INDENT> que . popleft ( ) <NEWLINE> <DEDENT> elif <STRING> == command : <NEWLINE> <INDENT> que . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command , num = command . split ( ) <NEWLINE> try : <NEWLINE> <INDENT> que . remove ( num ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , que ) ) ) <NEWLINE>
class DoublyLinkedList : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . nil = self . make_node ( None ) <NEWLINE> self . nil [ <STRING> ] = self . nil <NEWLINE> self . nil [ <STRING> ] = self . nil <NEWLINE> <NL> <DEDENT> def make_node ( self , v ) : <NEWLINE> <INDENT> return { <STRING> : v , <STRING> : None , <STRING> : None } <NEWLINE> <NL> <DEDENT> def dump ( self ) : <NEWLINE> <INDENT> n = self . nil [ <STRING> ] <NEWLINE> while True : <NEWLINE> <INDENT> if n [ <STRING> ] == None : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print str ( n [ <STRING> ] ) , <NEWLINE> n = n [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> print <NEWLINE> <NL> <NL> <DEDENT> def insert ( self , v ) : <NEWLINE> <INDENT> n = self . make_node ( v ) <NEWLINE> n [ <STRING> ] = self . nil [ <STRING> ] <NEWLINE> self . nil [ <STRING> ] [ <STRING> ] = n <NEWLINE> n [ <STRING> ] = self . nil <NEWLINE> self . nil [ <STRING> ] = n <NEWLINE> <NL> <DEDENT> def delete ( self , v ) : <NEWLINE> <INDENT> self . delete_node ( self . list_search ( v ) ) <NEWLINE> <NL> <DEDENT> def delete_node ( self , n ) : <NEWLINE> <INDENT> if n [ <STRING> ] == None : return <NEWLINE> n [ <STRING> ] [ <STRING> ] = n [ <STRING> ] <NEWLINE> n [ <STRING> ] [ <STRING> ] = n [ <STRING> ] <NEWLINE> <NL> <DEDENT> def list_search ( self , v ) : <NEWLINE> <INDENT> cur = self . nil [ <STRING> ] <NEWLINE> while ( cur [ <STRING> ] != None ) and ( cur [ <STRING> ] != v ) : <NEWLINE> <INDENT> cur = cur [ <STRING> ] <NEWLINE> <DEDENT> return cur <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . delete_node ( self . nil [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . delete_node ( self . nil [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> commands = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> commands . append ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> l = DoublyLinkedList ( ) <NEWLINE> for c in commands : <NEWLINE> <INDENT> a = c [ 6 ] <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> l . deleteFirst ( ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> l . deleteLast ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> val = int ( c [ 7 : ] ) <NEWLINE> op = c [ 0 ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> l . insert ( val ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l . delete ( val ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> l . dump ( ) <NEWLINE>
<COMMENT> <NL> import time <NEWLINE> <NL> class Node ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , key = None , previous_node = None , next_node = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . key = key <NEWLINE> <STRING> <NEWLINE> <NL> self . previous_node = previous_node <NEWLINE> <STRING> <NEWLINE> <NL> self . next_node = next_node <NEWLINE> <STRING> <NEWLINE> <NL> <DEDENT> def copy_from ( self , node ) : <NEWLINE> <INDENT> self . key = node . key <NEWLINE> self . previous_node = node . previous_node <NEWLINE> self . next_node = node . next_node <NEWLINE> <NL> <DEDENT> def print_on ( self , is_performance = False ) : <NEWLINE> <INDENT> if is_performance : <NEWLINE> <INDENT> pass <NEWLINE> print self . key , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print self . previous_node , str ( self . key ) + <STRING> + str ( self ) , self . next_node <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class DoublyLinkedList ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , sentinel_key = <STRING> ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . sentinel_node = Node ( key = sentinel_key ) <NEWLINE> self . sentinel_node . next_node = self . sentinel_node <NEWLINE> self . sentinel_node . previous_node = self . sentinel_node <NEWLINE> <NL> <DEDENT> def insert_node ( self , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> <COMMENT> <NL> new_node = Node ( key = key , previous_node = self . sentinel_node , next_node = self . sentinel_node . next_node ) <NEWLINE> <COMMENT> <NL> self . sentinel_node . next_node . previous_node = new_node <NEWLINE> <COMMENT> <NL> self . sentinel_node . next_node = new_node <NEWLINE> <NL> <NL> <DEDENT> def delete ( self , key = None ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> target_node = self . sentinel_node . next_node <NEWLINE> while target_node is not self . sentinel_node : <NEWLINE> <INDENT> if target_node . key == key : <NEWLINE> <INDENT> target_node . previous_node . next_node = target_node . next_node <NEWLINE> target_node . next_node . previous_node = target_node . previous_node <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> target_node = target_node . next_node <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def delete_first ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <COMMENT> <NL> self . sentinel_node . next_node = self . sentinel_node . next_node . next_node <NEWLINE> self . sentinel_node . next_node . previous_node = self . sentinel_node <NEWLINE> <NL> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . sentinel_node . previous_node = self . sentinel_node . previous_node . previous_node <NEWLINE> self . sentinel_node . previous_node . next_node = self . sentinel_node <NEWLINE> <NL> <DEDENT> def print_on ( self , is_performance = False ) : <NEWLINE> <INDENT> target_node = self . sentinel_node <NEWLINE> if not is_performance : <NEWLINE> <INDENT> target_node . print_on ( is_performance ) <NEWLINE> <DEDENT> while target_node . next_node is not self . sentinel_node : <NEWLINE> <INDENT> target_node = target_node . next_node <NEWLINE> target_node . print_on ( is_performance ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> doubly_linked_list = DoublyLinkedList ( ) <NEWLINE> <NL> input_length = int ( raw_input ( ) ) <NEWLINE> counter = 0 <NEWLINE> while counter < input_length : <NEWLINE> <INDENT> counter += 1 <NEWLINE> input_line = raw_input ( ) <NEWLINE> identifier = input_line [ 6 ] <NEWLINE> if identifier is <STRING> : <NEWLINE> <INDENT> doubly_linked_list . delete_first ( ) <NEWLINE> continue <NEWLINE> <DEDENT> elif identifier is <STRING> : <NEWLINE> <INDENT> doubly_linked_list . delete_last ( ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> input_command , input_key = input_line . split ( <STRING> ) <NEWLINE> if input_command == <STRING> : <NEWLINE> <INDENT> doubly_linked_list . insert_node ( input_key ) <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> doubly_linked_list . delete ( input_key ) <NEWLINE> <DEDENT> <DEDENT> doubly_linked_list . print_on ( is_performance = True ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from collections import deque <NEWLINE> <NL> def parse_cmd ( deque , input_cmd ) : <NEWLINE> <INDENT> if input_cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> deque . appendleft ( input_cmd [ 1 ] ) <NEWLINE> <DEDENT> elif input_cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> deque . remove ( input_cmd [ 1 ] ) <NEWLINE> <DEDENT> elif input_cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> deque . popleft ( ) <NEWLINE> <DEDENT> elif input_cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> deque . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> que = deque ( ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> cmd = [ raw_input ( ) . split ( ) for _ in range ( n ) ] <NEWLINE> <NL> for i in cmd : <NEWLINE> <INDENT> parse_cmd ( que , i ) <NEWLINE> <NL> <DEDENT> print <STRING> . join ( que ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> array = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inst = raw_input ( ) . split ( ) <NEWLINE> if inst [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> array . append ( int ( inst [ 1 ] ) ) <NEWLINE> <DEDENT> elif inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> if int ( inst [ 1 ] ) in array : <NEWLINE> <INDENT> x = array [ : : - 1 ] . index ( int ( inst [ 1 ] ) ) <NEWLINE> if x != - 1 and int ( inst [ 1 ] ) : <NEWLINE> <INDENT> del array [ - x - 1 ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif inst [ 0 ] [ 6 ] == <STRING> : <NEWLINE> <INDENT> array . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array . pop ( 0 ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , array [ : : - 1 ] ) ) <NEWLINE>
def insert ( x , a ) : <NEWLINE> <INDENT> a . insert ( 0 , x ) <NEWLINE> <DEDENT> def delete ( x , a ) : <NEWLINE> <INDENT> if x in a : <NEWLINE> <INDENT> a . remove ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> <DEDENT> def deletefirst ( a ) : <NEWLINE> <INDENT> del a [ 0 ] <NEWLINE> <DEDENT> def deletelast ( a ) : <NEWLINE> <INDENT> del a [ - 1 ] <NEWLINE> <DEDENT> n = input ( ) <NEWLINE> a = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> s = raw_input ( ) . split ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( s [ 1 ] , a ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete ( s [ 1 ] , a ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> deletefirst ( a ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> deletelast ( a ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . join ( a ) ) <NEWLINE>
from collections import deque <NEWLINE> from sys import stdin <NEWLINE> q = deque ( ) <NEWLINE> input ( ) <NEWLINE> for s in stdin : <NEWLINE> <INDENT> c , * k = s . split ( ) <NEWLINE> k = k [ 0 ] if k else None <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( k ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> if k in q : <NEWLINE> <INDENT> q . remove ( k ) <NEWLINE> <DEDENT> <DEDENT> if c == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print ( * q ) <NEWLINE>
import sys , gc <NEWLINE> <NL> <NL> A = [ ] <NEWLINE> fp = 0 <NEWLINE> bp = 0 <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> while n : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . append ( s [ 7 : ] ) <NEWLINE> fp += 1 <NEWLINE> <DEDENT> elif s [ 6 ] == <STRING> : <NEWLINE> <INDENT> i = - 1 <NEWLINE> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> i = A [ i + 1 : ] . index ( s [ 7 : ] ) <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> if i != - 1 : <NEWLINE> <INDENT> del A [ i ] <NEWLINE> fp -= 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif s [ 6 ] == <STRING> : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> fp -= 1 <NEWLINE> <DEDENT> elif s [ 6 ] == <STRING> : <NEWLINE> <INDENT> A [ bp ] = - 1 <NEWLINE> bp += 1 <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> <DEDENT> for e in A [ bp : fp + 1 ] [ : : - 1 ] : <NEWLINE> <INDENT> if e != - 1 : <NEWLINE> <INDENT> print int ( e ) , <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key = None , prev = None , next = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . prev = prev <NEWLINE> self . next = next <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class DoublyLinkedList ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . head = Node ( ) <NEWLINE> self . head . next = self . head <NEWLINE> self . head . prev = self . head <NEWLINE> <NL> <DEDENT> def insert ( self , x ) : <NEWLINE> <INDENT> node = Node ( key = x , prev = self . head , next = self . head . next ) <NEWLINE> self . head . next . prev = node <NEWLINE> self . head . next = node <NEWLINE> <NL> <DEDENT> def search ( self , x ) : <NEWLINE> <INDENT> node = self . head . next <NEWLINE> while node is not self . head and node . key != x : <NEWLINE> <INDENT> node = node . next <NEWLINE> <DEDENT> return node <NEWLINE> <NL> <DEDENT> def delete_key ( self , x ) : <NEWLINE> <INDENT> if node is self . head : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> node = self . search ( x ) <NEWLINE> self . _delete ( node ) <NEWLINE> <NL> <DEDENT> def _delete ( self , node ) : <NEWLINE> <INDENT> node . prev . next = node . next <NEWLINE> node . next . prev = node . prev <NEWLINE> <NL> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> self . _delete ( self . head . next ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> self . _delete ( self . head . prev ) <NEWLINE> <NL> <DEDENT> def getKeys ( self ) : <NEWLINE> <INDENT> node = self . head . next <NEWLINE> keys = [ ] <NEWLINE> while node is not self . head : <NEWLINE> <INDENT> keys . append ( node . key ) <NEWLINE> node = node . next <NEWLINE> <DEDENT> return <STRING> . join ( keys ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> L = DoublyLinkedList ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> if <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> L . insert ( x ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> L . deleteFirst ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> L . deleteLast ( ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> x = i [ 7 : - 1 ] <NEWLINE> L . delete_key ( x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> print ( L . getKeys ( ) ) <NEWLINE> <NL>
import sys <NEWLINE> import collections <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> ans = collections . deque ( ) <NEWLINE> while n : <NEWLINE> <INDENT> n -= 1 <NEWLINE> s = sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> if s [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> ans . appendleft ( s [ 1 ] ) <NEWLINE> <DEDENT> elif s [ 0 ] [ - 3 ] == <STRING> : <NEWLINE> <INDENT> ans . popleft ( ) <NEWLINE> <DEDENT> elif s [ 0 ] [ - 3 ] == <STRING> : <NEWLINE> <INDENT> ans . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans . remove ( s [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> sys . stdout . write ( <STRING> . join ( ans ) ) <NEWLINE> print <NEWLINE>
<NL> n = int ( input ( ) ) <NEWLINE> output = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> order = map ( str , input ( ) . split ( ) ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> output . append ( int ( order [ 1 ] ) ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> output . pop ( ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> output . popleft ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( output ) ) <NEWLINE> <COMMENT> <NL> <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> que_r = deque ( ) <NEWLINE> data = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> l = len ( s ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> que_r . appendleft ( s [ 7 : ] ) <NEWLINE> <DEDENT> elif s [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> que_r . remove ( s [ 7 : ] ) <NEWLINE> <DEDENT> except : pass <NEWLINE> <DEDENT> elif l > 10 : <NEWLINE> <INDENT> que_r . popleft ( ) <NEWLINE> <DEDENT> elif l > 6 : <NEWLINE> <INDENT> que_r . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> pr ( * que_r ) <NEWLINE>
import collections <NEWLINE> q = collections . deque ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com = input ( ) . split ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . remove ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> elif com [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> dlist = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> arr = input ( ) . split ( ) <NEWLINE> cmd = <STRING> <NEWLINE> key = 0 <NEWLINE> cmd = arr [ 0 ] <NEWLINE> if len ( arr ) > 1 : <NEWLINE> <INDENT> key = arr [ 1 ] <NEWLINE> <DEDENT> if cmd == <STRING> : <NEWLINE> <INDENT> dlist . appendleft ( key ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dlist . remove ( key ) <NEWLINE> <DEDENT> except : <NEWLINE> <COMMENT> <NL> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dlist . pop ( ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dlist . popleft ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( dlist ) ) <NEWLINE> <NL>
from collections import deque <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> stack = deque ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> i = raw_input ( ) <NEWLINE> if <STRING> in i : <NEWLINE> <INDENT> stack . insert ( 0 , int ( i [ 7 : ] ) ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> if int ( i [ 7 : ] ) in stack : <NEWLINE> <INDENT> stack . remove ( int ( i [ 7 : ] ) ) <NEWLINE> <DEDENT> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> stack . pop ( 0 ) <NEWLINE> <DEDENT> elif <STRING> in i : <NEWLINE> <INDENT> stack . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , stack ) ) <NEWLINE>
from collections import deque <NEWLINE> d = deque ( ) <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> if <STRING> == a [ 0 ] : d . appendleft ( int ( a [ 1 ] ) ) <NEWLINE> elif <STRING> == a [ 6 ] : d . popleft ( ) <NEWLINE> elif <STRING> == a [ 6 ] : d . pop ( ) <NEWLINE> else : <NEWLINE> <INDENT> try : d . remove ( int ( a [ 1 ] ) ) <NEWLINE> except : pass <NEWLINE> <DEDENT> <DEDENT> print ( * d ) <NEWLINE>
class Node : <NEWLINE> <INDENT> elm = None <NEWLINE> next = None <NEWLINE> prev = None <NEWLINE> <NL> <DEDENT> class MyList : <NEWLINE> <INDENT> head = tail = None <NEWLINE> lookup = { } <NEWLINE> <NL> def insert ( self , x ) : <NEWLINE> <INDENT> n = Node ( ) <NEWLINE> n . elm = x <NEWLINE> if self . head == None : <NEWLINE> <INDENT> self . head = self . tail = n <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . next = self . head <NEWLINE> self . head . prev = n <NEWLINE> self . head = n <NEWLINE> <DEDENT> self . lookup [ x ] = n <NEWLINE> <NL> <DEDENT> def delete ( self , x ) : <NEWLINE> <INDENT> if x in self . lookup : <NEWLINE> <INDENT> n = self . lookup [ x ] <NEWLINE> del self . lookup [ x ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n = self . head <NEWLINE> while n and n . elm != x : <NEWLINE> <INDENT> n = n . next <NEWLINE> <DEDENT> <DEDENT> if n : <NEWLINE> <INDENT> self . __delete_node ( n ) <NEWLINE> <NL> <DEDENT> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> x = self . head . elm <NEWLINE> if x in self . lookup : <NEWLINE> <INDENT> del self . lookup [ x ] <NEWLINE> <DEDENT> self . __delete_node ( self . head ) <NEWLINE> <NL> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> x = self . tail . elm <NEWLINE> if x in self . lookup and self . tail == self . lookup [ x ] : <NEWLINE> <INDENT> del self . lookup [ x ] <NEWLINE> <DEDENT> self . __delete_node ( self . tail ) <NEWLINE> <NL> <DEDENT> def __delete_node ( self , n ) : <NEWLINE> <INDENT> if n == self . head : <NEWLINE> <INDENT> self . head = n . next <NEWLINE> <DEDENT> if n == self . tail : <NEWLINE> <INDENT> self . tail = n . prev <NEWLINE> <DEDENT> if n . prev : <NEWLINE> <INDENT> n . prev . next = n . next <NEWLINE> <DEDENT> if n . next : <NEWLINE> <INDENT> n . next . prev = n . prev <NEWLINE> <NL> <DEDENT> <DEDENT> def print_all ( self ) : <NEWLINE> <INDENT> n = self . head <NEWLINE> while n : <NEWLINE> <INDENT> print n . elm , <NEWLINE> n = n . next <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> myList = MyList ( ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for _ in xrange ( n ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> myList . insert ( line [ 7 : ] ) <NEWLINE> <DEDENT> elif line [ 6 ] == <STRING> : <NEWLINE> <INDENT> myList . deleteFirst ( ) <NEWLINE> <DEDENT> elif line [ 6 ] == <STRING> : <NEWLINE> <INDENT> myList . deleteLast ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> myList . delete ( line [ 7 : ] ) <NEWLINE> <DEDENT> <DEDENT> myList . print_all ( ) <NEWLINE>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . prev = None <NEWLINE> self . next_node = None <NEWLINE> self . num = num <NEWLINE> <DEDENT> def delete ( self ) : <NEWLINE> <INDENT> if self . prev is not None : <NEWLINE> <INDENT> self . prev . next_node = self . next_node <NEWLINE> <DEDENT> if self . next_node is not None : <NEWLINE> <INDENT> self . next_node . prev = self . prev <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class LinkedList : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . start_node = None <NEWLINE> self . last_node = None <NEWLINE> <DEDENT> def add ( self , num ) : <NEWLINE> <INDENT> node = Node ( num ) <NEWLINE> if self . start_node is None : <NEWLINE> <INDENT> self . start_node = node <NEWLINE> self . last_node = node <NEWLINE> <DEDENT> elif self . last_node is None : <NEWLINE> <INDENT> self . last_node = self . start_node <NEWLINE> node . next_node = self . last_node <NEWLINE> self . last_node . prev = node <NEWLINE> self . start_node = node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . start_node . prev = node <NEWLINE> node . next_node = self . start_node <NEWLINE> self . start_node = node <NEWLINE> <DEDENT> <DEDENT> def delete ( self , num ) : <NEWLINE> <INDENT> node = self . start_node <NEWLINE> while node is not None : <NEWLINE> <INDENT> if node . num == num : <NEWLINE> <INDENT> if node == self . start_node : <NEWLINE> <INDENT> self . delete_first ( ) <NEWLINE> <DEDENT> elif node == self . last_node : <NEWLINE> <INDENT> self . delete_last ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . delete ( ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> node = node . next_node <NEWLINE> <DEDENT> <DEDENT> def delete_last ( self ) : <NEWLINE> <INDENT> if self . start_node == self . last_node : <NEWLINE> <INDENT> self . start_node = None <NEWLINE> self . last_node = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = self . last_node <NEWLINE> self . last_node = self . last_node . prev <NEWLINE> node . delete ( ) <NEWLINE> <DEDENT> <DEDENT> def delete_first ( self ) : <NEWLINE> <INDENT> if self . start_node == self . last_node : <NEWLINE> <INDENT> self . start_node = None <NEWLINE> self . last_node = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node = self . start_node <NEWLINE> self . start_node = self . start_node . next_node <NEWLINE> node . delete ( ) <NEWLINE> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> node = self . start_node <NEWLINE> while node is not None : <NEWLINE> <INDENT> s += str ( node . num ) + <STRING> <NEWLINE> node = node . next_node <NEWLINE> <DEDENT> return s . strip ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> linked_list = LinkedList ( ) <NEWLINE> c_num = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> for i in range ( 0 , c_num ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) <NEWLINE> op = line [ 0 ] <NEWLINE> if op == <STRING> : <NEWLINE> <INDENT> linked_list . add ( int ( line [ 1 ] ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> linked_list . delete ( int ( line [ 1 ] ) ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> linked_list . delete_first ( ) <NEWLINE> <DEDENT> if op == <STRING> : <NEWLINE> <INDENT> linked_list . delete_last ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print str ( linked_list ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dll = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . insert ( 0 , command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . pop ( 0 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <DEDENT> print ( dll [ i ] , sep = <STRING> ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
<NL> from sys import stdin <NEWLINE> import sys <NEWLINE> class node : <NEWLINE> <INDENT> def __init__ ( self , num , pre = None , nextnode = None ) : <NEWLINE> <INDENT> self . num = num <NEWLINE> self . prenode = pre <NEWLINE> self . nextnode = nextnode <NEWLINE> <NL> <DEDENT> <DEDENT> class doubly_linked_list : <NEWLINE> <INDENT> import sys <NEWLINE> begin_node = None <NEWLINE> end_node = None <NEWLINE> <NL> def insert ( self , num ) : <NEWLINE> <INDENT> if ( self . end_node ) : <NEWLINE> <INDENT> self . end_node . nextnode = node ( num , pre = self . end_node ) <NEWLINE> self . end_node = self . end_node . nextnode <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . begin_node = self . end_node = node ( num ) <NEWLINE> <DEDENT> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> if self . begin_node is self . end_node : <NEWLINE> <INDENT> self . begin_node = self . end_node = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . begin_node = self . begin_node . nextnode <NEWLINE> self . begin_node . prenode = None <NEWLINE> <NL> <DEDENT> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> if self . begin_node is self . end_node : <NEWLINE> <INDENT> self . begin_node = self . end_node = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . end_node = self . end_node . prenode <NEWLINE> self . end_node . nextnode = None <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_num ( self , target ) : <NEWLINE> <INDENT> it = self . begin_node <NEWLINE> while it is not None : <NEWLINE> <INDENT> if it . num == target : <NEWLINE> <INDENT> if it . prenode is None and it . nextnode is None : <NEWLINE> <INDENT> self . begin_node = self . end_node = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if it . prenode is not None : <NEWLINE> <INDENT> it . prenode . nextnode = it . nextnode <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . begin_node = self . begin_node . nextnode <NEWLINE> <NL> <DEDENT> if it . nextnode is not None : <NEWLINE> <INDENT> it . nextnode . prenode = it . prenode <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . end_node = self . end_node . prenode <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <DEDENT> it = it . nextnode <NEWLINE> <NL> <DEDENT> <DEDENT> def print_all ( self ) : <NEWLINE> <INDENT> current_node = self . begin_node <NEWLINE> while ( current_node is not self . end_node ) : <NEWLINE> <INDENT> print ( current_node . num , end = <STRING> , flush = True ) <NEWLINE> current_node = current_node . nextnode <NEWLINE> <DEDENT> print ( self . end_node . num , flush = True ) <NEWLINE> sys . stdout . flush ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> dll = doubly_linked_list ( ) <NEWLINE> dll . insert ( stdin . readline ( ) . strip ( ) . split ( ) [ 1 ] ) <NEWLINE> <NL> for i in range ( n - 1 ) : <NEWLINE> <INDENT> command = stdin . readline ( ) . strip ( ) <NEWLINE> if ( command == <STRING> ) : <NEWLINE> <INDENT> dll . deleteFirst ( ) <NEWLINE> <DEDENT> elif ( command == <STRING> ) : <NEWLINE> <INDENT> dll . deleteLast ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command , num = command . split ( sep = <STRING> ) <NEWLINE> <COMMENT> <NL> if ( command == <STRING> ) : <NEWLINE> <INDENT> dll . delete ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dll . insert ( num ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> dll . print_all ( ) <NEWLINE>
from collections import deque <NEWLINE> d = deque ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) . split ( ) <NEWLINE> if str ( s [ 0 ] [ 6 ] ) == <STRING> : d . popleft ( ) <NEWLINE> elif : str ( s [ 0 ] [ 6 ] ) == <STRING> : d . pop ( ) <NEWLINE> elif str ( s [ 0 ] [ 0 ] ) == <STRING> : d . appendleft ( int ( s [ 1 ] ) ) <NEWLINE> else : <NEWLINE> <INDENT> if int ( s [ 1 ] ) in d : <NEWLINE> <INDENT> d . remove ( int ( s [ 1 ] ) ) <NEWLINE> <DEDENT> else : pass <NEWLINE> <DEDENT> <DEDENT> print ( * d ) <NEWLINE> <NL>
<NL> n = int ( input ( ) ) <NEWLINE> List = [ ] <NEWLINE> command = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tmp = int ( command [ 1 ] ) <NEWLINE> List . append ( tmp ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> List . remove ( int ( command [ 1 ] ) ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> List . pop ( 0 ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> List . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> i = len ( List ) - 1 <NEWLINE> for j in range ( len ( List ) ) : <NEWLINE> <INDENT> if j is not i - 1 : <NEWLINE> <INDENT> print ( List [ i - j ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( * List [ i - j ] ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> from collections import deque <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> que = deque ( ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> o = raw_input ( ) <NEWLINE> if o == <STRING> : <NEWLINE> <INDENT> del que [ 0 ] <NEWLINE> <DEDENT> elif o == <STRING> : <NEWLINE> <INDENT> del que [ - 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c , p = o . split ( ) <NEWLINE> p = int ( p ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> que . appendleft ( p ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> que . remove ( p ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , que ) ) <NEWLINE>
dq = deque ( ) <NEWLINE> num = int ( sys . stdin . readline ( ) ) <NEWLINE> line = sys . stdin . readlines ( ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <NL> <INDENT> order = line [ i ] . split ( ) <NEWLINE> <NL> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( order [ 1 ] ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if order [ 1 ] in dq : <NEWLINE> <INDENT> dq . remove ( order [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dq ) ) <NEWLINE>
from collections import deque <NEWLINE> import sys <NEWLINE> <NL> dq = deque ( ) <NEWLINE> num = int ( input ( ) ) <NEWLINE> line = sys . stdin . readlines ( ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <NL> <INDENT> order = line [ i ] . split ( ) <NEWLINE> <NL> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . appendleft ( com [ 1 ] ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . popleft ( ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> dq . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if order [ 1 ] in dq : <NEWLINE> <INDENT> dq . remove ( com [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( dq ) ) <NEWLINE>
n = input ( ) <NEWLINE> lis = [ ] <NEWLINE> ans = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> com = raw_input ( ) <NEWLINE> if com [ 0 ] == <STRING> : <NEWLINE> <INDENT> lis . append ( com [ 7 : ] ) <NEWLINE> <DEDENT> elif com [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> lis . pop ( ~ lis [ : : - 1 ] . index ( com [ 7 : ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif com [ 6 ] == <STRING> : <NEWLINE> <INDENT> lis . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bot += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , reversed ( lis [ ans : ] ) ) ) <NEWLINE>
<COMMENT> <NL> n = input ( ) <NEWLINE> l = [ ] <NEWLINE> tail = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> cmd = raw_input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . append ( cmd [ 1 ] ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . pop ( len ( l ) - l [ : : - 1 ] . index ( cmd [ 1 ] ) - 1 ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> tail += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( l [ tail : ] [ : : - 1 ] ) <NEWLINE>
A = [ ] <NEWLINE> fp = 0 <NEWLINE> bp = 0 <NEWLINE> cmd = raw_input ( ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> while n : <NEWLINE> <INDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . append ( int ( cmd [ 7 : ] ) ) <NEWLINE> fp += 1 <NEWLINE> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> i = A [ : : - 1 ] . index ( int ( cmd [ 7 : ] ) ) <NEWLINE> if i != - 1 : <NEWLINE> <INDENT> del A [ - i - 1 ] <NEWLINE> fp -= 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> fp -= 1 <NEWLINE> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> bp += 1 <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> <DEDENT> for e in A [ bp : fp + 1 ] [ : : - 1 ] : <NEWLINE> <INDENT> print int ( e ) , <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> class DoublyLinkedList : <NEWLINE> <INDENT> def __init__ ( self , value = - 1 ) : <NEWLINE> <INDENT> self . value = value <NEWLINE> self . prev = self <NEWLINE> self . next = self <NEWLINE> <NL> <DEDENT> def insert ( self , value ) : <NEWLINE> <INDENT> newNode = DoublyLinkedList ( value ) <NEWLINE> newNode . next = self . next <NEWLINE> newNode . prev = self <NEWLINE> self . next . prev = newNode <NEWLINE> self . next = newNode <NEWLINE> <NL> <DEDENT> def delete ( self , value ) : <NEWLINE> <INDENT> node = self . next <NEWLINE> while node . value != - 1 : <NEWLINE> <INDENT> if node . value == value : <NEWLINE> <INDENT> node . next . prev = node . prev <NEWLINE> node . prev . next = node . next <NEWLINE> break <NEWLINE> <DEDENT> node = node . next <NEWLINE> <NL> <DEDENT> <DEDENT> def deleteFirst ( self ) : <NEWLINE> <INDENT> if self . next . value != - 1 : <NEWLINE> <INDENT> self . next = self . next . next <NEWLINE> self . next . prev = self <NEWLINE> <NL> <DEDENT> <DEDENT> def deleteLast ( self ) : <NEWLINE> <INDENT> if self . prev . value != - 1 : <NEWLINE> <INDENT> self . prev = self . prev . prev <NEWLINE> self . prev . next = self <NEWLINE> <NL> <DEDENT> <DEDENT> def printAll ( self ) : <NEWLINE> <INDENT> node = self . next <NEWLINE> while node . next . value != - 1 : <NEWLINE> <INDENT> print node . value , <NEWLINE> node = node . next <NEWLINE> <DEDENT> print node . value <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dll = DoublyLinkedList ( ) <NEWLINE> N = input ( ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> for line in lines : <NEWLINE> <INDENT> line = line . split ( ) <NEWLINE> cmd = line [ 0 ] <NEWLINE> if cmd == <STRING> : <NEWLINE> <INDENT> dll . insert ( int ( line [ 1 ] ) ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dll . delete ( int ( line [ 1 ] ) ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> dll . deleteFirst ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dll . deleteLast ( ) <NEWLINE> <DEDENT> <DEDENT> dll . printAll ( ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> R = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> L = raw_input ( ) . split ( ) <NEWLINE> order = L [ 0 ] <NEWLINE> value = 0 <NEWLINE> if len ( L ) > 1 : <NEWLINE> <INDENT> value = int ( L [ 1 ] ) <NEWLINE> <DEDENT> if order == <STRING> : <NEWLINE> <INDENT> R . insert ( 0 , value ) <NEWLINE> <DEDENT> if order == <STRING> and value in R : <NEWLINE> <INDENT> R . remove ( value ) <NEWLINE> <DEDENT> if order == <STRING> : <NEWLINE> <INDENT> R . pop ( 0 ) <NEWLINE> <DEDENT> if order == <STRING> : <NEWLINE> <INDENT> R . pop ( ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , R ) ) <NEWLINE>
from collections import deque <NEWLINE> query = int ( input ( ) ) <NEWLINE> l = deque ( ) <NEWLINE> for _ in range ( query ) : <NEWLINE> <INDENT> command = input ( ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> l . popleft ( ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> l . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command , value = command . split ( <STRING> ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> deque . append ( value ) <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> deque . remove ( value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( * l ) <NEWLINE>
A = [ ] <NEWLINE> n = input ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = raw_input ( ) . split ( ) <NEWLINE> <NL> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . insert ( 0 , command [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> if A . count ( command [ 1 ] ) != 0 : <NEWLINE> <INDENT> A . remove ( command [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . pop ( 0 ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> print A [ i ] , <NEWLINE> <DEDENT>
from collections in deque <NEWLINE> <NL> N = int ( input ( ) ) <NEWLINE> <NL> A = deque ( ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> b = input ( ) <NEWLINE> if b == <STRING> : <NEWLINE> <INDENT> A . popleft ( ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> b , c = b . split ( ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if b == <STRING> : <NEWLINE> <INDENT> A . appendleft ( c ) <NEWLINE> <DEDENT> elif b == <STRING> : <NEWLINE> <INDENT> if ( c in A ) : <NEWLINE> <INDENT> A . remove ( c ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> . join ( map ( str , A ) ) ) <NEWLINE>
<NL> import sys <NEWLINE> <NL> A = [ ] <NEWLINE> fp = 0 <NEWLINE> bp = 0 <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> while n : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . append ( int ( s [ 7 : ] ) ) <NEWLINE> fp += 1 <NEWLINE> <DEDENT> elif s [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> i = A [ : : - 1 ] . index ( int ( s [ 7 : ] ) ) <NEWLINE> if i != - 1 : <NEWLINE> <INDENT> del A [ - i - 1 ] <NEWLINE> fp -= 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif s [ 6 ] == <STRING> : <NEWLINE> <INDENT> A . pop ( ) <NEWLINE> fp -= 1 <NEWLINE> <DEDENT> elif s [ 6 ] == <STRING> : <NEWLINE> <INDENT> bp += 1 <NEWLINE> <DEDENT> n -= 1 <NEWLINE> <NL> <DEDENT> for e in A [ bp : fp + 1 ] [ : : - 1 ] : <NEWLINE> <INDENT> print int ( e ) , <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> x = [ 0 for i in range ( n ) ] <NEWLINE> pf = 0 <NEWLINE> pb = 0 <NEWLINE> <NL> li = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = ( raw_input ( ) . split ( ) ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> pf += 1 <NEWLINE> x [ pf ] = int ( s [ 1 ] ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> p = x [ pf : : - 1 ] . index ( int ( s [ 1 ] ) ) <NEWLINE> x [ pf - p ] = 0 <NEWLINE> while x [ pf ] == 0 : <NEWLINE> <INDENT> pb -= 1 <NEWLINE> <DEDENT> while x [ pb ] == 0 : <NEWLINE> <INDENT> pb += 1 <NEWLINE> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> x [ pf ] = 0 <NEWLINE> pf -= 1 <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> x [ pb ] = 0 <NEWLINE> pb += 1 <NEWLINE> <DEDENT> <DEDENT> for e in x [ pb : pf + 1 ] [ : : - 1 ] : <NEWLINE> <INDENT> if e != 0 : <NEWLINE> <INDENT> print e , <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> class MyList ( list ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . __init__ = list <NEWLINE> <NL> self . d = { <STRING> : self . delF , <STRING> : self . delL , <STRING> : self . insX , <STRING> : self . delX } <NEWLINE> <DEDENT> def cmd ( self , command ) : <NEWLINE> <INDENT> if <STRING> in command : <NEWLINE> <INDENT> ope , num = command . split ( ) <NEWLINE> num = int ( num ) <NEWLINE> self . d [ ope ] ( num ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . d [ command ] ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def delF ( self ) : <NEWLINE> <INDENT> self . pop ( 0 ) <NEWLINE> <NL> <DEDENT> def delL ( self ) : <NEWLINE> <INDENT> self . pop ( - 1 ) <NEWLINE> <NL> <DEDENT> def insX ( self , num ) : <NEWLINE> <INDENT> self . insert ( 0 , num ) <NEWLINE> <NL> <DEDENT> def delX ( self , num ) : <NEWLINE> <INDENT> if num in self : <NEWLINE> <INDENT> self . remove ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> l = MyList ( ) <NEWLINE> n = input ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> l . cmd ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> q = deque ( l ) <NEWLINE> for i in range ( len ( l ) - 1 ) : <NEWLINE> <INDENT> print q . popleft ( ) , <NEWLINE> <DEDENT> print l [ - 1 ] <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> q = [ ] <NEWLINE> bottom = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = input ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . append ( cmd [ 7 : ] ) <NEWLINE> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . pop ( ~ q [ : : - 1 ] . index ( cmd [ 7 : ] ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif cmd [ 6 ] == <STRING> : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> bottom += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> . join ( q [ bottom : ] [ : : - 1 ] ) <NEWLINE>
n = input ( ) <NEWLINE> lis = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> com = raw_input ( ) <NEWLINE> try : <NEWLINE> <INDENT> com , x = com . split ( ) <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> lis . append ( x ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> l = len ( lis ) - 1 <NEWLINE> while ( lis [ l ] != x ) and l >= 0 : <NEWLINE> <INDENT> l -= 1 <NEWLINE> <DEDENT> if lis [ l ] == x : <NEWLINE> <INDENT> lis . pop ( l ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> except : <NEWLINE> <INDENT> if com == <STRING> : <NEWLINE> <INDENT> lis . pop ( ) <NEWLINE> <DEDENT> if com == <STRING> : <NEWLINE> <INDENT> lis . pop ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print <STRING> . join ( map ( str , reversed ( lis ) ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dll = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> input_line = input ( ) . split ( ) <NEWLINE> if input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . appendleft ( input_line [ 1 ] ) <NEWLINE> <DEDENT> elif input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dll . remove ( input_line [ 1 ] ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif input_line [ 0 ] == <STRING> : <NEWLINE> <INDENT> dll . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dll . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * dll <NEWLINE>
rom collections import deque <NEWLINE> import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) ) <NEWLINE> q = deque ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = sys . stdin . readline ( ) [ : - 1 ] <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> q . appendleft ( command [ 7 : ] ) <NEWLINE> <DEDENT> elif command [ 6 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> q . remove ( command [ 7 : ] ) <NEWLINE> <DEDENT> except Exception as e : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 6 ] == <STRING> : <NEWLINE> <INDENT> q . popleft ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> q . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( q ) ) <NEWLINE>
from collections import deque <NEWLINE> <NL> queue = deque ( ) <NEWLINE> <NL> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> commands = input ( ) . split ( <STRING> ) <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> queue . appendleft ( commands [ 1 ] ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> queue . remove ( commands [ 1 ] ) <NEWLINE> <DEDENT> except ValueError : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> queue . popleft ( ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> queue . pop ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( queue ) ) <NEWLINE>
x = [ ] <NEWLINE> y = [ ] <NEWLINE> a = i = 0 <NEWLINE> for c in input ( ) : <NEWLINE> <INDENT> if <STRING> == c : x += [ i ] <NEWLINE> elif <STRING> == c and x : <NEWLINE> <INDENT> j = x . pop ( ) <NEWLINE> t = i - j <NEWLINE> a += t <NEWLINE> while y and y [ - 1 ] [ 0 ] > j : t += y [ - 1 ] [ 1 ] ; y . pop ( ) <NEWLINE> y += [ ( j , t ) ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> if p : print ( len ( y ) , * list ( zip ( * y ) ) [ 1 ] ) <NEWLINE> else : print ( 0 ) <NEWLINE>
s = [ ] <NEWLINE> p = [ ] <NEWLINE> a = i = 0 <NEWLINE> for c in input ( ) : <NEWLINE> <INDENT> if <STRING> == c : s += [ i ] <NEWLINE> elif c == <STRING> and s : <NEWLINE> <INDENT> j = p . pop ( ) <NEWLINE> t = i - j <NEWLINE> a += t <NEWLINE> while p and p [ - 1 ] [ 0 ] > j : t += p [ - 1 ] [ 1 ] ; p . pop ( ) <NEWLINE> p += [ ( j , t ) ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> if p : print ( len ( p ) , * list ( zip ( * p ) ) [ 1 ] ) <NEWLINE> else : print ( 0 ) <NEWLINE>
s = raw_input ( ) <NEWLINE> <NL> St1 , St2 = [ ] , [ ] <NEWLINE> sumv = 0 <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> if s [ i ] == <STRING> : <NEWLINE> <INDENT> St1 . append ( i ) <NEWLINE> <DEDENT> elif s [ i ] == <STRING> and len ( St1 ) > 0 : <NEWLINE> <INDENT> j = St1 . pop ( ) <NEWLINE> a = i - j <NEWLINE> sumv += a <NEWLINE> while len ( St2 ) > 0 and St2 [ - 1 ] [ 0 ] > j : <NEWLINE> <INDENT> a += St2 . pop ( ) [ 1 ] <NEWLINE> <NL> <DEDENT> St2 . append ( [ j , a ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> St2 . insert ( 0 , len ( St2 ) ) <NEWLINE> <NL> print sumv <NEWLINE> print <STRING> . join ( map ( lambda x : str ( x [ 1 ] ) , St2 ) ) <NEWLINE>
S = raw_input ( ) <NEWLINE> S1 , S2 = [ ] , [ ] <NEWLINE> <NL> ans = pool = 0 <NEWLINE> for i in xrange ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == <STRING> and len ( S1 ) > 0 : <NEWLINE> <INDENT> j = S1 . pop ( ) <NEWLINE> ans += i - j <NEWLINE> a = i - j <NEWLINE> while ( len ( S2 ) > 0 and S2 [ - 1 ] [ 0 ] > j ) : <NEWLINE> <INDENT> a += S2 . pop ( ) [ 1 ] <NEWLINE> <DEDENT> S2 . append ( [ j , a ] ) <NEWLINE> <DEDENT> if S [ i ] == <STRING> : <NEWLINE> <INDENT> S1 . append ( i ) <NEWLINE> <DEDENT> <DEDENT> print ans <NEWLINE> print len ( S2 ) , <STRING> . join ( map ( str , [ a for j , a in S2 ] ) ) if len ( S2 ) > 0 else <STRING> <NEWLINE>
<COMMENT> <NL> data = input ( ) <NEWLINE> xmax = len ( data ) <NEWLINE> data_list = list ( data ) <NEWLINE> data_list . reverse ( ) <NEWLINE> reverse_data = [ ] <NEWLINE> for sig in data_list : <NEWLINE> <INDENT> if sig == <STRING> : <NEWLINE> <INDENT> reverse_data . append ( <STRING> ) <NEWLINE> <DEDENT> elif sig == <STRING> : <NEWLINE> <INDENT> reverse_data . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> reverse_data . append ( sig ) <NEWLINE> <NL> <DEDENT> <DEDENT> reverse_data = <STRING> . join ( reverse_data ) <NEWLINE> <NL> <NL> def partialSqu ( h , sig ) : <NEWLINE> <INDENT> if sig == <STRING> : <NEWLINE> <INDENT> squ = h + 1 / 2 <NEWLINE> h += 1 <NEWLINE> <DEDENT> elif sig == <STRING> : <NEWLINE> <INDENT> squ = h - 1 / 2 <NEWLINE> h -= 1 <NEWLINE> <DEDENT> elif sig == <STRING> : <NEWLINE> <INDENT> squ = h <NEWLINE> <DEDENT> return squ , h <NEWLINE> <NL> <NL> <DEDENT> x_squ_dict = { } <NEWLINE> cnt = 0 <NEWLINE> sw , x , h , totalSqu = 0 , 0 , 0 , 0 <NEWLINE> for sig in data : <NEWLINE> <INDENT> x += 1 <NEWLINE> if sw == 0 and sig == <STRING> : <NEWLINE> <INDENT> sw = 1 <NEWLINE> <DEDENT> if sw == 1 : <NEWLINE> <INDENT> squ , h = partialSqu ( h , sig ) <NEWLINE> totalSqu += squ <NEWLINE> <NL> if h == 0 : <NEWLINE> <INDENT> x_squ_dict [ x ] = totalSqu <NEWLINE> totalSqu = 0 <NEWLINE> sw = 0 <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> keys = x_squ_dict . keys ( ) <NEWLINE> sw , x , h , totalSqu = 0 , 0 , 0 , 0 <NEWLINE> for sig in reverse_data : <NEWLINE> <INDENT> x += 1 <NEWLINE> if sw == 0 and sig == <STRING> : <NEWLINE> <INDENT> sw = 1 <NEWLINE> x_p = xmax - x + 1 <NEWLINE> <DEDENT> if sw == 1 : <NEWLINE> <INDENT> squ , h = partialSqu ( h , sig ) <NEWLINE> totalSqu += squ <NEWLINE> if h == 0 : <NEWLINE> <INDENT> x_squ_dict [ x_p ] = totalSqu <NEWLINE> totalSqu = 0 <NEWLINE> sw = 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> ) <NEWLINE> keys = x_squ_dict . keys ( ) <NEWLINE> keys = list ( keys ) <NEWLINE> keys . sort ( ) <NEWLINE> squ_list = [ ] <NEWLINE> for key in keys : <NEWLINE> <INDENT> squ_list . append ( x_squ_dict [ key ] ) <NEWLINE> <NL> <DEDENT> a = int ( sum ( squ_list ) ) <NEWLINE> print ( a ) <NEWLINE> squ_list . insert ( 0 , len ( keys ) ) <NEWLINE> <NL> squ_list = <STRING> . join ( [ str ( int ( num ) ) for num in squ_list ] ) <NEWLINE> print ( squ_list ) <NEWLINE> <NL>
section = raw_input ( ) <NEWLINE> depth = 0 <NEWLINE> area = 0 <NEWLINE> depthArr = deque ( ) <NEWLINE> areaArr = deque ( ) <NEWLINE> <NL> for i , ground in enumerate ( section ) : <NEWLINE> <INDENT> if <STRING> == ground : <NEWLINE> <INDENT> depth += 1 <NEWLINE> depthArr . append ( i ) <NEWLINE> <DEDENT> elif 0 < depth and <STRING> == ground : <NEWLINE> <INDENT> if len ( depthArr ) : <NEWLINE> <INDENT> j = depthArr . pop ( ) <NEWLINE> pool = i - j <NEWLINE> area += pool <NEWLINE> <NL> while len ( areaArr ) : <NEWLINE> <INDENT> preJ , prePool = areaArr . pop ( ) <NEWLINE> if j <= preJ : <NEWLINE> <INDENT> pool += prePool <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> areaArr . append ( ( preJ , prePool ) ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> areaArr . append ( ( j , pool ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( area ) <NEWLINE> output = [ ] <NEWLINE> output . append ( len ( areaArr ) ) <NEWLINE> for arr in areaArr : <NEWLINE> <INDENT> output . append ( arr [ 1 ] ) <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , output ) ) ) <NEWLINE>
<COMMENT> <NL> section = raw_input ( ) <NEWLINE> <NL> <COMMENT> <NL> height = 0 <NEWLINE> heights = [ 0 ] <NEWLINE> for p in xrange ( len ( section ) ) : <NEWLINE> <INDENT> if section [ p ] == <STRING> : <NEWLINE> <INDENT> height += 1 <NEWLINE> <DEDENT> elif section [ p ] == <STRING> : <NEWLINE> <INDENT> height -= 1 <NEWLINE> <DEDENT> heights . append ( height ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> pools = [ ] <NEWLINE> water = [ ] <NEWLINE> p = 0 <NEWLINE> while p < len ( section ) : <NEWLINE> <INDENT> if section [ p ] == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> pr = heights [ p + 1 : ] . index ( heights [ p ] ) <NEWLINE> pools . append ( [ p , p + 1 + pr ] ) <NEWLINE> p = p + 1 + pr <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> p += 1 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> for pool in pools : <NEWLINE> <INDENT> tp = section [ pool [ 0 ] : pool [ 1 ] ] <NEWLINE> depth = 0 <NEWLINE> s = 0 <NEWLINE> for p in xrange ( len ( tp ) ) : <NEWLINE> <INDENT> if tp [ p ] == <STRING> : <NEWLINE> <INDENT> depth -= 1 <NEWLINE> <DEDENT> elif tp [ p ] == <STRING> : <NEWLINE> <INDENT> depth += 1 <NEWLINE> s += 2 * ( depth - 1 ) + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s += depth <NEWLINE> <DEDENT> <DEDENT> water . append ( s ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> print sum ( water ) <NEWLINE> print len ( water ) , <STRING> . join ( map ( str , water ) ) <NEWLINE>
l = { } <NEWLINE> s = [ ] <NEWLINE> h = [ 0 ] <NEWLINE> n = d = m = 0 <NEWLINE> for c in raw_input ( ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> l [ d ] = n <NEWLINE> d -= 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> if d in l : <NEWLINE> <INDENT> while len ( s ) and s [ - 1 ] [ 1 ] > l [ d ] : s . pop ( ) <NEWLINE> s . append ( [ l [ d ] , n ] ) <NEWLINE> <DEDENT> <DEDENT> n += 1 <NEWLINE> h . append ( d ) <NEWLINE> <NL> <DEDENT> a = [ sum ( [ h [ i ] - k for k in h [ i : j + 1 ] ] ) for i , j in s ] <NEWLINE> print sum ( a ) <NEWLINE> print len ( a ) , <STRING> . join ( map ( str , a ) ) <NEWLINE>
A = [ ] <NEWLINE> B = [ ] <NEWLINE> a = 0 <NEWLINE> x = 0 <NEWLINE> for c in input ( ) : <NEWLINE> <INDENT> if <STRING> == c : A += [ x ] <NEWLINE> elif <STRING> == c and A : <NEWLINE> <INDENT> j = A . pop ( ) <NEWLINE> t = x - j <NEWLINE> a += t <NEWLINE> while B and B [ - 1 ] [ 0 ] > j : t += B [ - 1 ] [ 1 ] ; B . pop ( ) <NEWLINE> B += [ ( j , t ) ] <NEWLINE> <DEDENT> x += 1 <NEWLINE> <DEDENT> print ( a ) <NEWLINE> if p : print ( len ( B ) , * list ( zip ( * B ) ) [ 1 ] ) <NEWLINE> else : print ( 0 ) <NEWLINE>
import sys <NEWLINE> <NL> class Area : <NEWLINE> <INDENT> def __init__ ( self , start , end , area ) : <NEWLINE> <INDENT> self . start = start <NEWLINE> self . end = end <NEWLINE> self . area = area <NEWLINE> <DEDENT> def addArea ( self , area ) : <NEWLINE> <INDENT> self . area += area <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) . strip ( ) <NEWLINE> <NL> area_stack = [ ] <NEWLINE> field_stack = [ ] <NEWLINE> <NL> for i in range ( 0 , len ( line ) ) : <NEWLINE> <INDENT> c = line [ i ] <NEWLINE> if ( c == <STRING> ) : <NEWLINE> <INDENT> field_stack . append ( ( c , i ) ) <NEWLINE> <DEDENT> elif ( c == <STRING> ) : <NEWLINE> <INDENT> if len ( field_stack ) == 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cc = field_stack . pop ( ) <NEWLINE> current_area = Area ( cc [ 1 ] , i , ( i - cc [ 1 ] ) ) <NEWLINE> if len ( area_stack ) == 0 : <NEWLINE> <INDENT> area_stack . append ( current_area ) <NEWLINE> continue <NEWLINE> <DEDENT> prev_area = area_stack . pop ( ) <NEWLINE> flag = True <NEWLINE> while ( prev_area . start > current_area . start ) and ( prev_area . end < current_area . end ) : <NEWLINE> <INDENT> current_area . addArea ( prev_area . area ) <NEWLINE> if len ( area_stack ) == 0 : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> prev_area = area_stack . pop ( ) <NEWLINE> <DEDENT> if flag : <NEWLINE> <INDENT> area_stack . append ( prev_area ) <NEWLINE> <DEDENT> area_stack . append ( current_area ) <NEWLINE> <DEDENT> <DEDENT> print str ( reduce ( lambda x , y : x + y , map ( lambda x : x . area , area_stack ) ) ) <NEWLINE> s = <STRING> <NEWLINE> s += str ( len ( area_stack ) ) + <STRING> <NEWLINE> for item in area_stack : <NEWLINE> <INDENT> s += str ( item . area ) + <STRING> <NEWLINE> <DEDENT> s = s . strip ( ) <NEWLINE> print s <NEWLINE> <DEDENT>
def calc ( list ) : <NEWLINE> <COMMENT> <NL> <INDENT> d = 0 <NEWLINE> a = 0.0 <NEWLINE> for c in list : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> a += d - 1 + 0.5 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> a += d <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a += d - 1 + 0.5 <NEWLINE> d -= 1 <NEWLINE> <DEDENT> <DEDENT> return a <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> areas = [ ] <NEWLINE> mode = False <NEWLINE> d = 0 <NEWLINE> edge = 0 <NEWLINE> for i in range ( len ( line ) ) : <NEWLINE> <COMMENT> <NL> <INDENT> c = line [ i ] <NEWLINE> if mode : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> d -= 1 <NEWLINE> if d == 0 : <NEWLINE> <INDENT> areas . append ( calc ( line [ edge : i + 1 ] ) ) <NEWLINE> mode = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> edge = i <NEWLINE> mode = True <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> edge = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> last = len ( areas ) <NEWLINE> high = edge <NEWLINE> if d != 0 : <NEWLINE> <INDENT> d = 0 <NEWLINE> edge = len ( line ) - 1 <NEWLINE> mode = False <NEWLINE> for i in range ( len ( line ) - 1 , high - 1 , - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> c = line [ i ] <NEWLINE> if mode : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> d -= 1 <NEWLINE> if d == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> areas . insert ( last , calc ( line [ i : edge + 1 ] ) ) <NEWLINE> mode = False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> d += 1 <NEWLINE> edge = i <NEWLINE> mode = True <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> edge = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> edge = i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> areas = map ( int , areas ) <NEWLINE> print sum ( areas ) <NEWLINE> print len ( areas ) , <NEWLINE> for i in range ( len ( areas ) - 1 ) : <NEWLINE> <INDENT> print areas [ i ] , <NEWLINE> <DEDENT> print areas [ len ( areas ) - 1 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def calc_area ( startIndex , endIndex , terrain ) : <NEWLINE> <INDENT> level = terrain [ startIndex ] <NEWLINE> area = 0 <NEWLINE> for i in xrange ( startIndex , endIndex ) : <NEWLINE> <INDENT> area += ( level - terrain [ i ] ) + 0.5 * ( terrain [ i ] - terrain [ i + 1 ] ) <NEWLINE> <DEDENT> return int ( area ) <NEWLINE> <NL> <NL> <DEDENT> def check_area ( terrain ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> startIndex = 0 <NEWLINE> endIndex = 0 <NEWLINE> while i < len ( terrain ) - 1 : <NEWLINE> <INDENT> if terrain [ i + 1 ] - terrain [ i ] < 0 : <NEWLINE> <INDENT> startIndex = i <NEWLINE> break <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> for j in xrange ( i + 1 , len ( terrain ) ) : <NEWLINE> <INDENT> if terrain [ i ] == terrain [ j ] : <NEWLINE> <INDENT> endIndex = j <NEWLINE> return startIndex , endIndex <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return 0 , 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> string = list ( raw_input ( ) ) <NEWLINE> terrain = [ ] <NEWLINE> height = 0 <NEWLINE> for c in string : <NEWLINE> <INDENT> terrain . append ( height ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> height -= 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> height += 1 <NEWLINE> <DEDENT> <DEDENT> terrain . append ( height ) <NEWLINE> <NL> waterAreaRight = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> i , j = check_area ( terrain ) <NEWLINE> if i == j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> waterAreaRight . append ( calc_area ( i , j , terrain ) ) <NEWLINE> terrain = terrain [ j : ] <NEWLINE> <NL> <DEDENT> terrain = terrain [ : : - 1 ] <NEWLINE> waterAreaLeft = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> i , j = check_area ( terrain ) <NEWLINE> if i == j : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> waterAreaLeft . append ( calc_area ( i , j , terrain ) ) <NEWLINE> terrain = terrain [ j : ] <NEWLINE> <DEDENT> waterAreaRight . extend ( waterAreaLeft [ : : - 1 ] ) <NEWLINE> <NL> print sum ( waterAreaRight ) <NEWLINE> print len ( waterAreaRight ) , <NEWLINE> print <STRING> . join ( map ( str , waterAreaRight ) ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
A = input ( ) <NEWLINE> st = [ ( 0 , 0 , - 1 ) ] <NEWLINE> cur = 0 ; ma = 0 <NEWLINE> for i , a in enumerate ( A ) : <NEWLINE> <INDENT> if a == <STRING> : <NEWLINE> <INDENT> cur += 1 <NEWLINE> s = 0 <NEWLINE> while st and st [ - 1 ] [ 0 ] == cur - 1 and cur <= ma : <NEWLINE> <INDENT> lev , su , j = st . pop ( ) <NEWLINE> s += su <NEWLINE> <DEDENT> if st and st [ - 1 ] [ 0 ] == cur : <NEWLINE> <INDENT> s += i - st [ - 1 ] [ 2 ] - 1 <NEWLINE> <DEDENT> ma = max ( ma , cur ) <NEWLINE> st . append ( ( cur , s , i ) ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> cur -= 1 <NEWLINE> st . append ( ( cur , 0 , i ) ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> st . append ( ( cur , 0 , i ) ) <NEWLINE> <DEDENT> <DEDENT> ans = [ ] <NEWLINE> for lev , su , j in st : <NEWLINE> <INDENT> if su > 0 : <NEWLINE> <INDENT> and . append ( su ) <NEWLINE> <DEDENT> <DEDENT> print ( sum ( ans ) ) <NEWLINE> print ( len ( ans ) , * ans ) <NEWLINE>
import collections <NEWLINE> import sys <NEWLINE> <NL> S1 = collections . deque ( ) <NEWLINE> S2 = collections . deque ( ) <NEWLINE> <NL> f = open ( <STRING> , <STRING> ) <NEWLINE> <NL> for i , j in enumerate ( f . readline ( ) ) : <NEWLINE> <INDENT> if j == <STRING> : <NEWLINE> <INDENT> S1 . append ( i ) <NEWLINE> <DEDENT> elif j == <STRING> : <NEWLINE> <INDENT> if S1 : <NEWLINE> <INDENT> left_edge = S1 . pop ( ) <NEWLINE> new_puddle = i - left_edge <NEWLINE> while S2 and ( S2 [ - 1 ] [ 0 ] > left_edge ) : <NEWLINE> <INDENT> new_puddle += S2 [ - 1 ] [ 1 ] <NEWLINE> S2 . pop ( ) <NEWLINE> <DEDENT> S2 . append ( ( left_edge , new_puddle ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( sum ( j for i , j in S2 ) ) <NEWLINE> <NL> print ( len ( S2 ) , * ( j for i , j in S2 ) ) <NEWLINE>
import sys <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> S = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> T = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> res = [ ] <NEWLINE> <NL> for t in T : <NEWLINE> <INDENT> rse . append ( S . count ( t ) ) <NEWLINE> <DEDENT> print sum ( res ) <NEWLINE>
n = input ( ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> Search = T [ i ] <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if S [ j ] == Search : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
class Sequence : <NEWLINE> <INDENT> def __init__ ( self , num , seq ) : <NEWLINE> <INDENT> self . n = num <NEWLINE> self . sequence = seq <NEWLINE> <NL> <DEDENT> <DEDENT> def LinearSearch ( A , n , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> A [ n ] = key <NEWLINE> while A [ i ] != key : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> if i == n : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return i <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> with open ( <STRING> ) as fp : <NEWLINE> <INDENT> data = fp . readlines ( ) <NEWLINE> <NL> <DEDENT> x = data [ 1 ] . split ( ) <NEWLINE> x . append ( <STRING> ) <NEWLINE> A = Sequence ( int ( data [ 0 ] ) , x ) <NEWLINE> x = data [ 3 ] . split ( ) <NEWLINE> x . append ( <STRING> ) <NEWLINE> B = Sequence ( int ( data [ 2 ] ) , x ) <NEWLINE> <NL> C = [ ] <NEWLINE> <NL> for i in range ( B . n ) : <NEWLINE> <INDENT> res = LinearSearch ( A . sequence , A . n , B . sequence [ i ] ) <NEWLINE> if res != <STRING> : <NEWLINE> <INDENT> C . append ( A . sequence [ res ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( C ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) , split ( ) ) <NEWLINE> <NL> q = int ( raw_input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> ans = 0 <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> if i in S : <NEWLINE> <INDENT> ans += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ans <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def search ( S , k ) : <NEWLINE> <INDENT> for s in S : <NEWLINE> <INDENT> if s == k : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> c = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if search ( S , t ) : c += 1 <NEWLINE> <NL> <DEDENT> print c <NEWLINE>
<NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) . split ( <STRING> ) . strip ( <STRING> ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . split ( <STRING> ) . strip ( <STRING> ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for n in S : <NEWLINE> <INDENT> for j in T : <NEWLINE> <INDENT> if n == j : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
def linearSearch ( key , list , N ) : <NEWLINE> <INDENT> list [ N ] = key <NEWLINE> i = 0 <NEWLINE> while l [ i ] != key : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> return int ( i != N ) <NEWLINE> <NL> <NL> <DEDENT> N1 = int ( input ( ) ) <NEWLINE> arr1 = [ int ( n ) for n in input ( ) . split ( ) ] + [ 0 ] <NEWLINE> N2 = int ( input ( ) ) <NEWLINE> arr2 = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> print ( sum ( [ linearSearch ( key , arr1 , N1 ) for key in arr2 ] ) ) <NEWLINE> <NL>
<NL> n = int ( input ( ) ) <NEWLINE> lista = [ 0 for i in range ( n ) ] <NEWLINE> lista = input ( ) . split ( ) <NEWLINE> n2 = int ( input ( ) ) <NEWLINE> listb = [ 0 for i in range ( n2 ) ] <NEWLINE> listb = input ( ) . split ( ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( n2 ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> if listb [ i ] == lista [ j ] and if x == 0 : <NEWLINE> <INDENT> x = 1 <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( len ( S & T ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = input ( ) . split ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if s [ i ] == t [ j ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def linearSearch ( A , n , key ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> A . append ( key ) <NEWLINE> while A [ i ] != key : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> del A [ n ] <NEWLINE> return i != n <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in q : <NEWLINE> <INDENT> if linearSearch ( S , n , T [ i ] ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> q = input ( ) <NEWLINE> T = input ( ) . split ( ) <NEWLINE> c = 0 <NEWLINE> for ( t in T ) : <NEWLINE> <INDENT> if ( t in S ) : c += 1 <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
import sys <NEWLINE> <NL> ERROR_INPUT = <STRING> <NEWLINE> ERROR_INPUT_NOT_UNIQUE = <STRING> <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> S = get_input1 ( ) <NEWLINE> T = get_input2 ( ) <NEWLINE> <NL> count = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> for s in S : <NEWLINE> <INDENT> if t == s : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> def get_input1 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n > 10000 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> li = [ ] <NEWLINE> for x in input ( ) . split : <NEWLINE> <INDENT> if int ( x ) < 0 or int ( x ) > 10 ** 9 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> li . append ( x ) <NEWLINE> <NL> <DEDENT> return li <NEWLINE> <NL> <NL> <DEDENT> def get_input2 ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n > 500 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <NL> <DEDENT> li = [ ] <NEWLINE> for x in input ( ) . split : <NEWLINE> <INDENT> if int ( x ) < 0 or int ( x ) > 10 ** 9 : <NEWLINE> <INDENT> print ( ERROR_INPUT ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> elif int ( x ) in li : <NEWLINE> <INDENT> print ( ERROR_INPUT_NOT_UNIQUE ) <NEWLINE> sys . exit ( 1 ) <NEWLINE> <DEDENT> li . append ( x ) <NEWLINE> <NL> <DEDENT> return li <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( input ( ) ) <NEWLINE> ns = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> qs = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> <NL> def main ( ns , qs ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for q in qs : <NEWLINE> <INDENT> if q in ns : <NEWLINE> <INDENT> total += 1 <NEWLINE> <DEDENT> <DEDENT> return total <NEWLINE> <NL> <NL> <DEDENT> print ( main ( ns , qs ) ) <NEWLINE>
<COMMENT> <NL> def LS ( n , S , q , T ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if n > q : <NEWLINE> <INDENT> for i in q : <NEWLINE> <INDENT> if T [ i ] in S : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in n : <NEWLINE> <INDENT> if S [ i ] in T : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( <STRING> ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = input ( ) . split ( <STRING> ) <NEWLINE> LS ( n , S , q , T ) <NEWLINE> <DEDENT>
input ( ) <NEWLINE> s = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> t = set ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if t [ i ] in s : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> S = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> <NL> q = input ( ) <NEWLINE> <NL> T = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> <NL> C = 0 <NEWLINE> <NL> for i in S : <NEWLINE> <INDENT> for j in T : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> C += 1 <NEWLINE> break : <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print C <NEWLINE>
c = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) . split ( ) ) <NEWLINE> nqint ( input ( ) ) <NEWLINE> t = int ( input ( ) . split ( ) ) <NEWLINE> for i in t : <NEWLINE> <INDENT> for j in s : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> c += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( c ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) ) ) <NEWLINE> <NL> match_count = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> for j in S : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> match_count += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( str ( match_count ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if s in S : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( len ( S & T ) ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> q = input ( ) <NEWLINE> <NL> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> S . append ( 0 ) <NEWLINE> cnt = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> j = 0 <NEWLINE> S [ n ] = T [ i ] <NEWLINE> while S [ j ] != S [ n ] : <NEWLINE> <INDENT> j = j + 1 <NEWLINE> <DEDENT> if j != n : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print cnt <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> r = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cou = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if ( s [ i ] == r [ j ] ) : <NEWLINE> <INDENT> cou += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cou ) <NEWLINE>
n = input ( ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> q = input ( ) <NEWLINE> T = input ( ) . split ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( T ) : <NEWLINE> <INDENT> if T [ i ] in S : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> import sys <NEWLINE> <NL> <NL> class Solution : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . __input = sys . stdin . readlines ( ) <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def solution ( self ) : <NEWLINE> <INDENT> length_1 = int ( self . __input [ 0 ] ) <NEWLINE> array_1 = list ( map ( int , self . __input [ 1 ] . split ( ) ) ) <NEWLINE> length_2 = int ( self . __input [ 2 ] ) <NEWLINE> array_2 = list ( map ( int , self . __input [ 3 ] . split ( ) ) ) <NEWLINE> <NL> assert length_1 == len ( array_1 ) and length_2 == len ( array_2 ) <NEWLINE> <NL> count = 0 <NEWLINE> for each in array_2 : <NEWLINE> <INDENT> if self . linear_search ( key = each , array = array_1 , array_length = length_1 ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return str ( count ) <NEWLINE> <NL> <DEDENT> @ staticmethod <NEWLINE> def linear_search ( key , array , array_length ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in array_length : <NEWLINE> <INDENT> if array [ i ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> case = Solution ( ) <NEWLINE> print ( case . solution ) <NEWLINE> <DEDENT>
def linearSearch ( key , list ) : <NEWLINE> <INDENT> for e in list : <NEWLINE> <INDENT> if key == e : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> N1 = int ( input ( ) ) <NEWLINE> arr1 = [ int ( n ) or n in input ( ) . split ( ) ] <NEWLINE> N2 = int ( input ( ) ) <NEWLINE> arr2 = [ int ( n ) or n in input ( ) . split ( ) ] <NEWLINE> <NL> print ( sum ( [ linearSearch ( key , arr2 ) for key in arr ] ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = map ( int , input ( ) . split ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def binary_search ( A , key ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> if binary_search ( S , i ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
import sys <NEWLINE> <NL> def binary_search ( array , num , left , right ) : <NEWLINE> <INDENT> if right < left : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> center = ( right + left ) / 2 <NEWLINE> if array [ center ] == num : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif array [ center ] < num : <NEWLINE> <INDENT> return binary_search ( array , num , center + 1 , right ) <NEWLINE> <DEDENT> elif array [ center ] > num : <NEWLINE> <INDENT> return binary_search ( array , num , left , center ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> S = map ( lambda x : int ( x ) , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> n = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> T = map ( lambda x : int ( x ) , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> res = 0 <NEWLINE> <NL> for t in T : <NEWLINE> <INDENT> if binary_search ( S , t , 0 , len ( S ) ) : <NEWLINE> <INDENT> res += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print res <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n = int ( raw_input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> C = 0 <NEWLINE> <NL> def binary_search ( A , n ) : <NEWLINE> <INDENT> l = len ( A ) <NEWLINE> if l == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif A [ l / 2 ] > n : <NEWLINE> <INDENT> return binary_search ( A [ : l / 2 ] , n ) <NEWLINE> <DEDENT> elif A [ l / 2 ] == n : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif A [ l / 2 ] < n : <NEWLINE> <INDENT> return binary_search ( A [ ( l / 2 ) + 1 : ] , n ) <NEWLINE> <NL> <DEDENT> <DEDENT> for item in T : <NEWLINE> <INDENT> if binary_search ( S , item ) : <NEWLINE> <INDENT> C += 1 <NEWLINE> <DEDENT> <DEDENT> print C <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int . input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> point = 0 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> for i in T : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if S [ mid ] == i : <NEWLINE> <INDENT> point += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif i < S [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( point ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> if n > 1 : <NEWLINE> <INDENT> s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = int ( raw_input ( ) ) <NEWLINE> <NL> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> if q > 1 : <NEWLINE> <INDENT> t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = [ int ( raw_input ( ) ) ] <NEWLINE> <NL> <DEDENT> count = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> tmp = int ( n / 2 ) <NEWLINE> gap = 1. / 2 <NEWLINE> flag = 0 <NEWLINE> if t [ i ] < s [ 0 ] or t [ i ] > s [ n - 1 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if s [ tmp ] < t [ i ] : <NEWLINE> <INDENT> tmp = tmp + int ( n * gap ) <NEWLINE> <DEDENT> elif s [ tmp ] > t [ i ] : <NEWLINE> <INDENT> tmp = tmp - int ( n * gap ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> if int ( gap * n ) == 1 and flag == 0 : <NEWLINE> <INDENT> flag = 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif int ( gap * n ) < 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> gap *= 1. / 2 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
<COMMENT> <NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> for j in range ( n ) : <NEWLINE> <INDENT> if T [ i ] == S [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
n = input ( ) <NEWLINE> S = ( input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> T = ( input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( T ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n - 1 <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if S [ mid ] == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif S [ mid ] < i : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid - 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
def binarySearch ( A , key ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( A ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> S = [ int ( _ ) for _ in raw_input ( ) . split ( ) ] <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> T = [ int ( _ ) for _ in raw_input ( ) . split ( ) ] <NEWLINE> Sum = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if binarySearch ( S [ : ] , t ) : Sum += 1 <NEWLINE> <DEDENT> print Sum <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
input ( ) <NEWLINE> slist = raw_input ( ) . split ( ) <NEWLINE> input ( ) <NEWLINE> tlist = raw_input ( ) . split ( ) <NEWLINE> <NL> def func ( v , low , high ) : <NEWLINE> <NL> <INDENT> mid = ( low + high ) / 2 <NEWLINE> <NL> if mid >= len ( slist ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> if v > slist [ mid ] : <NEWLINE> <INDENT> if low == high : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return func ( v , mid + 1 , high ) <NEWLINE> <DEDENT> elif v == slist [ mid ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if low == high : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return func ( v , low , mid - 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> count = 0 <NEWLINE> for t in tlist : <NEWLINE> <INDENT> count += func ( t , 0 , len ( slist ) - 1 ) <NEWLINE> <NL> <DEDENT> print count <NEWLINE>
sn = int ( input ( ) ) <NEWLINE> S = [ 0 for i in range ( sn ) ] <NEWLINE> S = input ( ) . split ( ) <NEWLINE> for i in range ( sn ) : <NEWLINE> <INDENT> S [ i ] = int ( S [ i ] ) <NEWLINE> <NL> <DEDENT> tn = int ( input ( ) ) <NEWLINE> T = [ 0 for i in range ( tn ) ] <NEWLINE> T = input ( ) . split ( ) <NEWLINE> for i in range ( tn ) : <NEWLINE> <INDENT> T [ i ] = int ( T [ i ] ) <NEWLINE> <NL> <DEDENT> A = [ ] <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( tn ) : <NEWLINE> <NL> <INDENT> key = T [ i ] <NEWLINE> left = 0 <NEWLINE> right = sn <NEWLINE> <NL> while left < right : <NEWLINE> <NL> <INDENT> mid = ( int ) ( ( left + right ) / 2 ) <NEWLINE> <NL> if S [ mid ] == key : <NEWLINE> <INDENT> if T [ i ] not in A : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <INDENT> A . append ( key ) <NEWLINE> <DEDENT> <DEDENT> break <NEWLINE> <NL> <DEDENT> if S [ mid ] > key : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> if S [ mid ] < key : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> S = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> <NL> q = input ( ) <NEWLINE> <NL> T = [ int ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> <NL> C = 0 <NEWLINE> <NL> left = 0 <NEWLINE> right = n <NEWLINE> <NL> for key in T : <NEWLINE> <INDENT> while left < right : <NEWLINE> <INDENT> mid = ( right - left ) / 2 <NEWLINE> if key == S [ mid ] : <NEWLINE> <INDENT> C += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif key < S [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> elif key > S [ mid ] : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print C <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> lst = [ ] <NEWLINE> for v in S : <NEWLINE> <INDENT> if v in lst : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( q ) : <NEWLINE> <INDENT> if T [ i ] == v : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> lst . append ( v ) <NEWLINE> <DEDENT> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( t ) for t in input ( ) . split ( ) ] <NEWLINE> <NL> def binary_search ( A , key ) : <NEWLINE> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 return False <NEWLINE> <DEDENT> <DEDENT> t = 0 <NEWLINE> for i in T : <NEWLINE> <INDENT> if binary_search ( S , i ) : <NEWLINE> <INDENT> t += 1 <NEWLINE> <DEDENT> <DEDENT> print ( t ) <NEWLINE>
def gost ( lis , ky , r , l ) : <NEWLINE> <NL> <INDENT> lens = l - r + 1 <NEWLINE> <NL> if lens <= 5 : <NEWLINE> <INDENT> if ky in lis [ r : l ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> if ky <= lis [ ( lens // 2 ) - 1 ] : <NEWLINE> <INDENT> return gost ( lis , ky , r , r + ( lens // 2 ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return gost ( lis , ky , l - ( lens // 2 ) , l ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> s = list ( map ( int , a . split ( ) ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> a = input ( ) <NEWLINE> t = list ( map ( int , a . split ( ) ) ) <NEWLINE> <NL> <NL> i = 0 <NEWLINE> for it in t : <NEWLINE> <INDENT> if gost ( s , it , 0 , int ( a ) - 1 ) : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> <DEDENT> print ( i ) <NEWLINE>
def binary_search ( ) : <NEWLINE> <INDENT> input ( ) <NEWLINE> s = set ( input ( ) . split ( ) ) <NEWLINE> input ( ) <NEWLINE> t = set ( input ( ) . split ( ) ) <NEWLINE> print ( len ( s & t ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> linear_search ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum = 0 <NEWLINE> for c in T : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> mid = 0 <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if c == S [ mid ] : <NEWLINE> <INDENT> sum += 1 <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( sum ) <NEWLINE>
def main ( ) : <NEWLINE> <INDENT> n1 = int ( input ( ) ) <NEWLINE> if n1 > 100000 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> li1 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if len ( l1 ) > 10 ** 9 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> n2 = int ( input ( ) ) <NEWLINE> if n1 > 50000 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> li2 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if len ( l2 ) > 10 ** 9 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> count = 0 <NEWLINE> <NL> for l in li2 : <NEWLINE> <INDENT> if binary_search ( li1 , l ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> def binary_search ( li , x ) : <NEWLINE> <INDENT> if len ( li ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> mid = len ( li ) // 2 <NEWLINE> <NL> k = li [ mid ] <NEWLINE> if k == x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif k > x : <NEWLINE> <INDENT> li = li [ : mid ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> li = li [ mid + 1 : ] <NEWLINE> <NL> <DEDENT> return binary_search ( li , x ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def binarySearch ( x , S ) : <NEWLINE> <INDENT> mid = len ( S ) / 2 <NEWLINE> if mid < 2 : <NEWLINE> <INDENT> return x in S <NEWLINE> <DEDENT> if S [ mid ] == x : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif S [ mid ] > x : <NEWLINE> <INDENT> return binarySearch ( x , S [ : mid ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return binarySearch ( x , S [ mid + 1 : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for x in T : <NEWLINE> <INDENT> if binarySearch ( x , S ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = input ( ) . split ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> S [ i ] = int ( S [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( T ) ) : <NEWLINE> <INDENT> T [ i ] = int ( T [ i ] ) <NEWLINE> <DEDENT> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> x = 0 <NEWLINE> left = 0 <NEWLINE> right = n <NEWLINE> while left < right and x == 0 : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if S [ i ] == T [ mid ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> x += 1 <NEWLINE> <DEDENT> elif S [ i ] < T [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> isExist = False <NEWLINE> low = 0 <NEWLINE> high = n - 1 <NEWLINE> middle = 0 <NEWLINE> <NL> for j in range ( q ) : <NEWLINE> <INDENT> search = T [ j ] <NEWLINE> while True : <NEWLINE> <INDENT> middle = ( high + low ) / 2 <NEWLINE> print middle <NEWLINE> if S [ middle ] == search : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> break <NEWLINE> <DEDENT> elif middle == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif search < S [ middle ] : <NEWLINE> <INDENT> high = middle - 1 <NEWLINE> <DEDENT> elif S [ middle ] < search : <NEWLINE> <INDENT> low = middle + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( S ) - 1 <NEWLINE> center = int ( ( left + right ) / 2 ) <NEWLINE> <NL> while center >= left and center <= right : <NEWLINE> <INDENT> if S [ center ] == i : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif S [ center ] > i : <NEWLINE> <INDENT> right = center - 1 <NEWLINE> center = int ( ( left + right ) / 2 ) <NEWLINE> <DEDENT> elif S [ center ] < i : <NEWLINE> <INDENT> left = center - 1 <NEWLINE> center = int ( ( left + right ) / 2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> S = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> q = int ( input ( ) ) <NEWLINE> <NL> T = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def binary_search ( target , key ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( S ) <NEWLINE> <NL> while ( left < right ) : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if S [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif S [ mid ] < key : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> cnt = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if binary_search ( S , t ) : cnt += 1 <NEWLINE> <NL> <DEDENT> print ( cnt ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = set ( int , input ( ) . split ( ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = set ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( len ( S & T ) ) <NEWLINE>
n = input ( ) <NEWLINE> <NL> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> q = input ( ) <NEWLINE> <NL> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if S [ mid ] == T [ j ] : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> <DEDENT> else if T [ j ] < S [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print cnt <NEWLINE>
<COMMENT> <NL> <NL> input ( ) <NEWLINE> s = set ( input ( ) . split ( ) ) <NEWLINE> input ( ) <NEWLINE> t = set ( input ( ) . split ( ) ) <NEWLINE> print ( int ( s & t ) ) <NEWLINE>
count_n = int ( input ( ) ) <NEWLINE> N = [ ] <NEWLINE> n = input ( ) <NEWLINE> N = n . split ( ) <NEWLINE> N = list ( map ( lambda x : int ( x ) , N ) ) . sort ( ) <NEWLINE> <NL> <NL> count_p = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> p = input ( ) <NEWLINE> P = p . split ( ) <NEWLINE> P = list ( map ( lambda x : int ( x ) , P ) ) . sort ( ) <NEWLINE> <NL> <NL> def b ( i , l ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( l ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if l [ mid ] > i : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> elif l [ mid ] < i : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> elif l [ mid ] == i : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <DEDENT> answer = 0 <NEWLINE> for n in N : <NEWLINE> <INDENT> if b ( n , P ) : <NEWLINE> <INDENT> answer += 1 <NEWLINE> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = [ int ( val ) for val in input ( ) . split ( <STRING> ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = [ int ( val ) for val in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> cnt = 0 <NEWLINE> cnt = 0 <NEWLINE> for ti in t : <NEWLINE> <INDENT> low = 0 <NEWLINE> high = n - 1 <NEWLINE> while low <= high : <NEWLINE> <INDENT> m = ( low + high ) / 2 <NEWLINE> if ti < s [ m ] : <NEWLINE> <INDENT> high = m - 1 <NEWLINE> <DEDENT> elif s [ m ] < ti : <NEWLINE> <INDENT> low = m + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def binarySearch ( A , key ) : <NEWLINE> <INDENT> left , right = 0 , n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key < A [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid += 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = [ int ( i ) for i in range ( n ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = [ int ( i ) for i in range ( q ) ] <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> if ( S , i ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
<NL> n = int ( raw_input ( ) ) <NEWLINE> S = [ ] <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> q = int ( raw_input ( ) ) <NEWLINE> T = [ ] <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> if i in S : <NEWLINE> <INDENT> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print count <NEWLINE>
c = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> s = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = input ( ) . split ( ) <NEWLINE> s . sort ( ) <NEWLINE> <NL> print ( len ( set ( s ) & set ( t ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> NO_ANSWER = - 1 <NEWLINE> <NL> def binary_sarch ( target , ary , start , end ) : <NEWLINE> <INDENT> if start == end : <NEWLINE> <INDENT> if target == ary [ start ] : <NEWLINE> <INDENT> return start <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return NO_ANSWER <NEWLINE> <NL> <DEDENT> <DEDENT> mid = ( start + end ) / 2 <NEWLINE> if target < ary [ mid ] : <NEWLINE> <INDENT> return binary_sarch ( target , ary , start , mid - 1 ) <NEWLINE> <DEDENT> elif target > ary [ mid ] : <NEWLINE> <INDENT> return binary_sarch ( target , ary , mid + 1 , end ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return mid <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> ary_s_len = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ary_s = [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> ary_t_len = int ( sys . stdin . readline ( ) . rstrip ( ) ) <NEWLINE> ary_t = [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> assert len ( ary_s ) == ary_s_len <NEWLINE> assert len ( ary_t ) == ary_t_len <NEWLINE> <NL> count = 0 <NEWLINE> for e in ary_t : <NEWLINE> <INDENT> idx = binary_sarch ( e , ary_s , 0 , ary_s_len - 1 ) <NEWLINE> if idx >= 0 : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> print count <NEWLINE>
30 <NEWLINE> 0 0 0 0 2 3 3 3 4 5 6 7 8 8 8 9 9 9 10 11 11 12 12 12 12 13 13 7000000 500000000 1000000000 <NEWLINE> 16 <NEWLINE> 2 0 5 11 3 16 4 6 1 10 7 14 15 7000000 9 5555555 <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> <NL> def linear_search ( S , T ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for i in xrange ( len ( T ) ) : <NEWLINE> <INDENT> if T [ i ] in S : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print linear_search ( S , T ) <NEWLINE> <DEDENT>
import sys <NEWLINE> data = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> data . append ( line . split ( ) ) <NEWLINE> <NL> <DEDENT> S = [ ] <NEWLINE> T = [ ] <NEWLINE> ans = [ ] <NEWLINE> S = data [ 1 ] <NEWLINE> T = data [ 3 ] <NEWLINE> <NL> count = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> l = 0 <NEWLINE> r = len ( S ) <NEWLINE> <NL> while l < r : <NEWLINE> <INDENT> i = ( l + r ) / 2 <NEWLINE> if int ( S [ i ] ) < int ( t ) : <NEWLINE> <INDENT> l = i + 1 <NEWLINE> <DEDENT> elif int ( S [ i ] ) > int ( t ) : <NEWLINE> <INDENT> r = i <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = input ( ) . split ( ) <NEWLINE> <NL> S = list ( map ( int , S ) ) <NEWLINE> T = list ( map ( int , T ) ) <NEWLINE> <NL> cnt = 0 <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n - 1 <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if S [ mid ] == T [ i ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> break <NEWLINE> <DEDENT> elif S [ mid ] > T [ i ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( cnt <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import time <NEWLINE> import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> import math <NEWLINE> start = time . clock ( ) <NEWLINE> i = 0 <NEWLINE> n = input ( ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = sorted ( set ( S ) , key = S . index ) <NEWLINE> print len ( set ( s ) & set ( T ) ) <NEWLINE>
n = input ( ) <NEWLINE> S = set ( [ int ( s ) for s in raw_input ( ) . split ( ) ] ) <NEWLINE> m = input ( ) <NEWLINE> T = set ( [ int ( s ) for s in raw_input ( ) . split ( ) ] ) <NEWLINE> <NL> r = [ ] <NEWLINE> def binarySearch ( a = [ ] , p = 0 ) : <NEWLINE> <INDENT> ll = 0 <NEWLINE> ul = len ( a ) <NEWLINE> <NL> while ( True ) : <NEWLINE> <INDENT> if ll > ul : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> ms = ( int ( ll ) + int ( ul ) ) / 2 <NEWLINE> <NL> if a [ i ] == p : <NEWLINE> <INDENT> r . append ( p ) <NEWLINE> <DEDENT> elif a [ i ] > p : <NEWLINE> <INDENT> ul = i - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ll = i + 1 <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> for i in T : <NEWLINE> <INDENT> binarySearch ( S , i ) <NEWLINE> <NL> <DEDENT> print len ( r ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> T = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> count = 0 <NEWLINE> for key in T : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( right - left ) // 2 <NEWLINE> if S [ mid ] == key : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> break <NEWLINE> <DEDENT> if key < S [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> S = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> T = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def binary_search ( S , k ) : <NEWLINE> <INDENT> if len ( S ) == 0 : return False <NEWLINE> if len ( S ) == 1 and S [ 0 ] != k : return False <NEWLINE> p = len ( S ) / 2 <NEWLINE> if S [ p ] == k : return True <NEWLINE> elif S [ p ] > k : <NEWLINE> <INDENT> return binary_search ( S [ : p ] , k ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return binary_search ( S [ p : ] , k ) <NEWLINE> <NL> <DEDENT> <DEDENT> c = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if binary_search ( S , t ) : c += 1 <NEWLINE> <DEDENT> print c <NEWLINE>
n = input ( ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> q = input ( ) <NEWLINE> T = input ( ) . split ( ) <NEWLINE> <NL> print ( len ( S & T ) ) <NEWLINE>
n = input ( ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = input ( ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print len ( T & S ) <NEWLINE>
n = raw_input ( ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = raw_input ( ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def BinarySearch ( list , num ) : <NEWLINE> <COMMENT> <NL> <INDENT> l = len ( list ) <NEWLINE> if l == 1 and list [ 0 ] != num : <NEWLINE> <COMMENT> <NL> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if list [ l / 2 ] == num : <NEWLINE> <COMMENT> <NL> <INDENT> return 1 <NEWLINE> <DEDENT> elif list [ l / 2 ] < num : <NEWLINE> <COMMENT> <NL> <INDENT> return BinarySearch ( list [ l / 2 + 1 : ] , num ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> return BinarySearch ( list [ : l / 2 ] , num ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> cnt = 0 <NEWLINE> for i in T : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> cnt += BinarySearch ( S , i ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> print cnt <NEWLINE>
n1 = int ( input ( ) ) <NEWLINE> s = ( input ( ) ) . split ( ) <NEWLINE> n2 = int ( input ( ) ) <NEWLINE> t = ( input ( ) ) . split ( ) <NEWLINE> m = [ ] <NEWLINE> <NL> for i in range ( 0 , n2 ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n1 <NEWLINE> key = int ( t [ i ] ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> if int ( s [ mid ] ) == key : <NEWLINE> <INDENT> m . append ( key ) <NEWLINE> break <NEWLINE> <DEDENT> elif int ( key ) < s [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( len ( m ) ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> T = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def binary_search ( target_num , head , tail ) : <NEWLINE> <INDENT> idx = int ( head + tail ) <NEWLINE> if target_num == S [ idx ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif target_num < S [ idx ] : <NEWLINE> <INDENT> if head == idx : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> binary_search ( target_num , head , idx - 1 ) <NEWLINE> <DEDENT> else target_num > S [ idx ] : <NEWLINE> <INDENT> if tail == idx : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> binary_search ( target_num , idx + 1 , tail ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> match_count = 0 <NEWLINE> for target_num in T : <NEWLINE> <INDENT> if binary_search ( target_num , 0 , len ( T ) - 1 ) : <NEWLINE> <INDENT> match_count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( str ( match_count ) ) <NEWLINE>
n = input ( ) <NEWLINE> S = set ( int ( ) , raw_input ( ) . split ( ) ) <NEWLINE> m = input ( ) <NEWLINE> T = set ( int ( ) , raw_input ( ) . split ( ) ) <NEWLINE> print len ( S & T ) <NEWLINE>
def binarySearch ( array , key ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = len ( array ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if key == array [ mid ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif key > array [ mid ] : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> elif key < array [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> t = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> a = [ x for x in t if binarySearch ( s , x ) ] <NEWLINE> print ( len ( a ) ) <NEWLINE>
def binarySearch ( key , lst ) : <NEWLINE> <INDENT> start = 0 <NEWLINE> end = len ( lst ) - 1 <NEWLINE> while end - start >= 0 : <NEWLINE> <INDENT> i = ( end - start ) / 2 + start <NEWLINE> if lst [ i ] > key : <NEWLINE> <INDENT> end = i - 1 <NEWLINE> <DEDENT> elif lst [ i ] < key : <NEWLINE> <INDENT> start = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> input ( ) <NEWLINE> S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> input ( ) <NEWLINE> T = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> n = 0 <NEWLINE> for t in T : <NEWLINE> <INDENT> if binarySearch ( t , S [ : ] ) : <NEWLINE> <INDENT> n += 1 <NEWLINE> <DEDENT> <DEDENT> print n <NEWLINE> <DEDENT>
def binary_search ( S , i , S_num ) <NEWLINE> <INDENT> left = 0 <NEWLINE> right = <NEWLINE> while left < right : <NEWLINE> <INDENT> center = int ( ( left + right ) / 2 ) <NEWLINE> if S [ center ] == i : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif S [ center ] > i : <NEWLINE> <INDENT> right = center - 1 <NEWLINE> <DEDENT> elif S [ center ] < i : <NEWLINE> <INDENT> left = center + 1 <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> S = [ ] <NEWLINE> T = [ ] <NEWLINE> S_num = int ( input ( ) ) <NEWLINE> S = input ( ) . split ( ) <NEWLINE> T_num = int ( input ( ) ) <NEWLINE> T = input ( ) . split ( ) <NEWLINE> cnt = 0 <NEWLINE> <NL> for i in T : <NEWLINE> <INDENT> if binary_search ( S , i , S_num ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( cnt ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> class Solution : <NEWLINE> <INDENT> @ staticmethod <NEWLINE> def binary_search ( ) : <NEWLINE> <INDENT> array_length_1 = int ( input ( ) ) <NEWLINE> array_1 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> array_length_2 = int ( input ( ) ) <NEWLINE> array_2 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> <COMMENT> <NL> left , right , count = 0 , array_length_1 , 0 <NEWLINE> for each in array_2 : <NEWLINE> <INDENT> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> if array_1 [ mid ] == each : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> elif each < array_1 [ mid ] : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( count ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> solution = Solution ( ) <NEWLINE> solution . binary_search ( ) <NEWLINE> <DEDENT>
def BinarySearch ( A , n , key ) : <NEWLINE> <INDENT> left = 0 <NEWLINE> right = n <NEWLINE> <NL> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if A [ mid ] == key : <NEWLINE> <INDENT> return mid <NEWLINE> elif key < A [ mid ] : <NEWLINE> right = mid <NEWLINE> elif key > A [ mid ] : <NEWLINE> left = mid <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n1 = int ( raw_input ( ) ) <NEWLINE> x1 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n2 = int ( raw_input ( ) ) <NEWLINE> x2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> C_num = 0 <NEWLINE> <NL> for i in range ( n2 ) : <NEWLINE> if BinarySearch ( x1 , n1 , x2 [ i ] ) != <STRING> : <NEWLINE> <INDENT> C_num += 1 <NEWLINE> <NL> <DEDENT> print ( C_num ) <NEWLINE> <DEDENT>
a = [ raw_input ( ) for i in range ( 4 ) ] <NEWLINE> print len ( set ( a [ 1 ] . split ( ) ) & set ( a [ 3 ] . split ( ) ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> dictionary = dict ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> command , data = input ( ) . split ( ) <NEWLINE> if command = <STRING> : <NEWLINE> <INDENT> dictionary [ data ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if data in dictionary : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
N = int ( input ( ) ) <NEWLINE> A = [ input ( ) for i in range ( N ) ] <NEWLINE> <NL> D = { } <NEWLINE> for row in A : <NEWLINE> <INDENT> order , key = row . split ( ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> D [ value ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if key in D . keys ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
m = 10 ** 6 <NEWLINE> <NL> def MyHash ( k , i ) : <NEWLINE> <INDENT> return ( k % m + i * ( 1 + ( k % m ) ) ) % m <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> T = [ <STRING> ] * 10 ** 6 <NEWLINE> O = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> c , k = raw_input ( ) . split ( ) <NEWLINE> i = 0 <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> k_hashed = hash ( k ) <NEWLINE> while True : <NEWLINE> <INDENT> j = MyHash ( k_hashed , i ) <NEWLINE> if T [ j ] == <STRING> : <NEWLINE> <INDENT> T [ j ] = k <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> O . append ( search ( T , k ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for item in O : <NEWLINE> <INDENT> print item <NEWLINE> <NL> <DEDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> def search ( T , k ) : <NEWLINE> <INDENT> k_hashed = hash ( k ) <NEWLINE> i = 0 <NEWLINE> while True : <NEWLINE> <INDENT> j = MyHash ( k_hashed , i ) <NEWLINE> if T [ j ] == k : <NEWLINE> <INDENT> o = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif T [ j ] == <STRING> : <NEWLINE> <INDENT> o = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return o <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> box = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp , mozi = input ( ) . split ( ) <NEWLINE> <NL> if tmp == <STRING> : <NEWLINE> <INDENT> if word in box : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> box . add ( mozi ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> dic = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> order = raw_input ( ) . split ( ) <NEWLINE> if order [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic . append ( order [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> if order [ 1 ] in dic else <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> d = <STRING> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> p , q = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if p == <STRING> : <NEWLINE> <INDENT> d += q <NEWLINE> <DEDENT> elif p == <STRING> : <NEWLINE> <INDENT> r = d . find ( q ) <NEWLINE> if ( r >= 0 ) : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
mport sys <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> dic = { } <NEWLINE> input_ = sys . stdin . readlines ( ) <NEWLINE> <NL> for i in input_ : <NEWLINE> <INDENT> c , s = i . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> dic [ s ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if s in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
count = int ( raw_input ( ) ) <NEWLINE> l = [ ] <NEWLINE> n = [ ] <NEWLINE> for i in xrange ( count ) : <NEWLINE> <INDENT> a , b = raw_input ( ) . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> l . append ( b ) <NEWLINE> <DEDENT> elif a == <STRING> : <NEWLINE> <INDENT> if b in l : <NEWLINE> <INDENT> n . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> n . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in n : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> o = { <STRING> } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = len ( o ) <NEWLINE> op , ob = map ( str , input ( ) . split ( ) ) <NEWLINE> if op == <STRING> <NEWLINE> <INDENT> o . add ( ob ) <NEWLINE> if len ( o ) > a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> o . discard ( ob ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> o . add ( ob ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x [ 0 ] == <STRING> : <NEWLINE> <INDENT> d . append ( x [ 7 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( x [ 5 : ] in d ) : print ( <STRING> ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> ls = [ [ ] for i in range ( 12 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = raw_input ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> ls [ len ( inp [ 7 : ] ) ] . append ( inp [ 7 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> if inp [ 5 : ] in ls [ len ( inp [ 5 : ] ) ] else <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> dic = ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd , word = raw_input ( ) . split ( <STRING> ) <NEWLINE> if <STRING> == cmd : <NEWLINE> <INDENT> dic [ word ] = True <NEWLINE> <DEDENT> elif <STRING> == cmd : <NEWLINE> <INDENT> if word in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = input ( ) . split ( ) <NEWLINE> if x == <STRING> : <NEWLINE> <INDENT> A . add ( y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if A in y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> <NL> D = set ( ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> c , s = input ( ) . split ( ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> D . append ( s ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> if ( s in D ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> def m ( ) : <NEWLINE> <INDENT> d = { } ; input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e [ 0 ] : print ( [ <STRING> , <STRING> ] [ e [ 5 : ] in d ] ) <NEWLINE> else : d [ e [ 7 : ] ] = 0 <NEWLINE> <DEDENT> <DEDENT> if <STRING> == __name__ : m ( ) import sys <NEWLINE> def m ( ) : <NEWLINE> <INDENT> d = { 0 } ; input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e [ 0 ] : print ( [ <STRING> , <STRING> ] [ e [ 5 : ] in d ] ) <NEWLINE> else : d |= { e [ 7 : ] } <NEWLINE> <DEDENT> <DEDENT> if <STRING> == __name__ : m ( ) <NEWLINE>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> <NL> imps = sys . stdin . readlines ( ) <NEWLINE> <NL> db = { } <NEWLINE> for imp in imps : <NEWLINE> <INDENT> c , k = imp . split ( <STRING> ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> db [ k ] = 0 <NEWLINE> <DEDENT> elif db in k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
13 <NEWLINE> insert AAA <NEWLINE> insert AAC <NEWLINE> insert AGA <NEWLINE> insert AGG <NEWLINE> insert TTT <NEWLINE> find AAA <NEWLINE> find CCC <NEWLINE> find CCC <NEWLINE> insert CCC <NEWLINE> find CCC <NEWLINE> insert T <NEWLINE> find TTT <NEWLINE> find T <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print <STRING> <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> genoms = [ ] <NEWLINE> answers = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> values = raw_input ( ) . split ( ) <NEWLINE> order = values [ 0 ] <NEWLINE> genom = values [ 1 ] <NEWLINE> if order == <STRING> : <NEWLINE> <INDENT> genoms . append ( genom ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answers . append ( <STRING> if genom in genoms else <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for answer in answers : <NEWLINE> <INDENT> print answer <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if <STRING> in x : <NEWLINE> <INDENT> dic . add ( x . strip ( <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x . strip ( <STRING> ) in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = [ ] <NEWLINE> l = [ list ( i ) for i in input ( ) . split ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if l [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic . append ( l [ i ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if l [ i ] [ 1 ] in dic : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> L = [ ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> a , b = raw_input ( ) . split ( ) <NEWLINE> if a == <STRING> : <NEWLINE> <INDENT> L . append ( b ) <NEWLINE> <DEDENT> if a == <STRING> : <NEWLINE> <INDENT> if b in L : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> class HashTable : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . table = [ None ] * 4 <NEWLINE> self . flag = False <NEWLINE> <NL> <DEDENT> <DEDENT> class Dictionary : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . hashTable = HashTable ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> table = self . hashTable <NEWLINE> for c in key : <NEWLINE> <INDENT> hash = self . toHash ( c ) <NEWLINE> if table . table [ hash ] is None : <NEWLINE> <INDENT> table . table [ hash ] = HashTable ( ) <NEWLINE> <DEDENT> table = table . table [ hash ] <NEWLINE> <DEDENT> table . flag = True <NEWLINE> <NL> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> table = self . hashTable <NEWLINE> for c in key : <NEWLINE> <INDENT> hash = self . toHash ( c ) <NEWLINE> if table . table [ hash ] is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> table = table . table [ hash ] <NEWLINE> <DEDENT> if table . flag : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def toHash ( self , key ) : <NEWLINE> <INDENT> key = key . replace ( <STRING> , <STRING> ) <NEWLINE> key = key . replace ( <STRING> , <STRING> ) <NEWLINE> key = key . replace ( <STRING> , <STRING> ) <NEWLINE> key = key . replace ( <STRING> , <STRING> ) <NEWLINE> return int ( key ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dic = Dictionary ( ) <NEWLINE> lines = sys . stdin . readlines ( ) <NEWLINE> del lines [ 0 ] <NEWLINE> for command in lines : <NEWLINE> <INDENT> key = command . split ( ) [ 1 ] <NEWLINE> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> dic . insert ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if dic . find ( key ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> dic = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com , s = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> dic . append ( s ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> if s in dic : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class TrieTree : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . flag = 0 <NEWLINE> self . next = [ None , None , None , None ] <NEWLINE> <NL> <DEDENT> <DEDENT> def judge ( c ) : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 3 <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( key , trie ) : <NEWLINE> <NL> <INDENT> if ( len ( key ) >= 1 ) : <NEWLINE> <INDENT> index = judge ( key [ 0 ] ) <NEWLINE> if ( trie . next [ index ] == None ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> find ( key [ 1 : ] , trie . next [ index ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( trie . flag ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def insert ( key , trie ) : <NEWLINE> <INDENT> if ( len ( key ) >= 1 ) : <NEWLINE> index = judge ( key [ 0 ] ) <NEWLINE> if ( trie . next [ index ] == None ) : <NEWLINE> <INDENT> trie . next [ index ] = TrieTree ( ) <NEWLINE> insert ( key [ 1 : ] , trie . next [ index ] ) <NEWLINE> else : <NEWLINE> insert ( key [ 1 : ] , trie . next [ index ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> trie . flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> root = TrieTree ( ) <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> com = raw_input ( ) . split ( ) <NEWLINE> if ( com [ 0 ] [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> insert ( com [ 1 ] , root ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> find ( com [ 1 ] , root ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> d = { } <NEWLINE> for i in n : <NEWLINE> <INDENT> cmd = input ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> d [ cmd [ 7 : ] ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> if cmd [ 5 : ] in d else <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> a_dict = [ [ ] , [ ] , [ ] , [ ] , [ ] ] <NEWLINE> c_dict = [ [ ] , [ ] , [ ] , [ ] , [ ] ] <NEWLINE> t_dict = [ [ ] , [ ] , [ ] , [ ] , [ ] ] <NEWLINE> g_dict = [ [ ] , [ ] , [ ] , [ ] , [ ] ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> cmd = raw_input ( ) . split ( ) <NEWLINE> char = cmd [ 1 ] <NEWLINE> <NL> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> if char [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> a_dict [ 0 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> a_dict [ 1 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> a_dict [ 2 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> a_dict [ 3 ] . append ( char ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_dict [ 4 ] . append ( char ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> t_dict [ 0 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> t_dict [ 1 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> t_dict [ 2 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> t_dict [ 3 ] . append ( char ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_dict [ 4 ] . append ( char ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> c_dict [ 0 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> c_dict [ 1 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> c_dict [ 2 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> c_dict [ 3 ] . append ( char ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c_dict [ 4 ] . append ( char ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> g_dict [ 0 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> g_dict [ 1 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> g_dict [ 2 ] . append ( char ) <NEWLINE> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> g_dict [ 3 ] . append ( char ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> g_dict [ 4 ] . append ( char ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if char [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> if char in a_dict [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in a_dict [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in a_dict [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in a_dict [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if char in a_dict [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif char [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> if char in t_dict [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in t_dict [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in t_dict [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in t_dict [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if char in t_dict [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> elif char [ 0 ] == <STRING> : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> if char in c_dict [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in c_dict [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in c_dict [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in c_dict [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if char in c_dict [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if len ( char ) == 1 : <NEWLINE> <INDENT> if char in g_dict [ 0 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in g_dict [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in g_dict [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif char [ 1 ] == <STRING> : <NEWLINE> <INDENT> if char in g_dict [ 3 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if char in g_dict [ 4 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def input_converter ( key_string ) : <NEWLINE> <INDENT> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> return int ( key_string ) <NEWLINE> <NL> <NL> <DEDENT> class HashTable ( object ) : <NEWLINE> <INDENT> def __init__ ( self , hash_size = 2 ** 26 ) : <NEWLINE> <INDENT> self . hash_size = hash_size <NEWLINE> self . hash_array = [ None ] * self . hash_size <NEWLINE> <NL> <DEDENT> def insert_value ( self , data , key ) : <NEWLINE> <INDENT> collision_number = 0 <NEWLINE> next_index = self . hash_function ( key , collision_number ) <NEWLINE> while self . hash_array [ next_index ] is not None : <NEWLINE> <INDENT> collision_number += 1 <NEWLINE> next_index = self . hash_function ( key , collision_number ) <NEWLINE> <DEDENT> if collision_number != 0 : <NEWLINE> <INDENT> print collision_number <NEWLINE> <DEDENT> self . hash_array [ next_index ] = data <NEWLINE> <NL> <DEDENT> def search_value ( self , data , key ) : <NEWLINE> <INDENT> collision_number = 0 <NEWLINE> next_index = self . hash_function ( key , collision_number ) <NEWLINE> next_data = self . hash_array [ next_index ] <NEWLINE> while True : <NEWLINE> <INDENT> if ( next_data is None ) or ( collision_number > self . hash_size ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif next_data == data : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> collision_number += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def hash_function ( self , key , collision_number ) : <NEWLINE> <INDENT> def h1 ( key ) : <NEWLINE> <INDENT> return key % self . hash_size <NEWLINE> <NL> <DEDENT> def h2 ( key ) : <NEWLINE> <INDENT> return key % ( self . hash_size - 1 ) <NEWLINE> <NL> <DEDENT> return ( h1 ( key ) + collision_number * h2 ( key ) ) % self . hash_size <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input_size = int ( raw_input ( ) ) <NEWLINE> hash_table = HashTable ( ) <NEWLINE> counter = 0 <NEWLINE> while counter < input_size : <NEWLINE> <INDENT> command , key = raw_input ( ) . split ( <STRING> ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> hash_table . insert_value ( key , input_converter ( key ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if hash_table . search_value ( key , input_converter ( key ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> counter += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> <NL> d = [ ] <NEWLINE> for x in xrange ( n ) : <NEWLINE> <INDENT> cmd , st = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if cmd == <STRING> : <NEWLINE> <INDENT> d . append ( st ) <NEWLINE> <DEDENT> elif cmd == <STRING> : <NEWLINE> <INDENT> print <STRING> if st in d else <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> dict = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> command , word = raw_input ( ) . split ( ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> dict . append ( word ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> dict . index ( word ) <NEWLINE> print <STRING> <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> print <STRING> <NEWLINE> pass <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <NEWLINE> <NL> imps = sys . stdin . readlines ( ) <NEWLINE> <NL> db = { } <NEWLINE> for imp in imps : <NEWLINE> <INDENT> c , k = imp . split ( <STRING> ) <NEWLINE> if c == <STRING> : <NEWLINE> <INDENT> c [ k ] = 0 <NEWLINE> <DEDENT> elif db in k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
def insert ( S , string ) : <NEWLINE> <INDENT> S . add ( string ) <NEWLINE> <NL> <DEDENT> def find ( S , string ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> cnt = cnt + 1 <NEWLINE> if string in S : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif cnt == len ( S ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> if cnt == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> <NL> S = set ( [ ] ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> tmp1 , tmp2 = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if tmp1 == <STRING> : <NEWLINE> <INDENT> insert ( S , tmp2 ) <NEWLINE> <DEDENT> elif tmp1 == <STRING> : <NEWLINE> <INDENT> find ( S , tmp2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) . strip ( ) ) <NEWLINE> commands = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> commands . append ( raw_input ( ) . strip ( ) ) <NEWLINE> <NL> <NL> <DEDENT> d = [ False ] * 16777220 <NEWLINE> <NL> def hash ( s ) : <NEWLINE> <INDENT> ret = 0 <NEWLINE> i = 0 <NEWLINE> for dg in s : <NEWLINE> <INDENT> if dg == <STRING> : <NEWLINE> <INDENT> ret += 1 * 10 ** i <NEWLINE> <DEDENT> elif dg == <STRING> : <NEWLINE> <INDENT> ret += 2 * 10 ** i <NEWLINE> <DEDENT> elif dg == <STRING> : <NEWLINE> <INDENT> ret += 3 * 10 ** i <NEWLINE> <DEDENT> elif dg == <STRING> : <NEWLINE> <INDENT> ret += 4 * 10 ** i <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> def insert ( d , s ) : <NEWLINE> <INDENT> h = hash ( s ) <NEWLINE> d [ h ] = True <NEWLINE> <NL> <DEDENT> def find ( d , s ) : <NEWLINE> <INDENT> h = hash ( s ) <NEWLINE> if d [ h ] : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <NL> <DEDENT> for c in commands : <NEWLINE> <INDENT> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( d , c [ 7 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> find ( d , c [ 5 : ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> htable = [ 0 ] * 244140625 <NEWLINE> <NL> <NL> def to_int ( s ) : <NEWLINE> <INDENT> if s == <STRING> : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> return 2 <NEWLINE> <DEDENT> elif s == <STRING> : <NEWLINE> <INDENT> return 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 4 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def to_hash ( string ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> for i , s in enumerate ( string ) : <NEWLINE> <INDENT> ints = to_int ( s ) <NEWLINE> h += 5 ** i * ints <NEWLINE> <NL> <DEDENT> return h <NEWLINE> <NL> <NL> <DEDENT> def insert ( string ) : <NEWLINE> <INDENT> h = to_hash ( string ) <NEWLINE> htable [ h ] = 1 <NEWLINE> <NL> <NL> <DEDENT> def find ( string ) : <NEWLINE> <INDENT> h = to_hash ( string ) <NEWLINE> if htable [ h ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> cmd , string = line . strip ( ) . split ( ) <NEWLINE> <NL> if cmd == <STRING> : <NEWLINE> <INDENT> insert ( string ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> find ( string ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> s = set ( ) // 集合 <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> inst = input ( ) . split ( ) <NEWLINE> if inst [ 0 ] == <STRING> : <NEWLINE> <INDENT> s . add ( inst [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if inst [ 1 ] in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
dict = { <STRING> : 1 , <STRING> : 2 , <STRING> : 3 , <STRING> : 4 } <NEWLINE> def a2n ( a ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> ans += dict [ a [ i ] ] * 4 ** i <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> ls = [ 0 for i in range ( 1000000 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> inp = raw_input ( ) <NEWLINE> if inp [ 0 ] == <STRING> : <NEWLINE> <INDENT> ls [ a2n ( inp [ 7 : ] ) ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> if ls [ a2n ( inp [ 5 : ] ) ] else <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> s = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> order = list ( map ( str , input ( ) . split ( ) ) ) <NEWLINE> if ( order [ 0 ] [ 0 ] == <STRING> ) : <NEWLINE> <INDENT> s . add ( order [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if order [ 1 ] in s : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> dic = set ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> Cmd , Key = input ( ) . split ( ) <NEWLINE> if Cmd == <STRING> : <NEWLINE> dic . add ( Key ) <NEWLINE> else : <NEWLINE> <INDENT> if Key in dic : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import time <NEWLINE> import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> import math <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> a , b = [ ] , [ ] <NEWLINE> check = re . compile ( <STRING> ) <NEWLINE> n = input ( ) <NEWLINE> <COMMENT> <NL> for x in xrange ( n ) : <NEWLINE> <INDENT> ( i , f ) = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if check . search ( i ) : <NEWLINE> <INDENT> a . append ( f ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if f in a : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def input_converter ( key_string ) : <NEWLINE> <INDENT> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> key_string = key_string . replace ( <STRING> , <STRING> ) <NEWLINE> return int ( key_string ) <NEWLINE> <NL> <NL> <DEDENT> class HashTable ( object ) : <NEWLINE> <INDENT> def __init__ ( self , hash_size = 2 ** 26 ) : <NEWLINE> <INDENT> self . hash_size = hash_size <NEWLINE> self . hash_array = [ None ] * self . hash_size <NEWLINE> <NL> <DEDENT> def insert_value ( self , data , key ) : <NEWLINE> <INDENT> collision_number = 0 <NEWLINE> next_index = self . hash_function ( key , collision_number ) <NEWLINE> while self . hash_array [ next_index ] is not None : <NEWLINE> <INDENT> collision_number += 1 <NEWLINE> next_index = self . hash_function ( key , collision_number ) <NEWLINE> <COMMENT> <NL> <DEDENT> self . hash_array [ next_index ] = data <NEWLINE> <NL> <DEDENT> def search_value ( self , data , key ) : <NEWLINE> <INDENT> collision_number = 0 <NEWLINE> next_index = self . hash_function ( key , collision_number ) <NEWLINE> next_data = self . hash_array [ next_index ] <NEWLINE> while True : <NEWLINE> <INDENT> if ( next_data is None ) or ( collision_number > self . hash_size ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif next_data == data : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> collision_number += 1 <NEWLINE> next_index = self . hash_function ( key , collision_number ) <NEWLINE> next_data = self . hash_array [ next_index ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def hash_function ( self , key , collision_number ) : <NEWLINE> <INDENT> def h1 ( key ) : <NEWLINE> <INDENT> return key % self . hash_size <NEWLINE> <NL> <DEDENT> def h2 ( key ) : <NEWLINE> <INDENT> return key % ( self . hash_size - 1 ) <NEWLINE> <NL> <DEDENT> return ( h1 ( key ) + collision_number * h2 ( key ) ) % self . hash_size <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> input_size = int ( raw_input ( ) ) <NEWLINE> hash_table = HashTable ( 2 ** 20 ) <NEWLINE> counter = 0 <NEWLINE> while counter < input_size : <NEWLINE> <INDENT> command , key = raw_input ( ) . split ( <STRING> ) <NEWLINE> if command == <STRING> : <NEWLINE> <INDENT> hash_table . insert_value ( key , input_converter ( key ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if hash_table . search_value ( key , input_converter ( key ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> counter += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> dic = set ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> com , st = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> dic . add ( st ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> for j in dic : <NEWLINE> <INDENT> if j == st : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> elif j == count - 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> baggages = [ ] <NEWLINE> weight_sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> baggages . append ( int ( raw_input ( ) ) ) <NEWLINE> <DEDENT> for i in baggages : <NEWLINE> <INDENT> weight_sum += i <NEWLINE> <DEDENT> P_min = int ( weight_sum / k ) <NEWLINE> for i in baggages : <NEWLINE> <INDENT> P_min = max ( P_min , i ) <NEWLINE> <DEDENT> tmp = P_min <NEWLINE> while True : <NEWLINE> <INDENT> flag = True <NEWLINE> trucks = k - 1 <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> baggage = baggages [ i ] <NEWLINE> if tmp >= baggage : <NEWLINE> <INDENT> tmp -= baggage <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = P_min <NEWLINE> if trucks > 0 : <NEWLINE> <INDENT> trucks -= 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> P_min += 1 <NEWLINE> tmp = P_min <NEWLINE> <DEDENT> <DEDENT> print P_min <NEWLINE>
n , k = [ int ( val ) for val in raw_input ( ) . split ( <STRING> ) ] <NEWLINE> w = [ int ( raw_input ( ) ) for val in range ( n ) ] <NEWLINE> sumW = sum ( w ) <NEWLINE> maxW = max ( w ) <NEWLINE> <NL> minP = 0 <NEWLINE> if 1 == k : <NEWLINE> <INDENT> minP = sumW <NEWLINE> <DEDENT> elif n == k : <NEWLINE> <INDENT> minP = maxW <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = maxW <NEWLINE> right = 100000 * 10000 <NEWLINE> while left <= right : <NEWLINE> <INDENT> middle = ( left + right ) // 2 <NEWLINE> truckCnt = i = loadings = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> loadings += w [ i ] <NEWLINE> if middle < loadings : <NEWLINE> <INDENT> truckCnt += 1 <NEWLINE> if k < truckCnt + 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> loadings = w [ i ] <NEWLINE> <DEDENT> i += 1 <NEWLINE> <NL> <DEDENT> if truckCnt + 1 <= k : <NEWLINE> <INDENT> minP = middle <NEWLINE> <NL> <DEDENT> if k < truckCnt + 1 : <NEWLINE> <INDENT> left = middle + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = middle - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( minP ) <NEWLINE>
def carriable_baggage ( baggage , baggage_num , truck_capacity , truck_num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> laden_baggage = 0 <NEWLINE> for i in range ( truck_num ) : <NEWLINE> <INDENT> laden_weight = 0 <NEWLINE> while laden_weight + baggage [ laden_baggage ] <= truck_capacity : <NEWLINE> <INDENT> laden_weight += baggage [ laden_baggage ] <NEWLINE> laden_baggage += 1 <NEWLINE> if laden_baggage == baggage_num : <NEWLINE> <INDENT> return baggage_num <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return laden_baggage <NEWLINE> <NL> <DEDENT> def min_capacity ( baggage , baggage_num , truck_num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> left = max ( baggage ) <NEWLINE> right = sum ( baggage ) <NEWLINE> while left != right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> v = carriable_baggage ( baggage , baggage_num , mid , truck_num ) <NEWLINE> if v >= baggage_num : <NEWLINE> <INDENT> right = mid ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <DEDENT> <DEDENT> return right <NEWLINE> <NL> <NL> <DEDENT> import sys <NEWLINE> <NL> n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> <NL> T = list ( map ( int , sys . stdin ) ) <NEWLINE> <NL> P = min_capacity ( T , n , k ) <NEWLINE> <NL> print ( P ) <NEWLINE>
import sys <NEWLINE> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> w = list ( map ( int , sys . stdin . readlines ( ) ) ) <NEWLINE> def check ( P ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> for _ in [ 0 ] * k : <NEWLINE> <INDENT> s = 0 <NEWLINE> while s + w [ i ] <= P : <NEWLINE> <INDENT> s += w [ i ] ; i += 1 <NEWLINE> if i == n : return n <NEWLINE> <DEDENT> <DEDENT> return i <NEWLINE> <DEDENT> l , r = max ( w ) , sum ( w ) <NEWLINE> while l <= r : <NEWLINE> <INDENT> m = ( l + r ) // 2 <NEWLINE> if check ( m ) >= n : r = m <NEWLINE> else : l = m <NEWLINE> <DEDENT> print ( r ) <NEWLINE>
def maxStack ( k , p , W ) : <NEWLINE> <INDENT> nw = 0 <NEWLINE> count = 0 <NEWLINE> t = 1 <NEWLINE> for x in W : <NEWLINE> <INDENT> if x > p : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> if nw + x <= p : <NEWLINE> <INDENT> nw += x <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t == k : <NEWLINE> <INDENT> return count <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t += 1 <NEWLINE> nw = x <NEWLINE> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <NL> <DEDENT> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> W = [ int ( raw_input ( ) ) for i in xrange ( n ) ] <NEWLINE> <NL> left = 1 <NEWLINE> right = sum ( W ) <NEWLINE> while left < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> v = maxStack ( k , mid , W ) <NEWLINE> if v == n : <NEWLINE> <INDENT> while n == maxStack ( k , mid - 1 , W ) : <NEWLINE> <INDENT> mid -= 1 <NEWLINE> <DEDENT> print mid <NEWLINE> quit ( ) <NEWLINE> <DEDENT> elif v > n : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid + 1 <NEWLINE> <DEDENT> <DEDENT> print left <NEWLINE>
def check ( T , p , n , k ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> <NL> for j in range ( k ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> <NL> while ( s + T [ i ] <= p ) : <NEWLINE> <INDENT> s += T [ i ] <NEWLINE> i += 1 <NEWLINE> if i == n : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <DEDENT> n , k = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> T = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> T . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> left , right = 0 , 100000 * 10000 <NEWLINE> <NL> while ( right - left > 1 ) : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> if ( check ( T , mid , n , k ) >= n ) : <NEWLINE> <INDENT> right = mid <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = mid <NEWLINE> <NL> <DEDENT> <DEDENT> print right <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> def allocate ( k , w ) : <NEWLINE> <INDENT> t = [ 0 ] * k <NEWLINE> avg = math . ceil ( 1.0 * sum ( w ) / k ) <NEWLINE> while True : <NEWLINE> <INDENT> maxp = p = i = 0 <NEWLINE> for wi in w : <NEWLINE> <INDENT> p += wi <NEWLINE> if p > avg : <NEWLINE> <INDENT> p -= wi <NEWLINE> if p > maxp : <NEWLINE> <INDENT> maxp = p <NEWLINE> <DEDENT> p = wi <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if p > maxp : <NEWLINE> <INDENT> maxp = p <NEWLINE> <NL> <DEDENT> if i < k and maxp <= avg : <NEWLINE> <INDENT> return maxp <NEWLINE> <NL> <DEDENT> avg += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> w = sys . stdin . readlines ( ) <NEWLINE> k = int ( w [ 0 ] . split ( ) [ 1 ] ) <NEWLINE> del w [ 0 ] <NEWLINE> w = [ int ( wi ) for wi in w ] <NEWLINE> print allocate ( k , w ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> W = tuple ( int ( readline ( ) ) for _ in range ( n ) ) <NEWLINE> ma = max ( W ) <NEWLINE> def check ( x ) : <NEWLINE> <INDENT> if x < ma : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> use = 1 <NEWLINE> rest = x <NEWLINE> for w in W : <NEWLINE> <INDENT> if rest >= w : <NEWLINE> <INDENT> rest -= w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = x - w <NEWLINE> use += 1 <NEWLINE> <DEDENT> <DEDENT> return use <= K <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = sum ( W ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if check ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def check ( p ) : <NEWLINE> <INDENT> s = w [ 0 ] <NEWLINE> track = 1 <NEWLINE> for i in range ( 1 , n ) : <NEWLINE> <INDENT> if s + w [ i ] <= p : <NEWLINE> <INDENT> s += w [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> track += 1 <NEWLINE> if track > k : return False <NEWLINE> s = w [ i ] <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> n , k = map ( int , input ( ) . strip ( ) . split ( ) ) <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> L = max ( w ) <NEWLINE> if check ( L ) : return L <NEWLINE> R = sum ( w ) <NEWLINE> <NL> while L + 1 < R : <NEWLINE> <INDENT> M = ( L + R ) // 2 <NEWLINE> if check ( M ) : <NEWLINE> <INDENT> R = M <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L = M <NEWLINE> <NL> <DEDENT> <DEDENT> print ( R ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> N , K = map ( int , input ( ) . split ( ) ) <NEWLINE> W = tuple ( map ( int , sys . stdin . splitlines ( ) ) ) <NEWLINE> ma = max ( W ) <NEWLINE> def check ( x ) : <NEWLINE> <INDENT> if x < ma : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> use = 1 <NEWLINE> rest = x <NEWLINE> for w in W : <NEWLINE> <INDENT> if rest >= w : <NEWLINE> <INDENT> rest -= w <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rest = x - w <NEWLINE> use += 1 <NEWLINE> <DEDENT> <DEDENT> return use <= K <NEWLINE> <DEDENT> l = 0 <NEWLINE> r = sum ( W ) <NEWLINE> while r - l > 1 : <NEWLINE> <INDENT> m = ( r + l ) // 2 <NEWLINE> if check ( m ) : <NEWLINE> <INDENT> r = m <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> l = m <NEWLINE> <DEDENT> <DEDENT> print ( r ) <NEWLINE>
def allocate ( count , weights ) : <NEWLINE> <INDENT> def loadable_counts ( maxweight ) : <NEWLINE> <INDENT> n = 0 <NEWLINE> l = 0 <NEWLINE> c = count <NEWLINE> for w in weights : <NEWLINE> <INDENT> l += w <NEWLINE> if l > maxweight : <NEWLINE> <INDENT> l = w <NEWLINE> c -= 1 <NEWLINE> <NL> <DEDENT> if c <= 0 : <NEWLINE> <INDENT> return n <NEWLINE> <NL> <DEDENT> n += 1 <NEWLINE> <DEDENT> return n <NEWLINE> <NL> <DEDENT> i = 0 <NEWLINE> j = max ( weights ) * len ( weights ) // count <NEWLINE> <NL> while i < j : <NEWLINE> <INDENT> mid = ( i + j ) // 2 <NEWLINE> if loadable_counts ( mid ) < len ( weights ) : <NEWLINE> <INDENT> i = mid + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> j = mid <NEWLINE> <NL> <DEDENT> <DEDENT> return i <NEWLINE> <NL> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> k , n = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> ws = [ ] <NEWLINE> for i in sys . stdin : <NEWLINE> <INDENT> ws . append ( int ( i ) ) <NEWLINE> <NL> <DEDENT> print ( allocate ( n , ws ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
def moveRight ( trug , start , stop ) : <NEWLINE> <INDENT> if trug [ start ] [ 1 ] - trug [ start ] [ 0 ] > 1 : <NEWLINE> <INDENT> for i in xrange ( stop - start ) : <NEWLINE> <INDENT> trug [ start + i ] [ 1 ] -= 1 <NEWLINE> trug [ start + i + 1 ] [ 0 ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def moveLeft ( trug , start , stop ) : <NEWLINE> <INDENT> if trug [ start ] [ 1 ] - trug [ start ] [ 0 ] > 1 : <NEWLINE> <INDENT> for i in xrange ( start - stop ) : <NEWLINE> <INDENT> trug [ start - i ] [ 0 ] += 1 <NEWLINE> trug [ start - i - 1 ] [ 1 ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def calcWeight ( trug , w ) : <NEWLINE> <INDENT> temp = [ sum ( w [ trug [ i ] [ 0 ] : trug [ i ] [ 1 ] ] ) for i in xrange ( len ( trug ) ) ] <NEWLINE> return temp <NEWLINE> <NL> <DEDENT> n , k = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> w = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> w . append ( input ( ) ) <NEWLINE> <NL> <DEDENT> if k == 1 : <NEWLINE> <INDENT> trug = [ [ 0 , n ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ta = n / k <NEWLINE> trug = [ [ i * ta , ta + i * ta ] for i in xrange ( k - 1 ) ] <NEWLINE> trug . append ( [ ( i + 1 ) * ta , n ] ) <NEWLINE> <NL> <DEDENT> trugw = calcWeight ( trug , w ) <NEWLINE> maxt = max ( trugw ) <NEWLINE> imaxt = trugw . index ( maxt ) <NEWLINE> mint = min ( trugw ) <NEWLINE> imint = trugw . index ( mint ) <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if imaxt < imint : <NEWLINE> <INDENT> if mint + w [ trug [ imint - 1 ] [ 1 ] - 1 ] < maxt : <NEWLINE> <INDENT> moveRight ( trug , imaxt , imint ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if mint + w [ trug [ imint + 1 ] [ 0 ] ] < maxt : <NEWLINE> <INDENT> moveLeft ( trug , imaxt , imint ) <NEWLINE> <NL> <DEDENT> <DEDENT> trugw = calcWeight ( trug , w ) <NEWLINE> n = max ( trugw ) <NEWLINE> if n >= maxt : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> maxt = n <NEWLINE> imaxt = trugw . index ( maxt ) <NEWLINE> mint = min ( trugw ) <NEWLINE> imint = trugw . index ( mint ) <NEWLINE> <NL> <DEDENT> <DEDENT> print maxt <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> def be_able_to_convey ( w , k , p ) : <NEWLINE> <INDENT> counter = 0 <NEWLINE> cur_weight = 0 <NEWLINE> for wi in w : <NEWLINE> <INDENT> if wi > p : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> cur_weight += wi <NEWLINE> if ( cur_weight > p ) : <NEWLINE> <INDENT> cur_weight = wi <NEWLINE> counter += 1 <NEWLINE> if ( counter >= k ) : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> n , k = map ( int , fin . readline ( ) . split ( ) ) <NEWLINE> w = [ 0 for i in range ( n ) ] <NEWLINE> w_max = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> w [ i ] = int ( fin . readline ( ) ) <NEWLINE> w_max = max ( w [ i ] , w_max ) <NEWLINE> <NL> <NL> <DEDENT> pmin = 1 <NEWLINE> pmax = math . ceil ( w_max * w_max // k ) <NEWLINE> <NL> while pmin < pmax : <NEWLINE> <INDENT> p = math . ceil ( ( pmin + pmax ) / 2 ) <NEWLINE> if p == pmin or p == pmax : <NEWLINE> <INDENT> if be_able_to_convey ( w , k , pmax ) : <NEWLINE> <INDENT> if be_able_to_convey ( w , k , pmin ) : <NEWLINE> <INDENT> p = pmin <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = pmax <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> p = pmin <NEWLINE> <DEDENT> break <NEWLINE> <NL> <DEDENT> if not be_able_to_convey ( w , k , p ) : <NEWLINE> <INDENT> pmin = p <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pmax = p <NEWLINE> <NL> <DEDENT> <DEDENT> print ( p ) <NEWLINE>
def min_sufficient_load ( w , k ) : <NEWLINE> <INDENT> return check ( w , k , 0 , sum ( w ) ) <NEWLINE> <NL> <NL> <DEDENT> def check ( w , k , p1 , p2 ) : <NEWLINE> <INDENT> trunk_no = 1 <NEWLINE> temp = 0 <NEWLINE> m = 1 + ( p1 + p2 ) >> 1 <NEWLINE> for i in w : <NEWLINE> <INDENT> if temp + i <= m : <NEWLINE> <INDENT> temp += i <NEWLINE> if temp == m : <NEWLINE> <INDENT> trunk_no += 1 <NEWLINE> temp = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> trunk_no += 1 <NEWLINE> temp = i <NEWLINE> <DEDENT> <DEDENT> if trunk_no > k : <NEWLINE> <INDENT> return check ( w , k , m , p2 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if m - p1 == 0 : <NEWLINE> <INDENT> return m <NEWLINE> <DEDENT> return check ( w , k , p1 , m ) <NEWLINE> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , k = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> w = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> w . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> print ( min_sufficient_load ( w , k ) ) <NEWLINE> <DEDENT>
class MyClass ( ) : <NEWLINE> <INDENT> def main ( self ) : <NEWLINE> <INDENT> self . n = input ( ) <NEWLINE> self . A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> self . q = input ( ) <NEWLINE> self . M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> W = map ( self . solve , self . M ) <NEWLINE> for w in W : <NEWLINE> <INDENT> print w <NEWLINE> <NL> <DEDENT> <DEDENT> def solve ( self , m ) : <NEWLINE> <INDENT> w = self . rec ( m , self . A ) <NEWLINE> if w : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def rec ( self , m , A ) : <NEWLINE> <INDENT> if len ( A ) == 1 : <NEWLINE> <INDENT> r1 = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r1 = self . rec ( m , A [ 1 : ] ) <NEWLINE> <NL> <DEDENT> m_new = m - A [ 0 ] <NEWLINE> if m_new < 0 : <NEWLINE> <INDENT> r2 = False <NEWLINE> <DEDENT> elif m_new == 0 : <NEWLINE> <INDENT> r2 = True <NEWLINE> <DEDENT> elif len ( A ) == 1 or m_new < min ( A [ 1 : ] ) : <NEWLINE> <INDENT> r2 = False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> r2 = self . rec ( m_new , A [ 1 : ] ) <NEWLINE> <NL> <DEDENT> if r1 or r2 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> MC = MyClass ( ) <NEWLINE> MC . main ( ) <NEWLINE> <DEDENT>
n1 = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> n2 = input ( ) <NEWLINE> q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> list = set ( ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n1 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m in q : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ans = chk = 0 <NEWLINE> bits = ( 1 << n ) - 1 <NEWLINE> for i in m : <NEWLINE> <INDENT> p = bits <NEWLINE> flag = 0 <NEWLINE> while p : <NEWLINE> <INDENT> chk = str ( bin ( p ) ) [ 2 : ] <NEWLINE> chk = <STRING> * ( n - len ( chk ) ) + chk <NEWLINE> p -= 1 <NEWLINE> h = 0 <NEWLINE> for j , k in enumerate ( chk ) : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> h += a [ j ] <NEWLINE> <DEDENT> if h == i : <NEWLINE> <INDENT> print <STRING> <NEWLINE> p = 0 <NEWLINE> flag = 1 <NEWLINE> continue <NEWLINE> <DEDENT> elif h > i : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if flag == 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import time <NEWLINE> from array import array <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> A = array ( <STRING> , map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = array ( <STRING> , map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> start = time . time ( ) <NEWLINE> for m_i in m : <NEWLINE> <INDENT> print <STRING> if solve ( 0 , m_i ) else <STRING> <NEWLINE> <DEDENT> end = time . time ( ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p = int ( input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> def goukei ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m > sum ( a ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> r = goukei ( i + 1 , m ) or goukei ( i + 1 , m - a [ i ] ) <NEWLINE> return r <NEWLINE> <NL> <DEDENT> for u in range ( 0 , p ) : <NEWLINE> <NL> <INDENT> if s ( 0 , m [ u ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> import numpy as np <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> A = deque ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> q = input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a = np . array ( [ 0 ] ) <NEWLINE> p = rec ( a , A ) <NEWLINE> <NL> for m in M : <NEWLINE> <INDENT> print <STRING> if m in p else <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def rec ( a , A ) : <NEWLINE> <INDENT> if len ( A ) == 0 : <NEWLINE> <INDENT> return a <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = np . append ( a , a + A . popleft ( ) ) <NEWLINE> return rec ( a , A ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> A = sorted ( A ) <NEWLINE> <COMMENT> <NL> <NL> def sum_A ( A , n , pos , sum , m , res ) : <NEWLINE> <INDENT> if res [ 0 ] == <STRING> : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if sum + A [ pos ] > m : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if sum + A [ pos ] == m : <NEWLINE> <INDENT> res [ 0 ] = <STRING> <NEWLINE> return 0 <NEWLINE> <DEDENT> if pos + 1 > n - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> sum_A ( A , n , pos + 1 , sum + A [ pos ] , m , res ) <NEWLINE> sum_A ( A , n , pos + 1 , sum , m , res ) <NEWLINE> <NL> <DEDENT> for i , m_i in enumerate ( m ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> res = [ <STRING> ] <NEWLINE> sum_A ( A , n , 0 , sum , m_i , res ) <NEWLINE> print res [ 0 ] <NEWLINE> <DEDENT>
def ans ( n , AA , x ) : <NEWLINE> <INDENT> tmp = n + AA [ 0 ] <NEWLINE> if len ( AA ) == 1 : <NEWLINE> <INDENT> try : x [ tmp ] = 1 <NEWLINE> except : pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans ( n , AA [ 1 : ] , x ) <NEWLINE> try : <NEWLINE> <INDENT> x [ tmp ] = 1 <NEWLINE> ans ( tmp , AA [ 1 : ] , x ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> n = raw_input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = raw_input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> x = [ 0 for i in range ( max ( M ) + 1 ) ] <NEWLINE> f3 ( 0 , A , x ) <NEWLINE> <NL> for e in M : <NEWLINE> <INDENT> if x [ e ] == 1 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( j , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if j >= n or m > sum ( A ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = solve ( j + 1 , m ) or solve ( j + 1 , m - A [ j ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for i range ( 0 , q ) : <NEWLINE> <INDENT> if solve ( 0 , m [ i ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def soleve ( i , m , n ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = soleve ( i + 1 , m , n ) or soleve ( i + 1 , m - A [ i ] , n ) <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for m in M : <NEWLINE> <INDENT> if soleve ( 0 , m , n ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
num_n = input ( ) <NEWLINE> n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> num_m = input ( ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= num_n or m > sum ( n ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - n [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for k in m : <NEWLINE> <INDENT> if solve ( 0 , m [ k ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> <NL> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> q = input ( ) <NEWLINE> <NL> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m > sum ( A ) <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> from __future__ import print_function , division <NEWLINE> from itertools import combinations <NEWLINE> import time <NEWLINE> import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> import math <NEWLINE> start = time . clock ( ) <NEWLINE> i = 0 <NEWLINE> def enum_sum_numbers ( sets , s_range , r ) : <NEWLINE> <INDENT> for cmb in combinations ( sets , r ) : <NEWLINE> <INDENT> yield sum ( cmb ) <NEWLINE> <DEDENT> if r <= s_range : <NEWLINE> <INDENT> for s in enum_sum_numbers ( sets , s_range , r + 1 ) : <NEWLINE> <INDENT> yield s <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> sys . stdin . readline ( ) <NEWLINE> a = [ int ( s ) for s in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> sys . stdin . readline ( ) <NEWLINE> ms = [ int ( s ) for s in sys . stdin . readline ( ) . split ( ) ] <NEWLINE> sets = { s for s in enum_sum_numbers ( a , len ( a ) ) , 1 } <NEWLINE> for m in ms : <NEWLINE> <INDENT> print ( <STRING> if m in sets else <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> a = [ ] <NEWLINE> b = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] = input ( ) <NEWLINE> <NL> <DEDENT> m = input ( ) <NEWLINE> <NL> for j in range ( m ) : <NEWLINE> <INDENT> b [ j ] = input ( ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if b [ j ] - a [ i ] < 0 : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> <DEDENT> elif b [ j ] - a [ i ] == 0 : <NEWLINE> <INDENT> return yes <NEWLINE> <DEDENT> elif b [ j ] - a [ i ] > 0 : <NEWLINE> <INDENT> b [ j ] = b [ j ] - a [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return no <NEWLINE>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n and m > sum ( A ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for j in range ( 0 , q - 1 ) : <NEWLINE> <INDENT> if solve ( 0 , m [ j ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> input ( ) <NEWLINE> m = [ int ( input ( ) ) for _ in range ( n ) ] <NEWLINE> <NL> aa = [ 0 for _ in range ( n ** 2 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t = 2 ** i <NEWLINE> for j in range ( n ** 2 ) : <NEWLINE> <INDENT> if ( j // t ) % 2 : <NEWLINE> <INDENT> aa [ j ] += a [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> aa = set ( aa ) <NEWLINE> <NL> for k in m : <NEWLINE> <INDENT> if k in aa : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
wimport numpy as np <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> data = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> test = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = a + [ a [ j ] + data [ i ] for j in range ( len ( a ) ) ] <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if test [ i ] in a : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> minA = min ( a ) <NEWLINE> sumA = sum ( a ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - a [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for j in M : <NEWLINE> <INDENT> if j < minA or m > sumA : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if solve ( 0 , j ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for j in range ( 0 , q ) : <NEWLINE> <INDENT> if solve ( 0 , m [ j ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def solve ( a , m ) : <NEWLINE> <INDENT> if m < 0 or m > sumA : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if len ( a ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return solve ( a [ 1 : ] , m - a [ 0 ] ) or solve ( a [ 1 : ] , m ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> tmp = input ( ) . split ( ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( int ( tmp [ i ] ) ) <NEWLINE> <DEDENT> q = int ( input ( ) ) <NEWLINE> tmp = input ( ) . split ( ) <NEWLINE> m = [ ] <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> m . append ( int ( tmp [ i ] ) ) <NEWLINE> <NL> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> if solve ( a , m [ i ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : return True <NEWLINE> if i == n or m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> r1 = solve ( i + 1 , m ) <NEWLINE> r2 = solve ( i + 1 , m - A [ i ] ) <NEWLINE> <NL> return r1 or r2 <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in M : <NEWLINE> <INDENT> print <STRING> if solve ( 0 , i ) else <STRING> <NEWLINE> <DEDENT>
def solve ( p , t ) : <NEWLINE> <INDENT> global isExist , n , A <NEWLINE> isExist [ t ] = True <NEWLINE> if p < n : <NEWLINE> <INDENT> solve ( p + 1 , t - A [ p ] ) <NEWLINE> solve ( p + 1 , t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> isExist = [ False ] * 2001 <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> M = map ( int , input ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> s = sum ( A ) <NEWLINE> solve ( 0 , s ) <NEWLINE> for i in range ( 0 , q ) : <NEWLINE> <INDENT> if isExist [ M [ i ] ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def check ( m , g , A , n ) : <NEWLINE> <NL> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> gg = g + A [ n - i - 1 ] <NEWLINE> if m == gg : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif n == 0 or m < gg : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if check ( m , gg , A , n - i - 1 ) == True : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , str . split ( input ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , str . split ( input ( ) ) ) ) <NEWLINE> <NL> mini = min ( A ) <NEWLINE> nor = sum ( A ) <NEWLINE> <NL> for mi in m : <NEWLINE> <INDENT> if mi < mini or mi > nor : <NEWLINE> <INDENT> print ( no ) <NEWLINE> <DEDENT> if check ( mi , 0 , A , n ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> <NL> S = [ 0 ] * len ( A ) <NEWLINE> flags = [ False ] * len ( M ) <NEWLINE> def brute_force ( n ) : <NEWLINE> <INDENT> if n == len ( S ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> for i in range ( len ( S ) ) : <NEWLINE> <INDENT> if S [ i ] == 1 : ans += A [ i ] <NEWLINE> <DEDENT> for i in range ( len ( M ) ) : <NEWLINE> <INDENT> if ans == M [ i ] : flags [ i ] = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> S [ n ] = 0 <NEWLINE> brute_force ( n + 1 ) <NEWLINE> S [ n ] = 1 <NEWLINE> brute_force ( n + 1 ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> brute_force ( 0 ) <NEWLINE> <NL> for flag in flags : <NEWLINE> <INDENT> if flag : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if i > n or m > sum ( A ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for j in range ( 0 , q ) : <NEWLINE> <INDENT> if solve ( 0 , m [ j ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
num_n = int ( input ( ) ) <NEWLINE> n = map ( int , input ( ) . split ( ) ) <NEWLINE> num_m = int ( input ( ) ) <NEWLINE> m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= num_n or m > sum ( n ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - n [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for k in range ( num_m ) : <NEWLINE> <INDENT> if solve ( 0 , m [ k ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> memory = [ [ - 1 for i in range ( 2000 ) ] for j in range ( n ) ] <NEWLINE> <NL> def f ( i , k , sum ) : <NEWLINE> <INDENT> if memory [ i ] [ sum ] != - 1 : <NEWLINE> <INDENT> return memory [ i ] [ sum ] <NEWLINE> <DEDENT> if sum == k : <NEWLINE> <INDENT> memory [ i ] [ sum ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> elif sum > k : <NEWLINE> <INDENT> memory [ i ] [ sum ] = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res0 = f ( i + 1 , k , sum ) <NEWLINE> res1 = f ( i + 1 , k , sum + a [ i ] ) <NEWLINE> <NL> if res0 or res1 : <NEWLINE> <INDENT> memory [ i ] [ sum ] = 1 <NEWLINE> return 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memory [ i ] [ m ] = 0 <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in m : <NEWLINE> <INDENT> print ( <STRING> if f ( 0 , k , 0 ) else <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> def solve_recursively ( candidate_numbers , target_number ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if target_number == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif len ( candidate_numbers ) == 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> solution = solve_recursively ( candidate_numbers [ 1 : ] , target_number - candidate_numbers [ 0 ] ) or solve_recursively ( <NEWLINE> <INDENT> candidate_numbers [ 1 : ] , target_number ) <NEWLINE> <NL> <DEDENT> return solution <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> raw_input ( ) <COMMENT> <NEWLINE> candidate_numbers = [ int ( x ) for x in raw_input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> raw_input ( ) <COMMENT> <NEWLINE> target_numbers = [ int ( x ) for x in raw_input ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> for target_number in target_numbers : <NEWLINE> <INDENT> if solve_recursively ( candidate_numbers , target_number ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
A_count = int ( input ( ) ) ; <NEWLINE> A = [ int ( n ) for n in input ( ) . split ( ) ] ; <NEWLINE> M_count = int ( input ( ) ) ; <NEWLINE> M = [ int ( n ) for n in input ( ) . split ( ) ] ; <NEWLINE> <NL> memo = [ [ None for i in range ( 2000 ) ] for j in range ( A_count ) ] ; <NEWLINE> <NL> def solve ( start , target ) : <NEWLINE> <INDENT> if memo [ start ] [ target ] is not None : <NEWLINE> <INDENT> return memo [ start ] [ target ] ; <NEWLINE> <DEDENT> if target == 0 : <NEWLINE> <INDENT> return True ; <NEWLINE> <DEDENT> elif start >= A_count : <NEWLINE> <INDENT> return False ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> result = solve ( start + 1 , target ) or solve ( start + 1 , target - A [ start ] ) ; <NEWLINE> if result : <NEWLINE> <INDENT> memo [ start ] [ target ] = True ; <NEWLINE> return True ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> memo [ start ] [ target ] = False ; <NEWLINE> return False ; <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) ; <NEWLINE> <DEDENT> <DEDENT>
for i in range ( n ) : <NEWLINE> <INDENT> sum_n = A [ i ] <NEWLINE> for j in range ( q ) : <NEWLINE> <INDENT> if M [ j ] == sum_n : <NEWLINE> <INDENT> result [ j ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for j in range ( n - 1 - i ) : <NEWLINE> <INDENT> sum_n = A [ i ] <NEWLINE> ad = A [ i + j + 1 ] <NEWLINE> sum_n = sum_n + ad <NEWLINE> for k in range ( q ) : <NEWLINE> <INDENT> if M [ k ] == sum_n : <NEWLINE> <INDENT> result [ k ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for k in range ( n - 2 - i - j ) : <NEWLINE> <INDENT> ad = ad + A [ i + j + 2 + k ] <NEWLINE> sum_n = sum_n + ad <NEWLINE> for l in range ( q ) : <NEWLINE> <INDENT> if M [ l ] == sum_n : <NEWLINE> <INDENT> result [ l ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
import numpy as np <NEWLINE> <NL> n = input ( ) <NEWLINE> n = int ( n ) <NEWLINE> a = input ( ) <NEWLINE> a = a . split ( ) <NEWLINE> a = [ int ( x ) for x in a ] <NEWLINE> <NL> q = input ( ) <NEWLINE> q = int ( q ) <NEWLINE> ms = input ( ) <NEWLINE> ms = ms . split ( ) <NEWLINE> ms = [ int ( x ) for x in ms ] <NEWLINE> <NL> np . sort ( a ) <NEWLINE> a = np . array ( a ) <NEWLINE> for m in ms : <NEWLINE> <INDENT> if m > a [ - 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a . any ( ) == m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a_new = a [ a < m ] <NEWLINE> print ( a_new ) <NEWLINE> select = [ ] <NEWLINE> length = len ( a_new ) <NEWLINE> selects = np . zeros ( 2 ** length , length ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> r = set ( ) <NEWLINE> def f ( s , k ) : <NEWLINE> <INDENT> if k >= 0 : <NEWLINE> <INDENT> global r <NEWLINE> r |= set ( s ) <NEWLINE> f ( s + A [ k - 1 ] , k - 1 ) <NEWLINE> f ( s , k - 1 ) <NEWLINE> <DEDENT> <DEDENT> f ( 0 , n ) <NEWLINE> input ( ) <NEWLINE> for e in map ( int , input ( ) . split ( ) ) : print ( [ <STRING> , <STRING> ] [ e in r ] ) <NEWLINE>
def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> return solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for m_i in m : <NEWLINE> <INDENT> print <STRING> if solve ( 0 , m_i ) else <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def ans ( i , M ) : <NEWLINE> <INDENT> if M == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if i >= n or m > sum ( A ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = ans ( i + 1 , M ) or ans ( i + 1 , M - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for j in range ( 0 , q ) : <NEWLINE> <INDENT> if ans ( 0 , M [ j ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = input ( ) <NEWLINE> A = [ int ( s ) for s in A . split ( ) ] <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = input ( ) <NEWLINE> m = [ int ( s ) for s in m . split ( ) ] <NEWLINE> <NL> ans = <STRING> <NEWLINE> s = sum ( A ) <NEWLINE> for mm in m : <NEWLINE> <INDENT> if s < mm : <NEWLINE> <INDENT> ans += <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans += solve ( 0 , mm ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> print ( <STRING> . join ( ans ) ) <NEWLINE>
from numba . decorators import jit <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( input ( ) . split ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = int ( A [ i ] ) <NEWLINE> <DEDENT> m = int ( input ( ) ) <NEWLINE> B = list ( input ( ) . split ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> B [ i ] = int ( B [ i ] ) <NEWLINE> <NL> <DEDENT> def solve ( x , y ) : <NEWLINE> <INDENT> if x == n : <NEWLINE> <INDENT> S [ y ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> solve ( x + 1 , y ) <NEWLINE> if y + A [ x ] < 2001 : <NEWLINE> <INDENT> solve ( x + 1 , y + A [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> S = [ 0 for i in range ( 2001 ) ] <NEWLINE> <NL> solve ( 0 , 0 ) <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> if S [ B [ i ] ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
n_n = int ( input ( ) ) <NEWLINE> n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n_m = int ( input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n_n or m > sum ( n ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - n [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for k in range ( m_m ) : <NEWLINE> <INDENT> if solve ( 0 , m [ k ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> def func ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif m < 0 or i >= len ( A ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if func ( i + 1 , m - A [ i ] ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if func ( i + 1 , m ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> if func ( 0 , M [ i ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> <NL> f = [ ] <NEWLINE> f [ 1 ] = 1 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = input ( ) <NEWLINE> for j in range ( 2000 ) : <NEWLINE> <INDENT> if ( j + A [ i ] < 2000 & & f [ j ] == 1 ) : <NEWLINE> <INDENT> f [ j + A [ i ] ] == 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> Q = input ( ) <NEWLINE> for i in range ( Q ) : <NEWLINE> <INDENT> B [ i ] = input ( ) <NEWLINE> <INDENT> if ( f [ B [ i ] - 1 ] == 1 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = int ( input ( ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> T = [ [ 0 ] * 2001 for i in range ( n ) ] <NEWLINE> <NL> T [ 0 ] [ 0 ] = 1 <NEWLINE> T [ 0 ] [ A [ 0 ] ] = 1 <NEWLINE> for i in range ( 1 : n ) : <NEWLINE> <INDENT> for j in range ( 2001 ) : <NEWLINE> <INDENT> T [ i ] [ j ] = T [ i - 1 ] [ j ] <NEWLINE> if ( j - B [ i ] >= 0 ) and ( T [ i - 1 ] [ j - B [ i ] ] == 1 ) : <NEWLINE> <INDENT> T [ i ] [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if T [ n - 1 ] [ B [ i ] ] == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> box = [ ] <NEWLINE> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> b = <STRING> . format ( i , n ) <NEWLINE> tmp = [ ] <NEWLINE> for j in rangee ( n ) : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> if b [ j ] == <STRING> : <NEWLINE> <INDENT> tmp . append ( A [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> sum_list . append ( box ( tmp ) ) <NEWLINE> <NL> <DEDENT> for k in m : <NEWLINE> <INDENT> if k in box : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def solve ( i , m ) : <NEWLINE> <INDENT> if dp [ i ] [ m ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ m ] <NEWLINE> <NL> <DEDENT> if m == 0 : <NEWLINE> <INDENT> dp [ i ] [ m ] = 1 <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> dp [ i ] [ m ] = 0 <NEWLINE> <DEDENT> elif solve ( i + 1 , m ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = 1 <NEWLINE> <DEDENT> elif solve ( i + 1 , m - A [ i ] ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ m ] = 0 <NEWLINE> <NL> <DEDENT> return dp [ i ] [ m ] <NEWLINE> <NL> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p = input ( ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> dp = [ [ - 1 for col in range ( 2000 ) ] for row in range ( n ) ] <NEWLINE> <NL> for i in range ( p ) : <NEWLINE> <INDENT> if solve ( 0 , m [ i ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if i >= n or m - sum ( A ) > 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> <INDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> if solve ( 0 , m [ j ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
<NL> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if dp [ i ] [ m ] != - 1 : <NEWLINE> <INDENT> return dp [ i ] [ m ] <NEWLINE> <DEDENT> if m == 0 : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> dp [ i ] [ m ] = False <NEWLINE> <DEDENT> elif solve ( i + 1 , m ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> elif solve ( i + 1 , m - a [ i ] ) : <NEWLINE> <INDENT> dp [ i ] [ m ] = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ m ] = False <NEWLINE> <DEDENT> return dp [ i ] [ m ] <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> p = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dp = [ [ - 1 for i in xrange ( max ( p ) + 1 ) ] for j in xrange ( n + 1 ) ] <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> if solve ( 0 , p [ i ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m = 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m > sum ( A ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n1 = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n2 = int ( input ( ) ) <NEWLINE> q = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> B = [ ] <NEWLINE> <NL> n = n1 <NEWLINE> ans = list ( <STRING> for i in range ( n2 ) ) <NEWLINE> <NL> for i in range ( 2 ** n ) : <NEWLINE> <INDENT> C0 = [ ] <NEWLINE> B = list ( map ( int , format ( i , <STRING> ) . zfill ( n ) ) ) [ : : - 1 ] <NEWLINE> C0 = [ x * y for x , y in zip ( A , B ) ] <NEWLINE> C . append ( sum ( C0 ) ) <NEWLINE> <NL> <DEDENT> for j , r in enumerate ( q ) : <NEWLINE> <INDENT> if r in C : <NEWLINE> <INDENT> ans [ j ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> print ( * ans , sep = <STRING> ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - a [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for tmp_m in m : <NEWLINE> <INDENT> if sum ( a ) < tmp_m : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif solve ( 0 , tmp_m ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> mi = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = solve ( i + 1 , m ) | solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> <DEDENT> for m in mi : <NEWLINE> <INDENT> if solve ( 0 , m ) : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT>
def solve ( Mi , i ) : <NEWLINE> <INDENT> if Mi == 0 : return True <NEWLINE> if i < n and Mi > 0 : <NEWLINE> <INDENT> r1 = solve ( Mi - A [ i ] , i + 1 ) <NEWLINE> r2 = solve ( Mi , i + 1 ) <NEWLINE> if r1 : return r1 <NEWLINE> if r2 : return r2 <NEWLINE> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for Mi in M : <NEWLINE> <INDENT> print <STRING> if solve ( Mi , 0 ) else <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> def exhaustiveSearch ( A , m , i ) : <NEWLINE> <INDENT> if A [ i ] == m : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif i == len ( A ) - 1 or m < 0 : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> return exhaustiveSearch ( A , m , i + 1 ) or exhaustiveSearch ( A , m - A [ i ] , i + 1 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> A = map ( int , lines [ 1 ] . split ( ) ) <NEWLINE> M = map ( int , lines [ 3 ] . split ( ) ) <NEWLINE> <NL> for m in M : <NEWLINE> <INDENT> if exhaustiveSearch ( A , m , 0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> import itertools as itr <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> sum_array = [ ] <NEWLINE> for r in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for comb in itr . combinations ( a , r ) : <NEWLINE> <INDENT> sum_array . append [ sum ( comb ) ] <NEWLINE> <NL> <DEDENT> <DEDENT> for i in m : <NEWLINE> <INDENT> yesorno = <STRING> <NEWLINE> for j in sum_array : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> yesorno == <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
def solve ( pos , tot , A ) : <NEWLINE> <INDENT> if tot == 0 : return True <NEWLINE> if pos > len ( A ) - 1 : return False <NEWLINE> <NL> return solve ( pos + 1 , tot - A [ pos ] , A ) or solve ( pos + 1 , tot , A ) <NEWLINE> <NL> <DEDENT> n = raw_input ( ) <NEWLINE> b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n = raw_input ( ) <NEWLINE> t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for tt in t : <NEWLINE> <INDENT> print <STRING> if True == solve ( 0 , tt , b ) else <STRING> <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> <NL> memo = [ ] <NEWLINE> for i in range ( len ( A ) + 1 ) : <NEWLINE> <INDENT> memo . append ( [ None ] * 2000 ) <NEWLINE> <NL> <DEDENT> def solve ( i , m ) : <NEWLINE> <INDENT> if memo [ i ] [ m ] != None : return memo [ i ] [ m ] <NEWLINE> if m == 0 : <NEWLINE> <INDENT> memo [ i ] [ m ] = True <NEWLINE> return True <NEWLINE> <DEDENT> elif i >= n : <NEWLINE> <INDENT> memo [ i ] [ m ] = False <NEWLINE> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return solve ( i + 1 , m ) | solve ( i + 1 , m - A [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m > sum ( A ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> for m in M : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = input ( ) <NEWLINE> <NL> aset = set ( ) <NEWLINE> for i in range ( 1 , len ( a ) + 1 ) : <NEWLINE> <INDENT> aset |= set ( sum ( combi ) for combi in itertools . combinations ( a , i ) ) <NEWLINE> <NL> <DEDENT> for m in map ( int , input ( ) . split ( ) ) : <NEWLINE> <INDENT> print ( <STRING> if m in aset else <STRING> ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return 1 <NEWLINE> <DEDENT> if i >= n : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for m in M : <NEWLINE> <INDENT> res = solve ( 0 , m ) <NEWLINE> if res : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from sets import Set <NEWLINE> <NL> input ( ) <NEWLINE> n_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> input ( ) <NEWLINE> m_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> n = len ( n_list ) <NEWLINE> <NL> pool = Set ( [ ] ) <NEWLINE> <NL> def func ( idx , m ) : <NEWLINE> <NL> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if idx >= n : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = func ( idx + 1 , m ) | func ( idx + 1 , m - n_list [ idx ] ) <NEWLINE> <NL> if res : <NEWLINE> <INDENT> pool . add ( m ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> for v in m_list : <NEWLINE> <INDENT> if v in pool : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> if func ( 0 , v ) else <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> mi = map ( int , input ( ) . split ( ) ) <NEWLINE> t = { } <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if ( m == 0 ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if ( i >= n ) : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if ( i , m ) in t : <NEWLINE> <INDENT> return t [ ( i , m ) ] <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) <NEWLINE> t [ ( i , m ) ] = res <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> if solve ( 0 , mi ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def tansaku ( Mi , i ) : <NEWLINE> <INDENT> if Mi == 0 : return True <NEWLINE> if i < n and min ( A [ i : ] <= Mi <= sum ( A [ i : ] ) : <NEWLINE> <INDENT> r1 = tansaku ( Mi - A [ i ] , i + 1 ) <COMMENT> <NEWLINE> if r1 : return r1 <NEWLINE> r2 = tansaku ( Mi , i + 1 ) <NEWLINE> if r2 : return r2 <NEWLINE> <NL> <DEDENT> <DEDENT> for Mi in M : <NEWLINE> <INDENT> print <STRING> if solve ( Mi , 0 ) else <STRING> <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if i >= n or m - sum ( A ) > 0 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for j in range ( q ) : <NEWLINE> <INDENT> if solve ( 0 , M [ j ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = input ( ) <NEWLINE> M = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> def solve ( i , m ) : <NEWLINE> <INDENT> if m == 0 : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> if n <= i or sum ( A ) < m : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> res = ( solve ( i + 1 , m ) or solve ( i + 1 , m - A [ i ] ) ) <NEWLINE> return res <NEWLINE> <NL> <DEDENT> for m in range ( M ) : <NEWLINE> <INDENT> if solve ( 0 , m ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import math <NEWLINE> sentinel = 1e9 + 1 <NEWLINE> counter = 0 <NEWLINE> def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> global counter <NEWLINE> L = a [ left : mid ] + [ SEN ] <NEWLINE> R = a [ mid : right ] + [ SEN ] <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if ( L [ i ] <= R [ j ] ) : <NEWLINE> <INDENT> a [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> counter += right - left <NEWLINE> <DEDENT> def mergeSort ( a , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( a , left , mid ) <NEWLINE> mergeSort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( a , 0 , n ) <NEWLINE> print ( * a ) <NEWLINE> print ( counter ) <NEWLINE> <NL>
INFTY = 10 ** 10 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left ; <NEWLINE> n2 = right - mid ; <NEWLINE> <NL> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> L = A [ left : left + n1 ] <NEWLINE> R = A [ mid : mid + n2 ] <NEWLINE> <NL> L . append ( INFTY ) <NEWLINE> R . append ( INFTY ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) ; <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> <NL> n = sys . stdin . readline ( ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> items = line . strip ( ) . split ( ) <NEWLINE> items = [ int ( x ) for x in items ] <NEWLINE> mergeSort ( items , 0 , len ( items ) ) <NEWLINE> print ( <STRING> . join ( map ( str , items ) ) ) <NEWLINE> print ( count ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> infinity = pow ( 10 , 9 ) + 1 <NEWLINE> <NL> <NL> def merge ( ns , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> left_ns = ns [ left : mid ] <NEWLINE> right_ns = ns [ mid : right ] <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> left_ns [ n1 ] = infinity <NEWLINE> right_ns [ n2 ] = infinity <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if left_ns [ i ] <= right_ns [ j ] : <NEWLINE> <INDENT> ns [ k ] = left_ns [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ns [ k ] = right_ns [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( ns , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( ns , left , mid ) <NEWLINE> merge_sort ( ns , mid , right ) <NEWLINE> merge ( ns , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> ns = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> left = 0 <NEWLINE> right = len ( ns ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( ns , left , right ) <NEWLINE> <NL> print ( * ns ) <NEWLINE> print ( count ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> S = list ( map ( int , input ( ) , split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> mergeSort ( S , 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , S ) ) ) <NEWLINE> print ( cnt ) <NEWLINE>
def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = a [ left : left + n1 ] + SENTINEL <NEWLINE> R = a [ mid : mid + n2 ] + SENTINEL <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> a [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <DEDENT> def merge_sort ( a , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( a , left , mid ) <NEWLINE> merge_sort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> SENTINEL = 1000000001 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( a , 0 , len ( a ) ) <NEWLINE> print ( <STRING> . join ( map ( str , a ) ) ) <NEWLINE> print ( count ) <NEWLINE>
global count <NEWLINE> acount = 0 <NEWLINE> <NL> <NL> def merge ( num_list , left , mid , right ) : <NEWLINE> <INDENT> a = mid - left <NEWLINE> b = right - mid <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> <NL> for i in range ( a ) : <NEWLINE> <INDENT> L . append ( num_list [ left + i ] ) <NEWLINE> <DEDENT> for i in range ( b ) : <NEWLINE> <INDENT> R . append ( num_list [ mid + i ] ) <NEWLINE> <NL> <DEDENT> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> global count <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> num_list [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_list [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> count += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def mergeSort ( num_list , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> mergeSort ( num_list , left , mid ) <NEWLINE> mergeSort ( num_list , mid , right ) <NEWLINE> merge ( num_list , left , mid , right ) <NEWLINE> <NL> <DEDENT> return num_list <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> num = raw_input ( ) <NEWLINE> line = raw_input ( ) <NEWLINE> <NL> num_list = line . strip ( ) . split ( ) <NEWLINE> num_list = map ( int , num_list ) <NEWLINE> <NL> merge_list = mergeSort ( num_list , 0 , len ( num_list ) ) <NEWLINE> merge_list = map ( str , merge_list ) <NEWLINE> print <STRING> . join ( merge_list ) <NEWLINE> print count <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> count = 0 <NEWLINE> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = deque ( A [ left : mid ] ) <NEWLINE> R = deque ( A [ mid : right ] ) <NEWLINE> L . append ( 10 ** 9 ) <NEWLINE> R . append ( 10 ** 9 ) <NEWLINE> <NL> global count <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ 0 ] <= R [ 0 ] : <NEWLINE> <INDENT> A [ k ] = L . popleft ( ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R . popleft ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> middle = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , middle ) <NEWLINE> mergeSort ( A , middle , right ) <NEWLINE> merge ( A , left , middle , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> input ( ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( l , 0 , len ( l ) ) <NEWLINE> print ( <STRING> . join ( l ) ) <NEWLINE> print ( count ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> L = A [ left : mid ] + [ 10 ** 9 + 1 ] <NEWLINE> R = A [ mid : right ] + [ 10 ** 9 + 1 ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ i ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> mergeSort ( A , 0 , N ) <NEWLINE> print ( * A ) <NEWLINE> print ( count ) <NEWLINE>
def f ( ) : <NEWLINE> <INDENT> return int ( raw_input ( ) ) <NEWLINE> <DEDENT> def f2 ( ) : <NEWLINE> <INDENT> return map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> def merge ( left , mid , right ) : <NEWLINE> <INDENT> L = S [ left : mid ] <NEWLINE> R = S [ mid : right ] <NEWLINE> x = [ ] <NEWLINE> c = right - left <NEWLINE> lp = 0 <NEWLINE> rp = 0 <NEWLINE> fa = True <NEWLINE> fb = True <NEWLINE> while True : <NEWLINE> <INDENT> if fa : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a = L [ lp ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> lp += 1 <NEWLINE> fa = False <NEWLINE> <DEDENT> if fb : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> b = R [ rp ] <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rp += 1 <NEWLINE> fb = False <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> x . append ( a ) <NEWLINE> fa = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . append ( b ) <NEWLINE> fb = True <NEWLINE> <DEDENT> <DEDENT> if fa : <NEWLINE> <INDENT> x . extend ( R [ rp - 1 : ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . extend ( L [ lp - 1 : ] ) <NEWLINE> <DEDENT> S [ left : right ] = x <NEWLINE> return c <NEWLINE> <NL> <DEDENT> def mergesort ( left , right ) : <NEWLINE> <INDENT> c = 0 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> c += mergesort ( left , mid ) <NEWLINE> c += mergesort ( mid , right ) <NEWLINE> c += merge ( left , mid , right ) <NEWLINE> <DEDENT> return c <NEWLINE> <NL> <DEDENT> global S <NEWLINE> n = f ( ) <NEWLINE> S = f2 ( ) <NEWLINE> <NL> c = mergesort ( 0 , n ) <NEWLINE> print <STRING> . join ( map ( str , S ) ) <NEWLINE> print c <NEWLINE>
def mergeSort ( num_list , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> mergeSort ( num_list , left , mid ) <NEWLINE> mergeSort ( num_list , mid , right ) <NEWLINE> merge ( num_list , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( num_list , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> for i in range ( mid - left ) : <NEWLINE> <INDENT> L . append ( int ( num_list [ left + i ] ) ) <NEWLINE> <DEDENT> L . append ( float ( <STRING> ) ) <NEWLINE> for i in range ( right - mid ) : <NEWLINE> <INDENT> R . append ( int ( num_list [ mid + i ] ) ) <NEWLINE> <DEDENT> R . append ( float ( <STRING> ) ) <NEWLINE> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> num_list [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> count += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num_list [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> count += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> count = 0 <NEWLINE> n = int ( raw_input ( ) ) <NEWLINE> a = raw_input ( ) <NEWLINE> l = [ ] <NEWLINE> l = a . split ( <STRING> ) <NEWLINE> mergeSort ( l , 0 , n ) <NEWLINE> <NL> print <STRING> . join ( map ( str , l ) ) <NEWLINE> print count <NEWLINE>
n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> SENTINEL = 10 ** 9 + 1 <NEWLINE> count = 0 <NEWLINE> <NL> def merge ( S , left , mid , right ) : <NEWLINE> <INDENT> L = S [ left : mid ] + [ SENTINEL ] <NEWLINE> R = S [ mid : right ] + [ SENTINEL ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if ( L [ i ] <= R [ j ] ) : <NEWLINE> <INDENT> S [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <DEDENT> def mergeSort ( S , left , right ) : <NEWLINE> <INDENT> if ( left + 1 < right ) : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( S , left , mid ) <NEWLINE> mergeSort ( S , mid , right ) <NEWLINE> merge ( S , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> mergeSort ( S , 0 , n ) <NEWLINE> print ( * S ) <NEWLINE> print ( count ) <NEWLINE>
def merge ( tS , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> n1 = mid - left ; <NEWLINE> n2 = right - mid ; <NEWLINE> tL = tS [ left : mid ] ; <NEWLINE> tR = tS [ mid : right ] ; <NEWLINE> tL . append ( 1000000001 ) <NEWLINE> tR . append ( 1000000001 ) <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if tL [ i ] <= tR [ j ] : <NEWLINE> <INDENT> tS [ k ] = tL [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tS [ k ] = tR [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( tS , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> mergeSort ( tS , left , mid ) <NEWLINE> mergeSort ( tS , mid , right ) <NEWLINE> merge ( tS , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> arrS = [ int ( val ) for val in input ( ) . split ( <STRING> ) ] <NEWLINE> cnt = 0 <NEWLINE> mergeSort ( arrS , 0 , n ) <NEWLINE> print ( <STRING> . join ( map ( str , arrS ) ) ) <NEWLINE> print ( cnt ) <NEWLINE>
m = 0 <NEWLINE> def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> el = range ( 0 , n1 + 1 ) <NEWLINE> ar = range ( 0 , n2 + 1 ) <NEWLINE> for i in range ( n1 ) : <NEWLINE> <INDENT> el [ i ] = a [ left + i ] <NEWLINE> <DEDENT> for i in range ( n2 ) : <NEWLINE> <INDENT> ar [ i ] = a [ mid + i ] <NEWLINE> <DEDENT> el [ n1 ] = float ( <STRING> ) <NEWLINE> ar [ n2 ] = float ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> global m <NEWLINE> m += 1 <NEWLINE> if ( el [ i ] <= ar [ j ] ) : <NEWLINE> <INDENT> a [ k ] = el [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = ar [ j ] <NEWLINE> j = j + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( a , left , right ) : <NEWLINE> <INDENT> if ( left + 1 < right ) : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( a , left , mid ) <NEWLINE> merge_sort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if ( a [ left ] > a [ right - 1 ] ) : <NEWLINE> <INDENT> a [ left ] , a [ right - 1 ] = a [ right ] , a [ left ] <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> s = input ( ) <NEWLINE> a = list ( map ( int , s . split ( ) ) ) <NEWLINE> merge_sort ( a , 0 , n ) <NEWLINE> a = map ( str , a ) <NEWLINE> print ( <STRING> . join ( list ( a ) ) ) <NEWLINE> print ( m ) <NEWLINE>
cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> <COMMENT> <NL> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> L = [ 0 ] * ( n1 + 1 ) <NEWLINE> R = [ 0 ] * ( n2 + 1 ) <NEWLINE> <NL> for i in range ( int ( n1 ) ) : <NEWLINE> <INDENT> L [ i ] = A [ left + i ] <NEWLINE> <DEDENT> for i in range ( int ( n2 ) ) : <NEWLINE> <INDENT> R [ i ] = A [ mid + i ] <NEWLINE> <DEDENT> L [ n1 ] = 999999999 <NEWLINE> R [ n2 ] = 999999999 <NEWLINE> i , j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <COMMENT> <NL> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( S , 0 , n ) <NEWLINE> S = map ( str , S ) <NEWLINE> print ( <STRING> . join ( S ) ) <NEWLINE> print ( cnt ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <NL> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L [ n1 ] = float ( <STRING> ) <NEWLINE> R [ n2 ] = float ( <STRING> ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> global cnt <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> return cnt <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> mergeSort ( A , 0 , len ( A ) ) <NEWLINE> print ( * A ) <NEWLINE> print ( str ( cnt ) ) <NEWLINE>
def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> R . append [ 1000000001 ] <NEWLINE> L . append [ 1000000001 ] <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( A , 0 , N ) <NEWLINE> print ( * A ) <NEWLINE> print ( count ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> L = A [ left : mid ] + [ 1000000001 ] <NEWLINE> R = A [ mid : right ] + [ 1000000001 ] <NEWLINE> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> R . append [ 1000000001 ] <NEWLINE> L . append [ 1000000001 ] <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> count += right - left <NEWLINE> <NL> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( A , 0 , N ) <NEWLINE> print ( * A ) <NEWLINE> print ( count ) <NEWLINE>
def m ( L , R ) : <NEWLINE> <INDENT> T = [ ] <NEWLINE> for l in L [ : : - 1 ] : <NEWLINE> <INDENT> while R and R [ - 1 ] > l : T += [ R . pop ( ) ] <NEWLINE> T += [ l ] <NEWLINE> <DEDENT> return R + T [ : : - 1 ] <NEWLINE> <DEDENT> def d ( A ) : <NEWLINE> <INDENT> l = len ( A ) ; global c ; c += l <NEWLINE> s = l // 2 ; return m ( d ( A [ : s ] ) , d ( A [ s : ] ) ) if l > 1 else A <NEWLINE> <DEDENT> def s ( ) : <NEWLINE> <INDENT> c = - int ( input ( ) ) <NEWLINE> print ( * d ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> print ( c ) <NEWLINE> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> cnt = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def merge_sort ( a , left , right ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( a , left , mid ) <NEWLINE> merge_sort ( a , mid , right ) <NEWLINE> merge ( a , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def merge ( a , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <NL> l = a [ left : n1 ] <NEWLINE> r = a [ mid : n2 ] <NEWLINE> <NL> l . append ( 10 ** 10 ) <NEWLINE> r . append ( 10 ** 10 ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> if l [ i ] <= r [ j ] : <NEWLINE> <INDENT> a [ k ] = l [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ k ] = r [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> merge_sort ( a , 0 , len ( a ) ) <NEWLINE> print ( a [ 0 ] , end = <STRING> ) <NEWLINE> for i in range ( 1 , len ( a ) ) : <NEWLINE> <INDENT> print ( <STRING> . format ( a [ i ] ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> print ( cnt ) <NEWLINE> <NL>
counter = 0 <NEWLINE> <NL> def merge ( L , R , left , right ) : <NEWLINE> <INDENT> A = range ( 0 , right - left ) <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> <NL> i , j = ( 0 , 0 ) <NEWLINE> global counter <NEWLINE> for n in range ( 0 , right - left ) : <NEWLINE> <INDENT> counter = counter + 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ n ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ n ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> return A <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = int ( ( left + right ) / 2 ) <NEWLINE> L = mergeSort ( A [ left : mid ] , 0 , mid - left ) <NEWLINE> R = mergeSort ( A [ mid : right ] , 0 , right - mid ) <NEWLINE> A = merge ( L , R , left , right ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ll = mergeSort ( l , 0 , n ) <NEWLINE> print ( * ll ) <NEWLINE> print ( counter ) <NEWLINE>
N = int ( raw_input ( ) ) <NEWLINE> count = 0 <NEWLINE> <NL> A_str = raw_input ( ) . split ( ) <NEWLINE> A = map ( int , A_str ) <NEWLINE> <NL> def merge ( left , right ) : <NEWLINE> <INDENT> global count <NEWLINE> sorted_list = [ ] <NEWLINE> l_index = 0 <NEWLINE> r_index = 0 <NEWLINE> <NL> while l_index < len ( left ) and r_index < len ( right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if left [ l_index ] <= right [ r_index ] : <NEWLINE> <INDENT> sorted_list . append ( left [ l_index ] ) <NEWLINE> l_index += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> sorted_list . append ( right [ r_index ] ) <NEWLINE> r_index += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if len ( left ) != l_index : <NEWLINE> <INDENT> sorted_list . extend ( left [ l_index : ] ) <NEWLINE> count += len ( left [ l_index : ] ) <NEWLINE> <DEDENT> if len ( right ) != r_index : <NEWLINE> <INDENT> sorted_list . extend ( right [ r_index : ] ) <NEWLINE> count += len ( right [ r_index : ] ) <NEWLINE> <NL> <DEDENT> return sorted_list <NEWLINE> <NL> <DEDENT> def mergeSort ( A ) : <NEWLINE> <NL> <INDENT> if len ( A ) <= 1 : <NEWLINE> <INDENT> return A <NEWLINE> <NL> <DEDENT> mid = len ( A ) // 2 <NEWLINE> left = A [ : mid ] <NEWLINE> right = A [ mid : ] <NEWLINE> <NL> left = mergeSort ( left ) <NEWLINE> right = mergeSort ( right ) <NEWLINE> <NL> return list ( merge ( left , right ) ) <NEWLINE> <NL> <DEDENT> print <STRING> . join ( map ( str , mergeSort ( A ) ) ) print count <NEWLINE> print count <NEWLINE>
def f ( n ) : <NEWLINE> <INDENT> return 0 if n < 2 else n + f ( n / 2 ) + f ( n - n / 2 ) <NEWLINE> <DEDENT> n = f ( input ( ) ) <NEWLINE> print <STRING> . join ( sorted ( raw_input ( ) . split ( ) , key = int ) ) , <STRING> , n <NEWLINE>
global cmt <NEWLINE> cmt = 0 <NEWLINE> def Merge ( left , right ) : <NEWLINE> <INDENT> global cmt <NEWLINE> lst = [ ] <NEWLINE> i , j = 0 , 0 <NEWLINE> while i < len ( left ) and j < len ( right ) : <NEWLINE> <INDENT> if left [ i ] <= right [ j ] : <NEWLINE> <INDENT> lst . append ( left [ i ] ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst . append ( right [ j ] ) <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> lst += left [ i : ] <NEWLINE> lst += right [ j : ] <NEWLINE> cmt += len ( lst ) <NEWLINE> <NL> return lst <NEWLINE> <NL> <DEDENT> def MergeSort ( A ) : <NEWLINE> <INDENT> if len ( A ) == 1 : return A <NEWLINE> mid = len ( A ) / 2 <NEWLINE> left = MergeSort ( A [ : mid ] ) <NEWLINE> right = MergeSort ( A [ mid : ] ) <NEWLINE> <COMMENT> <NL> sortedList = Merge ( left , right ) <NEWLINE> return sortedList <NEWLINE> <NL> <DEDENT> n = raw_input ( ) <NEWLINE> output , i = <STRING> , 0 <NEWLINE> for n in MergeSort ( map ( int , raw_input ( ) . split ( ) ) ) : <NEWLINE> <INDENT> output += str ( n ) if i == 0 else <STRING> + str ( n ) <NEWLINE> i += 1 <NEWLINE> <DEDENT> print output , <STRING> , cmt <NEWLINE>
def merge_sort ( alist ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def _sort ( left , right ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> count += _sort ( left , mid ) <NEWLINE> count += _sort ( mid , right ) <NEWLINE> count += merge ( left , mid , right ) <NEWLINE> <NL> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def merge ( left , mid , right ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> ll = alist [ left : mid ] + [ SENTINEL ] <NEWLINE> rl = alist [ mid : right ] + [ SENTINEL ] <NEWLINE> <NL> i = j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if ll [ i ] <= rl [ j ] : <NEWLINE> <INDENT> alist [ k ] = ll [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> alist [ k ] = rl [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> comp = _sort ( 0 , len ( alist ) ) <NEWLINE> return ( comp , alist ) <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> _ = int ( input ( ) ) <COMMENT> <NEWLINE> <NL> li = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> ( c , s ) = merge_sort ( li ) <NEWLINE> print ( <STRING> . join ( [ str ( i ) for i in s ] ) ) <NEWLINE> print ( c ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <NL> <DEDENT>
def m ( L , R ) : <NEWLINE> <INDENT> T = [ ] <NEWLINE> for l in L [ : : - 1 ] : <NEWLINE> <INDENT> while R and R [ - 1 ] > l : T += [ R . pop ( ) ] <NEWLINE> T += [ l ] <NEWLINE> <DEDENT> return R + T [ : : - 1 ] <NEWLINE> <DEDENT> def d ( A ) : <NEWLINE> <INDENT> l = len ( A ) ; global c ; c += l <NEWLINE> s = l // 2 ; return m ( d ( A [ : s ] ) , d ( A [ s : ] ) ) if l > 1 else A <NEWLINE> <DEDENT> c = - int ( input ( ) ) <NEWLINE> print ( * d ( list ( map ( int , input ( ) . split ( ) ) ) ) ) <NEWLINE> print ( c - n ) <NEWLINE>
import sys <NEWLINE> <NL> compare_counter = 0 <NEWLINE> array = [ 0 for x in range ( 500000 ) ] <NEWLINE> <NL> def merge ( left , mid , right ) : <NEWLINE> <INDENT> n_fore = mid - left <NEWLINE> n_rear = right - mid <NEWLINE> l_fore = array [ left : left + n_fore ] <NEWLINE> l_fore . append ( sys . maxsize ) <NEWLINE> l_rear = array [ mid : mid + n_rear ] <NEWLINE> l_rear . append ( sys . maxsize ) <NEWLINE> <NL> i = j = 0 <NEWLINE> global compare_counter <NEWLINE> compare_counter += ( right - left ) <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if l_fore [ i ] < l_rear [ j ] : <NEWLINE> <INDENT> array [ k ] = l_fore [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> array [ k ] = l_rear [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( left , mid ) <NEWLINE> merge_sort ( mid , right ) <NEWLINE> merge ( left , mid , right ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> start = time . time ( ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for idx , tmp in enumerate ( input ( ) . split ( ) ) : <NEWLINE> <INDENT> array [ idx ] = int ( tmp ) <NEWLINE> <NL> <DEDENT> merge_sort ( 0 , n ) <NEWLINE> <NL> print ( <STRING> . join ( map ( str , array [ : n ] ) ) ) <NEWLINE> print ( compare_counter ) <NEWLINE> <NL> return <NEWLINE> <NL> <NL> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global count <NEWLINE> inf = 10 ** 9 <NEWLINE> L = A [ left : mid ] + [ inf ] <NEWLINE> R = A [ mid : right ] + [ inf ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count += 1 <NEWLINE> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> count = 0 <NEWLINE> merge_sort ( A , 0 , len ( A ) ) <NEWLINE> <NL> print ( <STRING> . join ( list ( map ( str , A ) ) ) ) <NEWLINE> print ( count ) <NEWLINE>
import sys <NEWLINE> <NL> def merge ( A , left , mid , right , num_compare ) : <NEWLINE> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <NL> L = A [ left : mid ] + [ SENTINEL ] <NEWLINE> R = A [ mid : right ] + [ SENTINEL ] <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> <NL> num_compare += right - left <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <DEDENT> <DEDENT> return num_compare <NEWLINE> <NL> <DEDENT> def merge_sort ( A , left , right , num_compare ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> num_compare = merge_sort ( A , left , mid , num_compare ) <NEWLINE> num_compare = merge_sort ( A , mid , right , num_compare ) <NEWLINE> num_compare = merge ( A , left , mid , right , num_compare ) <NEWLINE> <NL> <DEDENT> return num_compare <NEWLINE> <NL> <NL> <DEDENT> fin = open ( <STRING> , <STRING> ) <NEWLINE> <COMMENT> <NL> <NL> SENTINEL = float ( <STRING> ) <NEWLINE> <NL> n = int ( fin . readline ( ) ) <NEWLINE> S = list ( map ( int , fin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> num_compare = 0 <NEWLINE> num_compare = merge_sort ( S , 0 , n , num_compare ) <NEWLINE> <NL> print ( S [ 0 ] , end = <STRING> ) <NEWLINE> for s in S [ 1 : ] : <NEWLINE> <INDENT> print ( <STRING> + str ( s ) , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> ) <NEWLINE> print ( num_compare ) <NEWLINE>
import math <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> <NL> def vector_rot ( vector , radian ) : <NEWLINE> <INDENT> new_x = vector [ 0 ] * math . cos ( radian ) - vector [ 1 ] * math . sin ( radian ) <NEWLINE> new_y = vector [ 0 ] * math . sin ( radian ) + vector [ 1 ] * math . cos ( radian ) <NEWLINE> return [ new_x , new_y ] <NEWLINE> <NL> <DEDENT> def vector_add ( v1 , v2 ) : <NEWLINE> <INDENT> new_v = [ ] <NEWLINE> for i in range ( 2 ) : <NEWLINE> <INDENT> add = v1 [ i ] + v2 [ i ] <NEWLINE> new_v . append ( add ) <NEWLINE> <DEDENT> return new_v <NEWLINE> <NL> <DEDENT> def makepoint ( p_A1 , p_A2 ) : <NEWLINE> <INDENT> x_p_C1 = ( p_A2 [ 0 ] - p_A1 [ 0 ] ) / 3 + p_A1 [ 0 ] <NEWLINE> y_p_C1 = ( p_A2 [ 1 ] - p_A1 [ 1 ] ) / 3 + p_A1 [ 1 ] <NEWLINE> x_p_C3 = ( p_A2 [ 0 ] - p_A1 [ 0 ] ) * 2 / 3 + p_A1 [ 0 ] <NEWLINE> y_p_C3 = ( p_A2 [ 1 ] - p_A1 [ 1 ] ) * 2 / 3 + p_A1 [ 1 ] <NEWLINE> <NL> p_C1 = [ x_p_C1 , y_p_C1 ] <NEWLINE> p_C3 = [ x_p_C3 , y_p_C3 ] <NEWLINE> <NL> v01 = [ x_p_C1 - p_A1 [ 0 ] , y_p_C1 - p_A1 [ 1 ] ] <NEWLINE> rot_v01 = vector_rot ( v01 , 60 * math . pi / 180 ) <NEWLINE> v02 = vector_add ( v01 , rot_v01 ) <NEWLINE> p_C2 = vector_add ( p_A1 , v02 ) <NEWLINE> <NL> C = [ p_C1 , p_C2 , p_C3 ] <NEWLINE> return C <NEWLINE> <NL> <DEDENT> A = [ [ 0. , 0. ] , [ 100. , 0. ] ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> B = [ ] <NEWLINE> for j in range ( len ( A ) - 1 ) : <COMMENT> <NEWLINE> <INDENT> C = makepoint ( A [ j ] , A [ j + 1 ] ) <COMMENT> <NEWLINE> B . append ( A [ j ] ) <NEWLINE> for p in C : <NEWLINE> <INDENT> B . append ( p ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> B . append ( A [ - 1 ] ) <COMMENT> <NEWLINE> A = B <NEWLINE> <NL> <DEDENT> for x in A : <NEWLINE> <INDENT> print ( <STRING> . format ( x [ 0 ] ) ) , <NEWLINE> print ( <STRING> . format ( x [ 1 ] ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> <NL> th = math . pi * 60.0 / 180.0 <NEWLINE> <NL> def split ( x , y ) : <NEWLINE> <INDENT> s = ( ( 2 * x [ 0 ] + y [ 0 ] ) / 3 , ( 2 * x [ 1 ] + y [ 1 ] ) / 3 ) <NEWLINE> t = ( ( x [ 0 ] + 2 * y [ 0 ] ) / 3 , ( x [ 1 ] + 2 * y [ 1 ] ) / 3 ) <NEWLINE> u = ( ( t [ 0 ] - s [ 0 ] ) * math . cos ( th ) - ( t [ 1 ] - s [ 1 ] ) * math . sin ( th ) + s [ 0 ] , ( t [ 0 ] - s [ 0 ] ) * math . sin ( th ) + ( t [ 1 ] - s [ 1 ] ) * math . cos ( th ) + s [ 1 ] ) <NEWLINE> return ( s , u , t ) <NEWLINE> <NL> <NL> <DEDENT> s = ( 0. , 0. ) <NEWLINE> t = ( 100. , 0. ) <NEWLINE> points = [ ] <NEWLINE> points . append ( s ) <NEWLINE> points . append ( t ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> new_points = [ ] <NEWLINE> j = 0 <NEWLINE> while True : <NEWLINE> <INDENT> s , u , t = split ( points [ j ] , points [ j + 1 ] ) <NEWLINE> new_points . extend ( ( points [ j ] , s , u , t , points [ j + 1 ] ) ) <NEWLINE> j += 1 <NEWLINE> if j + 1 >= len ( points ) : break <NEWLINE> <DEDENT> points = new_points <NEWLINE> <DEDENT> for p in new_points : <NEWLINE> <INDENT> print p [ 0 ] , p [ 1 ] <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def koch ( n , p1 , p2 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> s = [ ( 2 * p1 [ 0 ] + 1 * p2 [ 0 ] ) / 3 , ( 2 * p1 [ 1 ] + 1 * p2 [ 1 ] ) / 3 ] <NEWLINE> t = [ ( 1 * p1 [ 0 ] + 2 * p2 [ 0 ] ) / 3 , ( 1 * p1 [ 1 ] + 2 * p2 [ 1 ] ) / 3 ] <NEWLINE> u = [ ( t [ 0 ] - s [ 0 ] ) * 0.5 - ( t [ 1 ] - s [ 1 ] ) * sin60 + s [ 0 ] , <NEWLINE> <INDENT> ( t [ 0 ] - s [ 0 ] ) * sin60 + ( t [ 1 ] - s [ 1 ] ) * 0.5 + s [ 1 ] ] <NEWLINE> <DEDENT> koch ( n - 1 , p1 , s ) <NEWLINE> print s [ 0 ] , s [ 1 ] <NEWLINE> koch ( n - 1 , s , u ) <NEWLINE> print u [ 0 ] , u [ 1 ] <NEWLINE> koch ( n - 1 , u , t ) <NEWLINE> print t [ 0 ] , t [ 1 ] <NEWLINE> koch ( n - 1 , t , p2 ) <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> p1 = ( 0 , 0 ) <NEWLINE> p2 = ( 100 , 0 ) <NEWLINE> print p1 [ 0 ] , p1 [ 1 ] <NEWLINE> koch ( n , p1 , p2 ) <NEWLINE> print p2 [ 0 ] , p1 [ 1 ] <NEWLINE>
def koch ( n , a_x , a_y , b_x , b_y ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> th = math . pi * 60.0 / 180.0 <NEWLINE> <NL> s_x = ( 2.0 * a_x + 1.0 * b_x ) / 3.0 <NEWLINE> s_y = ( 2.0 * a_x + 1.0 * b_x ) / 3.0 <NEWLINE> t_x = ( 1.0 * a_x + 2.0 * b_x ) / 3.0 <NEWLINE> t_y = ( 1.0 * a_x + 2.0 * b_x ) / 3.0 <NEWLINE> u_x = ( t_x - s_x ) * math . cos ( th ) + ( t_y - s_y ) * math . sin ( th ) + s_x <NEWLINE> u_y = ( t_x - s_x ) * math . sin ( th ) + ( t_y - s_y ) * math . cos ( th ) + s_y <NEWLINE> <NL> koch ( n - 1 , a_x , a_y , s_x , s_y ) <NEWLINE> print <STRING> % ( s_x , s_y ) <NEWLINE> koch ( n - 1 , s_x , s_y , u_x , u_y ) <NEWLINE> print <STRING> % ( u_x , u_y ) <NEWLINE> koch ( n - 1 , u_x , u_y , t_x , t_y ) <NEWLINE> print <STRING> % ( t_x , t_y ) <NEWLINE> koch ( n - 1 , t_x , t_y , b_x , b_y ) <NEWLINE> <NL> <NL> <NL> <DEDENT> n = input ( ) <NEWLINE> a_x = 0.0 <NEWLINE> a_y = 0.0 <NEWLINE> b_x = 100.0 <NEWLINE> b_y = 0.0 <NEWLINE> <NL> print <STRING> % ( a_x , a_y ) <NEWLINE> koch ( n , a_x , a_y , b_x , b_y ) <NEWLINE> print <STRING> % ( b_x , b_y ) <NEWLINE>
import math , cmath <NEWLINE> <NL> def koch ( v1 , v2 , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return [ v1 , v2 ] <NEWLINE> <NL> <DEDENT> rad60 = math . pi / 3 <NEWLINE> u1 = ( v2 - v1 ) / 3 <NEWLINE> u2 = cmath . rect ( abs ( u1 ) , cmath . phase ( u1 ) + rad60 ) <NEWLINE> q1 = v1 + u1 <NEWLINE> q2 = q1 + u2 <NEWLINE> q3 = q1 + u1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return [ v1 , q1 , q2 , q3 , v2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 = koch ( v1 , q1 , n - 1 ) [ : - 1 ] <NEWLINE> x2 = koch ( q1 , q2 , n - 1 ) [ : - 1 ] <NEWLINE> x3 = koch ( q2 , q3 , n - 1 ) [ : - 1 ] <NEWLINE> x4 = koch ( q3 , v2 , n - 1 ) <NEWLINE> x = x1 + x2 + x3 + x4 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> v1 = complex ( 0 , 0 ) <NEWLINE> v2 = complex ( 100 , 0 ) <NEWLINE> <NL> for e in koch ( p1 , p2 , n ) : <NEWLINE> <INDENT> print e . real , e . imag <NEWLINE> <DEDENT>
import math , cmath <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> p1 = complex ( 0 , 0 ) <NEWLINE> p2 = complex ( 100 , 0 ) <NEWLINE> <NL> for e in koch ( p1 , p2 , n ) : <NEWLINE> <INDENT> print e . real , e . imag <NEWLINE> <NL> <DEDENT> def koch ( p1 , p2 , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return [ p1 , p2 ] <NEWLINE> <NL> <DEDENT> rad60 = math . pi / 3 <NEWLINE> v1 = ( p2 - p1 ) / 3 <NEWLINE> v2 = cmath . rect ( abs ( v1 ) , cmath . phase ( v1 ) + rad60 ) <NEWLINE> q1 = p1 + v1 <NEWLINE> q2 = q1 + v2 <NEWLINE> q3 = q1 + v1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return [ p1 , q1 , q2 , q3 , p2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 = koch ( p1 , q1 , n - 1 ) [ : - 1 ] <NEWLINE> x2 = koch ( q1 , q2 , n - 1 ) [ : - 1 ] <NEWLINE> x3 = koch ( q2 , q3 , n - 1 ) [ : - 1 ] <NEWLINE> x4 = koch ( q3 , p2 , n - 1 ) <NEWLINE> x = x1 + x2 + x3 + x4 <NEWLINE> <DEDENT> return x <NEWLINE> <INDENT> x4 = koch ( q3 , p2 , n - 1 ) <NEWLINE> x = x1 + x2 + x3 + x4 <NEWLINE> <DEDENT> return x <NEWLINE> <DEDENT>
import math <NEWLINE> n = input ( ) <NEWLINE> <NL> def koch ( n , p1_x , p2_x , p1_y , p2_y ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> s_x = ( 2 * p1_x + p2_x ) / 3 <NEWLINE> s_y = ( 2 * p1_y + p2_y ) / 3 <NEWLINE> t_x = ( p1_x + 2 * p2_x ) / 3 <NEWLINE> t_y = ( p1_y + 2 * p2_y ) / 3 <NEWLINE> <NL> u_x = ( t_x - s_x ) / 2 - ( t_y - s_y ) * sqrt ( 3 ) / 2 + s_x <NEWLINE> u_y = ( t_x - s_x ) * sqrt ( 3 ) / 2 + ( t_y - s_y ) / 2 + s_y <NEWLINE> <NL> koch ( n - 1 , p1_x , s_x , p1_y , s_y ) <NEWLINE> print s_x , s_y <NEWLINE> koch ( n - 1 , s_x , u_x , s_y , u_y ) <NEWLINE> print u_x , u_y <NEWLINE> koch ( n - 1 , u_x , t_x , u_y , t_y ) <NEWLINE> print t_x , t_y <NEWLINE> koch ( n - 1 , t_x , p2_x , t_y , p2_y ) <NEWLINE> <NL> <DEDENT> p1_x = 0.0 <NEWLINE> p1_y = 0.0 <NEWLINE> p2_x = 100.0 <NEWLINE> p2_y = 0.0 <NEWLINE> <NL> print p1_x , p1_y <NEWLINE> koch ( n , 0 , 100 , 0 , 0 ) <NEWLINE> print p2_x , p2_y <NEWLINE>
import math <NEWLINE> <NL> def kock ( n , x1 , y1 , x1 , y2 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> angle = math . radians ( 60 ) <NEWLINE> <NL> sx = ( 2 * x1 + x2 ) / 3 <NEWLINE> sy = ( 2 * y1 + y2 ) / 3 <NEWLINE> tx = ( 2 * x2 + x1 ) / 3 <NEWLINE> ty = ( 2 * y2 + y1 ) / 3 <NEWLINE> ux = ( tx - sx ) * math . cos ( angle ) - ( ty - sy ) * math . sin ( angle ) + sx <NEWLINE> uy = ( tx - sx ) * math . sin ( angle ) + ( ty - sy ) * math . cos ( angle ) + sy <NEWLINE> <NL> kock ( n - 1 , x1 , y1 , sx , sy ) <NEWLINE> print sx , sy <NEWLINE> kock ( n - 1 , sx , sy , ux , uy ) <NEWLINE> print ux , uy <NEWLINE> kock ( n - 1 , ux , uy , tx , ty ) <NEWLINE> print tx , ty <NEWLINE> kock ( n - 1 , tx , ty , x2 , y2 ) <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> p1x = 0. <NEWLINE> p1y = 0. <NEWLINE> p2x = 100. <NEWLINE> p2y = 0. <NEWLINE> <NL> print p1x , p1y <NEWLINE> kock ( n , p1x , p1y , p2x , p2y ) <NEWLINE> print p2x , p2y <NEWLINE>
import math <NEWLINE> <NL> def koch ( n , h , i , j , k ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> s . x = ( h * 2 + j ) / 3 <NEWLINE> s . y = ( i * 2 + k ) / 3 <NEWLINE> t . x = ( h + j * 2 ) / 3 <NEWLINE> t . y = ( i + k * 2 ) / 3 <NEWLINE> u . x = ( t . x - s . x ) * math . cos ( math . pi / 3 ) - ( t . y - s . y ) * math . sin ( math . pi / 3 ) + s . x <NEWLINE> u . y = ( t . x - s . x ) * math . sin ( math . pi / 3 ) + ( t . y - s . y ) * math . cos ( math . pi / 3 ) + s . y <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> px = float ( 0 ) <NEWLINE> py = float ( 0 ) <NEWLINE> qx = float ( 100 ) <NEWLINE> qy = float ( 0 ) <NEWLINE> <NL> print px , py <NEWLINE> koch ( n , px , py , qx , qy ) <NEWLINE> print qx , qy <NEWLINE>
import java . io . BufferedReader ; <NEWLINE> import java . io . IOException ; <NEWLINE> import java . io . InputStreamReader ; <NEWLINE> <NL> public class Main { <NEWLINE> <NL> <INDENT> static class Point { <NEWLINE> <INDENT> double x ; <NEWLINE> double y ; <NEWLINE> public Point ( double x , double y ) { <NEWLINE> <INDENT> this . x = x ; <NEWLINE> this . y = y ; <NEWLINE> <DEDENT> } <NEWLINE> public String toString ( ) { <NEWLINE> <INDENT> return String . format ( <STRING> , x , y ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> public static void main ( String [ ] args ) throws IOException { <NEWLINE> <INDENT> BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; <NEWLINE> int n = Integer . parseInt ( reader . readLine ( ) ) ; <NEWLINE> reader . close ( ) ; <NEWLINE> getKochCurve ( n , new Point ( 0 , 0 ) , new Point ( 100 , 0 ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> private static void getKochCurve ( int n , Point start , Point end ) { <NEWLINE> <INDENT> System . out . println ( start ) ; <NEWLINE> getKochCurve ( 0 , n , start , end ) ; <NEWLINE> System . out . println ( end ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> private static void getKochCurve ( int i , int n , Point start , Point end ) { <NEWLINE> <INDENT> if ( i < n ) { <NEWLINE> <INDENT> Point firstPoint = getPoint ( start , end , 1.0 / 3.0 ) ; <NEWLINE> Point thirdPoint = getPoint ( start , end , 2.0 / 3.0 ) ; <NEWLINE> Point secondPoint = getSecondPoint ( start , end , firstPoint , thirdPoint ) ; <NEWLINE> getKochCurve ( i + 1 , n , start , firstPoint ) ; <NEWLINE> System . out . println ( firstPoint ) ; <NEWLINE> getKochCurve ( i + 1 , n , firstPoint , secondPoint ) ; <NEWLINE> System . out . println ( secondPoint ) ; <NEWLINE> getKochCurve ( i + 1 , n , secondPoint , thirdPoint ) ; <NEWLINE> System . out . println ( thirdPoint ) ; <NEWLINE> getKochCurve ( i + 1 , n , thirdPoint , end ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> private static Point getPoint ( Point start , Point end , double d ) { <NEWLINE> <INDENT> double deltaX = end . x - start . x ; <NEWLINE> double deltaY = end . y - start . y ; <NEWLINE> deltaX = deltaX * d ; <NEWLINE> deltaY = deltaY * d ; <NEWLINE> return new Point ( start . x + deltaX , start . y + deltaY ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> private static Point getSecondPoint ( Point start , Point end , Point second , Point third ) { <NEWLINE> <INDENT> double deltaX = third . x - second . x ; <NEWLINE> double deltaY = third . y - second . y ; <NEWLINE> double len = Math . sqrt ( Math . pow ( deltaX , 2 ) + Math . pow ( deltaY , 2 ) ) ; <NEWLINE> double x ; <NEWLINE> double y ; <NEWLINE> if ( deltaY == 0 ) { <NEWLINE> <INDENT> x = start . x + ( end . x - start . x ) / 2 ; <NEWLINE> if ( start . x < end . x ) { <NEWLINE> <INDENT> y = second . y + Math . sqrt ( ( Math . pow ( len , 2 ) - Math . pow ( len / 2.0 , 2 ) ) ) ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> y = second . y - Math . sqrt ( ( Math . pow ( len , 2 ) - Math . pow ( len / 2.0 , 2 ) ) ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } else if ( start . x < end . x & & start . y < end . y ) { <NEWLINE> <INDENT> x = start . x ; <NEWLINE> y = third . y ; <NEWLINE> <DEDENT> } else if ( start . x < end . x & & start . y > end . y ) { <NEWLINE> <INDENT> x = end . x ; <NEWLINE> y = second . y ; <NEWLINE> <DEDENT> } else if ( start . x > end . x & & start . y < end . y ) { <NEWLINE> <INDENT> x = end . x ; <NEWLINE> y = second . y ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> x = start . x ; <NEWLINE> y = third . y ; <NEWLINE> <DEDENT> } <NEWLINE> return new Point ( x , y ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE>
class coordinates : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <DEDENT> <DEDENT> def koch ( n , a , b ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> s = coordinates ( ( 2.0 * a . x + b . x ) / 3.0 , ( 2.0 * a . y + b . y ) / 3.0 ) <NEWLINE> t = coordinates ( ( a . x + 2.0 * b . x ) / 3.0 , ( a . y + 2.0 * b . y ) / 3.0 ) <NEWLINE> ux = ( t . x - s . x ) * cos ( pi / 3.0 ) - ( t . y - s . y ) * sin ( pi / 3.0 ) + s . x <NEWLINE> uy = ( t . x - s . x ) * sin ( pi / 3.0 ) + ( t . y - s . y ) * cos ( pi / 3.0 ) + s . y <NEWLINE> u = coordinates ( ux , uy ) <NEWLINE> <NL> koch ( n - 1 , a , s ) <NEWLINE> print s . x , s . y <NEWLINE> koch ( n - 1 , s , u ) <NEWLINE> print u . x , u . y <NEWLINE> koch ( n - 1 , u , t ) <NEWLINE> print t . x , t . y <NEWLINE> koch ( n - 1 , t , b ) <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> p1 = coordinates ( 0.0 , 0.0 ) <NEWLINE> p2 = coordinates ( 100.0 , 0.0 ) <NEWLINE> <NL> print p1 . x , p1 . y <NEWLINE> koch ( n , p1 , p2 ) <NEWLINE> print p2 . x , p2 . y <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> p1_x = float ( 0 ) <NEWLINE> p1_y = float ( 0 ) <NEWLINE> p2_x = float ( 100 ) <NEWLINE> p2_y = float ( 0 ) <NEWLINE> <NL> def KC ( i , n , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> v = [ 0 ] * 5 <NEWLINE> w = [ 0 ] * 5 <NEWLINE> if i < n : <NEWLINE> <INDENT> v [ 0 ] = x1 <NEWLINE> w [ 0 ] = y1 <NEWLINE> v [ 1 ] = ( 2 * x1 + x2 ) / 3.0 <NEWLINE> w [ 1 ] = ( 2 * y1 + y2 ) / 3.0 <NEWLINE> v [ 2 ] = ( x1 + 2 * x2 ) / 3.0 <NEWLINE> w [ 2 ] = ( y1 + 2 * y2 ) / 3.0 <NEWLINE> v [ 3 ] = ( v [ 2 ] - v [ 1 ] ) * math . cos ( math . pi / 3 ) - ( w [ 2 ] - w [ 1 ] ) * math . sin ( math . pi / 3 ) + v [ 1 ] <NEWLINE> w [ 3 ] = ( w [ 2 ] - w [ 1 ] ) * math . cos ( math . pi / 3 ) + ( v [ 2 ] - v [ 1 ] ) * math . sin ( math . pi / 3 ) + w [ 1 ] <NEWLINE> v [ 3 ] = x2 <NEWLINE> w [ 3 ] = y2 <NEWLINE> KC ( i + 1 , n , v [ 0 ] , w [ 0 ] , v [ 1 ] , w [ 1 ] ) <NEWLINE> print v [ 1 ] , w [ 1 ] <NEWLINE> KC ( i + 1 , n , v [ 1 ] , w [ 1 ] , v [ 3 ] , w [ 3 ] ) <NEWLINE> print v [ 3 ] , w [ 3 ] <NEWLINE> KC ( i + 1 , n , v [ 3 ] , w [ 3 ] , v [ 2 ] , w [ 2 ] ) <NEWLINE> print v [ 2 ] , w [ 2 ] <NEWLINE> KC ( i + 1 , n , v [ 2 ] , w [ 2 ] , v [ 4 ] , w [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print p1_x , p1_y <NEWLINE> KC ( 0 , n , p1_x , p1_y , p2_x , p2_y ) <NEWLINE> print p2_x , p2_y <NEWLINE>
import math <NEWLINE> <NL> <NL> x1 = 0 <NEWLINE> y1 = 0 <NEWLINE> x2 = 100 <NEWLINE> y2 = 0 <NEWLINE> <NL> def koch_curve ( i , n , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> x = [ 0 ] * 5 <NEWLINE> y = [ 0 ] * 5 <NEWLINE> if i < n : <NEWLINE> <INDENT> x [ 0 ] = x1 <NEWLINE> y [ 0 ] = y1 <NEWLINE> x [ 1 ] = ( 2 * x1 + x2 ) / 3.0 <NEWLINE> y [ 1 ] = ( 2 * y1 + y2 ) / 3.0 <NEWLINE> x [ 2 ] = ( x1 + 2 * x2 ) / 3.0 <NEWLINE> y [ 2 ] = ( y1 + 2 * y2 ) / 3.0 <NEWLINE> x [ 3 ] = ( x [ 2 ] - x [ 1 ] ) * math . cos ( math . pi / 3 ) - ( x [ 2 ] - x [ 1 ] ) * math . sin ( math . pi / 3 ) + x [ 1 ] <NEWLINE> y [ 3 ] = ( y [ 2 ] - y [ 1 ] ) * math . cos ( math . pi / 3 ) + ( y [ 2 ] - y [ 1 ] ) * math . sin ( math . pi / 3 ) + y [ 1 ] <NEWLINE> x [ 4 ] = x2 <NEWLINE> y [ 4 ] = y2 <NEWLINE> koch_curve ( i + 1 , n , x [ 0 ] , y [ 0 ] , x [ 1 ] , y [ 1 ] ) <NEWLINE> print x [ 1 ] , y [ 1 ] <NEWLINE> koch_curve ( i + 1 , n , x [ 1 ] , y [ 1 ] , x [ 3 ] , y [ 3 ] ) <NEWLINE> print x [ 3 ] , y [ 3 ] <NEWLINE> koch_curve ( i + 1 , n , x [ 3 ] , y [ 3 ] , x [ 2 ] , y [ 2 ] ) <NEWLINE> print x [ 2 ] , y [ 2 ] <NEWLINE> koch_curve ( i + 1 , n , x [ 2 ] , y [ 2 ] , x [ 4 ] , y [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> print x1 y1 <NEWLINE> koch_curve ( 0 , n , x1 , y1 , x2 , y2 ) <NEWLINE> print x2 , y2 <NEWLINE>
import math , cmath <NEWLINE> <NL> def koch ( p1 , p2 , n ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return [ p1 , p2 ] <NEWLINE> <NL> <DEDENT> rad60 = math . pi / 3 <NEWLINE> v1 = ( p2 - p1 ) / 3 <NEWLINE> v2 = cmath . rect ( abs ( v1 ) , cmath . phase ( v1 ) + rad60 ) <NEWLINE> q1 = p1 + v1 <NEWLINE> q2 = q1 + v2 <NEWLINE> q3 = q1 + v1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return [ p1 , q1 , q2 , q3 , p2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 = koch ( p1 , q1 , n - 1 ) [ - 1 ] <NEWLINE> x2 = koch ( q1 , q2 , n - 1 ) [ - 1 ] <NEWLINE> x3 = koch ( q2 , q3 , n - 1 ) [ - 1 ] <NEWLINE> x4 = koch ( q3 , p2 , n - 1 ) <NEWLINE> x = x1 + x2 + x3 + x4 <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> p1 = complex ( 0 , 0 ) <NEWLINE> p2 = complex ( 100 , 0 ) <NEWLINE> <NL> for e in koch ( p1 , p2 , n ) : <NEWLINE> <INDENT> print e . real , e . imag <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def koch ( n , x1 , y1 , x2 , y2 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> angle = math . radians ( 60 ) <NEWLINE> <NL> sx = ( 2 * x1 + x2 ) / 3 <NEWLINE> sy = ( 2 * y1 + y2 ) / 3 <NEWLINE> tx = ( 2 * x2 + x1 ) / 3 <NEWLINE> ty = ( 2 * y2 + y1 ) / 3 <NEWLINE> ux = ( tx - sx ) * math . cos ( angle ) - ( ty - sy ) * math . sin ( angle ) + sx <NEWLINE> uy = ( tx - sx ) * math . sin ( angle ) + ( ty - sy ) * math . cos ( angle ) + sy <NEWLINE> <NL> koch ( n - 1 , x1 , y1 , sx , sy ) <NEWLINE> print sx , sy <NEWLINE> koch ( n - 1 , sx , sy , ux , uy ) <NEWLINE> print ux , uy <NEWLINE> koch ( n - 1 , ux , uy , tx , ty ) <NEWLINE> print tx , ty <NEWLINE> koch ( n - 1 , tx , ty , x2 , y2 ) <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> p1x = 0.0 <NEWLINE> p1y = 0.0 <NEWLINE> p2x = 100.0 <NEWLINE> p2y = 0.0 <NEWLINE> <NL> print p1x , p1y <NEWLINE> kock ( n , p1x , p1y , p2x , p2y ) <NEWLINE> print p2x , p2y <NEWLINE>
import math <NEWLINE> <NL> class Point : <NEWLINE> <INDENT> def __init__ ( self , num_x , num_y ) : <NEWLINE> <INDENT> self . x = num_x <NEWLINE> self . y = num_y <NEWLINE> <NL> <DEDENT> <DEDENT> def kock ( n , p1 , p2 ) : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> s = Point ( ( 2 * p1 . x + 1 * p2 . x ) / 3.0 , ( 2 * p1 . y + 1 * p2 . y ) / 3.0 ) <NEWLINE> t = Point ( ( 1 * p1 . x + 2 * p2 . x ) / 3.0 , ( 1 * p1 . y + 2 * p2 . y ) / 3.0 ) <NEWLINE> u = Point ( 0 , 0 ) <NEWLINE> u . x = ( t . x - s . x ) * math . cos ( math . pi / 3 ) - ( t . y - s . y ) * math . cos ( math . pi / 3 ) + s . x <NEWLINE> u . y = ( t . x - s . x ) * math . sin ( math . pi / 3 ) - ( t . y - s . y ) * math . cos ( math . pi / 3 ) + s . y <NEWLINE> <NL> kock ( n - 1 , p1 , s ) <NEWLINE> print <STRING> % ( s . x , s . y ) <NEWLINE> kock ( n - 1 , s , u ) <NEWLINE> print <STRING> % ( u . x , u . y ) <NEWLINE> kock ( n - 1 , u , t ) <NEWLINE> print <STRING> % ( t . x , t . y ) <NEWLINE> kock ( n - 1 , t , p2 ) <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> <NL> p1 = Point ( 0 , 0 ) <NEWLINE> p2 = Point ( 100 , 0 ) <NEWLINE> <NL> print <STRING> % ( p1 . x , p1 . y ) <NEWLINE> kock ( n , p1 , p2 ) <NEWLINE> print <STRING> % ( p2 . x , p2 . y <NEWLINE>
import math , cmath <NEWLINE> <NL> def koch ( p1 , p2 , n ) : <NEWLINE> <NL> <INDENT> rad60 = math . pi / 3 <NEWLINE> v1 = ( p2 - p1 ) / 3 <NEWLINE> v2 = cmath . rect ( abs ( v1 ) , cmath . phase ( v1 ) + rad60 ) <NEWLINE> q1 = p1 + v1 <NEWLINE> q2 = q1 + v2 <NEWLINE> q3 = q1 + v1 <NEWLINE> if n == 1 : <NEWLINE> <INDENT> return [ p1 , q1 , q2 , q3 , p2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x1 = koch ( p1 , q1 , n - 1 ) [ 1 : - 1 ] <NEWLINE> x2 = koch ( q1 , q2 , n - 1 ) [ 1 : - 1 ] <NEWLINE> x3 = koch ( q2 , q3 , n - 1 ) [ 1 : - 1 ] <NEWLINE> x4 = koch ( q3 , p2 , n - 1 ) [ 1 : - 1 ] <NEWLINE> x = [ p1 ] + x1 + [ q1 ] + x2 + [ q2 ] + x3 + [ q3 ] + x4 + [ p2 ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> p1 = complex ( 0 , 0 ) <NEWLINE> p2 = complex ( 100 , 0 ) <NEWLINE> <NL> for e in koch ( p1 , p2 , n ) : <NEWLINE> <INDENT> print e . real , e . imag <NEWLINE> <DEDENT>
def merge ( A , left , mid , right ) : <NEWLINE> <NL> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> L = A [ left : mid ] <NEWLINE> R = A [ mid : right ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> global cnt <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> cnt += l - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> cnt = 0 <NEWLINE> mergeSort ( A , 0 , len ( A ) ) <NEWLINE> <COMMENT> <NL> print ( str ( cnt ) ) <NEWLINE>
<COMMENT> <NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> count = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i , n ) : <NEWLINE> <INDENT> if A [ i ] > A [ j ] : <NEWLINE> <INDENT> count += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print count <NEWLINE>
cnt = 0 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> global cnt <NEWLINE> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> <NL> L = [ A [ i ] for i in range ( left , mid ) ] <NEWLINE> R = [ A [ i ] for i in range ( mid , right ) ] <NEWLINE> L . append ( float ( <STRING> ) ) <NEWLINE> R . append ( float ( <STRING> ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if L [ i ] <= R [ j ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cnt += n1 - i <NEWLINE> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> mergeSort ( A , left , mid ) <NEWLINE> mergeSort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> input ( ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> mergeSort ( a , 0 , len ( a ) ) <NEWLINE> return cnt <NEWLINE> <NL>
import array <NEWLINE> <NL> def merge_sort ( A ) : <NEWLINE> <INDENT> if len ( A ) <= 1 : <NEWLINE> <INDENT> return A , 0 <NEWLINE> <DEDENT> mid = len ( A ) // 2 <NEWLINE> left , lcount = merge_sort ( A [ : mid ] ) <NEWLINE> right , rcount = merge_sort ( A [ mid : ] ) <NEWLINE> merged , count = merge ( left , right ) <NEWLINE> return merged , lcount + rcount + count <NEWLINE> <NL> <DEDENT> def merge ( left , right ) : <NEWLINE> <INDENT> lpos = 0 <NEWLINE> rpos = 0 <NEWLINE> rcount = 0 <NEWLINE> merged = array . array ( <STRING> , [ ] ) <COMMENT> <NEWLINE> len_left = len ( left ) <NEWLINE> len_right = len ( right ) <NEWLINE> while lpos < len_left and rpos < len_right : <NEWLINE> <INDENT> if left [ lpos ] < right [ rpos ] : <NEWLINE> <INDENT> merged . append ( left [ lpos ] ) <NEWLINE> lpos += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> merged . append ( right [ rpos ] ) <NEWLINE> rpos += 1 <NEWLINE> rcount += len ( left [ lpos : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> if left [ lpos : ] : <NEWLINE> <INDENT> merged . extend ( left [ lpos : ] ) <NEWLINE> <DEDENT> if right [ rpos : ] : <NEWLINE> <INDENT> merged . extend ( right [ rpos : ] ) <NEWLINE> <NL> <DEDENT> return merged , rcount <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> A = array . array ( <STRING> , map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> sorted , count = merge_sort ( A ) <NEWLINE> <COMMENT> <NL> print count <NEWLINE> <DEDENT>
def countInversions ( A , cnt ) : <NEWLINE> <INDENT> if len ( A ) == 1 : <NEWLINE> <INDENT> return cnt <NEWLINE> <NL> <DEDENT> maxi = argmax ( A ) <NEWLINE> cnt += len ( A ) - maxi - 1 <NEWLINE> del A [ maxi ] <NEWLINE> return countInversions ( A , cnt ) <NEWLINE> <NL> <DEDENT> def argmax ( A ) : <NEWLINE> <INDENT> max = maxi = 0 <NEWLINE> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] > max : <NEWLINE> <INDENT> max = A [ i ] <NEWLINE> maxi = i <NEWLINE> <DEDENT> <DEDENT> return maxi <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> input ( ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print countInversions ( A , 0 ) <NEWLINE> <DEDENT>
def CountingSort ( A , k ) : <NEWLINE> <INDENT> C = [ 0 ] * k <NEWLINE> B = C [ : ] <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , len ( C ) ) : <NEWLINE> <INDENT> C [ i ] += C [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( len ( A ) - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> B [ C [ A [ i ] ] ] = A [ i ] <NEWLINE> C [ A [ i ] ] -= 1 <NEWLINE> <DEDENT> return B <NEWLINE> <NL> <NL> <DEDENT> fin = open ( <STRING> ) <NEWLINE> input = fin . readline <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> sorted_A = CountingSort ( A , int ( 3E6 ) ) <NEWLINE> print ( <STRING> . join ( [ str ( a ) for a in sorted_A [ 1 : len ( A ) + 1 ] ] ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def countSort ( a ) : <NEWLINE> <INDENT> N = max ( a ) <NEWLINE> c = [ 0 ] * ( N + 2 ) <NEWLINE> b = [ 0 ] * len ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , len ( c ) ) : <NEWLINE> <INDENT> c [ i ] += c [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in a : <NEWLINE> <INDENT> b [ c [ i ] - 1 ] = i <NEWLINE> c [ i ] -= 1 <NEWLINE> <DEDENT> print ( b ) <NEWLINE> <NL> <DEDENT> countSort ( * a ) <NEWLINE>
<NL> def counting_sort ( target_list ) : <NEWLINE> <INDENT> counter = [ 0 for i in range ( 10000 ) ] <NEWLINE> <NL> for n in target_list : <NEWLINE> <INDENT> counter [ n ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , 10000 ) : <NEWLINE> <INDENT> counter [ i ] = counter [ i ] + counter [ i - 1 ] <NEWLINE> <NL> <DEDENT> result = [ 0 for i in range ( len ( target_list ) ) ] <NEWLINE> for n in target_list [ : : - 1 ] : <NEWLINE> <INDENT> result [ counter [ n ] - 1 ] = n <NEWLINE> counter [ n ] -= 1 <NEWLINE> <NL> <DEDENT> return result <NEWLINE> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n_list = int ( input ( ) ) <NEWLINE> target_list = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> sorted_list = counting_sort ( target_list ) <NEWLINE> print ( <STRING> . join ( [ int ( s ) for s in sorted_list ] ) ) <NEWLINE> <DEDENT>
def counting_sort ( MAX ) : <NEWLINE> <INDENT> C = [ 0 for _ in range ( MAX + 1 ) ] <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> C [ A [ i ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( 1 , MAX + 1 ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in range ( N - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> C [ A [ i ] ] -= 1 <NEWLINE> B [ C [ A [ i ] ] ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> MAX = 0 <NEWLINE> for n in A : <NEWLINE> <INDENT> if MAX < n : <NEWLINE> <INDENT> MAX = n <NEWLINE> <NL> <DEDENT> <DEDENT> B = [ 0 for _ in range ( N ) ] <NEWLINE> counting_sort ( MAX ) <NEWLINE> print ( <STRING> . join ( B ) ) <NEWLINE>
def counting_sort ( A , B , k ) : <NEWLINE> <INDENT> C = [ 0 for _ in xrange ( k + 1 ) ] <NEWLINE> for a in A : <NEWLINE> <INDENT> C [ a ] += 1 <NEWLINE> <NL> <DEDENT> for i in xrange ( k ) : <NEWLINE> <INDENT> C [ i ] = C [ i ] + C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for i in xrange ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> B [ C [ A [ i ] ] - 1 ] = A [ i ] <NEWLINE> C [ A [ i ] ] -= 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> B = [ 0 for _ in xrange ( n ) ] <NEWLINE> <NL> counting_sort ( A , B , 10000 ) <NEWLINE> <NL> print <STRING> . join ( map ( str , B ) <NEWLINE>
<COMMENT> <NL> <NL> def countSort ( A , m ) : <NEWLINE> <INDENT> count = [ 0 ] * ( m + 1 ) <NEWLINE> n = len ( A ) <NEWLINE> B = [ 0 ] * 2000000 <NEWLINE> j = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> count [ A [ i ] ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , m ) : <NEWLINE> <INDENT> count [ i ] += count [ i - 1 ] <NEWLINE> <DEDENT> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> j = count [ A [ i ] ] <NEWLINE> B [ j ] = A [ i ] <NEWLINE> count [ A [ i ] ] = j - 1 <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> A [ i ] = B [ i + 1 ] <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> B = countSort ( A , 10000 ) <NEWLINE> print <STRING> . join ( map ( str , B ) ) <NEWLINE>
<NL> <NL> def counting_sort ( A , k ) : <NEWLINE> <INDENT> B = [ 0 for i in range ( len ( A ) ) ] <NEWLINE> C = [ 0 for i in range ( 0 , k + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> for j in range ( 1 , n ) : <NEWLINE> <INDENT> C [ A [ j ] ] += 1 <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> C [ i ] += C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in reversed ( range ( 1 , n ) ) : <NEWLINE> <INDENT> B [ C [ A [ j ] ] ] = A [ j ] <NEWLINE> C [ A [ j ] ] -= 1 <NEWLINE> <DEDENT> return B <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> k = max ( A ) <NEWLINE> <NL> print ( counting_sort ( A , B , k ) ) <NEWLINE>
def countingsort ( a , k ) : <NEWLINE> <INDENT> c = [ 0 ] * ( k + 1 ) <NEWLINE> n = len ( a ) <NEWLINE> for i in a : <NEWLINE> <INDENT> c [ i ] += 1 <NEWLINE> <DEDENT> for i in range ( 1 , k + 1 ) : <NEWLINE> <INDENT> c [ i ] = c [ i ] + c [ i - 1 ] <NEWLINE> <DEDENT> b = [ 0 ] * n <NEWLINE> for i in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> b [ c [ a [ i ] ] - 1 ] = a [ i ] <NEWLINE> c [ a [ i ] ] -= 1 <NEWLINE> <DEDENT> return b <NEWLINE> <DEDENT> o = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = max ( a ) <NEWLINE> ret = countingsort ( a , q ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i != n - 1 : <NEWLINE> <INDENT> print ( ret [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ret [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
def CountingSort ( A , B , k ) : <NEWLINE> <INDENT> C = [ 0 for i in range ( k + 2 ) ] <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> C [ A [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( k + 1 ) : <NEWLINE> <INDENT> C [ i ] += C [ i - 1 ] <NEWLINE> <NL> <DEDENT> for j in range ( n - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> B [ C [ A [ j ] ] - 1 ] = A [ j ] <NEWLINE> C [ A [ j ] ] -= 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> D = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = max ( D ) <NEWLINE> E = D [ : ] <NEWLINE> CountingSort ( D , E , l ) <NEWLINE> print ( <STRING> . join ( map , str ( E ) ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def countingsort ( a , k ) : <NEWLINE> <INDENT> c = [ 0 for i in range ( k ) ] <NEWLINE> b = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for j in range ( n ) : <NEWLINE> <INDENT> c [ a [ j ] ] += 1 <NEWLINE> <NL> <DEDENT> for i in range ( k ) : <NEWLINE> <INDENT> c [ i + 1 ] += c [ i ] <NEWLINE> <NL> <DEDENT> for j in reversed ( range ( n ) ) : <NEWLINE> <INDENT> b [ c [ a [ j ] ] ] = a [ j ] <NEWLINE> c [ a [ j ] ] -= 1 <NEWLINE> <NL> <DEDENT> return b <NEWLINE> <NL> <DEDENT> b = countingsort ( a , 10001 ) <NEWLINE> print ( * b ) <NEWLINE>
def Partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if ( A [ j ] <= x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> st = input ( ) <NEWLINE> data = list ( map ( int , st . split ( ) ) ) <NEWLINE> <NL> mid = Partition ( data , 0 , len ( data ) - 1 ) <NEWLINE> <NL> for i in range ( 0 , mid ) : <NEWLINE> <INDENT> print ( data [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( <STRING> . format ( data [ mid ] ) ) ) <NEWLINE> for i in range ( mid + 1 , len ( data ) - 2 ) : <NEWLINE> <INDENT> print ( data [ i ] , end = <STRING> ) <NEWLINE> <DEDENT> print ( data [ len ( data ) - 1 ] ) <NEWLINE>
def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] < x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> fin = open ( <STRING> ) <NEWLINE> input = fin . readline <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> AA = [ int ( a ) for a in input ( ) . strip ( ) . split ( ) ] <NEWLINE> i = partition ( AA , 0 , N - 1 ) <NEWLINE> _str = <STRING> . join ( [ str ( a ) for a in AA [ : i ] ] ) + <STRING> . format ( AA [ i ] ) + <STRING> . join ( [ str ( a ) for a in AA [ i + 1 : ] ] ) <NEWLINE> print ( _str ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> x = a [ - 1 ] <NEWLINE> i = - 1 <NEWLINE> <NL> for j in range ( len ( a ) - 1 ) : <NEWLINE> <INDENT> if a [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> a [ i + 1 ] , a [ n ] = <STRING> + str ( a [ n ] ) + <STRING> , a [ i + 1 ] <NEWLINE> <NL> print ( * a ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p <NEWLINE> for j in range ( 1 , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i ] , A [ r ] = A [ r ] , A [ i ] <NEWLINE> return i <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ int ( e ) for e in input ( ) . split ( ) ] <NEWLINE> p = 0 <NEWLINE> r = len ( A ) - 1 <NEWLINE> idx = partition ( A , p , r ) <NEWLINE> A [ idx ] = <STRING> % A [ idx ] <NEWLINE> return <STRING> . join ( A ) <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
<NL> <NL> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> q = partition ( A , 1 , len ( A ) - 1 ) <NEWLINE> <NL> print ( * A [ : q ] + <STRING> + * A [ q + 1 : ] ) <NEWLINE>
def partition ( A , p , r ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = A [ r ] p <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> temp = A [ i ] <NEWLINE> A [ i ] = A [ j ] <NEWLINE> A [ j ] = temp <NEWLINE> <DEDENT> <DEDENT> temp = A [ i + 1 ] <NEWLINE> A [ i + 1 ] = A [ r ] <NEWLINE> A [ r ] = temp <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> num_of_data = int ( input ( ) ) <NEWLINE> A = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <COMMENT> <NL> p = partition ( A , 0 , len ( A ) - 1 ) <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> left = A [ : p ] <NEWLINE> partition = A [ p ] <NEWLINE> right = A [ p + 1 : ] <NEWLINE> print ( <STRING> . format ( <STRING> . join ( map ( str , left ) ) , partition , <STRING> . join ( map ( str , right ) ) ) ) <NEWLINE> <DEDENT>
def s ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) - 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> for j in range ( n ) : A [ j ] <= A [ - 1 ] and A [ i ] , A [ j ] = A [ j ] , A [ i ] ; i += 1 <NEWLINE> A [ i ] , A [ n ] = A [ n ] , A [ i ] <NEWLINE> print ( <STRING> . join ( map ( str , A [ : i ] ) ) + <STRING> + str ( A [ i ] ) + <STRING> + <STRING> . join ( map ( str , A [ i + 1 : ] ) ) ) <NEWLINE> <DEDENT> if <STRING> == __name__ : s ( ) <NEWLINE>
n = int ( input ( ) ) - 1 <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if A [ j ] <= A [ - 1 ] : A [ i ] , A [ j ] = A [ j ] , A [ i ] ; i += 1 <NEWLINE> <DEDENT> A [ i ] , A [ n ] = A [ n ] , A [ i ] <NEWLINE> print ( <STRING> . join ( map ( str , A [ : k ] ) ) + <STRING> + str ( A [ i ] ) + <STRING> + <STRING> . join ( map ( str , A [ k + 1 : ] ) ) ) <NEWLINE>
def partition ( a , p , r ) : <NEWLINE> <INDENT> x = a [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if a [ j ] <= x : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> <DEDENT> <DEDENT> a [ i + 1 ] , a [ r ] = a [ r ] , a [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = partition ( a , 0 , n - 1 ) <NEWLINE> a [ m ] = <STRING> % ( a [ m ] ) <NEWLINE> print ( <STRING> . join ( a ) ) <NEWLINE>
def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = partition ( A , 0 , n ) <NEWLINE> A [ i ] = <STRING> + str ( A [ i ] ) + <STRING> <NEWLINE> print ( * A ) <NEWLINE>
list = [ ] <NEWLINE> <NL> def partition ( p , r ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> x = list [ r ] <NEWLINE> i = p - 1 <NEWLINE> j = p <NEWLINE> while ( j < r ) : <NEWLINE> <INDENT> if ( int ( list [ j ] ) <= x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> t = int ( list [ i ] ) <NEWLINE> list [ i ] = list [ j ] <NEWLINE> list [ j ] = t <NEWLINE> <DEDENT> j += 1 <NEWLINE> <NL> <DEDENT> t = int ( list [ i + 1 ] ) <NEWLINE> list [ i + 1 ] = list [ r ] <NEWLINE> list [ r ] = t <NEWLINE> <NL> return i + 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> list . append ( int ( input ( ) ) ) <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> q = partition ( 0 , n - 1 ) <NEWLINE> i = 0 <NEWLINE> while ( i < n ) : <NEWLINE> <INDENT> if ( i == q ) : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( str ( list [ i ] ) , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( str ( list [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT> print ( ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> def mergesort ( A , left , right ) : <NEWLINE> <NL> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) / 2 <NEWLINE> <NL> mergesort ( A , left , mid ) <NEWLINE> mergesort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def merge ( A , left , mid , right ) : <NEWLINE> <NL> <INDENT> n1 = mid - left <NEWLINE> n2 = right - mid <NEWLINE> L = [ ] <NEWLINE> R = [ ] <NEWLINE> x = [ <STRING> , <STRING> , 10 ** 10 ] <NEWLINE> for i in range ( 0 , n1 ) : <NEWLINE> <INDENT> L . append ( A [ left + i ] ) <NEWLINE> <DEDENT> for i in range ( 0 , n2 ) : <NEWLINE> <INDENT> R . append ( A [ mid + i ] ) <NEWLINE> <DEDENT> L . append ( x ) <NEWLINE> R . append ( x ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <NL> <INDENT> if float ( L [ i ] ) <= float ( R [ j ] ) : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = float ( A [ r ] [ 2 ] ) <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if float ( A [ j ] [ 2 ] ) <= x : <NEWLINE> <INDENT> i = i + 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quicksort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> <NL> quicksort ( A , p , q - 1 ) <NEWLINE> quicksort ( A , q + 1 , r ) <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> num = int ( raw_input ( ) ) <NEWLINE> num_list = [ ] <NEWLINE> num_list1 = [ ] <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> num_list . append ( raw_input ( ) ) <NEWLINE> <DEDENT> num_list1 = list ( num_list ) <NEWLINE> quicksort ( num_list , 0 , len ( num_list ) - 1 ) <NEWLINE> <NL> mergesort ( num_list1 , 0 , len ( num_list1 ) ) <NEWLINE> <NL> if num_list == num_list1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print <STRING> . join ( num_list ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <DEDENT> def quicksort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quicksort ( A , p , q - 1 ) <NEWLINE> quicksort ( A , q + 1 , r ) <NEWLINE> <DEDENT> <DEDENT> def isStable ( A ) : <NEWLINE> <INDENT> for i in range ( 0 , len ( A ) - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == A [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> if A [ i ] [ 2 ] > A [ i + 1 ] [ 2 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> f = lambda a : ( a [ 0 ] , int ( a [ 1 ] ) ) <NEWLINE> A = [ f ( readline ( ) . split ( ) ) + ( i ) for i in range ( n ) ] <NEWLINE> quicksort ( A , 0 , n - 1 ) <NEWLINE> print ( <STRING> if isStable ( A ) else <STRING> ) <NEWLINE> print ( <STRING> . join ( <STRING> for a , b , c in A ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> x = numbers [ n - 1 ] <NEWLINE> i = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if numbers [ j ] <= x : <NEWLINE> <INDENT> numbers [ i ] , numbers [ j ] = numbers [ j ] , numbers [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> [ print ( numbers [ j ] if j != i - 1 else <STRING> + str ( numbers [ j ] ) + <STRING> , end = <STRING> if j != n - 1 else <STRING> ) for j in range ( n ) ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
a = [ ] <NEWLINE> b = { } <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> s , i = input ( ) . split ( ) <NEWLINE> a += [ ( s , int ( i ) ) ] <NEWLINE> b . setdefault ( int ( i ) , [ ] ) . append ( s ) <NEWLINE> <DEDENT> b = { val : iter ( s ) . __next__ for val , s in D . items ( ) } <NEWLINE> <NL> def partition ( a , left , right ) : <NEWLINE> <INDENT> standard = a [ right ] [ 1 ] <NEWLINE> cnt = left <NEWLINE> for i in range ( left , right ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] <= standard : <NEWLINE> <INDENT> a [ cnt ] , a [ i ] = a [ i ] , a [ cnt ] <NEWLINE> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> a [ cnt ] , a [ i ] = a [ i ] , a [ cnt ] <NEWLINE> return cnt <NEWLINE> <NL> <DEDENT> def quickSort ( a , left = 0 , right = len ( a ) - 1 ) : <NEWLINE> <INDENT> if 1 <= right - left : <NEWLINE> <INDENT> cnt_ = partition ( a , left , right ) <NEWLINE> quickSort ( a , left , cnt_ - 1 ) <NEWLINE> quickSort ( a , cnt_ + 1 , right ) <NEWLINE> <NL> <DEDENT> <DEDENT> quickSort ( a , 0 , len ( a ) - 1 ) <NEWLINE> <NL> ok = 1 <NEWLINE> for v , d in A : <NEWLINE> <INDENT> if D [ d ] ( ) != v : <NEWLINE> <INDENT> ok = 0 <NEWLINE> <DEDENT> <DEDENT> print ( [ <STRING> , <STRING> ] [ ok ] ) <NEWLINE> <NL> <NL> for i in range ( n ) : <NEWLINE> <INDENT> print ( * a [ i ] ) <NEWLINE> <DEDENT>
def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in xrange ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quicksort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quicksort ( A , p , q - 1 ) <NEWLINE> quicksort ( A , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bubblesort ( a , n ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> while flag : <NEWLINE> <INDENT> flag = 0 <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in xrange ( n - 1 , 0 , - 1 ) : <NEWLINE> <INDENT> if a [ i ] [ 1 ] < a [ i - 1 ] [ 1 ] : <NEWLINE> <INDENT> a [ i - 1 ] , a [ i ] = a [ i ] , a [ i - 1 ] <NEWLINE> flag = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n = input ( ) <NEWLINE> card_1 = [ [ 0 ] * 2 for i in xrange ( n ) ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> card_1 [ i ] [ 0 ] , card_1 [ i ] [ 1 ] = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> card_1 [ i ] [ 1 ] = int ( card_1 [ i ] [ 1 ] ) <NEWLINE> <NL> <DEDENT> card_2 = list ( card_1 ) <NEWLINE> quicksort ( card_1 , 0 , n - 1 ) <NEWLINE> bubblesort ( card_2 , n ) <NEWLINE> <NL> if card_1 == card_2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> card_1 [ i ] = map ( str , card_1 [ i ] ) <NEWLINE> print ( <STRING> . join ( card_1 [ i ] ) ) <NEWLINE> <DEDENT>
INF = 10 ** 10 <NEWLINE> <NL> <NL> def partition ( ary , p , r ) : <NEWLINE> <INDENT> x = ary [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if ary [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> ary [ i ] , ary [ j ] = ary [ j ] , ary [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> ary [ i + 1 ] , ary [ r ] = ary [ r ] , ary [ i + 1 ] <NEWLINE> <NL> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> def quick_sort ( ary , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( ary , p , r ) <NEWLINE> quick_sort ( ary , p , q - 1 ) <NEWLINE> quick_sort ( ary , q + 1 , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def merge ( ary , left , mid , right ) : <NEWLINE> <INDENT> lry = ary [ left : mid ] <NEWLINE> rry = ary [ mid : right ] <NEWLINE> lry . append ( INF ) <NEWLINE> rry . append ( INF ) <NEWLINE> <NL> i = 0 <NEWLINE> j = 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> if lry [ i ] [ 1 ] <= rry [ j ] [ 1 ] : <NEWLINE> <INDENT> ary [ k ] = lry [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ary [ k ] = rry [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return right - left <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( ary , left , right ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> cnt += merge_sort ( ary , left , mid ) <NEWLINE> cnt += merge_sort ( ary , mid , right ) <NEWLINE> cnt += merge ( ary , left , mid , right ) <NEWLINE> <NL> <DEDENT> return cnt <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> from copy import deepcopy <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> ary = [ ] <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> _ = line . strip ( ) . split ( ) <NEWLINE> ary . append ( ( _ [ 0 ] , int ( _ [ 1 ] ) ) ) <NEWLINE> <NL> <DEDENT> qary = deepcopy ( ary ) <NEWLINE> mary = deepcopy ( ary ) <NEWLINE> quick_sort ( qary , 0 , n - 1 ) <NEWLINE> merge_sort ( mary , 0 , n ) <NEWLINE> <NL> if qary == mary : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> [ print ( * _ ) for _ in qary ] <NEWLINE> <NL> <DEDENT>
def swap ( A , i , j ) : <NEWLINE> <INDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> return A <NEWLINE> <NL> <DEDENT> def isStable ( A ) : <NEWLINE> <INDENT> for i in range ( 1 , len ( A ) ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == A [ i - 1 ] [ 1 ] : <NEWLINE> <INDENT> if A [ i ] [ 2 ] < A [ i - 1 ] [ 2 ] : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <DEDENT> def partition ( A , p = 0 , r = None ) : <NEWLINE> <INDENT> if r is None : <NEWLINE> <INDENT> r = len ( A ) - 1 <NEWLINE> <DEDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x [ 1 ] : <NEWLINE> <INDENT> i += 1 <NEWLINE> swap ( A , i , j ) <NEWLINE> <DEDENT> <DEDENT> swap ( A , i + 1 , r ) <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quick ( A , p = 0 , r = None ) : <NEWLINE> <INDENT> if r is None : <NEWLINE> <INDENT> r = len ( A ) - 1 <NEWLINE> <DEDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quick ( A , p , q - 1 ) <NEWLINE> quick ( A , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> import sys <NEWLINE> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( sys . stdin . readline ( ) ) <NEWLINE> A = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> card = sys . stdin . readline ( ) . split ( ) <NEWLINE> A . append ( [ card [ 0 ] , int ( card [ 1 ] ) , i ] ) <NEWLINE> <DEDENT> quick ( A , 0 , n - 1 ) <NEWLINE> if isStable ( A ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for card in A : <NEWLINE> <INDENT> print ( card [ 0 ] , card [ 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
def partition ( A , B , p , r ) : <NEWLINE> <INDENT> x = A [ r ] <NEWLINE> i = p - 1 <NEWLINE> for j in xrange ( p , r ) : <NEWLINE> <INDENT> if A [ j ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> tmp = A [ i ] <NEWLINE> A [ i ] = A [ j ] <NEWLINE> A [ j ] = tmp <NEWLINE> tmp = B [ i ] <NEWLINE> B [ i ] = B [ j ] <NEWLINE> B [ j ] = tmp <NEWLINE> <DEDENT> <DEDENT> tmp = A [ i + 1 ] <NEWLINE> A [ i + 1 ] = A [ r ] <NEWLINE> A [ r ] = tmp <NEWLINE> tmp = B [ i + 1 ] <NEWLINE> B [ i + 1 ] = B [ r ] <NEWLINE> B [ r ] = tmp <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quick_sort ( A , B , p , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if p < r : <NEWLINE> <COMMENT> <NL> <INDENT> q = partition ( A , B , p , r ) <NEWLINE> quick_sort ( A , B , p , q - 1 ) <NEWLINE> quick_sort ( A , B , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def stable_check ( sorted_values , sorted_suits , default_values , default_suits , n ) : <NEWLINE> <INDENT> for i in xrange ( 1 , 10 ) : <NEWLINE> <INDENT> check_ss = [ ] <NEWLINE> check_ds = [ ] <NEWLINE> if i in sorted_values : <NEWLINE> <INDENT> for x in xrange ( n ) : <NEWLINE> <INDENT> if i == sorted_values [ x ] : <NEWLINE> <INDENT> check_ss . append ( sorted_suits [ x ] ) <NEWLINE> <DEDENT> if i == default_values [ x ] : <NEWLINE> <INDENT> check_ds . append ( default_suits [ x ] ) <NEWLINE> <DEDENT> <DEDENT> for x in xrange ( len ( check_ss ) ) : <NEWLINE> <INDENT> if check_ss [ x ] != check_ds [ x ] : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> A = [ ] <NEWLINE> B = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> b , a = raw_input ( ) . split ( ) <NEWLINE> A . append ( int ( a ) ) <NEWLINE> B . append ( b ) <NEWLINE> <DEDENT> cpA = list ( A ) <NEWLINE> setA = set ( A ) <NEWLINE> cpB = list ( B ) <NEWLINE> quick_sort ( A , B , 0 , n - 1 ) <NEWLINE> <NL> <COMMENT> <NL> print stable_check ( A , B , cpA , cpB , n ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> line = <STRING> % ( B [ i ] , A [ i ] ) <NEWLINE> print line <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def t ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] ; i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : i += 1 ; A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <DEDENT> def k ( A , p , r ) : <NEWLINE> <INDENT> if p < r : q = t ( A , p , r ) ; k ( A , p , q - 1 ) ; k ( A , q + 1 , r ) <NEWLINE> <DEDENT> def s ( A ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == A [ i + 1 ] [ 1 ] : <NEWLINE> <INDENT> if A [ i ] [ 2 ] > A [ i + 1 ] [ 2 ] : return 0 <NEWLINE> <DEDENT> <DEDENT> return 1 <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> f = lambda x , i : ( x [ 0 ] , int ( x [ 1 ] ) , i ) <NEWLINE> A = [ f ( sys . stdin . readline ( ) . split ( ) , i ) ) for i in range ( n ) ] <NEWLINE> k ( A , 0 , n - 1 ) <NEWLINE> print ( [ <STRING> , <STRING> ] [ s ( A ) ] + <STRING> ) <NEWLINE> for e in A : print ( * e [ : 2 ] ) <NEWLINE>
import sys <NEWLINE> def t ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] ; i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : i += 1 ; A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <DEDENT> def k ( A , p , r ) : <NEWLINE> <INDENT> if p < r : q = t ( A , p , r ) ; k ( A , p , q - 1 ) ; k ( A , q + 1 , r ) <NEWLINE> <DEDENT> def s ( A ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == A [ i + 1 ] [ 1 ] and A [ i ] [ 2 ] > A [ i + 1 ] [ 2 ] : return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ ( e [ 0 ] , int ( e [ 2 : ] ) , i ) for i , e in enumerate ( sys . stdin ) ] <NEWLINE> k ( A , 0 , n - 1 ) <NEWLINE> print ( s ( A ) + <STRING> ) <NEWLINE> print ( <STRING> . join ( <STRING> for a , b in A [ : 2 ] ) ) <NEWLINE>
def partition ( a , p , r ) : <NEWLINE> <INDENT> x = int ( a [ r ] [ 1 : ] ) <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if ( int ( a [ j ] [ 1 : ] ) <= x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> <DEDENT> <DEDENT> a [ i + 1 ] , a [ r ] = a [ r ] , a [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <DEDENT> def quicksort ( a , p , r ) : <NEWLINE> <INDENT> if ( p < r ) : <NEWLINE> <INDENT> q = partition ( a , p , r ) <NEWLINE> quicksort ( a , p , q - 1 ) <NEWLINE> quicksort ( a , q + 1 , r ) <NEWLINE> <NL> <DEDENT> <DEDENT> a = [ ] <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> s = input ( ) <NEWLINE> a . append ( <STRING> . join ( s . split ( ) ) ) <NEWLINE> <NL> <DEDENT> b = list ( a ) <NEWLINE> strr_bubble_sort ( b , n ) <NEWLINE> c = list ( a ) <NEWLINE> quicksort ( c , 0 , n - 1 ) <NEWLINE> <NL> d = dict ( ) <NEWLINE> i = 0 <NEWLINE> x = <STRING> <NEWLINE> for i in c : <NEWLINE> <INDENT> if ( x != i [ 1 : ] ) : <NEWLINE> <INDENT> d [ i [ 1 : ] ] = [ i [ : 1 ] ] <NEWLINE> x = i [ 1 : ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d [ x ] . append ( i [ : 1 ] ) <NEWLINE> <DEDENT> print ( d ) <NEWLINE> <NL> <DEDENT> message = <STRING> <NEWLINE> <NL> for i in reversed ( a ) : <NEWLINE> <INDENT> if ( i [ 1 : ] in d ) : <NEWLINE> <INDENT> print ( d ) <NEWLINE> if ( d [ i [ 1 : ] ] . pop ( ) != i [ : 1 ] ) : <NEWLINE> <INDENT> message = <STRING> <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( message ) <NEWLINE> <NL> for i in c : <NEWLINE> <INDENT> print ( <STRING> % ( i [ : 1 ] , i [ 1 : ] ) ) <NEWLINE> <DEDENT>
def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> def quicksort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quicksort ( A , p , q - 1 ) <NEWLINE> quicksort ( A , q + 1 , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def suitlist ( cards ) : <NEWLINE> <INDENT> suits = [ [ ] ] * 10 ** 9 <NEWLINE> for card in cards : <NEWLINE> <INDENT> suits [ int ( card [ 1 ] ) - 1 ] . append ( card [ 0 ] ) <NEWLINE> <DEDENT> return suits <NEWLINE> <NL> <NL> <DEDENT> def is_stable ( before , after ) : <NEWLINE> <INDENT> suits_b = suitlist ( before ) <NEWLINE> suits_a = suitlist ( after ) <NEWLINE> for a , b in zip ( suits_b , suits_a ) : <NEWLINE> <INDENT> if a != b : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> <DEDENT> return True <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> cards = [ ] <NEWLINE> origin = cards . copy ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> cards . append ( input ( ) . split ( ) ) <NEWLINE> <DEDENT> origin = cards . copy ( ) <NEWLINE> quicksort ( cards , 0 , n - 1 ) <NEWLINE> print ( <STRING> if is_stable ( origin , cards ) else <STRING> ) <NEWLINE> for card in cards : <NEWLINE> <INDENT> print ( * card ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> import sys <NEWLINE> import copy <NEWLINE> <NL> <NL> def partition ( array , start , end ) : <NEWLINE> <INDENT> x = int ( array [ end ] [ 2 : ] ) <NEWLINE> i = start - 1 <NEWLINE> assert start <= end <NEWLINE> for j in range ( start , end ) : <NEWLINE> <INDENT> if int ( array [ j ] [ 2 : ] ) <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> array [ i ] , array [ j ] = array [ j ] , array [ i ] <NEWLINE> <DEDENT> <DEDENT> array [ i + 1 ] , array [ end ] = array [ end ] , array [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> def quick_sort ( array , start , end ) : <NEWLINE> <INDENT> if start + 1 < end : <NEWLINE> <INDENT> cursor = partition ( array , start , end ) <NEWLINE> quick_sort ( array , start , cursor - 1 ) <NEWLINE> quick_sort ( array , cursor + 1 , end ) <NEWLINE> <DEDENT> return array <NEWLINE> <NL> <NL> <DEDENT> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> L = A [ left : mid ] + [ <STRING> + str ( int ( 1e9 + 1 ) ) ] <NEWLINE> R = A [ mid : right ] + [ <STRING> + str ( int ( 1e9 + 1 ) ) ] <NEWLINE> <NL> i , j = 0 , 0 <NEWLINE> <NL> for k in range ( left , right ) : <NEWLINE> <INDENT> if int ( L [ i ] [ 2 : ] ) <= int ( R [ j ] [ 2 : ] ) : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def merge_sort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> merge_sort ( A , left , mid ) <NEWLINE> merge_sort ( A , mid , right ) <NEWLINE> merge ( A , left , mid , right ) <NEWLINE> <DEDENT> return A <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> array_length = int ( _input [ 0 ] ) <NEWLINE> array = list ( map ( lambda x : x . strip ( <STRING> ) , _input [ 1 : ] ) ) <NEWLINE> assert len ( array ) == array_length <NEWLINE> <NL> merge_array = copy . deepcopy ( array ) <NEWLINE> <NL> <COMMENT> <NL> merge_result = merge_sort ( A = merge_array , left = 0 , right = array_length ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> quick_result = quick_sort ( array = array , start = 0 , end = array_length ) <NEWLINE> if quick_result != merge_result : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> print ( * quick_result , sep = <STRING> ) <NEWLINE> <DEDENT>
def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] / 10 <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] / 10 <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> i += 1 <NEWLINE> A [ i ] , A [ r ] = A [ r ] , A [ i ] <NEWLINE> return i <NEWLINE> <NL> <DEDENT> def quicksort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( A , p , r ) <NEWLINE> quicksort ( A , p , q - 1 ) <NEWLINE> quicksort ( A , q + 1 , r ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> def bubblesort ( A ) : <NEWLINE> <INDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> for j in range ( i + 1 , len ( A ) ) [ : : - 1 ] : <NEWLINE> <INDENT> if A [ j ] / 10 < A [ j - 1 ] / 10 : <NEWLINE> <INDENT> A [ j ] , A [ j - 1 ] = A [ j - 1 ] , A [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = [ [ ] for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = raw_input ( ) . split ( ) <NEWLINE> x [ i ] = int ( b ) * 10 + <STRING> . index ( a ) <NEWLINE> <NL> <DEDENT> x1 = x + [ ] <NEWLINE> quicksort ( x1 , 0 , n - 1 ) <NEWLINE> x2 = x + [ ] <NEWLINE> bubblesort ( x2 ) <NEWLINE> <NL> if x1 == x2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> for e in x1 : <NEWLINE> <INDENT> print <STRING> [ e % 10 ] , e / 10 <NEWLINE> <DEDENT>
def mergesort ( A , s , e ) : <NEWLINE> <INDENT> if s + 1 < e : <NEWLINE> <INDENT> m = ( e + s ) // 2 <NEWLINE> mergesort ( A , s , m ) <NEWLINE> mergesort ( A , m , e ) <NEWLINE> merge ( A , s , m , e ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def merge ( A , s , m , e ) : <NEWLINE> <INDENT> L = A [ s : m ] + [ ( <STRING> , 1E10 ) ] <NEWLINE> R = A [ m : e ] + [ ( <STRING> , 1E10 ) ] <NEWLINE> ix_l = ix_r = 0 <NEWLINE> for ix in range ( s , e ) : <NEWLINE> <INDENT> if L [ ix_l ] [ 1 ] < R [ ix_r ] [ 1 ] : <NEWLINE> <INDENT> A [ ix ] = L [ ix_l ] <NEWLINE> ix_l += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ ix ] = R [ ix_r ] <NEWLINE> ix_r += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def partition ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <NL> <NL> <DEDENT> def quicksort ( A , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> i = partition ( A , p , r ) <NEWLINE> quicksort ( A , p , i - 1 ) <NEWLINE> quicksort ( A , i + 1 , r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> fin = open ( <STRING> ) <NEWLINE> input = fin . readline <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> N = int ( input ( ) . strip ( ) ) <NEWLINE> AA = [ 0 ] * N <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> key , val = input ( ) . strip ( ) . split ( ) <NEWLINE> val = int ( val ) <NEWLINE> AA [ i ] = ( key , val ) <NEWLINE> <DEDENT> AA2 = AA [ : ] <NEWLINE> quicksort ( AA , 0 , len ( AA ) - 1 ) <NEWLINE> mergesort ( AA2 , 0 , len ( AA2 ) ) <NEWLINE> if all ( [ a == a2 for a , a2 in zip ( AA , AA2 ) ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> for key , val in AA : <NEWLINE> <INDENT> print ( <STRING> . format ( key , val ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> def t ( A , p , r ) : <NEWLINE> <INDENT> x = A [ r ] [ 1 ] ; i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if A [ j ] [ 1 ] <= x : i += 1 ; A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> <DEDENT> A [ i + 1 ] , A [ r ] = A [ r ] , A [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <DEDENT> def k ( A , p , r ) : <NEWLINE> <INDENT> if p < r : q = t ( A , p , r ) ; k ( A , p , q - 1 ) ; k ( A , q + 1 , r ) <NEWLINE> <DEDENT> def s ( A ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> if A [ i ] [ 1 ] == A [ i + 1 ] [ 1 ] and A [ i ] [ 2 ] > A [ i + 1 ] [ 2 ] : return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> def m ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> A = [ ( e [ 0 ] , int ( e [ 2 : ] ) , i ) for i , e in enumerate ( sys . stdin ) ] <NEWLINE> k ( A , 0 , n - 1 ) <NEWLINE> print ( s ( A ) + <STRING> ) <NEWLINE> print ( <STRING> . join ( <STRING> for a , b , _ in A ) ) <NEWLINE> <DEDENT> if <STRING> == __name__ : m ( ) <NEWLINE>
import copy <NEWLINE> <NL> INF = 10000000000 <NEWLINE> def merge ( A , left , mid , right ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> L = A [ left : mid ] + [ ( INF , INF ) ] <NEWLINE> R = A [ mid : right ] + [ ( INF , INF ) ] <NEWLINE> <NL> i , j = 0 , 0 <NEWLINE> for k in range ( left , right ) : <NEWLINE> <INDENT> count = count + 1 <NEWLINE> if L [ i ] [ 1 ] <= R [ j ] [ 1 ] : <NEWLINE> <INDENT> A [ k ] = L [ i ] <NEWLINE> i = i + 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A [ k ] = R [ j ] <NEWLINE> j = j + 1 <NEWLINE> <DEDENT> <DEDENT> return count <NEWLINE> <NL> <DEDENT> def mergeSort ( A , left , right ) : <NEWLINE> <INDENT> if left + 1 < right : <NEWLINE> <INDENT> mid = ( left + right ) // 2 <NEWLINE> countL = mergeSort ( A , left , mid ) <NEWLINE> countR = mergeSort ( A , mid , right ) <NEWLINE> return merge ( A , left , mid , right ) + countL + countR <NEWLINE> <DEDENT> return 0 <NEWLINE> <DEDENT> def partition ( a , p , r ) : <NEWLINE> <INDENT> x = a [ r ] [ 1 ] <NEWLINE> i = p - 1 <NEWLINE> for j in range ( p , r ) : <NEWLINE> <INDENT> if a [ j ] [ 1 ] <= x : <NEWLINE> <INDENT> i += 1 <NEWLINE> a [ i ] , a [ j ] = a [ j ] , a [ i ] <NEWLINE> <DEDENT> <DEDENT> a [ i + 1 ] , a [ r ] = a [ r ] , a [ i + 1 ] <NEWLINE> return i + 1 <NEWLINE> <DEDENT> def quickSort ( a , p , r ) : <NEWLINE> <INDENT> if p < r : <NEWLINE> <INDENT> q = partition ( a , p , r ) <NEWLINE> quicksort ( a , p , q - 1 ) <NEWLINE> quicksort ( a , q + 1 , r ) <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> A = [ None for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> A [ i ] = ( a , int ( b ) ) <NEWLINE> <NL> <DEDENT> B = copy . deepcopy ( A ) <NEWLINE> quickSort ( A , 0 , n - 1 ) <NEWLINE> mergeSort ( B , 0 , n ) <NEWLINE> if A == B : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> ans = [ str ( x [ 0 ] ) + <STRING> + str ( x [ 1 ] ) for x in A ] <NEWLINE> ans = <STRING> . join ( ans ) <NEWLINE> print ( ans ) <NEWLINE>
import sys <NEWLINE> <NL> def minimumCostSort ( A ) : <NEWLINE> <INDENT> B = sorted ( A ) <NEWLINE> V = [ False ] * len ( A ) <NEWLINE> T = [ 0 ] * 10000 <NEWLINE> ans = 0 <NEWLINE> s = min ( A ) <NEWLINE> <NL> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> T [ B [ i ] ] = i <NEWLINE> <NL> <DEDENT> for i in range ( len ( A ) ) : <NEWLINE> <INDENT> if V [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> S = an = 0 <NEWLINE> j = i <NEWLINE> m = 10000 <NEWLINE> while True : <NEWLINE> <INDENT> V [ j ] = True <NEWLINE> an += 1 <NEWLINE> v = A [ j ] <NEWLINE> m = min ( m , v ) <NEWLINE> S += v <NEWLINE> j = T [ v ] <NEWLINE> if V [ j ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> ans += min ( S + ( an - 2 ) * m , m + S + ( an + 1 ) * s ) <NEWLINE> <DEDENT> return ans <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> A = map ( int , lines [ 1 ] . split ( ) ) <NEWLINE> print minimumCostSort ( A ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> s = min ( A ) <NEWLINE> def solve ( ) : <NEWLINE> <INDENT> ans = 0 <NEWLINE> V = [ False ] * n <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> T = { B : i for i , B in enumerate ( sorted ( A ) ) } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if V [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cur = i <NEWLINE> S = an = 0 <NEWLINE> m = 10000 <NEWLINE> while not V [ cur ] : <NEWLINE> <INDENT> V [ cur ] = True <NEWLINE> an += 1 <NEWLINE> v = A [ cur ] <NEWLINE> m = min ( m , v ) <NEWLINE> S += v <NEWLINE> cur = T [ v ] <NEWLINE> <DEDENT> ans += min ( S + ( an - 2 ) * m , m + S + ( an + 1 ) * s ) <NEWLINE> <DEDENT> return ans <NEWLINE> <DEDENT> print ( solve ( ) ) <NEWLINE> <NL>
def get_weights ( ) : <NEWLINE> <INDENT> raw_input ( ) <NEWLINE> return map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def minimam_cost_sort ( weights ) : <NEWLINE> <INDENT> lol = [ ] <NEWLINE> for i in range ( len ( weights ) ) : <NEWLINE> <INDENT> if weights [ i ] != 0 : <NEWLINE> <INDENT> j = weights [ i ] <NEWLINE> weights [ i ] = 0 <NEWLINE> l = [ j ] <NEWLINE> while weights [ j - 1 ] != 0 : <NEWLINE> <INDENT> l . append ( weights [ j - 1 ] ) <NEWLINE> k = j <NEWLINE> j = weights [ k - 1 ] <NEWLINE> weights [ k - 1 ] = 0 <NEWLINE> <DEDENT> l . sort ( ) <NEWLINE> lol . append ( l ) <NEWLINE> <NL> <DEDENT> <DEDENT> lol . sort ( ) <NEWLINE> s = 0 <NEWLINE> for l in lol : <NEWLINE> <INDENT> s += get_wol ( l ) <NEWLINE> <NL> <DEDENT> print s <NEWLINE> <NL> <DEDENT> def get_wol ( l ) : <NEWLINE> <INDENT> sub = ( l [ 0 ] - 1 ) * ( len ( l ) - 1 ) - ( l [ 0 ] + 1 ) * 2 <NEWLINE> s = sum ( l ) + ( l [ 0 ] * ( len ( l ) - 2 ) ) <NEWLINE> if sub > 0 : <NEWLINE> <INDENT> return s - sub <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> minimam_cost_sort ( get_weights ( ) ) <NEWLINE>
def swap ( A , i , j ) : <NEWLINE> <INDENT> A [ i ] , A [ j ] = A [ j ] , A [ i ] <NEWLINE> return A <NEWLINE> <NL> <DEDENT> def mincost ( A ) : <NEWLINE> <INDENT> B = sorted ( A ) <NEWLINE> cost = 0 <NEWLINE> <NL> for i , bi in enumerate ( B ) : <NEWLINE> <INDENT> t = 0 <NEWLINE> j = A . index ( bi ) <NEWLINE> tmp_cost = 0 <NEWLINE> <NL> <COMMENT> <NL> while j != i : <NEWLINE> <INDENT> t += 1 <NEWLINE> bj = B [ j ] <NEWLINE> k = A . index ( bj ) <NEWLINE> tmp_cost += bi + bj <NEWLINE> swap ( A , j , k ) <NEWLINE> j = k <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> dec = t * ( bj - B [ 0 ] ) <NEWLINE> inc = 2 * ( bj + B [ 0 ] ) <NEWLINE> <NL> if dec < inc : <NEWLINE> <INDENT> cost += tmp_cost <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost += tmp_cost - dec + inc <NEWLINE> <DEDENT> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> input ( ) <NEWLINE> A = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> cost = mincost ( A ) <NEWLINE> print ( cost ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = sorted ( a ) <NEWLINE> c = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = a . index ( b [ i ] ) <NEWLINE> j = 0 <NEWLINE> while x > i : <NEWLINE> <INDENT> j += 1 <NEWLINE> y = a . index ( b [ x ] ) <NEWLINE> c += a [ b ] <NEWLINE> a [ x ] , a [ y ] = a [ y ] , a [ x ] <NEWLINE> x = y <NEWLINE> <DEDENT> c += min ( b [ i ] * j , b [ i ] * 2 + b [ 0 ] * ( j + 2 ) ) <NEWLINE> <DEDENT> print ( c ) <NEWLINE>
def q ( a , h ) : <NEWLINE> <INDENT> d [ a ] = str ( h ) <NEWLINE> for b in t [ a ] : q ( b , h + 1 ) <NEWLINE> <DEDENT> t , p , d = { } , { } , { } <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> e = input ( ) . split ( ) <NEWLINE> t [ e [ 0 ] ] = e [ 2 : ] <NEWLINE> for i in e [ 2 : ] : p [ i ] = e [ 0 ] <NEWLINE> <DEDENT> r = ( set ( t ) - set ( p ) ) . pop ( ) <NEWLINE> p [ r ] = <STRING> <NEWLINE> q ( r , 0 ) <NEWLINE> for i in sorted ( map ( int , t ) ) : <NEWLINE> <INDENT> i = str ( i ) ; print ( <STRING> root <STRING> - 1 <STRING> internal node <STRING> leaf <STRING> ) <NEWLINE> <DEDENT>
fin = open ( <STRING> ) <NEWLINE> input = fin . readline <NEWLINE> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> A = [ 0 ] * N <NEWLINE> node_info = [ [ - 1 , 0 , <STRING> , None ] for _ in range ( int ( 1E5 + 1 ) ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> A [ i ] = [ int ( i ) for i in input ( ) . strip ( ) . split ( ) ] <NEWLINE> <DEDENT> for line in A : <NEWLINE> <INDENT> if line [ 1 ] != 0 : <NEWLINE> <INDENT> node_info [ line [ 0 ] ] [ 3 ] = line [ 2 : ] <NEWLINE> for c in line [ 2 : ] : <NEWLINE> <INDENT> node_info [ c ] [ 0 ] = line [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for line in A : <NEWLINE> <INDENT> pid = node_info [ line [ 0 ] ] [ 0 ] <NEWLINE> if pid == - 1 : <NEWLINE> <INDENT> node_info [ line [ 0 ] ] [ 2 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if node_info [ line [ 0 ] ] [ 3 ] is None : <NEWLINE> <INDENT> node_info [ line [ 0 ] ] [ 2 ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> if node_info [ line [ 0 ] ] [ 3 ] is None : <NEWLINE> <INDENT> node_info [ line [ 0 ] ] [ 3 ] = [ <STRING> ] <NEWLINE> <NL> <DEDENT> depth = 0 <NEWLINE> while pid != - 1 : <NEWLINE> <INDENT> depth += 1 <NEWLINE> pid = node_info [ pid ] [ 0 ] <NEWLINE> <DEDENT> node_info [ line [ 0 ] ] [ 1 ] = depth <NEWLINE> <NL> <DEDENT> for line in sorted ( A , key = lambda a : a [ 0 ] ) : <NEWLINE> <INDENT> print ( <STRING> . format ( <NEWLINE> <INDENT> line [ 0 ] , node_info [ line [ 0 ] ] [ 0 ] , <NEWLINE> node_info [ line [ 0 ] ] [ 1 ] , node_info [ line [ 0 ] ] [ 2 ] , <STRING> . join ( [ str ( i ) for i in node_info [ line [ 0 ] ] [ 3 ] ] ) ) <NEWLINE> <DEDENT> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . parent_id = - 1 <NEWLINE> self . depth = - 1 <NEWLINE> self . children = None <NEWLINE> <DEDENT> def get_type ( self ) : <NEWLINE> <INDENT> if self . parent_id == - 1 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif self . children == None or len ( self . children ) == 0 : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> strNode = <STRING> + str ( self . id ) + <STRING> <NEWLINE> strNode += <STRING> + str ( self . parent_id ) + <STRING> <NEWLINE> strNode += <STRING> + str ( self . depth ) + <STRING> <NEWLINE> strNode += self . get_type ( ) + <STRING> <NEWLINE> if len ( self . children ) > 0 : <NEWLINE> <INDENT> strNode += str ( self . children [ 0 ] ) <NEWLINE> for i in range ( 1 , len ( self . children ) ) : <NEWLINE> <INDENT> strNode += <STRING> + str ( self . children [ i ] ) <NEWLINE> <DEDENT> <DEDENT> strNode += <STRING> <NEWLINE> return strNode <NEWLINE> <NL> <DEDENT> <DEDENT> def calc_depth ( nodes ) : <NEWLINE> <INDENT> stack = [ ] <NEWLINE> for i in range ( len ( nodes ) ) : <NEWLINE> <INDENT> if nodes [ i ] . parent_id == - 1 : <NEWLINE> <INDENT> nodes [ i ] . depth = 0 <NEWLINE> stack . append ( nodes [ i ] . id ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> while len ( stack ) != 0 : <NEWLINE> <INDENT> node = nodes [ stack . pop ( ) ] <NEWLINE> for i in range ( len ( node . children ) ) : <NEWLINE> <INDENT> child_id = node . children [ i ] <NEWLINE> nodes [ child_id ] . depth = node . depth + 1 <NEWLINE> stack . append ( child_id ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> nodes = [ Node ( i ) for i in range ( n ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> id = a [ 0 ] <NEWLINE> m = a [ 1 ] <NEWLINE> children = [ 0 ] * m <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> child_id = a [ 2 + j ] <NEWLINE> child = nodes [ child_id ] <NEWLINE> child . parent_id = id <NEWLINE> children [ j ] = child_id <NEWLINE> <DEDENT> nodes [ id ] . children = children <NEWLINE> <NL> <DEDENT> calc_depth ( nodes ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE>
t = { } <NEWLINE> p = { } <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> e = input ( ) . split ( ) <NEWLINE> t [ e [ 0 ] ] = e [ 2 : ] <NEWLINE> for i in e [ 2 : ] : p [ i ] = e [ 0 ] <NEWLINE> <DEDENT> r = ( set ( t ) - set ( p ) ) . pop ( ) <NEWLINE> p [ r ] = <STRING> <NEWLINE> d = { r : 0 } <NEWLINE> for <NEWLINE> for i in t : <NEWLINE> <INDENT> f = <STRING> if <STRING> == p [ i ] else <STRING> if t [ i ] else <STRING> <NEWLINE> d = <STRING> <NEWLINE> print ( <STRING> , i + <STRING> , <STRING> , p [ i ] + <STRING> , <STRING> , d + <STRING> , f , list ( map ( int , t [ i ] ) ) ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> class Node_Class ( ) : <NEWLINE> <INDENT> def __init__ ( self , c_list ) : <NEWLINE> <INDENT> self . c_list = c_list <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> node_dic = { } <NEWLINE> p_list = [ 0 ] * n <NEWLINE> d_list = [ 0 ] * n <NEWLINE> t_list = [ <STRING> ] * n <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> line = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if int ( line [ 1 ] ) > 0 : <NEWLINE> <INDENT> node_dic [ int ( line [ 0 ] ) ] = Node_Class ( map ( int , line [ 2 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node_dic [ int ( line [ 0 ] ) ] = Node_Class ( [ ] ) <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> flag = False <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> if i in node_dic [ j ] . c_list : <NEWLINE> <INDENT> p_list [ i ] = j <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if not flag : <NEWLINE> <INDENT> p_list [ i ] = - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> j = i <NEWLINE> while p_list [ j ] > - 1 : <NEWLINE> <INDENT> j = p_list [ j ] <NEWLINE> d_list [ i ] += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if p_list [ i ] == - 1 : <NEWLINE> <INDENT> t_list [ i ] = t_list [ i ] + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( node_dic [ i ] . c_list ) : <NEWLINE> <INDENT> t_list [ i ] = t_list [ i ] + <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t_list [ i ] = t_list [ i ] + <STRING> <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s = <STRING> % ( i , p_list [ i ] , d_list [ i ] , t_list [ i ] ) <NEWLINE> print s , node_dic [ i ] . c_list <NEWLINE> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , num , parent , children ) : <NEWLINE> <INDENT> self . id = num <NEWLINE> self . parent = - 1 <NEWLINE> self . depth = 0 <NEWLINE> self . type = None <NEWLINE> self . children = children <NEWLINE> <NL> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . id , self . parent , self . depth , self . type , self . children ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def set_node ( node_data ) : <NEWLINE> <INDENT> L = list ( map ( int , node_data . split ( ) ) ) <NEWLINE> num = i_l [ 0 ] <NEWLINE> children = i_l [ 2 : ] <NEWLINE> node = Node ( num , - 1 , children ) <NEWLINE> T [ num ] = node <NEWLINE> for n in children : <NEWLINE> <INDENT> T [ - 1 ] -= n <NEWLINE> <NL> <DEDENT> <DEDENT> def set_pdt ( n_i , parent , depth ) : <NEWLINE> <INDENT> node = T [ n_i ] <NEWLINE> node . parent = parent <NEWLINE> node . depth = depth <NEWLINE> if node . children : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> for n in node . children : <NEWLINE> <INDENT> set_pdt ( n , n_i , depth + 1 ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> node . type = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <NL> T = [ None ] * n <NEWLINE> <NL> T . append ( int ( n * ( n - 1 ) / 2 ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> set_node ( x ) <NEWLINE> <NL> <DEDENT> set_pdt ( T [ - 1 ] , - 1 , 0 ) <NEWLINE> <NL> T [ T [ - 1 ] ] . type = <STRING> <NEWLINE> <NL> for n in T [ : - 1 ] : <NEWLINE> <INDENT> n . show ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> n = int ( raw_input ( ) ) <NEWLINE> <NL> <NL> <COMMENT> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . p = - 1 <NEWLINE> self . l = - 1 <NEWLINE> self . r = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> T = [ Node ( ) for _ in xrange ( n ) ] <COMMENT> <NEWLINE> D = [ 0 ] * n <COMMENT> <NEWLINE> <NL> def printInfo ( u ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> print <STRING> . format ( u , T [ u ] . p , D [ u ] ) , <NEWLINE> if T [ u ] . p == - 1 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> elif T [ u ] . l == - 1 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> c = T [ u ] . l <NEWLINE> i = 0 <NEWLINE> while c != - 1 : <NEWLINE> <INDENT> if i > 0 : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> <DEDENT> sys . stdout . write ( str ( c ) ) <NEWLINE> <COMMENT> <NL> c = T [ c ] . r <NEWLINE> i += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> return 0 <NEWLINE> <NL> <DEDENT> def rec ( u , p ) : <NEWLINE> <INDENT> D [ u ] = p <NEWLINE> if T [ u ] . r != - 1 : <NEWLINE> <INDENT> rec ( T [ u ] . r , p ) <NEWLINE> <DEDENT> if T [ u ] . l != - 1 : <NEWLINE> <INDENT> rec ( T [ u ] . l , p + 1 ) <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> v = a [ 0 ] <NEWLINE> d = a [ 1 ] <NEWLINE> for j in xrange ( d ) : <NEWLINE> <INDENT> if j == 0 : <NEWLINE> <INDENT> T [ v ] . l = a [ j + 2 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> T [ l ] . r = a [ j + 2 ] <NEWLINE> <DEDENT> l = a [ j + 2 ] <NEWLINE> T [ a [ j + 2 ] ] . p = v <NEWLINE> <DEDENT> <DEDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> if T [ i ] . p == - 1 : <NEWLINE> <INDENT> r = i <NEWLINE> <NL> <DEDENT> <DEDENT> rec ( r , 0 ) <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> printInfo ( i ) <NEWLINE> <NL> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
def set_pdt ( i , p , d ) : <NEWLINE> <INDENT> u = tree [ i ] <NEWLINE> u [ 0 ] , u [ 1 ] = p , d <NEWLINE> for c in u [ 3 ] : <NEWLINE> <INDENT> set_pdt ( c , i , d + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if u [ 0 ] == - 1 : <NEWLINE> <INDENT> u [ 2 ] = <STRING> <NEWLINE> <DEDENT> elif u [ 3 ] : <NEWLINE> <INDENT> u [ 2 ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> u [ 2 ] = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> <COMMENT> <NL> tree = [ [ - 1 , 0 , 0 , 0 ] for _ in range ( n ) ] <NEWLINE> root = set ( range ( n ) ) <NEWLINE> <NL> for _ in range ( n ) : <NEWLINE> <INDENT> i , k , * c = map ( int , input ( ) . split ( ) ) <NEWLINE> tree [ i ] [ 3 ] = c <NEWLINE> root -= set ( c ) <NEWLINE> <NL> <DEDENT> set_pdt ( root [ 0 ] , - 1 , 0 ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> u = tree [ i ] <NEWLINE> print ( <STRING> . format ( i , * u ) ) <NEWLINE> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , parent , left , right ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def get_type ( self ) : <NEWLINE> <INDENT> if self . parent == - 1 : return <STRING> <NEWLINE> elif self . left == - 1 : return <STRING> <NEWLINE> else : return <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def set_depth ( u , d ) : <NEWLINE> <INDENT> global D <NEWLINE> global tree <NEWLINE> D [ u ] = d <NEWLINE> while not tree [ u ] . right == - 1 : <NEWLINE> <INDENT> u = tree [ u ] . right <NEWLINE> D [ u ] = d <NEWLINE> <DEDENT> if not tree [ u ] . left == - 1 : <NEWLINE> <INDENT> set_depth ( tree [ u ] . left , d + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_tree ( t , D ) : <NEWLINE> <INDENT> for i in range ( len ( t ) ) : <NEWLINE> <INDENT> children = [ ] <NEWLINE> c = t [ i ] . left <NEWLINE> if not c == - 1 : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> children . append ( c ) <NEWLINE> c = t [ c ] . right <NEWLINE> if c == - 1 : break <NEWLINE> <DEDENT> <DEDENT> print <STRING> % ( i , t [ i ] . parent , D [ i ] , t [ i ] . get_type ( ) , <STRING> . join ( map ( str , children ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) . strip ( ) ) <NEWLINE> <NL> tree = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tree [ i ] = Node ( - 1 , - 1 , - 1 ) <NEWLINE> <DEDENT> for _ in range ( n ) : <NEWLINE> <INDENT> entry = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> nid = entry [ 0 ] <NEWLINE> n_child = entry [ 1 ] <NEWLINE> for i in range ( n_child ) : <NEWLINE> <INDENT> if i == 0 : tree [ nid ] . left = entry [ i + 2 ] <NEWLINE> else : tree [ entry [ i + 1 ] ] . right = entry [ i + 2 ] <NEWLINE> tree [ entry [ i + 2 ] ] . parent = nid <NEWLINE> <NL> <DEDENT> <DEDENT> r = - 1 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if tree [ i ] . parent == - 1 : r = i <NEWLINE> <NL> <DEDENT> D = { } <NEWLINE> set_depth ( r , 0 ) <NEWLINE> <NL> print_tree ( tree , D ) <NEWLINE>
import java . io . BufferedReader ; <NEWLINE> import java . io . IOException ; <NEWLINE> import java . io . InputStreamReader ; <NEWLINE> import java . util . Arrays ; <NEWLINE> import java . util . StringTokenizer ; <NEWLINE> <NL> public class Main { <NEWLINE> <NL> <INDENT> static class Node { <NEWLINE> <INDENT> int id ; <NEWLINE> int parentId ; <NEWLINE> int depth ; <NEWLINE> int [ ] children ; <NEWLINE> public Node ( int id , int parentId ) { <NEWLINE> <INDENT> this . id = id ; <NEWLINE> this . parentId = parentId ; <NEWLINE> this . children = null ; <NEWLINE> this . depth = 0 ; <NEWLINE> <DEDENT> } <NEWLINE> public void setChildlen ( int [ ] childlen ) { <NEWLINE> <INDENT> this . children = childlen ; <NEWLINE> <DEDENT> } <NEWLINE> public void setParentId ( int parentId ) { <NEWLINE> <INDENT> this . parentId = parentId ; <NEWLINE> <DEDENT> } <NEWLINE> public void setDepth ( int depth ) { <NEWLINE> <INDENT> this . depth = depth ; <NEWLINE> <DEDENT> } <NEWLINE> private String getType ( ) { <NEWLINE> <INDENT> if ( depth == 0 ) { <NEWLINE> <INDENT> return <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> if ( children == null | | children . length == 0 ) { <NEWLINE> <INDENT> return <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> return <STRING> ; <NEWLINE> <DEDENT> } <NEWLINE> public String toString ( ) { <NEWLINE> <INDENT> StringBuilder sb = new StringBuilder ( ) ; <NEWLINE> sb . append ( <STRING> + id + <STRING> ) ; <NEWLINE> sb . append ( <STRING> + parentId + <STRING> ) ; <NEWLINE> sb . append ( <STRING> + depth + <STRING> ) ; <NEWLINE> sb . append ( getType ( ) + <STRING> ) ; <NEWLINE> sb . append ( Arrays . toString ( children ) ) ; <NEWLINE> return sb . toString ( ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL> public static void main ( String [ ] args ) throws IOException { <NEWLINE> <INDENT> BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; <NEWLINE> int n = Integer . parseInt ( reader . readLine ( ) ) ; <NEWLINE> Node [ ] nodes = new Node [ n ] ; <NEWLINE> <NL> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <NL> <INDENT> StringTokenizer st = new StringTokenizer ( reader . readLine ( ) ) ; <NEWLINE> <NL> int id = Integer . parseInt ( st . nextToken ( ) ) ; <NEWLINE> if ( nodes [ id ] == null ) { <NEWLINE> <INDENT> nodes [ id ] = new Node ( id , - 1 ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> int m = Integer . parseInt ( st . nextToken ( ) ) ; <NEWLINE> int [ ] children = new int [ m ] ; <NEWLINE> for ( int j = 0 ; j < m ; j + + ) { <NEWLINE> <INDENT> int childId = Integer . parseInt ( st . nextToken ( ) ) ; <NEWLINE> children [ j ] = childId ; <NEWLINE> if ( nodes [ childId ] == null ) { <NEWLINE> <INDENT> nodes [ childId ] = new Node ( childId , id ) ; <NEWLINE> <DEDENT> } else { <NEWLINE> <INDENT> nodes [ childId ] . setParentId ( id ) ; <NEWLINE> <DEDENT> } <NEWLINE> nodes [ childId ] . setDepth ( nodes [ id ] . depth + 1 ) ; <NEWLINE> <DEDENT> } <NEWLINE> nodes [ id ] . setChildlen ( children ) ; <NEWLINE> <DEDENT> } <NEWLINE> <NL> for ( Node node : nodes ) { <NEWLINE> <INDENT> System . out . println ( node ) ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <NL>
N = int ( input ( ) ) <NEWLINE> t = [ 0 ] * N <NEWLINE> r = set ( range ( N ) ) <NEWLINE> for _ in [ 0 ] * N : <NEWLINE> <INDENT> e = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t [ e [ 0 ] ] = e [ 1 : ] + [ 0 ] * 5 <NEWLINE> r -= { e [ 1 : ] } <NEWLINE> <DEDENT> def f ( i , p , s , d ) : <NEWLINE> <INDENT> if i < 0 : return - 1 <NEWLINE> l , r = t [ i ] [ : 2 ] <NEWLINE> t [ i ] [ 2 : ] = [ p , s , ( l != - 1 ) + ( r != - 1 ) , d , max ( f ( l , i , r , d + 1 ) , f ( r , i , l , d + 1 ) ) + 1 ] <NEWLINE> return t [ i ] [ - 1 ] <NEWLINE> <DEDENT> f ( r . pop ( ) , - 1 , - 1 , 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , * t [ i ] [ 2 : ] , <STRING> if not t [ i ] [ 5 ] else <STRING> if t [ i ] [ 4 ] else <STRING> ) ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> def dfs ( here , p , d , conn , parent , depth , height ) : <NEWLINE> <INDENT> parent [ here ] = p <NEWLINE> depth [ here ] = d <NEWLINE> l_d , r_d = 0 , 0 <NEWLINE> for c in conn [ here ] : <NEWLINE> <INDENT> if c [ 0 ] >= 0 : <NEWLINE> <INDENT> l_d = dfs ( c [ 0 ] , here , d + 1 , conn , parent , depth , height ) <NEWLINE> <DEDENT> if c [ 1 ] >= 0 : <NEWLINE> <INDENT> r_d = dfs ( c [ 1 ] , here , d + 1 , conn , parent , depth , height ) <NEWLINE> <DEDENT> <DEDENT> if len ( conn [ here ] ) : <NEWLINE> <INDENT> height [ here ] = max ( max ( l_d , r_d ) - d , 0 ) <NEWLINE> <DEDENT> return max ( l_d , r_d , d ) <NEWLINE> <NL> <DEDENT> v_num = int ( input ( ) ) <NEWLINE> conn = defaultdict ( list ) <NEWLINE> in_v = [ 0 for n in range ( v_num + 1 ) ] <NEWLINE> for _ in range ( v_num ) : <NEWLINE> <INDENT> v , left , right = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> conn [ v ] . append ( [ left , right ] ) <NEWLINE> in_v [ left ] += 1 <NEWLINE> in_v [ right ] += 1 <NEWLINE> degree [ v ] += int ( left >= 0 ) + int ( right >= 0 ) <NEWLINE> <DEDENT> for i , n in enumerate ( in_v ) : <NEWLINE> <INDENT> if not n : <NEWLINE> <INDENT> root = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> parent = [ - 1 for n in range ( v_num ) ] <NEWLINE> depth = [ 0 for n in range ( v_num ) ] <NEWLINE> height = [ 0 for n in range ( v_num ) ] <NEWLINE> dfs ( root , - 1 , 0 , conn , parent , depth , height ) <NEWLINE> sibling = [ - 1 for n in range ( v_num ) ] <NEWLINE> degree = [ 0 for n in range ( v_num ) ] <NEWLINE> for i in range ( v_num ) : <NEWLINE> <INDENT> for j in range ( v_num ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> elif parent [ i ] == parent [ j ] : <NEWLINE> <INDENT> sibling [ i ] = j <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> v_type = [ <STRING> for n in range ( v_num ) ] <NEWLINE> for i in range ( v_num ) : <NEWLINE> <INDENT> if i == root : <NEWLINE> <INDENT> v_type [ i ] = <STRING> <NEWLINE> <DEDENT> elif len ( conn [ i ] ) != 0 : <NEWLINE> <INDENT> v_type [ i ] = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> v_type [ i ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> for i in range ( v_num ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , parent [ i ] , sibling [ i ] , degree [ i ] , depth [ i ] , height [ i ] , v_type [ i ] ) ) <NEWLINE> <DEDENT>
def q ( a , k ) : <NEWLINE> <INDENT> d [ a ] = k <NEWLINE> for b in t [ a ] : <NEWLINE> <INDENT> if <STRING> != b : q ( b , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> def n ( a , k ) : <NEWLINE> <INDENT> h [ a ] = max ( h [ a ] , k ) if a in h else k <NEWLINE> if <STRING> != p [ a ] : n ( p [ a ] , k + 1 ) <NEWLINE> <DEDENT> t , p , s , d , h = { } , { } , { } , { } , { } <NEWLINE> for _ in [ 0 ] * int ( input ( ) ) : <NEWLINE> <INDENT> x , y , z = input ( ) . split ( ) <NEWLINE> t [ x ] = set ( [ y , z ] ) - { - 1 } <NEWLINE> p [ y ] = p [ z ] = x <NEWLINE> s [ y ] , s [ z ] = z , y <NEWLINE> <DEDENT> r = ( set ( t ) - set ( p ) ) . pop ( ) <NEWLINE> p [ r ] = s [ r ] = <STRING> <NEWLINE> q ( r , 0 ) <NEWLINE> for i in t : <NEWLINE> <INDENT> if not t [ i ] : n ( i , 0 ) <NEWLINE> <DEDENT> for i in map ( str , sorted ( map ( int , t ) ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
def f ( n , d ) : <NEWLINE> <INDENT> t = [ f ( i , d + 1 ) + 1 for i in l [ n ] [ 1 ] ] <NEWLINE> h = 0 if t == [ ] else max ( t ) <NEWLINE> c [ n ] [ 3 : 3 ] = [ len ( l [ n ] [ 1 ] ) , d , h , <STRING> if d < 1 else <STRING> if h < 1 else <STRING> ] <NEWLINE> return h <NEWLINE> <DEDENT> m = input ( ) <NEWLINE> c = [ 0 ] * m <NEWLINE> l = sorted ( [ map ( int , raw_input ( ) . split ( ) ) for _ in range ( m ) ] ) <NEWLINE> for i in l : <NEWLINE> <INDENT> n , a , b = i <NEWLINE> if a > 0 : c [ a ] = [ a , n , b ] <NEWLINE> if b > 0 : c [ b ] = [ b , n , a ] <NEWLINE> i [ 1 : ] = [ [ j for j in i [ 1 : ] if j >= 0 ] ] <NEWLINE> <DEDENT> n = c . index ( 0 ) <NEWLINE> c [ n ] = [ n , - 1 , - 1 ] <NEWLINE> f ( n , 0 ) <NEWLINE> for i in c : print <STRING> . format ( * i ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> t = [ 0 ] * N <NEWLINE> r = set ( range ( N ) ) <NEWLINE> for _ in [ 0 ] * N : <NEWLINE> <INDENT> x , y , z = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> t [ x ] = [ y , z ] + [ 0 ] * 2 + [ ( l != - 1 ) + ( r != - 1 ) ] + [ 0 ] * 2 <NEWLINE> r -= { y , z } <NEWLINE> <DEDENT> def f ( i , p , s , d ) : <NEWLINE> <INDENT> if i < 0 : return - 1 <NEWLINE> l , r = t [ i ] [ : 2 ] <NEWLINE> t [ i ] [ 2 : ] = [ p , s , t [ i ] [ 4 ] , d , max ( f ( l , i , r , d + 1 ) , f ( r , i , l , d + 1 ) ) + 1 ] <NEWLINE> return t [ i ] [ - 1 ] <NEWLINE> <DEDENT> f ( r . pop ( ) , - 1 , - 1 , 0 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> print ( <STRING> . format ( i , * t [ i ] [ 2 : ] , <STRING> if not t [ i ] [ 5 ] else <STRING> if t [ i ] [ 4 ] else <STRING> ) ) <NEWLINE> <DEDENT>
def q ( a , k ) : <NEWLINE> <INDENT> d [ a ] = k <NEWLINE> for b in t [ a ] : <NEWLINE> <INDENT> if <STRING> != b : q ( b , k + 1 ) <NEWLINE> <DEDENT> <DEDENT> def n ( a , k ) : <NEWLINE> <INDENT> h [ a ] = max ( h [ a ] , k ) if a in h else k <NEWLINE> if <STRING> != p [ a ] : n ( p [ a ] , k + 1 ) <NEWLINE> <DEDENT> t , p , s , d , h = { } , { } , { } , { } , { } <NEWLINE> N = int ( input ( ) ) <NEWLINE> for _ in [ 0 ] * n : <NEWLINE> <INDENT> x , y , z = input ( ) . split ( ) <NEWLINE> t [ x ] = set ( [ y , z ] ) - { <STRING> } <NEWLINE> p [ y ] = p [ z ] = x <NEWLINE> s [ y ] , s [ z ] = z , y <NEWLINE> <DEDENT> r = ( set ( t ) - set ( p ) ) . pop ( ) <NEWLINE> p [ r ] = s [ r ] = <STRING> <NEWLINE> q ( r , 0 ) <NEWLINE> for i in t : <NEWLINE> <INDENT> if not t [ i ] : n ( i , 0 ) <NEWLINE> <DEDENT> for i in map ( str , range ( N ) ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , id , left , right , degree , depth , type ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . parent = None <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = degree <NEWLINE> self . depth = depth <NEWLINE> self . height = 0 <NEWLINE> self . type = type <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def printInfo ( self ) : <NEWLINE> <INDENT> print <STRING> . format ( self ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildTree ( id , nodeList , depth ) : <NEWLINE> <INDENT> leftId , rightId = nodeList [ id ] [ 0 ] , nodeList [ id ] [ 1 ] <NEWLINE> if leftId == - 1 and rightId == - 1 : <NEWLINE> <INDENT> dummy = Node ( - 1 , None , None , 0 , 0 , <STRING> ) <NEWLINE> return Node ( id , dummy , dummy , 0 , depth , <STRING> ) <NEWLINE> <DEDENT> degree = 0 <NEWLINE> if leftId == - 1 : <NEWLINE> <INDENT> left = Node ( - 1 , None , None , 0 , 0 , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = buildTree ( leftId , nodeList , depth + 1 ) <NEWLINE> degree += 1 <NEWLINE> <DEDENT> if rightId == - 1 : <NEWLINE> <INDENT> right = Node ( - 1 , None , None , 0 , 0 , <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = buildTree ( rightId , nodeList , depth + 1 ) <NEWLINE> degree += 1 <NEWLINE> <DEDENT> node = Node ( id , left , right , degree , depth , <STRING> ) <NEWLINE> <NL> node . left . parent = node <NEWLINE> node . left . sibling = node . right . id <NEWLINE> node . right . parent = node <NEWLINE> node . right . sibling = node . left . id <NEWLINE> node . height = max ( node . left . height , node . right . height ) + 1 <NEWLINE> return node <NEWLINE> <NL> <DEDENT> def tree2linear ( node , list ) : <NEWLINE> <INDENT> list [ node . id ] = node <NEWLINE> if node . left . id != - 1 : <NEWLINE> <INDENT> tree2linear ( node . left , list ) <NEWLINE> <DEDENT> if node . right . id != - 1 : <NEWLINE> <INDENT> tree2linear ( node . right , list ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> N = int ( lines [ 0 ] ) <NEWLINE> del lines [ 0 ] <NEWLINE> <NL> nodeList = [ [ ] ] * N <NEWLINE> sum = N * ( N - 1 ) / 2 <NEWLINE> for line in lines : <NEWLINE> <INDENT> line = map ( int , line . split ( ) ) <NEWLINE> id , children = line [ 0 ] , line [ 1 : ] <NEWLINE> nodeList [ id ] = children <NEWLINE> for child in children : <NEWLINE> <INDENT> if child == - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sum -= child <NEWLINE> <NL> <DEDENT> <DEDENT> root = buildTree ( sum , nodeList , 0 ) <NEWLINE> root . type = <STRING> <NEWLINE> root . parent = Node ( - 1 , None , None , 0 , 0 , <STRING> ) <NEWLINE> <NL> nodeList = [ 0 ] * N <NEWLINE> tree2linear ( root , nodeList ) <NEWLINE> for node in nodeList : <NEWLINE> <INDENT> node . printInfo ( ) <NEWLINE> <DEDENT> <DEDENT>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , id , left , right , parent = - 1 , sibling = - 1 , degree = - 1 , depth = - 1 , height = - 1 , type = None ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> self . parent = parent <NEWLINE> self . sibling = sibling <NEWLINE> self . degree = degree <NEWLINE> self . depth = depth <NEWLINE> self . height = height <NEWLINE> self . type = type <NEWLINE> <DEDENT> def show ( self ) : <NEWLINE> <INDENT> print <STRING> % ( self . id , self . parent , self . sibling , self . degree , self . depth , self . height , self . type ) <NEWLINE> <NL> <DEDENT> <DEDENT> def hasChild ( x ) : <NEWLINE> <INDENT> if x == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def calcDepth ( node ) : <NEWLINE> <INDENT> if node . parent == - 1 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 + calcDepth ( a [ node . parent ] ) <NEWLINE> <NL> <DEDENT> def calcHeight ( node ) : <NEWLINE> <INDENT> if node . degree == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return 1 + max ( calcHeight ( a [ node . left ] ) , calcHeight ( a [ node . right ] ) ) <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> tmp = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if tmp [ 1 ] == - 1 and tmp [ 2 ] == - 1 : <NEWLINE> <INDENT> a . append ( Node ( tmp [ 0 ] , tmp [ 1 ] , tmp [ 2 ] , degree = 0 , type = <STRING> ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a . append ( Node ( tmp [ 0 ] , tmp [ 1 ] , tmp [ 2 ] , degree = hasChild ( tmp [ 1 ] ) + hasChild ( tmp [ 2 ] ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] . right != - 1 : <NEWLINE> <INDENT> a [ a [ i ] . right ] . parent = a [ i ] . id <NEWLINE> <DEDENT> if a [ i ] . left != - 1 : <NEWLINE> <INDENT> a [ a [ i ] . left ] . parent = a [ i ] . id <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a [ i ] . depth = calcDepth ( a [ i ] ) <NEWLINE> a [ i ] . height = calcHeight ( a [ i ] ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> if a [ i ] . parent != - 1 and a [ i ] . degree != 0 : <NEWLINE> <INDENT> a [ i ] . type = <STRING> <NEWLINE> <DEDENT> elif a [ i ] . parent == - 1 and a [ i ] . degree > 0 : <NEWLINE> <INDENT> a [ i ] . type = <STRING> <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> if i == j : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if a [ i ] . depth == a [ j ] . depth and a [ i ] . parent == a [ j ] . parent : <NEWLINE> <INDENT> a [ i ] . sibling = j <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for el in a : <NEWLINE> <INDENT> el . show ( ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> class BiTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , node , left , right ) : <NEWLINE> <INDENT> self . node = node <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <DEDENT> <DEDENT> dali = [ 0 ] * n <NEWLINE> def inputdata ( i ) : <NEWLINE> <INDENT> node , left , right = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dali [ node ] = BiTree ( node , left , right ) <NEWLINE> <DEDENT> def getParent ( i ) : <NEWLINE> <INDENT> for k in range ( n ) : <NEWLINE> <INDENT> if ( dali [ k ] . right == dali [ i ] . node ) or ( dali [ k ] . left == dali [ i ] . node ) : <NEWLINE> <INDENT> dali [ i ] . parent = dali [ k ] . node <NEWLINE> return dali [ i ] . parent <NEWLINE> <DEDENT> <DEDENT> dali [ i ] . parent = - 1 <NEWLINE> <NL> return dali [ i ] . parent <NEWLINE> <DEDENT> def getDepth ( i ) : <NEWLINE> <INDENT> h = 0 <NEWLINE> tmp = dali [ i ] . parent <NEWLINE> while True : <NEWLINE> <INDENT> if tmp == - 1 : <NEWLINE> <INDENT> dali [ i ] . depth = h <NEWLINE> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = getParent ( tmp ) <NEWLINE> h += 1 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def getHeight ( i ) : <COMMENT> <NEWLINE> <INDENT> h1 = 0 <NEWLINE> h2 = 0 <NEWLINE> if dali [ i ] . right != - 1 : <NEWLINE> <INDENT> h1 = getHeight ( dali [ i ] . right ) + 1 <NEWLINE> <DEDENT> if dali [ i ] . left != - 1 : <NEWLINE> <INDENT> h2 = getHeight ( dali [ i ] . left ) + 1 <NEWLINE> <DEDENT> return max ( h1 , h2 ) <NEWLINE> <DEDENT> def getDegree ( i ) : <NEWLINE> <INDENT> if dali [ i ] . right == - 1 and dali [ i ] . left == - 1 : <NEWLINE> <INDENT> dali [ i ] . deg = 0 <NEWLINE> <DEDENT> elif . ( dali [ i ] . right ) * dali [ i ] . left == - 1 : <NEWLINE> <INDENT> dali [ i ] . deg = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dali [ i ] . deg = 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def getType ( i ) : <NEWLINE> <INDENT> if dali [ i ] . parent == - 1 : <NEWLINE> <INDENT> dali [ i ] . type = <STRING> <NEWLINE> <DEDENT> elif dali [ i ] . deg == 0 : <NEWLINE> <INDENT> dali [ i ] . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dali [ i ] . type = <STRING> <NEWLINE> <DEDENT> <DEDENT> def getSibling ( i ) : <NEWLINE> <INDENT> if dali [ i ] . type == <STRING> : <NEWLINE> <INDENT> dali [ i ] . sibling = - 1 <NEWLINE> return 0 <NEWLINE> <DEDENT> sib = [ ] <NEWLINE> sib . append ( ( dali [ dali [ i ] . parent ] . right ) ) <NEWLINE> sib . append ( dali [ dali [ i ] . parent ] . left ) <NEWLINE> if sib [ 0 ] == dali [ i ] . node : <NEWLINE> <INDENT> dali [ i ] . sibling = sib [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dali [ i ] . sibling = sib [ 0 ] <NEWLINE> <DEDENT> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> inputdata ( j ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> getParent ( dali [ j ] . node ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> getDepth ( dali [ j ] . node ) <NEWLINE> <DEDENT> h1 = 0 <NEWLINE> h2 = 0 <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> dali [ j ] . height = getHeight ( dali [ j ] . node ) <NEWLINE> h1 = 0 <NEWLINE> h2 = 0 <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> getDegree ( dali [ j ] . node ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> getType ( dali [ j ] . node ) <NEWLINE> <DEDENT> for j in range ( n ) : <NEWLINE> <INDENT> getSibling ( dali [ j ] . node ) <NEWLINE> <DEDENT> for j in range ( ( dali [ j ] . node ) + 1 ) : <NEWLINE> <INDENT> print ( <STRING> % ( dali [ j ] . node , dali [ j ] . parent , dali [ j ] . sibling , dali [ j ] . deg , dali [ j ] . depth , dali [ j ] . height , dali [ j ] . type ) ) <NEWLINE> <NL> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . sibling = None <NEWLINE> self . parent = None <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_tree_walk ( root ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> result . append ( root . id ) <NEWLINE> if root . left != None : <NEWLINE> <INDENT> result . extend ( preorder_tree_walk ( root . left ) ) <NEWLINE> <DEDENT> if root . right != None : <NEWLINE> <INDENT> result . extend ( preorder_tree_walk ( root . right ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def inorder_tree_walk ( root ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if root . left != None : <NEWLINE> <INDENT> result . extend ( inorder_tree_walk ( root . left ) ) <NEWLINE> <DEDENT> result . append ( root . id ) <NEWLINE> if root . right != None : <NEWLINE> <INDENT> result . extend ( inorder_tree_walk ( root . right ) ) <NEWLINE> <DEDENT> return result <NEWLINE> <NL> <DEDENT> def postorder_tree_walk ( root ) : <NEWLINE> <INDENT> result = [ ] <NEWLINE> if root . left != None : <NEWLINE> <INDENT> result . extend ( postorder_tree_walk ( root . left ) ) <NEWLINE> <DEDENT> if root . right != None : <NEWLINE> <INDENT> result . extend ( postorder_tree_walk ( root . right ) ) <NEWLINE> <DEDENT> result . append ( root . id ) <NEWLINE> return result <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> tree = [ Node ( i ) for i in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> line = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> id , left_id , right_id = line [ 0 ] , line [ 1 ] , line [ 2 ] <NEWLINE> if left_id != - 1 : <NEWLINE> <INDENT> tree [ id ] . left = tree [ left_id ] <NEWLINE> tree [ left_id ] . parent = tree [ id ] <NEWLINE> <DEDENT> if right_id != - 1 : <NEWLINE> <INDENT> tree [ id ] . right = tree [ right_id ] <NEWLINE> tree [ right_id ] . parent = tree [ id ] <NEWLINE> <DEDENT> if left_id != - 1 and right_id != - 1 : <NEWLINE> <INDENT> tree [ left_id ] . sibling = tree [ right_id ] <NEWLINE> tree [ right_id ] . sibling = tree [ left_id ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> root = None <NEWLINE> for t in tree : <NEWLINE> <INDENT> if t . parent == None : <NEWLINE> <INDENT> root = t <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> <NEWLINE> print <STRING> . join ( map ( str , preorder_tree_walk ( root ) ) ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> . join ( map ( str , inorder_tree_walk ( root ) ) ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> . join ( map ( str , postorder_tree_walk ( root ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> tree = MyTree ( n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> id_cn = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> id_node = id_cn . pop ( 0 ) <NEWLINE> <NL> tree . add ( id_node , None , id_cn ) <NEWLINE> <NL> <DEDENT> tree . search_children ( ) <NEWLINE> tree . set_depth_height ( tree . nodes [ tree . id_root ] , 0 ) <NEWLINE> <NL> print <STRING> <NEWLINE> tree . preorder ( tree . nodes [ tree . id_root ] ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> <NEWLINE> tree . inorder ( tree . nodes [ tree . id_root ] ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> <NEWLINE> tree . postorder ( tree . nodes [ tree . id_root ] ) <NEWLINE> <NL> <NL> <DEDENT> class MyTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , num_nodes ) : <NEWLINE> <INDENT> self . nodes = [ MyNode ( ) for i in range ( num_nodes ) ] <NEWLINE> self . id_root = None <NEWLINE> <NL> <DEDENT> def add ( self , id_node , id_parent , id_children ) : <NEWLINE> <INDENT> node = self . nodes [ id_node ] <NEWLINE> node . id_self = id_node <NEWLINE> node . id_parent = id_parent <NEWLINE> node . id_children = id_children <NEWLINE> <NL> <DEDENT> def search_children ( self ) : <NEWLINE> <INDENT> for node in self . nodes : <NEWLINE> <INDENT> if all ( item == - 1 for item in node . id_children ) : <NEWLINE> <INDENT> node . node_type = <STRING> <NEWLINE> node . degree = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . node_type = <STRING> <NEWLINE> l = node . id_children [ 0 ] <NEWLINE> r = node . id_children [ 1 ] <NEWLINE> if l == - 1 : <NEWLINE> <INDENT> node . degree = 1 <NEWLINE> self . nodes [ r ] . id_parent = node . id_self <NEWLINE> self . nodes [ r ] . sibling = l <NEWLINE> <DEDENT> elif r == - 1 : <NEWLINE> <INDENT> node . degree = 1 <NEWLINE> self . nodes [ l ] . id_parent = node . id_self <NEWLINE> self . nodes [ l ] . sibling = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> node . degree = 2 <NEWLINE> self . nodes [ l ] . id_parent = node . id_self <NEWLINE> self . nodes [ r ] . id_parent = node . id_self <NEWLINE> self . nodes [ l ] . sibling = r <NEWLINE> self . nodes [ r ] . sibling = l <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for node in self . nodes : <NEWLINE> <INDENT> if node . id_parent == None : <NEWLINE> <INDENT> node . id_parent = - 1 <NEWLINE> node . node_type = <STRING> <NEWLINE> self . id_root = node . id_self <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def set_depth_height ( self , node , depth ) : <NEWLINE> <INDENT> node . depth = depth <NEWLINE> l_height = [ ] <NEWLINE> if all ( item == - 1 for item in node . id_children ) : <NEWLINE> <INDENT> node . height = 0 <NEWLINE> return 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for item in node . id_children : <NEWLINE> <INDENT> if not item == - 1 : <NEWLINE> <INDENT> l_height . append ( self . set_depth_height ( self . nodes [ item ] , depth + 1 ) ) <NEWLINE> <DEDENT> <DEDENT> height = max ( l_height ) + 1 <NEWLINE> node . height = height <NEWLINE> return height <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( self , node ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> . format ( node . id_self ) ) <NEWLINE> l , r = node . id_children <NEWLINE> if not l == - 1 : <NEWLINE> <INDENT> self . preorder ( self . nodes [ l ] ) <NEWLINE> <DEDENT> if not r == - 1 : <NEWLINE> <INDENT> self . preorder ( self . nodes [ r ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder ( self , node ) : <NEWLINE> <INDENT> l , r = node . id_children <NEWLINE> if not l == - 1 : <NEWLINE> <INDENT> self . inorder ( self . nodes [ l ] ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> . format ( node . id_self ) ) <NEWLINE> if not r == - 1 : <NEWLINE> <INDENT> self . inorder ( self . nodes [ r ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def postorder ( self , node ) : <NEWLINE> <INDENT> l , r = node . id_children <NEWLINE> if not l == - 1 : <NEWLINE> <INDENT> self . postorder ( self . nodes [ l ] ) <NEWLINE> <DEDENT> if not r == - 1 : <NEWLINE> <INDENT> self . postorder ( self . nodes [ r ] ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> . format ( node . id_self ) ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> class MyNode ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . id_self = None <NEWLINE> self . id_parent = None <NEWLINE> self . id_children = None <NEWLINE> self . depth = None <NEWLINE> self . node_type = None <NEWLINE> self . n_children = 0 <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = 0 <NEWLINE> self . height = 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def p ( u ) : <NEWLINE> <INDENT> if u + 1 : print ( s , u , end = s ) ; p ( T [ u ] ) ; p ( T [ u + N ] ) <NEWLINE> <DEDENT> def i ( u ) : <NEWLINE> <INDENT> if u + 1 : i ( T [ u ] ) ; print ( s , u , end = s ) ; i ( T [ u + N ] ) <NEWLINE> <DEDENT> def o ( u ) : <NEWLINE> <INDENT> if u + 1 : o ( T [ u ] ) ; o ( T [ u + N ] ) ; print ( s , u , end = s ) <NEWLINE> <DEDENT> s , o = <STRING> , <STRING> <NEWLINE> N = int ( input ( ) ) <NEWLINE> T = [ 0 , 0 ] * N <NEWLINE> R = set ( range ( N ) ) <NEWLINE> for _ in [ 0 ] * N : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> T [ a ] , T [ a + N ] = b , c <NEWLINE> R -= { b , c } <NEWLINE> <DEDENT> r = R . pop ( ) <NEWLINE> print ( <STRING> + o ) <NEWLINE> p ( r ) <NEWLINE> print ( <STRING> + o ) <NEWLINE> i ( r ) <NEWLINE> print ( <STRING> + o ) <NEWLINE> o ( r ) <NEWLINE> print ( ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> left = [ None for i in range ( n ) ] <NEWLINE> right = [ None for i in range ( n ) ] <NEWLINE> root = sum ( range ( n ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> i , l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left [ i ] = l <NEWLINE> right [ i ] = r <NEWLINE> root -= ( l + r ) <NEWLINE> <NL> <DEDENT> def Preorder ( i ) : <NEWLINE> <INDENT> if ( i == - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> Preorder ( left [ i ] ) <NEWLINE> Preorder ( right [ i ] ) <NEWLINE> <NL> <DEDENT> def Inorder ( i ) : <NEWLINE> <INDENT> if ( i == - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> Inorder ( left [ i ] ) <NEWLINE> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> Inorder ( right [ i ] ) <NEWLINE> <NL> <DEDENT> def Postorder ( i ) : <NEWLINE> <INDENT> if ( i == - 1 ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> Postorder ( left [ i ] ) <NEWLINE> Postorder ( right [ i ] ) <NEWLINE> print ( <STRING> . format ( i ) , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> Preorder ( root ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> Inorder ( root ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> Postorder ( root ) <NEWLINE> print ( ) <NEWLINE>
N = int ( input ( ) ) <NEWLINE> left = [ - 1 for i in range ( N ) ] <NEWLINE> right = [ - 1 for i in range ( N ) ] <NEWLINE> root = sum ( range ( N ) ) - N - 1 <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> i , l , r = map ( int , input ( ) . split ( ) ) <NEWLINE> left [ i ] = l <NEWLINE> right [ i ] = r <NEWLINE> root -= ( l + r ) <NEWLINE> <NL> <DEDENT> def preorder ( i ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> , i , sep = <STRING> , end = <STRING> ) <NEWLINE> preorder ( left [ i ] ) <NEWLINE> preorder ( right [ i ] ) <NEWLINE> <NL> <DEDENT> def inorder ( i ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( left [ i ] ) <NEWLINE> print ( <STRING> , i , sep = <STRING> , end = <STRING> ) <NEWLINE> inorder ( right [ i ] ) <NEWLINE> <NL> <DEDENT> def postorder ( i ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> ( l , r ) = tree [ i ] <NEWLINE> postorder ( left [ i ] ) <NEWLINE> postorder ( right [ i ] ) <NEWLINE> print ( <STRING> , i , sep = <STRING> , end = <STRING> ) <NEWLINE> <NL> <DEDENT> print ( <STRING> ) <NEWLINE> preorder ( root ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> inorder ( root ) <NEWLINE> print ( ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> postorder ( root ) <NEWLINE> print ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> def preorder ( here , conn , chain ) : <NEWLINE> <INDENT> if here == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> chain . append ( here ) <NEWLINE> if conn [ here ] : <NEWLINE> <INDENT> preorder ( conn [ here ] [ 0 ] , conn , chain ) <NEWLINE> preorder ( conn [ here ] [ 1 ] , conn , chain ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder ( here , conn , chain ) : <NEWLINE> <INDENT> if here == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if conn [ here ] : <NEWLINE> <INDENT> inorder ( conn [ here ] [ 0 ] , conn , chain ) <NEWLINE> chain . append ( here ) <NEWLINE> inorder ( conn [ here ] [ 1 ] , conn , chain ) <NEWLINE> <NL> <DEDENT> <DEDENT> def postorder ( here , conn , chain ) : <NEWLINE> <INDENT> if here == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> if conn [ here ] : <NEWLINE> <INDENT> postorder ( conn [ here ] [ 0 ] , conn , chain ) <NEWLINE> postorder ( conn [ here ] [ 1 ] , conn , chain ) <NEWLINE> <DEDENT> chain . append ( here ) <NEWLINE> <NL> <DEDENT> query = int ( input ( ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> in_v = [ 0 for n in range ( query + 1 ) ] <NEWLINE> for _ in range ( query ) : <NEWLINE> <INDENT> here , left , right = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect [ here ] = [ left , right ] <NEWLINE> in_v [ left ] += 1 <NEWLINE> in_v [ right ] += 1 <NEWLINE> <DEDENT> for i in range ( query ) : <NEWLINE> <INDENT> if not in_v [ i ] : <NEWLINE> <INDENT> root = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> preo = [ ] <NEWLINE> ino = [ ] <NEWLINE> posto = [ ] <NEWLINE> preorder ( root , connect , preo ) <NEWLINE> inorder ( root , connect , ino ) <NEWLINE> postorder ( root , connect , posto ) <NEWLINE> <NL> print ( <STRING> ) <NEWLINE> print ( <STRING> + * preo ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> + * ino ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> + * posto ) <NEWLINE>
def s ( x ) : <NEWLINE> <INDENT> print ( <STRING> , x , end = <STRING> ) <NEWLINE> <DEDENT> def p ( u ) : <NEWLINE> <INDENT> if u + 1 : s ( u ) ; p ( R [ u ] ) ; p ( L ( u ) ) <NEWLINE> <DEDENT> def i ( u ) : <NEWLINE> <INDENT> if u + 1 : i ( R ( u ) ) ; s ( u ) ; p ( L ( u ) ) <NEWLINE> <DEDENT> def o ( u ) : <NEWLINE> <INDENT> if u + 1 : o ( R ( u ) ) ; o ( L ( u ) ) ; s ( u ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> R , L = [ 0 ] * n , [ 0 ] * n <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> R [ a ] = b <NEWLINE> L [ a ] = c <NEWLINE> <DEDENT> root = ( set ( range ( n ) ) - set ( R ) - set ( L ) ) . pop ( ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , id , left , right ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . parent = None <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> def preorderTreeWalk ( self ) : <NEWLINE> <INDENT> if self . id == - 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> return [ self . id ] + self . left . preorderTreeWalk ( ) + self . right . preorderTreeWalk ( ) <NEWLINE> <NL> <DEDENT> def inorderTreeWalk ( self ) : <NEWLINE> <INDENT> if self . id == - 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> return self . left . inorderTreeWalk ( ) + [ self . id ] + self . right . inorderTreeWalk ( ) <NEWLINE> <NL> <DEDENT> def postorderTreeWalk ( self ) : <NEWLINE> <INDENT> if self . id == - 1 : <NEWLINE> <INDENT> return [ ] <NEWLINE> <DEDENT> return self . left . postorderTreeWalk ( ) + self . right . postorderTreeWalk ( ) + [ self . id ] <NEWLINE> <NL> <DEDENT> <DEDENT> def buildTree ( id , nodeList ) : <NEWLINE> <INDENT> leftId , rightId = nodeList [ id ] [ 0 ] , nodeList [ id ] [ 1 ] <NEWLINE> dummy = Node ( - 1 , None , None ) <NEWLINE> <NL> if leftId == - 1 and rightId == - 1 : <NEWLINE> <INDENT> return Node ( id , dummy , dummy ) <NEWLINE> <NL> <DEDENT> if leftId == - 1 : <NEWLINE> <INDENT> left = dummy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left = buildTree ( leftId , nodeList ) <NEWLINE> <NL> <DEDENT> if rightId == - 1 : <NEWLINE> <INDENT> right = dummy <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> right = buildTree ( rightId , nodeList ) <NEWLINE> <NL> <DEDENT> node = Node ( id , left , right ) <NEWLINE> node . left . parent = node <NEWLINE> node . right . parent = node <NEWLINE> <NL> return node <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> N = int ( lines [ 0 ] ) <NEWLINE> del lines [ 0 ] <NEWLINE> <NL> nodeList = [ [ ] ] * N <NEWLINE> sum = N * ( N - 1 ) / 2 <NEWLINE> for line in lines : <NEWLINE> <INDENT> line = map ( int , line . split ( ) ) <NEWLINE> id , children = line [ 0 ] , line [ 1 : ] <NEWLINE> nodeList [ id ] = children <NEWLINE> for child in children : <NEWLINE> <INDENT> if child == - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> sum -= child <NEWLINE> <NL> <DEDENT> <DEDENT> root = buildTree ( sum , nodeList ) <NEWLINE> root . parent = Node ( - 1 , None , None ) <NEWLINE> <NL> print <STRING> <NEWLINE> order = root . preorderTreeWalk ( ) <NEWLINE> print <STRING> . join ( map ( str , order ) ) <NEWLINE> <NL> print <STRING> <NEWLINE> order = root . inorderTreeWalk ( ) <NEWLINE> print <STRING> . join ( map ( str , order ) ) <NEWLINE> <NL> print <STRING> <NEWLINE> order = root . postorderTreeWalk ( ) <NEWLINE> print <STRING> . join ( map ( str , order ) ) <NEWLINE> <DEDENT>
c = set ( range ( input ( ) ) ) <NEWLINE> l = sorted ( [ map ( int , raw_input ( ) . split ( ) ) for _ in c ] ) <NEWLINE> for i in l : c -= set ( i [ 1 : ] ) <NEWLINE> d = c . pop ( ) <NEWLINE> def f ( n ) : return <STRING> if n < 0 else <STRING> . join ( [ <STRING> + str ( n ) if j < 1 else f ( l [ n ] [ j ] ) for j in a ] ) <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> a = [ 1 , 2 ] <NEWLINE> a [ i : i ] = [ 0 ] <NEWLINE> print [ <STRING> , <STRING> , <STRING> ] [ i ] + <STRING> , <STRING> , f ( d ) <NEWLINE> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> <NL> <NL> <NL> FORMAT = ( <STRING> ) . format <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . id = - 1 <NEWLINE> self . parent = - 1 <NEWLINE> self . left = - 1 <NEWLINE> self . right = - 1 <NEWLINE> self . sibling = - 1 <NEWLINE> self . degree = 0 <NEWLINE> self . depth = 0 <NEWLINE> self . height = 0 <NEWLINE> self . type = <STRING> if self . height == 0 else <STRING> <NEWLINE> <NL> <DEDENT> def setType ( self ) : <NEWLINE> <INDENT> if self . height == 0 and self . parent != - 1 : <NEWLINE> <INDENT> self . type = <STRING> <NEWLINE> <DEDENT> elif self . parent == - 1 : <NEWLINE> <INDENT> self . type = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . type = <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def __str__ ( self ) : <NEWLINE> <INDENT> return FORMAT ( self ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preParse ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print u , <NEWLINE> preParse ( T [ u ] . left ) <NEWLINE> preParse ( T [ u ] . right ) <NEWLINE> <NL> <DEDENT> def inParse ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inParse ( T [ u ] . left ) <NEWLINE> print u , <NEWLINE> inParse ( T [ u ] . right ) <NEWLINE> <NL> <DEDENT> def postParse ( u ) : <NEWLINE> <INDENT> if u == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> postParse ( T [ u ] . left ) <NEWLINE> postParse ( T [ u ] . right ) <NEWLINE> print u , <NEWLINE> <NL> <NL> <DEDENT> T = [ Node ( ) for _ in xrange ( n ) ] <NEWLINE> <NL> for i in xrange ( n ) : <NEWLINE> <INDENT> a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> u = a [ 0 ] <NEWLINE> l = a [ 1 ] <NEWLINE> r = a [ 2 ] <NEWLINE> T [ u ] . id = u <NEWLINE> T [ u ] . left = l <COMMENT> <NEWLINE> T [ u ] . right = r <COMMENT> <NEWLINE> if l != - 1 and r != - 1 : <NEWLINE> <INDENT> T [ l ] . parent = u <COMMENT> <NEWLINE> T [ r ] . parent = u <COMMENT> <NEWLINE> <DEDENT> elif l != - 1 and r == - 1 : <NEWLINE> <INDENT> T [ l ] . parent = u <COMMENT> <NEWLINE> <DEDENT> elif l == - 1 and r != - 1 : <NEWLINE> <INDENT> T [ r ] . parent = u <COMMENT> <NEWLINE> <NL> <DEDENT> if l != - 1 and r != - 1 : <NEWLINE> <INDENT> T [ u ] . degree = 2 <NEWLINE> T [ l ] . sibling = r <NEWLINE> T [ r ] . sibling = l <NEWLINE> <DEDENT> elif l != - 1 and r == - 1 : <NEWLINE> <INDENT> T [ u ] . degree = 1 <NEWLINE> <DEDENT> elif l == - 1 and r != - 1 : <NEWLINE> <INDENT> T [ u ] . degree = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> N = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> if T [ i ] . parent == - 1 : <NEWLINE> <INDENT> N = T [ i ] . id <NEWLINE> <NL> <DEDENT> <DEDENT> print <STRING> <NEWLINE> print <STRING> , <NEWLINE> preParse ( N ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> <NEWLINE> print <STRING> , <NEWLINE> inParse ( N ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> <NEWLINE> print <STRING> , <NEWLINE> postParse ( N ) <NEWLINE> print <STRING> <NEWLINE>
class Node : <NEWLINE> <INDENT> def __init__ ( self , p , l , r ) : <NEWLINE> <INDENT> self . parent = p <NEWLINE> self . left = l <NEWLINE> self . right = r <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( u ) : <NEWLINE> <INDENT> print u , <NEWLINE> if tree [ u ] . left != - 1 : <NEWLINE> <INDENT> preorder ( tree [ u ] . left ) <NEWLINE> <DEDENT> if tree [ u ] . right != - 1 : <NEWLINE> <INDENT> preorder ( tree [ u ] . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder ( u ) : <NEWLINE> <INDENT> if tree [ u ] . left != - 1 : <NEWLINE> <INDENT> inorder ( tree [ u ] . left ) <NEWLINE> <DEDENT> print u , <NEWLINE> if tree [ u ] . right != - 1 : <NEWLINE> <INDENT> inorder ( tree [ u ] . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def postorder ( u ) : <NEWLINE> <INDENT> if tree [ u ] . left != - 1 : <NEWLINE> <INDENT> postorder ( tree [ u ] . left ) <NEWLINE> <DEDENT> if tree [ u ] . right != - 1 : <NEWLINE> <INDENT> postorder ( tree [ u ] . right ) <NEWLINE> <DEDENT> print u , <NEWLINE> <NL> <NL> <NL> <DEDENT> n = int ( raw_input ( ) . strip ( ) ) <NEWLINE> tree = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> nid , left , right = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> if not nid in tree : tree [ nid ] = Node ( - 1 , left , right ) <NEWLINE> else : <NEWLINE> <INDENT> tree [ nid ] . left = left <NEWLINE> tree [ nid ] . right = right <NEWLINE> <DEDENT> if not left == - 1 : <NEWLINE> <INDENT> if not left in tree : tree [ left ] = Node ( nid , - 1 , - 1 ) <NEWLINE> else : tree [ left ] . parent = nid <NEWLINE> <DEDENT> if not right == - 1 : <NEWLINE> <INDENT> if not right in tree : tree [ right ] = Node ( nid , - 1 , - 1 ) <NEWLINE> else : tree [ right ] . parent = nid <NEWLINE> <NL> <DEDENT> <DEDENT> r = - 1 <NEWLINE> for i in range ( len ( tree ) ) : <NEWLINE> <INDENT> if tree [ i ] . parent == - 1 : <NEWLINE> <INDENT> r = i <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print <STRING> <NEWLINE> preorder ( r ) <NEWLINE> print <NEWLINE> print <STRING> <NEWLINE> inorder ( r ) <NEWLINE> print <NEWLINE> print <STRING> <NEWLINE> postorder ( r ) <NEWLINE> print <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> pre = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ino = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> post = [ ] <NEWLINE> i = - 1 <NEWLINE> def recaonstruction ( l , r ) : <NEWLINE> <INDENT> global i <NEWLINE> if l >= r : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> i += 1 <NEWLINE> c = pre [ i ] <NEWLINE> m = ino . index ( c ) <NEWLINE> reconstruction ( l , m ) <NEWLINE> reconstruction ( m + 1 , r ) <NEWLINE> post . append ( c ) <NEWLINE> <DEDENT> reconstruction ( 0 , n ) <NEWLINE> print ( <STRING> . join ( map ( str , post ) ) ) <NEWLINE>
def postorder ( n , preorder , inorder ) : <NEWLINE> <INDENT> if len ( preorder ) > 1 : <NEWLINE> <INDENT> left_inorder = [ ] <NEWLINE> right_inorder = [ ] <NEWLINE> flag = False <NEWLINE> for i in range ( len ( inorder ) ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> if n == inorder [ i ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> left_inorder . append ( inorder [ i ] ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> right_inorder . append ( inorder [ i ] ) <NEWLINE> <DEDENT> <DEDENT> left_preorder = [ ] <NEWLINE> right_preorder = [ ] <NEWLINE> flag = False <NEWLINE> for i in range ( 1 , len ( preorder ) ) : <NEWLINE> <INDENT> if flag == False : <NEWLINE> <INDENT> left_preorder . append ( preorder [ i ] ) <NEWLINE> if len ( left_preorder ) == len ( left_inorder ) : <NEWLINE> <INDENT> flag = True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> right_preorder . append ( preorder [ i ] ) <NEWLINE> <DEDENT> <DEDENT> postorder ( left_preorder [ 0 ] , left_preorder , left_inorder ) <NEWLINE> postorder ( right_preorder [ 0 ] , right_preorder , right_inorder ) <NEWLINE> <DEDENT> if len ( preorder ) >= 0 : <NEWLINE> <INDENT> print n , <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> preorder = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> inorder = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> postorder ( preorder [ 0 ] , preorder , inorder ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> tree = [ None for i in range ( n + 1 ) ] <NEWLINE> list_pre = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> list_in = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def reconstruct ( tree_pre , tree_in ) : <NEWLINE> <INDENT> if not tree_pre : <NEWLINE> <INDENT> return - 1 <NEWLINE> <DEDENT> root = tree_pre [ 0 ] <NEWLINE> idx = tree_in . index ( root ) <NEWLINE> tree [ root ] = ( reconstruct ( tree_pre [ 1 : i + 1 ] , tree_in [ : i ] ) , <NEWLINE> <INDENT> reconstruct ( tree_pre [ i + 1 : ] , tree_in [ i + 1 : ] ) ) <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <NL> <DEDENT> def post_order_search ( i ) : <NEWLINE> <INDENT> if i == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> l , r = tree [ i ] <NEWLINE> for j in post_order_search ( l ) : <NEWLINE> <INDENT> yield j <NEWLINE> <DEDENT> for j in post_order_search ( r ) : <NEWLINE> <INDENT> yield j <NEWLINE> <DEDENT> yield i <NEWLINE> <NL> <NL> <DEDENT> solve ( list_pre , list_in ) <NEWLINE> <NL> print ( * postorder ( list_pre [ 0 ] ) ) <NEWLINE>
I = 0 <NEWLINE> L = 1 <NEWLINE> R = 2 <NEWLINE> P = 3 <NEWLINE> B = 4 <NEWLINE> D = 5 <NEWLINE> H = 6 <NEWLINE> <NL> def getidx ( Tree , value ) : <NEWLINE> <INDENT> idx = - 1 <NEWLINE> for i in range ( len ( Tree ) ) : <NEWLINE> <INDENT> if Tree [ i ] [ I ] == value : <NEWLINE> <INDENT> idx = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return idx <NEWLINE> <NL> <DEDENT> def search ( Tree , A , B , num ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> root = A [ 0 ] <NEWLINE> rootidx = getidx ( Tree , root ) <NEWLINE> ld = num <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> if B [ i ] == root : <NEWLINE> <INDENT> ld = i <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ld > 0 : <NEWLINE> <INDENT> left , lidx = search ( Tree , A [ 1 : ld + 1 ] , B [ : ld ] , ld ) <NEWLINE> Tree [ rootidx ] [ L ] = lidx <NEWLINE> <DEDENT> rt = ld + 1 <NEWLINE> if rt < num : <NEWLINE> <INDENT> right , ridx = search ( Tree , A [ rt : ] , B [ rt : ] , num - rt ) <NEWLINE> Tree [ rootidx ] [ R ] = ridx <NEWLINE> <DEDENT> return ( root , rootidx ) <NEWLINE> <NL> <DEDENT> def getroot ( Tree , nidx ) : <NEWLINE> <INDENT> pidx = Tree [ nidx ] [ P ] <NEWLINE> if pidx < 0 : <NEWLINE> <INDENT> return nidx <NEWLINE> <DEDENT> return getroot ( Tree , pidx ) <NEWLINE> <NL> <DEDENT> ef postorder ( Tree , nidx , A ) : <NEWLINE> <INDENT> if nidx < 0 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> postorder ( Tree , Tree [ nidx ] [ L ] , A ) <NEWLINE> postorder ( Tree , Tree [ nidx ] [ R ] , A ) <NEWLINE> A . append ( Tree [ nidx ] [ I ] ) <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <NL> <INDENT> <STRING> <NEWLINE> num = int ( input ( ) . strip ( ) ) <NEWLINE> plist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ilist = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tree = [ ] <NEWLINE> for i in plist : <NEWLINE> <INDENT> tree . append ( [ i , - 1 , - 1 , - 1 , - 1 , 0 , 0 ] ) <NEWLINE> <NL> <DEDENT> root , ridx = search ( tree , plist , ilist , num ) <NEWLINE> <NL> pos = [ ] <NEWLINE> <NL> postorder ( tree , ridx , pos ) <NEWLINE> print ( <STRING> . join ( map ( str , pos ) ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> class BST : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> x , y = self . root , None <NEWLINE> while x != None : x , y = x . left if key < x . key else x . right , x <NEWLINE> if y == None : self . root = Node ( key ) <NEWLINE> elif key < y . key : y . left = Node ( key ) <NEWLINE> else : y . right = z <NEWLINE> <DEDENT> def print_tree ( self ) : <NEWLINE> <INDENT> def inorder ( node ) : <NEWLINE> <INDENT> return inorder ( node . left ) + <STRING> + inorder ( node . right ) if node else <STRING> <NEWLINE> <DEDENT> def preorder ( node ) : <NEWLINE> <INDENT> return <STRING> + preorder ( node . left ) + preorder ( node . right ) if node else <STRING> <NEWLINE> <DEDENT> print ( inorder ( self . root ) ) <NEWLINE> print ( preorder ( self . root ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> tree = BST ( ) <NEWLINE> input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if e [ 0 ] == <STRING> : tree . insert ( int ( e [ 7 : ] ) ) <NEWLINE> else : tree . print_tree ( ) <NEWLINE> <DEDENT>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class BinarySearchTree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> root_node = self . root <NEWLINE> insert_node = Node ( key ) <NEWLINE> parent_node = None <NEWLINE> <NL> while root_node : <NEWLINE> <INDENT> parent_node = root_node <NEWLINE> if insert_node . key < root_node . key : <NEWLINE> <INDENT> root_node = root_node . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root_node = root_node . right <NEWLINE> <NL> <DEDENT> <DEDENT> insert_node . parent = parent_node <NEWLINE> <NL> if parent_node is None : <NEWLINE> <INDENT> self . root = insert_node <NEWLINE> <DEDENT> elif insert_node . key < parent_node . key : <NEWLINE> <INDENT> parent_node . left = insert_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent_node . right = insert_node <NEWLINE> <NL> <DEDENT> <DEDENT> def show_preorder ( self , node ) : <NEWLINE> <INDENT> node_list = [ ] <NEWLINE> <NL> node_list . append ( node . key ) <NEWLINE> if node . left is not None : <NEWLINE> <INDENT> node_list . extend ( self . show_preorder ( node . left ) ) <NEWLINE> <DEDENT> if node . right is not None : <NEWLINE> <INDENT> node_list . extend ( self . show_preorder ( node . right ) ) <NEWLINE> <NL> <DEDENT> return node_list <NEWLINE> <NL> <DEDENT> def show_inorder ( self , node ) : <NEWLINE> <INDENT> node_list = [ ] <NEWLINE> <NL> if node . left is not None : <NEWLINE> <INDENT> node_list . extend ( self . show_inorder ( node . left ) ) <NEWLINE> <DEDENT> node_list . append ( node . key ) <NEWLINE> if node . right is not None : <NEWLINE> <INDENT> node_list . extend ( self . show_inorder ( node . right ) ) <NEWLINE> <NL> <DEDENT> return node_list <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( <STRING> + * self . show_inorder ( self . root ) ) <NEWLINE> print ( <STRING> + * self . show_preorder ( self . root ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> tree = BinarySearchTree ( ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> command = input ( ) . split ( ) <NEWLINE> <NL> if command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( command [ 1 ] ) ) <NEWLINE> <DEDENT> elif command [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . print ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> tree = { } <NEWLINE> np = - 1 <NEWLINE> <NL> home = 0 <NEWLINE> tree [ home ] = [ None , None , None ] <NEWLINE> <NL> def search ( p , x ) : <NEWLINE> <INDENT> while p != None : <NEWLINE> <INDENT> tmp = tree [ p ] [ 0 ] <NEWLINE> if tmp == x : return True <NEWLINE> if x < tmp : <NEWLINE> <INDENT> p = tree [ p ] [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = tree [ p ] [ 2 ] <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def node ( x ) : <NEWLINE> <INDENT> global np <NEWLINE> np += 1 <NEWLINE> tree [ np ] = [ x , None , None ] <NEWLINE> return np <NEWLINE> <NL> <DEDENT> def insert ( p , x ) : <NEWLINE> <INDENT> if p == None or np == - 1 : return node ( x ) <NEWLINE> tmp = tree [ p ] [ 0 ] <NEWLINE> if x == tmp : return p <NEWLINE> elif x < tmp : <NEWLINE> <INDENT> tree [ p ] [ 1 ] = insert ( tree [ p ] [ 1 ] , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ p ] [ 2 ] = insert ( tree [ p ] [ 2 ] , x ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def preorder ( p ) : <NEWLINE> <INDENT> if p == None : return [ ] <NEWLINE> p1 , p2 = tree [ p ] [ 1 : 3 ] <NEWLINE> return [ tree [ p ] [ 0 ] ] + preorder ( p1 ) + preorder ( p2 ) <NEWLINE> <NL> <DEDENT> def inorder ( p ) : <NEWLINE> <INDENT> if p == None : return [ ] <NEWLINE> p1 , p2 = tree [ p ] [ 1 : 3 ] <NEWLINE> return inorder ( p1 ) + [ tree [ p ] [ 0 ] ] + inorder ( p2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( 0 , int ( s [ 7 : ] ) ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> + <STRING> . join ( map ( str , inorder ( home ) ) ) <NEWLINE> print <STRING> + <STRING> . join ( map ( str , preorder ( home ) ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
class BinaryTree : <NEWLINE> <NL> <INDENT> from io import StringIO <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> self . output = StringIO ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> self . root = self . Node ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = self . root <NEWLINE> temp = None <NEWLINE> while True : <NEWLINE> <INDENT> temp = root <NEWLINE> if key > root . key : <NEWLINE> <INDENT> root = root . right <NEWLINE> if root is None : <NEWLINE> <INDENT> temp . right = self . Node ( key ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> root = root . left <NEWLINE> if root is None : <NEWLINE> <INDENT> temp . left = self . Node ( key ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def ini_print_inorder ( self ) : <NEWLINE> <INDENT> self . output = StringIO ( ) <NEWLINE> self . print_inorder ( self . root ) <NEWLINE> return self . output . getvalue ( ) <NEWLINE> <NL> <DEDENT> def ini_print_preorder ( self ) : <NEWLINE> <INDENT> self . output = StringIO ( ) <NEWLINE> self . print_preorder ( self . root ) <NEWLINE> return self . output . getvalue ( ) <NEWLINE> <NL> <DEDENT> def print_inorder ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> self . print_inorder ( node . left ) <NEWLINE> print ( node . key , end = <STRING> , file = self . output ) <NEWLINE> self . print_inorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_preorder ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> print ( node . key , end = <STRING> , file = self . output ) <NEWLINE> self . print_preorder ( node . left ) <NEWLINE> self . print_preorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def test_insert ( self , keys ) : <NEWLINE> <INDENT> for k in keys : <NEWLINE> <INDENT> self . insert ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> length = int ( input ( ) ) <NEWLINE> b = BinaryTree ( ) <NEWLINE> for _ in range ( length ) : <NEWLINE> <INDENT> comm = input ( ) <NEWLINE> if comm [ 0 ] == <STRING> : <NEWLINE> <INDENT> com , num = comm . split ( <STRING> ) <NEWLINE> b . insert ( int ( num ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ( b . ini_print_inorder ( ) ) [ : - 1 ] ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( b . ini_print_preorder ( ) [ : - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> class BST : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> y = None <NEWLINE> z = Node ( key ) <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> x = x . left if z . key < x . key else x . right <NEWLINE> <DEDENT> if y == None : self . root = z <NEWLINE> else : <NEWLINE> <INDENT> if z . key < y . key : y . left = z <NEWLINE> else : y . right = z <NEWLINE> <DEDENT> <DEDENT> def print_tree ( self ) : <NEWLINE> <INDENT> def inorder ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> inorder ( node . left ) <NEWLINE> temp += <STRING> <NEWLINE> inorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> def preorder ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> temp += <STRING> <NEWLINE> preorder ( node . left ) <NEWLINE> preorder ( node . right ) <NEWLINE> <DEDENT> <DEDENT> temp = <STRING> <NEWLINE> inorder ( self . root ) <NEWLINE> print ( temp ) <NEWLINE> temp = <STRING> <NEWLINE> preorder ( self . root ) <NEWLINE> print ( temp ) <NEWLINE> <NL> <DEDENT> <DEDENT> tree = BST ( ) <NEWLINE> input ( ) <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if e [ 0 ] == <STRING> : tree . insert ( int ( e [ 7 : ] ) ) <NEWLINE> else : tree . print_tree ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> import time <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( z ) : <NEWLINE> <INDENT> global root <NEWLINE> y = None <NEWLINE> x = root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y is None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def inorderTreeWalk ( node ) : <NEWLINE> <INDENT> global In <NEWLINE> if node : <NEWLINE> <INDENT> inorderTreeWalk ( node . left ) <NEWLINE> In . append ( str ( node . key ) ) <NEWLINE> inorderTreeWalk ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorderTreeWalk ( node ) : <NEWLINE> <INDENT> global Pre <NEWLINE> if node : <NEWLINE> <INDENT> Pre . append ( str ( node . key ) ) <NEWLINE> preorderTreeWalk ( node . left ) <NEWLINE> preorderTreeWalk ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> del lines [ 0 ] <NEWLINE> <NL> root = None <NEWLINE> for line in lines : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( Node ( int ( line . split ( ) [ 1 ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> In = [ ] <NEWLINE> Pre = [ ] <NEWLINE> inorderTreeWalk ( root ) <NEWLINE> print <STRING> + <STRING> . join ( map ( str , In ) ) <NEWLINE> preorderTreeWalk ( root ) <NEWLINE> print <STRING> + <STRING> . join ( map ( str , Pre ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key = - 1 ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = - 1 <NEWLINE> self . left = - 1 <NEWLINE> self . right = - 1 <NEWLINE> <NL> <DEDENT> def setKey ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def insert ( T_ , z ) : <COMMENT> <NEWLINE> <INDENT> global T <NEWLINE> y = - 1 <NEWLINE> x = T_ <COMMENT> <NEWLINE> while x != - 1 : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y == - 1 : <NEWLINE> <INDENT> T = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def preParse ( T ) : <NEWLINE> <INDENT> if T == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print T . key , <NEWLINE> preParse ( T . left ) <NEWLINE> preParse ( T . right ) <NEWLINE> <NL> <DEDENT> def inParse ( T ) : <NEWLINE> <INDENT> if T == - 1 : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inParse ( T . left ) <COMMENT> <NEWLINE> print T . key , <NEWLINE> inParse ( T . right ) <NEWLINE> <NL> <NL> <DEDENT> T = - 1 <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> com = [ ] <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> com . append ( raw_input ( ) ) <NEWLINE> <DEDENT> for i in xrange ( m ) : <NEWLINE> <INDENT> if com [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( T , Node ( key = int ( com [ i ] [ 7 : ] ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> inParse ( T ) <NEWLINE> print <NEWLINE> print <STRING> , <NEWLINE> preParse ( T ) <NEWLINE> print <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE>
class node : <NEWLINE> <INDENT> def __init__ ( self , key = None ) : <NEWLINE> <INDENT> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> self . key = key <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( T , z ) : <NEWLINE> <INDENT> x = T <NEWLINE> y = None <NEWLINE> while isinstance ( x , node ) : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y is None : <NEWLINE> <INDENT> T = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return T <NEWLINE> <NL> <DEDENT> def preorder ( u ) : <NEWLINE> <INDENT> if not isinstance ( u , node ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> pripre . append ( str ( u . key ) ) <NEWLINE> preorder ( u . left ) <NEWLINE> preorder ( u . right ) <NEWLINE> <NL> <DEDENT> def inorder ( u ) : <NEWLINE> <INDENT> if not isinstance ( u , node ) : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( u . left ) <NEWLINE> priin . append ( str ( u . key ) ) <NEWLINE> inorder ( u . right ) <NEWLINE> <NL> <DEDENT> pripre = [ ] <NEWLINE> priin = [ ] <NEWLINE> m = input ( ) <NEWLINE> root = None <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> cmd = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> preorder ( root ) <NEWLINE> inorder ( root ) <NEWLINE> print ( <STRING> . join ( priin ) ) <NEWLINE> print ( <STRING> . join ( pripre ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> key = int ( cmd [ 1 ] ) <NEWLINE> z = node ( key ) <NEWLINE> root = insert ( root , z ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> class TreeNode : <NEWLINE> <INDENT> def __init__ ( self , val ) : <NEWLINE> <INDENT> self . val = val <NEWLINE> self . left = self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> class BST : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , node ) : <NEWLINE> <INDENT> def helper ( root ) : <NEWLINE> <INDENT> if root is None : <NEWLINE> <INDENT> root = node <NEWLINE> <DEDENT> elif node . val < root . val : <NEWLINE> <INDENT> lr = helper ( root . left ) <NEWLINE> root . left = lr <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> rr = helper ( root . right ) <NEWLINE> root . right = rr <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> self . root = helper ( self . root ) <NEWLINE> <NL> <DEDENT> def inorder ( self ) : <NEWLINE> <INDENT> def helper ( root ) : <NEWLINE> <INDENT> return [ ] if root is None else helper ( root . left ) + [ root . val ] + helper ( root . right ) <NEWLINE> <DEDENT> return helper ( self . root ) <NEWLINE> <NL> <DEDENT> def preorder ( self ) : <NEWLINE> <INDENT> def helper ( root ) : <NEWLINE> <INDENT> return [ ] if root is None else [ root . val ] + helper ( root . left ) + helper ( root . right ) <NEWLINE> <DEDENT> return helper ( self . root ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> q = sys . stdin . readline ( ) <NEWLINE> q = int ( q ) <NEWLINE> bst = BST ( ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> tmp = sys . stdin . readline ( ) <NEWLINE> if tmp . startswith ( <STRING> ) : <NEWLINE> <INDENT> print <STRING> + <STRING> . join ( map ( lambda x : str ( x ) , bst . inorder ( ) ) ) <NEWLINE> print <STRING> + <STRING> . join ( map ( lambda x : str ( x ) , bst . preorder ( ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> _ , val = tmp . split ( ) <NEWLINE> node = TreeNode ( int ( val ) ) <NEWLINE> bst . insert ( node ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( key ) : <NEWLINE> <INDENT> global root <NEWLINE> <NL> x = root <NEWLINE> y = None <NEWLINE> while x : x , y = x . left if key < x . key else x . right , x <NEWLINE> if y == None : root = Node ( key ) <NEWLINE> elif y . key < key : y . right = Node ( key ) <NEWLINE> else : y . left = Node ( key ) <NEWLINE> <NL> <NL> <DEDENT> def pre ( node ) : <NEWLINE> <INDENT> if node == None : return <NEWLINE> print ( <STRING> , node . key , end = <STRING> ) ; pre ( node . left ) ; pre ( node . right ) <NEWLINE> <NL> <DEDENT> def ino ( node ) : <NEWLINE> <INDENT> if node == None : return <NEWLINE> ino ( node . left ) ; print ( <STRING> , node . key , end = <STRING> ) ; ino ( node . right ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> root = None <NEWLINE> for j in range ( n ) : <NEWLINE> <INDENT> s , * i = input ( ) . split ( ) <NEWLINE> if s [ 0 ] == <STRING> : insert ( int ( i [ 0 ] ) ) <NEWLINE> else : <NEWLINE> <INDENT> ino ( root ) ; print ( <STRING> ) ; pre ( root ) print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
def reconstruct ( pre_list , in_list ) : <NEWLINE> <INDENT> if len ( pre_list ) <= 1 : <NEWLINE> <INDENT> return pre_list <NEWLINE> <DEDENT> now = pre_list [ 0 ] <NEWLINE> split_place = in_list . index ( now ) <NEWLINE> pre_left = pre_list [ 1 : split_place + 1 ] <NEWLINE> in_left = in_list [ 0 : split_place ] <NEWLINE> pre_right = pre_list [ split_place + 1 : ] <NEWLINE> in_right = in_list [ split_place + 1 : ] <NEWLINE> return reconstruct ( pre_left , in_left ) + reconstruct ( pre_right , in_right ) + [ now ] <NEWLINE> <NL> <DEDENT> def print_list_split_whitespace ( a ) : <NEWLINE> <INDENT> for x in a [ : - 1 ] : <NEWLINE> <INDENT> print ( x , end = <STRING> ) <NEWLINE> <DEDENT> print ( a [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> pre_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> in_list = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> post_list = reconstruct ( pre_list , in_list ) <NEWLINE> print_list_split_whitespace ( post_list ) <NEWLINE>
<COMMENT> <NL> <NL> class Node_Class ( ) : <NEWLINE> <INDENT> def __init__ ( self , key , parent , left , right ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( z ) : <NEWLINE> <INDENT> global root <NEWLINE> y = None <NEWLINE> x = root <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y is None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def pre_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> print node . key , <NEWLINE> pre_order ( node . left ) <NEWLINE> pre_order ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def in_order ( node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> in_order ( node . left ) <NEWLINE> print node . key , <NEWLINE> in_order ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> m = int ( raw_input ( ) ) <NEWLINE> root = None <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> line = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> z = Node_Class ( int ( line [ 1 ] ) , None , None , None ) <NEWLINE> insert ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> in_order ( root ) <NEWLINE> print <STRING> <NEWLINE> print <STRING> , <NEWLINE> pre_order ( root ) <NEWLINE> <DEDENT> <DEDENT>
class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . p = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( tree , k ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = tree <NEWLINE> z = Node ( k ) <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if x . key > k : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> if y == None : <NEWLINE> <INDENT> tree = z <NEWLINE> <DEDENT> elif y . key > k : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return tree <NEWLINE> <NL> <DEDENT> def middleorder ( x ) : <NEWLINE> <INDENT> if x != None : <NEWLINE> <INDENT> middleorder ( x . left ) <NEWLINE> print x . key , <NEWLINE> middleorder ( x . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( x ) : <NEWLINE> <INDENT> if x != None : <NEWLINE> <INDENT> print x . key , <NEWLINE> preorder ( x . left ) <NEWLINE> preorder ( x . right ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> tree = None <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> c = raw_input ( ) . strip ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree = insert ( tree , int ( c [ 7 : ] ) ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> middleorder ( tree ) <NEWLINE> print <NEWLINE> print <STRING> , <NEWLINE> preorder ( tree ) <NEWLINE> print <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> class Node_Class ( ) : <NEWLINE> <INDENT> def __init__ ( self , key , parent , left , right ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = parent <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( z ) : <NEWLINE> <INDENT> global root <NEWLINE> y = None <NEWLINE> x = root <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if y is None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def pre_order ( node , list ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> list . append ( node . key ) <NEWLINE> pre_order ( node . left , list ) <NEWLINE> pre_order ( node . right , list ) <NEWLINE> <NL> <DEDENT> <DEDENT> def in_order ( node , list ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> in_order ( node . left , list ) <NEWLINE> list . append ( node . key ) <NEWLINE> in_order ( node . right , list ) <NEWLINE> <NL> <DEDENT> <DEDENT> m = int ( raw_input ( ) ) <NEWLINE> root = None <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> line = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> z = Node_Class ( int ( line [ 1 ] ) , None , None , None ) <NEWLINE> insert ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> A = [ ] <NEWLINE> B = [ ] <NEWLINE> in_order ( root , A ) <NEWLINE> pre_order ( root , B ) <NEWLINE> print <STRING> . join ( map ( str , A ) ) <NEWLINE> print <STRING> . join ( map ( str , B ) ) <NEWLINE> <DEDENT> <DEDENT>
class binaryTree : <NEWLINE> <INDENT> def __init__ ( self , key , p = None , l = None , r = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . p = p <NEWLINE> self . l = l <NEWLINE> self . r = r <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> treelist = [ list ( input ( ) . split ( ) ) for i in range ( N ) ] <NEWLINE> root = None <NEWLINE> <NL> def inorder ( root ) : <NEWLINE> <INDENT> x = root <NEWLINE> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( x . l ) <NEWLINE> <NL> global inlist <NEWLINE> inlist . append ( x . key ) <NEWLINE> <NL> inorder ( x . r ) <NEWLINE> <NL> <DEDENT> def insert ( root , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . r <NEWLINE> <DEDENT> <DEDENT> z . p = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . l = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . r = z <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def outorder ( root ) : <NEWLINE> <INDENT> x = root <NEWLINE> if x == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> global outlist <NEWLINE> outlist . append ( x . key ) <NEWLINE> <NL> outorder ( x . l ) <NEWLINE> outorder ( x . r ) <NEWLINE> <NL> <DEDENT> for data in treelist : <NEWLINE> <INDENT> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> z = binaryTree ( int ( data [ 1 ] ) ) <NEWLINE> root = insert ( root , z ) <NEWLINE> <NL> <DEDENT> if data [ 0 ] == <STRING> : <NEWLINE> <INDENT> inlist = [ ] <NEWLINE> outlist = [ ] <NEWLINE> <NL> inorder ( root ) <NEWLINE> indata = <STRING> + <STRING> . join ( [ str ( num ) for num in inlist ] ) <NEWLINE> print ( indata ) <NEWLINE> <NL> outorder ( root ) <NEWLINE> outdata = <STRING> + <STRING> . join ( [ str ( num ) for num in outist ] ) <NEWLINE> print ( outdata ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> class Node : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_tree_walk ( root ) : <NEWLINE> <INDENT> print ( <STRING> , root . id , end = <STRING> ) <NEWLINE> if root . left != None : <NEWLINE> <INDENT> preorder_tree_walk ( root . left ) <NEWLINE> <DEDENT> if root . right != None : <NEWLINE> <INDENT> preorder_tree_walk ( root . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder_tree_walk ( root ) : <NEWLINE> <INDENT> if root . left != None : <NEWLINE> <INDENT> inorder_tree_walk ( root . left ) <NEWLINE> <DEDENT> print ( <STRING> , root . id , end = <STRING> ) <NEWLINE> if root . right != None : <NEWLINE> <INDENT> inorder_tree_walk ( root . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( root , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . id < x . id : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . id < y . id : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> root = None <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> line = raw_input ( ) . split ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> num = int ( line [ 1 ] ) <NEWLINE> root = insert ( root , Node ( num ) ) <NEWLINE> <DEDENT> elif line [ 0 ] == <STRING> : <NEWLINE> <INDENT> inorder_tree_walk ( root ) <NEWLINE> print ( ) <NEWLINE> preorder_tree_walk ( root ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . right = None <NEWLINE> self . left = None <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( T , z ) : <NEWLINE> <COMMENT> <NL> <INDENT> y = None <COMMENT> <NEWLINE> x = T <NEWLINE> <NL> <COMMENT> <NL> while ( x != None ) : <NEWLINE> <INDENT> y = x <NEWLINE> if ( z . key < x . key ) : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if ( y == None ) : <NEWLINE> T = z <NEWLINE> elif ( z . key < y . key ) : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> return T <NEWLINE> <NL> <NL> <DEDENT> def inorder_walk ( node ) : <NEWLINE> <INDENT> if node . left : <NEWLINE> <INDENT> inorder_walk ( node . left ) <NEWLINE> <DEDENT> print ( <STRING> , node . key , end = <STRING> ) <NEWLINE> if node . right : <NEWLINE> <INDENT> inorder_walk ( node . right ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def preorder_walk ( node ) : <NEWLINE> <INDENT> print ( <STRING> , node . key , end = <STRING> ) <NEWLINE> if node . left : <NEWLINE> <INDENT> preorder_walk ( node . left ) <NEWLINE> <DEDENT> if node . right : <NEWLINE> <INDENT> preorder_walk ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> T = None <NEWLINE> num = int ( input ( ) ) <NEWLINE> <NL> for _ in range ( num ) : <NEWLINE> <INDENT> cmd = input ( ) <NEWLINE> if ( cmd . startswith ( <STRING> ) ) : <NEWLINE> <INDENT> n = Node ( int ( cmd [ 7 : ] ) ) <NEWLINE> T = insert ( T , n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> inorder_walk ( T ) <NEWLINE> print ( ) <NEWLINE> preorder_walk ( T ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> class Node ( ) : <NEWLINE> <INDENT> __slots__ = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left , self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> root = None <NEWLINE> def insert ( z ) : <NEWLINE> <INDENT> global root <NEWLINE> x , y = root , None <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <DEDENT> <DEDENT> if y == - 1 : <NEWLINE> <INDENT> root = Node ( z ) <NEWLINE> <DEDENT> elif z < y . key : <NEWLINE> <INDENT> y . left = Node ( z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = Node ( z ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( x ) : <NEWLINE> <INDENT> return <STRING> + preorder ( x . left ) + preorder ( x . right ) if x else <STRING> <NEWLINE> <NL> <DEDENT> def inorder ( x ) : <NEWLINE> <INDENT> return inorder ( x . left ) + <STRING> + inorder ( x . right ) if x else <STRING> <NEWLINE> <NL> <DEDENT> input ( ) <NEWLINE> node = { } <NEWLINE> root = - 1 <NEWLINE> for s in sys . stdin : <NEWLINE> <INDENT> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( inorder ( root ) ) <NEWLINE> print ( preorder ( root ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> insert ( int ( s [ 7 : ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> <DEDENT> def prewalk ( self ) : <NEWLINE> <INDENT> nodeList = [ self . key ] <NEWLINE> if self . left : <NEWLINE> <INDENT> nodeList += self . left . prewalk ( ) <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> nodeList += self . right . prewalk ( ) <NEWLINE> <DEDENT> return nodeList <NEWLINE> <NL> <DEDENT> def inwalk ( self ) : <NEWLINE> <INDENT> nodeList = [ ] <NEWLINE> if self . left : <NEWLINE> <INDENT> nodeList += self . left . inwalk ( ) <NEWLINE> <DEDENT> nodeList += [ self . key ] <NEWLINE> if self . right : <NEWLINE> <INDENT> nodeList += self . right . inwalk ( ) <NEWLINE> <DEDENT> return nodeList <NEWLINE> <NL> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( <STRING> , <STRING> . join ( map ( str , self . root . inwalk ( ) ) ) ) <NEWLINE> print ( <STRING> , <STRING> . join ( map ( str , self . root . prewalk ( ) ) ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Tree ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> Nz = Node ( key ) <NEWLINE> Ny = None <COMMENT> <NEWLINE> Nx = self . root <NEWLINE> while Nx : <NEWLINE> <INDENT> Ny = Nx <NEWLINE> if Nz . key < Ny . key : <NEWLINE> <INDENT> Nx = Nx . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Nx = Nx . right <NEWLINE> <NL> <DEDENT> <DEDENT> Nz . parent = Ny <NEWLINE> if Ny == None : <NEWLINE> <INDENT> self . root = Nz <NEWLINE> <DEDENT> elif Nz . key < Ny . key : <NEWLINE> <INDENT> Ny . left = Nz <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> Ny . right = Nz <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> tree = Tree ( ) <NEWLINE> <NL> n = sys . stdin . readline ( ) <NEWLINE> for line in sys . stdin : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . insert ( int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree . print ( ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> tree = { } <NEWLINE> np = - 1 <NEWLINE> <NL> home = 0 <NEWLINE> tree [ home ] = [ None , None , None ] <NEWLINE> <NL> def search ( p , x ) : <NEWLINE> <INDENT> while p != None : <NEWLINE> <INDENT> tmp = tree [ p ] <NEWLINE> if tmp [ 0 ] == x : return True <NEWLINE> if x < tmp [ 0 ] : <NEWLINE> <INDENT> p = tmp [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = tmp [ 2 ] <NEWLINE> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def node ( x ) : <NEWLINE> <INDENT> global np <NEWLINE> np += 1 <NEWLINE> tree [ np ] = [ x , None , None ] <NEWLINE> return np <NEWLINE> <NL> <DEDENT> def insert ( p , x ) : <NEWLINE> <INDENT> if p == None or np == - 1 : return node ( x ) <NEWLINE> tmp = tree [ p ] <NEWLINE> if x == tmp [ 0 ] : return p <NEWLINE> elif x < tmp [ 0 ] : <NEWLINE> <INDENT> tree [ p ] [ 1 ] = insert ( tmp [ 1 ] , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ p ] [ 2 ] = insert ( tmp [ 2 ] , x ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def preorder ( p ) : <NEWLINE> <INDENT> if p == None : return [ ] <NEWLINE> p1 , p2 = tree [ p ] [ 1 : 3 ] <NEWLINE> return [ tree [ p ] [ 0 ] ] + preorder ( p1 ) + preorder ( p2 ) <NEWLINE> <NL> <DEDENT> def inorder ( p ) : <NEWLINE> <INDENT> if p == None : return [ ] <NEWLINE> p1 , p2 = tree [ p ] [ 1 : 3 ] <NEWLINE> return inorder ( p1 ) + [ tree [ p ] [ 0 ] ] + inorder ( p2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( 0 , int ( s [ 7 : ] ) ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if search ( 0 , int ( s [ 5 : ] ) ) : print <STRING> <NEWLINE> else print <STRING> <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> + <STRING> . join ( map ( str , inorder ( home ) ) ) <NEWLINE> print <STRING> + <STRING> . join ( map ( str , preorder ( home ) ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
class Tree : <NEWLINE> <INDENT> def __init__ ( self , orders ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> for order in orders : <NEWLINE> <INDENT> if len ( order ) == 1 : <NEWLINE> <INDENT> self . inorder_print ( ) <NEWLINE> self . preorder_print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( order [ 0 ] ) == 4 : <NEWLINE> <INDENT> self . find ( int ( order [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . insert ( int ( order [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> z = Node ( key ) <NEWLINE> y = None <NEWLINE> x = self . root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> <NL> if not y : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> self . root . find ( key ) <NEWLINE> <NL> <DEDENT> def inorder_print ( self ) : <NEWLINE> <INDENT> self . root . inorder_print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> def preorder_print ( self ) : <NEWLINE> <INDENT> self . root . preorder_print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init_ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> k = self . key <NEWLINE> if key == k : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif key < k : <NEWLINE> <INDENT> if self . left : <NEWLINE> <INDENT> self . left . find ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if self . right : <NEWLINE> <INDENT> self . right . find ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def inorder_print ( self ) : <NEWLINE> <INDENT> if self . left : <NEWLINE> <INDENT> self . left . inorder_print ( ) <NEWLINE> <DEDENT> print ( <STRING> . format ( self . key ) , end = <STRING> ) <NEWLINE> if self . right : <NEWLINE> <INDENT> self . right . inorder_print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_print ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . key ) , end = <STRING> ) <NEWLINE> if self . left : <NEWLINE> <INDENT> self . left . preorder_print ( ) <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> self . right . preorder_print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> m = int ( input ( ) ) <NEWLINE> orders = [ line . strip ( ) . split ( ) for line in sys . stdin ] <NEWLINE> Tree ( orders ) <NEWLINE> <NL> <DEDENT>
from __future__ import print_function <NEWLINE> from sys import stdin <NEWLINE> class Node : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_tree_walk ( root ) : <NEWLINE> <INDENT> print ( <STRING> , root . id , end = <STRING> ) <NEWLINE> if root . left != None : <NEWLINE> <INDENT> preorder_tree_walk ( root . left ) <NEWLINE> <DEDENT> if root . right != None : <NEWLINE> <INDENT> preorder_tree_walk ( root . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder_tree_walk ( root ) : <NEWLINE> <INDENT> if root . left != None : <NEWLINE> <INDENT> inorder_tree_walk ( root . left ) <NEWLINE> <DEDENT> print ( <STRING> , root . id , end = <STRING> ) <NEWLINE> if root . right != None : <NEWLINE> <INDENT> inorder_tree_walk ( root . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( root , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> while isinstance ( x , Node ) : <NEWLINE> <INDENT> y = x <NEWLINE> if z . id < x . id : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . id < y . id : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def find ( root , x ) : <NEWLINE> <INDENT> if root . id == x : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> if root . id > x : <NEWLINE> <INDENT> if root . left == None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( root . left , x ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if root . right == None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( root . right , x ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> root = None <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) <NEWLINE> if cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> num = int ( cmd [ 7 : ] ) <NEWLINE> root = insert ( root , Node ( num ) ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> inorder_tree_walk ( root ) <NEWLINE> print ( ) <NEWLINE> preorder_tree_walk ( root ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> num = int ( cmd [ 5 : ] ) <NEWLINE> if find ( root , num ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
from io import StringIO <NEWLINE> <NL> class BinaryTree : <NEWLINE> <NL> <INDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> self . output = StringIO ( ) <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> if self . root is None : <NEWLINE> <INDENT> self . root = self . Node ( key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = self . root <NEWLINE> temp = None <NEWLINE> while True : <NEWLINE> <INDENT> temp = root <NEWLINE> if key > root . key : <NEWLINE> <INDENT> root = root . right <NEWLINE> if root is None : <NEWLINE> <INDENT> temp . right = self . Node ( key ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> root = root . left <NEWLINE> if root is None : <NEWLINE> <INDENT> temp . left = self . Node ( key ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def ini_print_inorder ( self ) : <NEWLINE> <INDENT> self . output = StringIO ( ) <NEWLINE> self . print_inorder ( self . root ) <NEWLINE> return self . output . getvalue ( ) <NEWLINE> <NL> <DEDENT> def ini_print_preorder ( self ) : <NEWLINE> <INDENT> self . output = StringIO ( ) <NEWLINE> self . print_preorder ( self . root ) <NEWLINE> return self . output . getvalue ( ) <NEWLINE> <NL> <DEDENT> def print_inorder ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> self . print_inorder ( node . left ) <NEWLINE> print ( node . key , end = <STRING> , file = self . output ) <NEWLINE> self . print_inorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_preorder ( self , node ) : <NEWLINE> <INDENT> if node is not None : <NEWLINE> <INDENT> print ( node . key , end = <STRING> , file = self . output ) <NEWLINE> self . print_preorder ( node . left ) <NEWLINE> self . print_preorder ( node . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def test_insert ( self , keys ) : <NEWLINE> <INDENT> for k in keys : <NEWLINE> <INDENT> self . insert ( k ) <NEWLINE> <NL> <DEDENT> <DEDENT> def ini_find ( self , key ) : <NEWLINE> <INDENT> print ( self . find ( key ) ) <NEWLINE> <NL> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> root = self . root <NEWLINE> while root is not None : <NEWLINE> <INDENT> if key == root . key : <NEWLINE> <INDENT> return <STRING> <NEWLINE> <DEDENT> elif key < root . key : <NEWLINE> <INDENT> root = root . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = root . right <NEWLINE> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> length = int ( input ( ) ) <NEWLINE> b = BinaryTree ( ) <NEWLINE> for _ in range ( length ) : <NEWLINE> <INDENT> comm = input ( ) <NEWLINE> if comm [ 0 ] == <STRING> : <NEWLINE> <INDENT> com , num = comm . split ( <STRING> ) <NEWLINE> b . insert ( int ( num ) ) <NEWLINE> <DEDENT> elif comm [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( ( b . ini_print_inorder ( ) ) [ : - 1 ] ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( b . ini_print_preorder ( ) [ : - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> com , num = comm . split ( <STRING> ) <NEWLINE> b . ini_find ( num ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import sys <NEWLINE> import time <NEWLINE> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( key ) : <NEWLINE> <INDENT> global root <NEWLINE> z = Node ( key ) <NEWLINE> y = None <NEWLINE> x = root <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <DEDENT> <DEDENT> if y is None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( node , key ) : <NEWLINE> <INDENT> if node is None : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> elif node . key == key : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return find ( node . left , key ) or find ( node . right , key ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorderTreeWalk ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> return inorderTreeWalk ( node . left ) + <STRING> + str ( node . key ) + inorderTreeWalk ( node . right ) <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> def preorderTreeWalk ( node ) : <NEWLINE> <INDENT> if node : <NEWLINE> <INDENT> return <STRING> + str ( node . key ) + preorderTreeWalk ( node . left ) + preorderTreeWalk ( node . right ) <NEWLINE> <DEDENT> return <STRING> <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> del lines [ 0 ] <NEWLINE> <NL> root = None <NEWLINE> for line in lines : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> print inorderTreeWalk ( root ) <NEWLINE> print preorderTreeWalk ( root ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> com = line . split ( ) <NEWLINE> if com [ 0 ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( int ( com [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if find ( root , int ( com [ 1 ] ) ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT>
def insert ( tree , k ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = tree <NEWLINE> z = { <STRING> : k , <STRING> : None , <STRING> : None , <STRING> : None } <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if x [ <STRING> ] > k : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> z [ <STRING> ] = y <NEWLINE> if y == None : <NEWLINE> <INDENT> tree = z <NEWLINE> <DEDENT> elif y [ <STRING> ] > k : <NEWLINE> <INDENT> y [ <STRING> ] = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y [ <STRING> ] = z <NEWLINE> <DEDENT> return tree <NEWLINE> <NL> <DEDENT> def get_successor ( x ) : <NEWLINE> <INDENT> if x [ <STRING> ] != None : <NEWLINE> <INDENT> return get_minimum ( x [ <STRING> ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = x [ <STRING> ] <NEWLINE> while y != None and x == y [ <STRING> ] : <NEWLINE> <INDENT> x = y <NEWLINE> y = y [ <STRING> ] <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> <DEDENT> def get_minimum ( x ) : <NEWLINE> <INDENT> while x [ <STRING> ] != None : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def delete_node ( tree , z ) : <NEWLINE> <INDENT> if z [ <STRING> ] == None or z [ <STRING> ] == None : <NEWLINE> <INDENT> y = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = get_successor ( z ) <NEWLINE> <NL> <DEDENT> if y [ <STRING> ] != None : <NEWLINE> <INDENT> x = y [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y [ <STRING> ] <NEWLINE> <NL> <DEDENT> if x != None : <NEWLINE> <INDENT> x [ <STRING> ] = y [ <STRING> ] <NEWLINE> <NL> <DEDENT> if y [ <STRING> ] == None : <NEWLINE> <INDENT> tree = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if y [ <STRING> ] [ <STRING> ] [ <STRING> ] == y [ <STRING> ] : <NEWLINE> <INDENT> y [ <STRING> ] [ <STRING> ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y [ <STRING> ] [ <STRING> ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> z [ <STRING> ] = y [ <STRING> ] <NEWLINE> <NL> return tree <NEWLINE> <NL> <DEDENT> def find ( tree , k ) : <NEWLINE> <INDENT> x = tree <NEWLINE> while x != None : <NEWLINE> <INDENT> if x [ <STRING> ] == k : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> elif x [ <STRING> ] > k : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def middleorder ( x ) : <NEWLINE> <INDENT> if x != None : <NEWLINE> <INDENT> middleorder ( x [ <STRING> ] ) <NEWLINE> print x [ <STRING> ] , <NEWLINE> middleorder ( x [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( x ) : <NEWLINE> <INDENT> if x != None : <NEWLINE> <INDENT> print x [ <STRING> ] , <NEWLINE> preorder ( x [ <STRING> ] ) <NEWLINE> preorder ( x [ <STRING> ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> tree = None <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> c = raw_input ( ) . strip ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree = insert ( tree , int ( c [ 7 : ] ) ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> x = find ( tree , int ( c [ 5 : ] ) ) <NEWLINE> if x == None : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> z = find ( tree , int ( c [ 7 : ] ) ) <NEWLINE> if not z == None : tree = delete_node ( tree , z ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> middleorder ( tree ) <NEWLINE> print <NEWLINE> print <STRING> , <NEWLINE> preorder ( tree ) <NEWLINE> print <NEWLINE> <DEDENT> <DEDENT>
from __future__ import print_function <NEWLINE> from sys import stdin <NEWLINE> class Node : <NEWLINE> <INDENT> def __init__ ( self , id ) : <NEWLINE> <INDENT> self . id = id <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_tree_walk ( root ) : <NEWLINE> <INDENT> print ( <STRING> , root . id , end = <STRING> ) <NEWLINE> if root . left != None : <NEWLINE> <INDENT> preorder_tree_walk ( root . left ) <NEWLINE> <DEDENT> if root . right != None : <NEWLINE> <INDENT> preorder_tree_walk ( root . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder_tree_walk ( root ) : <NEWLINE> <INDENT> if root . left != None : <NEWLINE> <INDENT> inorder_tree_walk ( root . left ) <NEWLINE> <DEDENT> print ( <STRING> , root . id , end = <STRING> ) <NEWLINE> if root . right != None : <NEWLINE> <INDENT> inorder_tree_walk ( root . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( root , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> while isinstance ( x , Node ) : <NEWLINE> <INDENT> y = x <NEWLINE> if z . id < x . id : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> <NL> if y == None : <NEWLINE> <INDENT> root = z <NEWLINE> <DEDENT> elif z . id < y . id : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def find ( root , x ) : <NEWLINE> <INDENT> while root != None and x != root . id : <NEWLINE> <INDENT> if x < root . id : <NEWLINE> <INDENT> root = root . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> root = root . right <NEWLINE> <DEDENT> <DEDENT> return root <NEWLINE> <NL> <DEDENT> def delete ( root , z ) : <NEWLINE> <COMMENT> <NL> <INDENT> if z . left == None or z . right == None : <NEWLINE> <INDENT> y = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = get_successor ( z ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> if y . left != None : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <NL> <DEDENT> if x != None : <NEWLINE> <INDENT> x . parent = y . parent <NEWLINE> <NL> <DEDENT> if y . parent == None : <NEWLINE> <INDENT> root = x <NEWLINE> <DEDENT> elif y == y . parent . left : <NEWLINE> <INDENT> y . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . parent . right = x <NEWLINE> <NL> <DEDENT> if y != z : <NEWLINE> <INDENT> z . id = y . id <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def get_successor ( x ) : <NEWLINE> <INDENT> if x . right != None : <NEWLINE> <INDENT> return get_minimum ( x . right ) <NEWLINE> <NL> <DEDENT> y = x . parent <NEWLINE> while y != None and x == y . right : <NEWLINE> <INDENT> x = y <NEWLINE> y = y . parent <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def get_minumum ( x ) : <NEWLINE> <INDENT> while x . left != None : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> root = None <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> cmd = stdin . readline ( ) <NEWLINE> if cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> num = int ( cmd [ 7 : ] ) <NEWLINE> root = insert ( root , Node ( num ) ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> inorder_tree_walk ( root ) <NEWLINE> print ( ) <NEWLINE> preorder_tree_walk ( root ) <NEWLINE> print ( ) <NEWLINE> <DEDENT> elif cmd . startswith ( <STRING> ) : <NEWLINE> <INDENT> num = int ( cmd [ 7 : ] ) <NEWLINE> node = find ( root , num ) <NEWLINE> if node != None : <NEWLINE> <INDENT> delete ( root , node ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> num = int ( cmd [ 5 : ] ) <NEWLINE> if find ( root , num ) != None : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> tree = MyBinaryTree ( n ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> cmd = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( tree , MyNode ( int ( cmd [ 1 ] ) ) ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . inorder ( tree . root ) <NEWLINE> print <STRING> <NEWLINE> tree . preorder ( tree . root ) <NEWLINE> print <STRING> <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> find ( tree , int ( cmd [ 1 ] ) ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete ( tree , int ( cmd [ 1 ] ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class MyBinaryTree ( ) : <NEWLINE> <INDENT> def __init__ ( self , num_nodes ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def preorder ( self , node ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> . format ( node . key ) ) <NEWLINE> l = node . left <NEWLINE> r = node . right <NEWLINE> if l is not None : <NEWLINE> <INDENT> self . preorder ( l ) <NEWLINE> <DEDENT> if r is not None : <NEWLINE> <INDENT> self . preorder ( r ) <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder ( self , node ) : <NEWLINE> <INDENT> l = node . left <NEWLINE> r = node . right <NEWLINE> if l is not None : <NEWLINE> <INDENT> self . inorder ( l ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> . format ( node . key ) ) <NEWLINE> if r is not None : <NEWLINE> <INDENT> self . inorder ( r ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def insert ( T , z ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = T . root <NEWLINE> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> <NL> if y is None : <NEWLINE> <INDENT> T . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def find ( T , key ) : <NEWLINE> <INDENT> x = T . root <NEWLINE> while x is not None and key != x . key : <NEWLINE> <INDENT> if key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <DEDENT> <DEDENT> if x is not None : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def delete ( T , key ) : <NEWLINE> <INDENT> x = T . root <NEWLINE> where = None <NEWLINE> while x is not None and key != x . key : <NEWLINE> <INDENT> if key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> where = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> where = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> if x is not None : <NEWLINE> <INDENT> if x . left is None : <NEWLINE> <INDENT> if x . right is None : <NEWLINE> <INDENT> if where == 0 : <NEWLINE> <INDENT> x . parent . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . parent . right = None <NEWLINE> <DEDENT> <DEDENT> elif where == 0 : <NEWLINE> <INDENT> x . parent . left = x . right <NEWLINE> x . right . parent = x . parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . parent . right = x . right <NEWLINE> x . right . parent = x . parent <NEWLINE> <DEDENT> x = None <NEWLINE> <DEDENT> elif x . rightt is None : <NEWLINE> <INDENT> if where == 0 : <NEWLINE> <INDENT> x . parent . left = x . left <NEWLINE> x . left . parent = x . parent <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x . parent . right = x . left <NEWLINE> x . left . parent = x . parent <NEWLINE> <DEDENT> x = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = x . right <NEWLINE> while y . left is not None : <NEWLINE> <INDENT> y = y . left <NEWLINE> <NL> <DEDENT> x . key = y . key <NEWLINE> if y . right is not None : <NEWLINE> <INDENT> y . right . parent = y . parent <NEWLINE> y . parent . left = y . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . parent . left = None <NEWLINE> <DEDENT> y = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> class MyNode ( ) : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Tree : <NEWLINE> <INDENT> def __init__ ( self , orders ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> for order in orders : <NEWLINE> <INDENT> if len ( order ) == 1 : <NEWLINE> <INDENT> self . inorder_print ( ) <NEWLINE> self . preorder_print ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if len ( order [ 0 ] ) == 4 : <NEWLINE> <INDENT> self . find ( int ( order [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . insert ( int ( order [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> z = Node ( key ) <NEWLINE> y = None <NEWLINE> x = self . root <NEWLINE> while x : <NEWLINE> <INDENT> y = x <NEWLINE> if z . key < x . key : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> z . parent = y <NEWLINE> if not y : <NEWLINE> <INDENT> self . root = z <NEWLINE> <DEDENT> elif z . key < y . key : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> while True : <NEWLINE> <INDENT> if key == x . key : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif key < x . key : <NEWLINE> <INDENT> if not x . left : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if not x . right : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> z = self . root <NEWLINE> while z . key != key : <NEWLINE> <INDENT> if key < z . key : <NEWLINE> <INDENT> z = z . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> z = z . right <NEWLINE> <NL> <DEDENT> <DEDENT> if not z . left or not z . right : <NEWLINE> <INDENT> y = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y = self . get_successor ( z ) <NEWLINE> <NL> <DEDENT> if y . left : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <NL> <DEDENT> if x : <NEWLINE> <INDENT> x . parent = y . parent <NEWLINE> <NL> <DEDENT> if not y . parent : <NEWLINE> <INDENT> self . root = x <NEWLINE> <DEDENT> elif y == y . parent . left : <NEWLINE> <INDENT> y . parent . left = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . parent . right = x <NEWLINE> <NL> <DEDENT> if y != z : <NEWLINE> <INDENT> z . key = y . key <NEWLINE> <NL> <DEDENT> del ( y ) <NEWLINE> <NL> <DEDENT> def get_successor ( self , x ) : <NEWLINE> <INDENT> if x . right : <NEWLINE> <INDENT> return self . get_minimum ( x . right ) <NEWLINE> <NL> <DEDENT> y = x . parent <NEWLINE> while y and x == y . right : <NEWLINE> <INDENT> x = y <NEWLINE> y = y . parent <NEWLINE> <DEDENT> return y <NEWLINE> <NL> <DEDENT> def get_minimum ( self , x ) : <NEWLINE> <INDENT> while x . left : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def inorder_print ( self ) : <NEWLINE> <INDENT> self . root . inorder_print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <DEDENT> def preorder_print ( self ) : <NEWLINE> <INDENT> self . root . preorder_print ( ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . parent = None <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> def inorder_print ( self ) : <NEWLINE> <INDENT> if self . left : <NEWLINE> <INDENT> self . left . inorder_print ( ) <NEWLINE> <DEDENT> print ( <STRING> . format ( self . key ) , end = <STRING> ) <NEWLINE> if self . right : <NEWLINE> <INDENT> self . right . inorder_print ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder_print ( self ) : <NEWLINE> <INDENT> print ( <STRING> . format ( self . key ) , end = <STRING> ) <NEWLINE> if self . left : <NEWLINE> <INDENT> self . left . preorder_print ( ) <NEWLINE> <DEDENT> if self . right : <NEWLINE> <INDENT> self . right . preorder_print ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> m = int ( input ( ) ) <NEWLINE> orders = [ line . strip ( ) . split ( ) for line in sys . stdin ] <NEWLINE> Tree ( orders ) <NEWLINE> <NL> <DEDENT>
<NL> <NL> class Node ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , key ) : <NEWLINE> <INDENT> self . left = None <NEWLINE> self . right = None <NEWLINE> self . parent = None <NEWLINE> <NL> self . key = key <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Tree ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . root = None <NEWLINE> <NL> <DEDENT> def insert ( self , new_key ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> y = None <NEWLINE> <NL> while x is not None : <NEWLINE> <INDENT> y = x <NEWLINE> <NL> if new_key < y . key : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <NL> <DEDENT> <DEDENT> new_node = Node ( new_key ) <NEWLINE> new_node . parent = y <NEWLINE> if y is None : <NEWLINE> <INDENT> self . root = new_node <NEWLINE> <DEDENT> elif new_key < y . key : <NEWLINE> <INDENT> y . left = new_node <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = new_node <NEWLINE> <NL> <DEDENT> <DEDENT> def inorder ( self , now ) : <NEWLINE> <INDENT> visited = list ( ) <NEWLINE> if now is None : <NEWLINE> <INDENT> return visited <NEWLINE> <NL> <DEDENT> visited . extend ( self . inorder ( now . left ) ) <NEWLINE> visited . append ( now . key ) <NEWLINE> visited . extend ( self . inorder ( now . right ) ) <NEWLINE> return visited <NEWLINE> <NL> <DEDENT> def preorder ( self , now ) : <NEWLINE> <INDENT> visited = list ( ) <NEWLINE> if now is None : <NEWLINE> <INDENT> return visited <NEWLINE> <NL> <DEDENT> visited . append ( now . key ) <NEWLINE> visited . extend ( self . preorder ( now . left ) ) <NEWLINE> visited . extend ( self . preorder ( now . right ) ) <NEWLINE> return visited <NEWLINE> <NL> <DEDENT> def order_print ( self ) : <NEWLINE> <INDENT> keys = list ( ) <NEWLINE> keys . append ( self . inorder ( self . root ) ) <NEWLINE> keys . append ( self . preorder ( self . root ) ) <NEWLINE> <NL> for visited_keys in keys : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> print <STRING> . join ( map ( str , visited_keys ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , key ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> x = self . root <NEWLINE> y = None <NEWLINE> <NL> while not ( x is None or x . key == key ) : <NEWLINE> <INDENT> y = x <NEWLINE> if key < y . key : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <NL> <DEDENT> <DEDENT> if x is not None : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def min_node ( self , now ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if now . left is not None : <NEWLINE> <INDENT> return min_node ( now . left ) <NEWLINE> <DEDENT> return now <NEWLINE> <NL> <NL> <DEDENT> def delete ( self , key ) : <NEWLINE> <INDENT> x = self . root <NEWLINE> y = None <NEWLINE> <NL> while x . key != key : <NEWLINE> <INDENT> y = x <NEWLINE> if key < y . key : <NEWLINE> <INDENT> x = y . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = y . right <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> if x . left is None and x . right is None : <NEWLINE> <INDENT> if y . left == x : <NEWLINE> <INDENT> y . left = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = None <NEWLINE> <DEDENT> <DEDENT> elif x . left is None or x . right is None : <NEWLINE> <INDENT> child = x . left if x . left is not None else x . right <NEWLINE> child . parent = y <NEWLINE> if y . left == x : <NEWLINE> <INDENT> y . left = child <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = child <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> next_node = self . min_node ( x . right ) <NEWLINE> x . key = next_node . key <NEWLINE> self . delete ( next_node ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> tree = Tree ( ) <NEWLINE> <NL> num_orders = int ( raw_input ( ) ) <NEWLINE> for _ in xrange ( num_orders ) : <NEWLINE> <INDENT> order = raw_input ( ) <NEWLINE> if order [ 0 ] == <STRING> : <NEWLINE> <INDENT> new_key = int ( order . split ( ) [ 1 ] ) <NEWLINE> tree . insert ( new_key ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree . order_print ( ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( order . split ( ) [ 1 ] ) <NEWLINE> tree . find ( key ) <NEWLINE> <DEDENT> elif order [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( order . split ( ) [ 1 ] ) <NEWLINE> tree . delete ( key ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> tree = { } <NEWLINE> np = - 1 <NEWLINE> <NL> home = 0 <NEWLINE> tree [ home ] = [ None , None , None ] <NEWLINE> <NL> def search ( p , x ) : <NEWLINE> <INDENT> node_pos = [ None , None ] <NEWLINE> while p != None : <NEWLINE> <INDENT> tmp = tree [ p ] <NEWLINE> if tmp [ 0 ] == x : <NEWLINE> <INDENT> node_pos [ 0 ] = p <NEWLINE> return node_pos <NEWLINE> <DEDENT> node_pos [ 1 ] = p <NEWLINE> if x < tmp [ 0 ] : <NEWLINE> <INDENT> p = tmp [ 1 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = tmp [ 2 ] <NEWLINE> <DEDENT> <DEDENT> return node_pos <NEWLINE> <NL> <DEDENT> def node ( x ) : <NEWLINE> <INDENT> global np <NEWLINE> np += 1 <NEWLINE> tree [ np ] = [ x , None , None ] <NEWLINE> return np <NEWLINE> <NL> <DEDENT> def insert ( p , x ) : <NEWLINE> <INDENT> if p == None or np == - 1 : return node ( x ) <NEWLINE> tmp = tree [ p ] <NEWLINE> if x == tmp [ 0 ] : return p <NEWLINE> elif x < tmp [ 0 ] : <NEWLINE> <INDENT> tree [ p ] [ 1 ] = insert ( tmp [ 1 ] , x ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree [ p ] [ 2 ] = insert ( tmp [ 2 ] , x ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def deletenode ( p , parent , child = None ) : <NEWLINE> <INDENT> if tree [ parent ] [ 1 ] == p : <NEWLINE> <INDENT> tree [ parent ] [ 1 ] = child <NEWLINE> <DEDENT> elif tree [ parent ] [ 2 ] == p : <NEWLINE> <INDENT> tree [ parent ] [ 2 ] = child <NEWLINE> <DEDENT> del tree [ p ] <NEWLINE> <NL> <DEDENT> def searchmin ( p ) : <NEWLINE> <INDENT> if tree [ p ] [ 1 ] != none : <NEWLINE> <INDENT> p = tree [ p ] [ 1 ] <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def delete ( x ) : <NEWLINE> <INDENT> p , parent = search ( 0 , x ) <NEWLINE> if tree [ p ] [ 1 : 3 ] == [ None , None ] : <NEWLINE> <INDENT> deletenode ( p , parent ) <NEWLINE> <DEDENT> elif tree [ p ] [ 1 ] == None : <NEWLINE> <INDENT> deletenode ( p , parent , tree [ p ] [ 2 ] ) <NEWLINE> <DEDENT> elif tree [ p ] [ 2 ] == None : <NEWLINE> <INDENT> deletenode ( p , parent , tree [ p ] [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p1 = searchmin ( tree [ p ] [ 2 ] ) <NEWLINE> if tree [ parent ] [ 1 ] == p : <NEWLINE> <INDENT> tree [ parent ] [ 1 ] = p1 <NEWLINE> <DEDENT> elif tree [ parent ] [ 2 ] == p : <NEWLINE> <INDENT> tree [ parent ] [ 2 ] = p1 <NEWLINE> <DEDENT> tree [ p1 ] [ 1 ] = tree [ p ] [ 1 ] <NEWLINE> tree [ p1 ] [ 2 ] = tree [ p ] [ 2 ] <NEWLINE> del tree [ p ] <NEWLINE> <DEDENT> return <NEWLINE> <NL> <DEDENT> def preorder ( p ) : <NEWLINE> <INDENT> if p == None : return [ ] <NEWLINE> p1 , p2 = tree [ p ] [ 1 : 3 ] <NEWLINE> return [ tree [ p ] [ 0 ] ] + preorder ( p1 ) + preorder ( p2 ) <NEWLINE> <NL> <DEDENT> def inorder ( p ) : <NEWLINE> <INDENT> if p == None : return [ ] <NEWLINE> p1 , p2 = tree [ p ] [ 1 : 3 ] <NEWLINE> return inorder ( p1 ) + [ tree [ p ] [ 0 ] ] + inorder ( p2 ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> i = 0 <NEWLINE> while i < n : <NEWLINE> <INDENT> s = raw_input ( ) <NEWLINE> if s [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( 0 , int ( s [ 7 : ] ) ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> if search ( 0 , int ( s [ 5 : ] ) ) [ 0 ] != None : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> delete ( int ( s [ 7 : ] ) ) <NEWLINE> <DEDENT> elif s [ 0 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> + <STRING> . join ( map ( str , inorder ( home ) ) ) <NEWLINE> print <STRING> + <STRING> . join ( map ( str , preorder ( home ) ) ) <NEWLINE> <DEDENT> i += 1 <NEWLINE> <DEDENT>
def insert ( tree , k ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = tree <NEWLINE> z = { <STRING> : k , <STRING> : None , <STRING> : None , <STRING> : None } <NEWLINE> while x != None : <NEWLINE> <INDENT> y = x <NEWLINE> if x [ <STRING> ] > k : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> z [ <STRING> ] = y <NEWLINE> if y == None : <NEWLINE> <INDENT> tree = z <NEWLINE> <DEDENT> elif y [ <STRING> ] > k : <NEWLINE> <INDENT> y [ <STRING> ] = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y [ <STRING> ] = z <NEWLINE> <DEDENT> return tree <NEWLINE> <NL> <DEDENT> def delete_leaf ( p , x ) : <NEWLINE> <INDENT> if left ( p , x ) : <NEWLINE> <INDENT> p [ <STRING> ] = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ <STRING> ] = None <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def delete_half_leaf ( p , x , y ) : <NEWLINE> <INDENT> if left ( p , x ) : <NEWLINE> <INDENT> p [ <STRING> ] = y <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p [ <STRING> ] = y <NEWLINE> <DEDENT> y [ <STRING> ] = p <NEWLINE> return p <NEWLINE> <NL> <NL> <DEDENT> def left ( p , x ) : <NEWLINE> <INDENT> if p [ <STRING> ] != None and p [ <STRING> ] [ <STRING> ] == x [ <STRING> ] : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def delete_internal ( p , x ) : <NEWLINE> <INDENT> y = x [ <STRING> ] <NEWLINE> while y [ <STRING> ] != None : <NEWLINE> <INDENT> y = y [ <STRING> ] <NEWLINE> <DEDENT> x [ <STRING> ] = y [ <STRING> ] <NEWLINE> if y [ <STRING> ] == None : <NEWLINE> <INDENT> tree = delete_leaf ( tree , y [ <STRING> ] , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tree = delete_half_leaf ( tree , y [ <STRING> ] , y , y [ <STRING> ] ) <NEWLINE> <DEDENT> return p <NEWLINE> <NL> <DEDENT> def delete ( tree , k ) : <NEWLINE> <INDENT> x = find ( tree , k ) <NEWLINE> if x == None : return <NEWLINE> p = x [ <STRING> ] <NEWLINE> if p == None : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if x [ <STRING> ] == x [ <STRING> ] == None : <NEWLINE> <INDENT> p = delete_leaf ( p , x ) <NEWLINE> <DEDENT> elif x [ <STRING> ] == None : <NEWLINE> <INDENT> p = delete_half_leaf ( p , x , x [ <STRING> ] ) <NEWLINE> <DEDENT> elif x [ <STRING> ] == None : <NEWLINE> <INDENT> p = delete_half_leaf ( p , x , x [ <STRING> ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = delete_internal ( p , x ) <NEWLINE> <DEDENT> <DEDENT> return tree <NEWLINE> <NL> <DEDENT> def find ( tree , k ) : <NEWLINE> <INDENT> x = tree <NEWLINE> while x != None : <NEWLINE> <INDENT> if x [ <STRING> ] == k : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> elif x [ <STRING> ] > k : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x [ <STRING> ] <NEWLINE> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <DEDENT> def middleorder ( x ) : <NEWLINE> <INDENT> if x != None : <NEWLINE> <INDENT> middleorder ( x [ <STRING> ] ) <NEWLINE> print x [ <STRING> ] , <NEWLINE> middleorder ( x [ <STRING> ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def preorder ( x ) : <NEWLINE> <INDENT> if x != None : <NEWLINE> <INDENT> print x [ <STRING> ] , <NEWLINE> preorder ( x [ <STRING> ] ) <NEWLINE> preorder ( x [ <STRING> ] ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> tree = None <NEWLINE> m = int ( raw_input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> c = raw_input ( ) . strip ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree = insert ( tree , int ( c [ 7 : ] ) ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> x = find ( tree , int ( c [ 5 : ] ) ) <NEWLINE> if x == None : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> tree = delete ( tree , int ( c [ 7 : ] ) ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print <STRING> , <NEWLINE> middleorder ( tree ) <NEWLINE> print <NEWLINE> print <STRING> , <NEWLINE> preorder ( tree ) <NEWLINE> print <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> class Node : <NEWLINE> <INDENT> def __init__ ( self , key , priority , left = None , right = None ) : <NEWLINE> <INDENT> self . key = key <NEWLINE> self . priority = priority <NEWLINE> self . left = left <NEWLINE> self . right = right <NEWLINE> <NL> <DEDENT> <DEDENT> def rightRotate ( t ) : <NEWLINE> <INDENT> s = t . left <NEWLINE> t . left = s . right <NEWLINE> s . right = t <NEWLINE> return s <NEWLINE> <NL> <DEDENT> def leftRotate ( t ) : <NEWLINE> <INDENT> s = t . right <NEWLINE> t . right = s . left <NEWLINE> s . left = t <NEWLINE> return s <NEWLINE> <NL> <DEDENT> def insert ( t , key , priority ) : <NEWLINE> <NL> <INDENT> if not t : return Node ( key , priority ) <NEWLINE> if key == t . key : return t <NEWLINE> <NL> if key < t . key : <NEWLINE> <INDENT> t . left = insert ( t . left , key , priority ) <NEWLINE> if t . priority < t . left . priority : <NEWLINE> <INDENT> t = rightRotate ( t ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t . right = insert ( t . right , key , priority ) <NEWLINE> if t . priority < t . right . priority : <NEWLINE> <INDENT> t = leftRotate ( t ) <NEWLINE> <NL> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <DEDENT> def erase ( t , key ) : <NEWLINE> <NL> <INDENT> if not t : return None <NEWLINE> <NL> if key == t . key : <NEWLINE> <INDENT> if ( not t . left ) and ( not t . right ) : return None <NEWLINE> elif not t . left : <NEWLINE> <INDENT> t = leftRotate ( t ) <NEWLINE> <DEDENT> elif not t . right : <NEWLINE> <INDENT> t = rightRotate ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t . left . priority > t . right . priority : <NEWLINE> <INDENT> t = rightRotate ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = leftRotate ( t ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return erase ( t , key ) <NEWLINE> <NL> <NL> <DEDENT> def find ( t , key ) : <NEWLINE> <INDENT> if t . key == key : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif t . key < key and t . right != None : <NEWLINE> <INDENT> find ( t . right , key ) <NEWLINE> <DEDENT> elif t . key > key and t . left != None : <NEWLINE> <INDENT> find ( t . left , key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def in_print ( t ) : <NEWLINE> <INDENT> if t . left != None : <NEWLINE> <INDENT> in_print ( t . left ) <NEWLINE> <DEDENT> print ( <STRING> + str ( t ) , end = <STRING> ) <NEWLINE> if t . right != None : <NEWLINE> <INDENT> in_print ( t . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> def pre_print ( t ) : <NEWLINE> <INDENT> print ( <STRING> + str ( t ) , end = <STRING> ) <NEWLINE> if t . left != None : <NEWLINE> <INDENT> pre_print ( t . left ) <NEWLINE> <DEDENT> if t . right != None : <NEWLINE> <INDENT> pre_print ( t . right ) <NEWLINE> <NL> <DEDENT> <DEDENT> Treap = None <NEWLINE> num = int ( input ( ) ) <NEWLINE> for i in range ( num ) : <NEWLINE> <INDENT> string = list ( input ( ) . split ( ) ) <NEWLINE> if string [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( string [ 1 ] ) <NEWLINE> priority = int ( string [ 2 ] ) <NEWLINE> Treap = insert ( Treap , key , priority ) <NEWLINE> <DEDENT> elif string [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( string [ 1 ] ) <NEWLINE> find ( Treap , key ) <NEWLINE> <DEDENT> elif string [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( string [ 1 ] ) <NEWLINE> Treap = erase ( Treap , key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> in_print ( Treap ) <NEWLINE> print ( ) <NEWLINE> pre_print ( Treap ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , k , p ) : <NEWLINE> <INDENT> self . k = k <NEWLINE> self . p = p <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <DEDENT> <DEDENT> def rightRotate ( t ) : <NEWLINE> <INDENT> s = t . left <NEWLINE> t . left = s . right <NEWLINE> s . right = t <NEWLINE> return s <NEWLINE> <NL> <DEDENT> def leftRotate ( t ) : <NEWLINE> <INDENT> s = t . right <NEWLINE> t . right = s . left <NEWLINE> s . left = t <NEWLINE> return s <NEWLINE> <NL> <DEDENT> def insert ( t , key , pri ) : <NEWLINE> <INDENT> if t == None : <NEWLINE> <INDENT> return Node ( key , pri ) <NEWLINE> <DEDENT> if key == t . k : <NEWLINE> <INDENT> return t <NEWLINE> <NL> <DEDENT> if key < t . k : <NEWLINE> <INDENT> t . left = insert ( t . left , key , pri ) <NEWLINE> if t . p < t . left . p : <NEWLINE> <INDENT> t = rightRotate ( t ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t . right = insert ( t . right , key , pri ) <NEWLINE> if t . p < t . right . p : <NEWLINE> <INDENT> t = leftRotate ( t ) <NEWLINE> <DEDENT> <DEDENT> return t <NEWLINE> <NL> <DEDENT> def erase ( t , key ) : <NEWLINE> <INDENT> if t == None : <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> if key == t . k : <NEWLINE> <INDENT> if t . left == None and t . right == None : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif t . left == None : <NEWLINE> <INDENT> t = leftRotate ( t ) <NEWLINE> <DEDENT> elif t . right == None : <NEWLINE> <INDENT> t = rightRotate ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if t . left . p > t . right . p : <NEWLINE> <INDENT> t = rightRotate ( t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t = leftRotate ( t ) <NEWLINE> <DEDENT> <DEDENT> return erase ( t , key ) <NEWLINE> <NL> <DEDENT> if key < t . k : <NEWLINE> <INDENT> t . left = erase ( t . left , key ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> t . right = erase ( t . right , key ) <NEWLINE> <DEDENT> return t <NEWLINE> <DEDENT> <STRING> <NEWLINE> def inorder ( t ) : <NEWLINE> <INDENT> if t == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> inorder ( t . left ) <NEWLINE> print ( <STRING> + str ( t . k ) , end = <STRING> ) <NEWLINE> inorder ( t . right ) <NEWLINE> <NL> <DEDENT> def preorder ( t ) : <NEWLINE> <INDENT> if t == None : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> print ( <STRING> + str ( t . k ) , end = <STRING> ) <NEWLINE> preorder ( t . left ) <NEWLINE> preorder ( t . right ) <NEWLINE> <NL> <DEDENT> def output ( t ) : <NEWLINE> <INDENT> inorder ( t ) <NEWLINE> print ( ) <NEWLINE> preorder ( t ) <NEWLINE> print ( ) <NEWLINE> <NL> <NL> <DEDENT> t = None <NEWLINE> data = [ ] <NEWLINE> dict = { } <NEWLINE> m = int ( input ( ) ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> data . append ( list ( input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> if data [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> if ( data [ i ] [ 1 ] in dict ) == False : <NEWLINE> <INDENT> t = insert ( t , int ( data [ i ] [ 1 ] ) , int ( data [ i ] [ 2 ] ) ) <NEWLINE> dict [ data [ i ] [ 1 ] ] = True <NEWLINE> <DEDENT> <DEDENT> elif data [ i ] [ 0 ] == <STRING> : <NEWLINE> <INDENT> output ( t ) <NEWLINE> <DEDENT> elif data [ i ] [ 0 ] == <STRING> : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if ( data [ i ] [ 1 ] in dict ) == True : <NEWLINE> <COMMENT> <NL> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t = erase ( t , int ( data [ i ] [ 1 ] ) ) <NEWLINE> del dict [ data [ i ] [ 1 ] ] <NEWLINE> <DEDENT> <DEDENT>
n = int ( raw_input ( ) ) <NEWLINE> heap = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> for i in range ( len ( heap ) ) : <NEWLINE> <INDENT> j = i + 1 <NEWLINE> nid = j <NEWLINE> key = heap [ j - 1 ] <NEWLINE> pid = j / 2 - 1 <NEWLINE> if pid >= 0 : <NEWLINE> <INDENT> p = heap [ pid ] <NEWLINE> <DEDENT> lid = j * 2 - 1 <NEWLINE> rid = j * 2 <NEWLINE> if lid < len ( heap ) : <NEWLINE> <INDENT> l = heap [ j * 2 - 1 ] <NEWLINE> <DEDENT> if rid < len ( heap ) : <NEWLINE> <INDENT> r = heap [ j * 2 ] <NEWLINE> <DEDENT> print <STRING> % nid , <NEWLINE> print <STRING> % key , <NEWLINE> if pid >= 0 : <NEWLINE> <INDENT> print <STRING> % p , <NEWLINE> <DEDENT> if lid < len ( heap ) : <NEWLINE> <INDENT> print <STRING> % l , <NEWLINE> <DEDENT> if rid < len ( heap ) : <NEWLINE> <INDENT> print <STRING> % r , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> H = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> for i in range ( H ) : <NEWLINE> <INDENT> parent_key = <STRING> <NEWLINE> left_key = <STRING> <NEWLINE> right_key = <STRING> <NEWLINE> ans = <STRING> <NEWLINE> if i == 0 : <NEWLINE> <INDENT> if 2 * ( i + 1 ) - 1 < H : <NEWLINE> <INDENT> left_key = <STRING> + str ( A [ 2 * ( i + 1 ) - 1 ] ) + <STRING> <NEWLINE> <DEDENT> if 2 * ( i + 1 ) < H : <NEWLINE> <INDENT> right_key = <STRING> + str ( A [ 2 * ( i + 1 ) ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> parent_key = <STRING> + str ( A [ ( i + 1 ) / 2 - 1 ] ) + <STRING> <NEWLINE> if 2 * ( i + 1 ) - 1 < H : <NEWLINE> <INDENT> left_key = <STRING> + str ( A [ 2 * ( i + 1 ) - 1 ] ) + <STRING> <NEWLINE> <DEDENT> if 2 * ( i + 1 ) < H : <NEWLINE> <INDENT> right_key = <STRING> + str ( A [ 2 * ( i + 1 ) ] ) + <STRING> <NEWLINE> <DEDENT> <DEDENT> ans = <STRING> + str ( i + 1 ) + <STRING> + str ( A [ i ] ) + <STRING> + parent_key + left_key + right_key <NEWLINE> print ans . strip ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> n = int ( raw_input ( ) ) <NEWLINE> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> A . append ( l [ i ] ) <NEWLINE> <DEDENT> print <STRING> % ( 1 , A [ 1 ] , A [ 2 * 1 ] , A [ 2 * 1 + 1 ] ) <NEWLINE> for i in range ( 2 , int ( n / 2 + 1 ) ) : <NEWLINE> <INDENT> print <STRING> % ( i , A [ i ] , A [ int ( i / 2 ) ] , A [ 2 * i ] , A [ 2 * i + 1 ] ) <NEWLINE> <DEDENT> for i in range ( int ( n / 2 + 1 ) , n + 1 ) : <NEWLINE> <INDENT> print <STRING> % ( i , A [ i ] , A [ int ( i / 2 ) ] ) <NEWLINE> <DEDENT>
def parent ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) / 2 - 1 <NEWLINE> <NL> <DEDENT> def left ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) * 2 - 1 <NEWLINE> <NL> <DEDENT> def right ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) * 2 <NEWLINE> <NL> <DEDENT> heap = [ ] <NEWLINE> <NL> H = int ( raw_input ( ) ) <NEWLINE> keys = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> i = 0 <NEWLINE> for k in keys : <NEWLINE> <INDENT> p = parent ( i ) <NEWLINE> l = left ( i ) <NEWLINE> r = right ( i ) <NEWLINE> print <STRING> % ( i + 1 , k ) , <NEWLINE> if p >= 0 : print <STRING> % keys [ p ] , <NEWLINE> if l < len ( keys ) : print <STRING> % keys [ l ] , <NEWLINE> if r < len ( keys ) : print <STRING> % keys [ r ] , <NEWLINE> print <NEWLINE> i += 1 <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> keys = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> heap = [ ] <NEWLINE> for i , x in enumerate ( heap_keys ) : <NEWLINE> <INDENT> node = i + 1 <NEWLINE> key = x <NEWLINE> parent_key = heap_keys [ int ( node / 2 ) - 1 ] if i > 0 else None <NEWLINE> left_key = heap_keys [ 2 * node - 1 ] if 2 * node - 1 < len ( heap_keys ) else None <NEWLINE> right_key = heap_keys [ 2 * node ] if 2 * node < len ( heap_keys ) else None <NEWLINE> heap . append ( { <STRING> : node , <STRING> : x , <STRING> : parent_key , <STRING> : left_key , <STRING> : right_key } ) <NEWLINE> <NL> <DEDENT> for h in heap : <NEWLINE> <INDENT> out_str = <STRING> % ( h [ <STRING> ] , h [ <STRING> ] ) <NEWLINE> if h [ <STRING> ] : out_str += <STRING> % h [ <STRING> ] <NEWLINE> if h [ <STRING> ] : out_str += <STRING> % h [ <STRING> ] <NEWLINE> if h [ <STRING> ] : out_str += <STRING> % h [ <STRING> ] <NEWLINE> print ( out_str ) <NEWLINE> <DEDENT>
def parent ( i ) : <NEWLINE> <INDENT> return int ( i / 2 ) <NEWLINE> <NL> <DEDENT> def left ( i ) : <NEWLINE> <INDENT> return 2 * i <NEWLINE> <NL> <DEDENT> def right ( i ) : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for i in xrange ( 1 , H + 1 ) : <NEWLINE> <INDENT> print <STRING> . format ( i , A [ i - 1 ] ) , <NEWLINE> if parent ( i ) >= 1 : <NEWLINE> <INDENT> print <STRING> . format ( A [ parent ( i ) - 1 ] ) , <NEWLINE> <DEDENT> if left ( i ) <= H : <NEWLINE> <INDENT> print <STRING> . format ( A [ left ( i ) - 1 ] ) , <NEWLINE> <DEDENT> if right ( i ) <= H : <NEWLINE> <INDENT> print <STRING> . format ( A [ right ( i ) - 1 ] ) , <NEWLINE> <DEDENT> print <STRING> <NEWLINE> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> main ( ) <NEWLINE> <NL> <NL>
import sys <NEWLINE> <NL> def fun ( arr ) : <NEWLINE> <INDENT> sz = 1 <NEWLINE> while sz < len ( arr ) : sz *= 2 <NEWLINE> <NL> for idx , val in enumerate ( arr ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> + str ( idx + 1 ) + <STRING> + str ( val ) + <STRING> ) <NEWLINE> if idx > 0 : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> + str ( arr [ ( idx - 1 ) // 2 ] ) + <STRING> ) <NEWLINE> <DEDENT> if idx * 2 + 1 < len ( arr ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> + str ( arr [ idx * 2 + 1 ] ) + <STRING> ) <NEWLINE> <DEDENT> if idx * 2 + 2 < len ( arr ) : <NEWLINE> <INDENT> sys . stdout . write ( <STRING> + str ( arr [ idx * 2 + 2 ] ) + <STRING> ) <NEWLINE> <DEDENT> sys . stdout . write ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = sys . stdin . readline ( ) <NEWLINE> n = int ( n ) <NEWLINE> arr = sys . stdin . readline ( ) <NEWLINE> arr = map ( lambda x : int ( x ) , arr . split ( ) ) <NEWLINE> fun ( arr ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> list = [ ] <NEWLINE> list . append ( <STRING> ) <NEWLINE> <NL> def parent ( i ) : <NEWLINE> <INDENT> return i // 2 <NEWLINE> <NL> <DEDENT> def left ( i ) : <NEWLINE> <INDENT> return i * 2 <NEWLINE> <NL> <DEDENT> def right ( i ) : <NEWLINE> <INDENT> return i * 2 + 1 <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> H = int ( input ( ) ) <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> list . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( H ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> print ( <STRING> + str ( i ) + <STRING> + str ( list [ i ] ) + <STRING> , end = <STRING> ) <NEWLINE> if ( parent ( i ) ) : <NEWLINE> <INDENT> print ( <STRING> + str ( list [ parent ( i ) ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if ( left ( i ) <= H ) : <NEWLINE> <INDENT> print ( <STRING> + str ( list [ left ( i ) ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> if ( right ( i ) <= H ) : <NEWLINE> <INDENT> print ( <STRING> + str ( list [ right ( i ) ] ) + <STRING> , end = <STRING> ) <NEWLINE> <DEDENT> print ( ) <NEWLINE> <NL> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <NL> def maxHeapify ( heap , i ) : <NEWLINE> <INDENT> left = ( i + 1 ) * 2 - 1 <NEWLINE> right = ( i + 1 ) * 2 <NEWLINE> largest = left if heap [ left ] > heap [ i ] and left < len ( heap ) else i <NEWLINE> largest = right if heap [ right ] > heap [ largest ] and right < len ( heap ) else largest <NEWLINE> if largest != i : <NEWLINE> <INDENT> heap [ i ] , heap [ largest ] = heap [ largest ] , heap [ i ] <NEWLINE> maxHeapify ( heap , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( heap ) : <NEWLINE> <INDENT> for i in range ( len ( heap ) // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( heap , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> heap = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> buildMaxHeap ( heap ) <NEWLINE> print ( <STRING> , * heap ) <NEWLINE> <NL> <STRING> <NEWLINE>
input ( ) <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> H = len ( A ) <NEWLINE> def h ( i ) : <NEWLINE> <INDENT> l = 2 * i ; r , g = l + 1 , [ i , l ] [ A [ i ] < A [ l ] and l < H ] <NEWLINE> if A [ g ] < A [ r ] and r < H : g = r <NEWLINE> if g != i : A [ i ] , A [ g ] = A [ g ] , A [ i ] ; h ( g ) <NEWLINE> <DEDENT> for i in range ( H // 2 , 0 , - 1 ) : h ( i ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , A [ 1 : ] ) ) ) <NEWLINE>
def maxHeapify ( heap , i ) : <NEWLINE> <INDENT> left = ( i + 1 ) * 2 - 1 <NEWLINE> right = ( i + 1 ) * 2 <NEWLINE> largest = left if heap [ left ] > heap [ i ] and left < len ( heap ) else i <NEWLINE> largest = right if heap [ right ] > heap [ largest ] and right < len ( heap ) else largest <NEWLINE> if largest != i : <NEWLINE> <INDENT> heap [ i ] , heap [ largest ] = heap [ largest ] , heap [ i ] <NEWLINE> maxHeapify ( heap , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( heap ) : <NEWLINE> <INDENT> for i in range ( len ( heap ) // 2 , - 1 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( heap , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> heap = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> buildMaxHeap ( heap ) <NEWLINE> print ( <STRING> , * heap ) <NEWLINE> <STRING> <NEWLINE>
H = int ( input ( ) ) + 1 <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def h ( i ) : <NEWLINE> <INDENT> l = 2 * i ; r = l + 1 <NEWLINE> if r < H & & l < H : <NEWLINE> <INDENT> if A [ i ] < A [ l ] : <NEWLINE> <INDENT> if A [ l ] < A [ r ] : A [ i ] , A [ r ] = A [ r ] , A [ i ] ; h ( r ) <NEWLINE> else : A [ i ] , A [ l ] = A [ l ] , A [ i ] ; h ( l ) <NEWLINE> <DEDENT> elif A [ i ] < A [ r ] : A [ i ] , A [ r ] = A [ r ] , A [ i ] ; h ( r ) <NEWLINE> <DEDENT> elif l < H and A [ i ] < A [ l ] : A [ i ] , A [ l ] = A [ l ] , A [ i ] ; h ( l ) <NEWLINE> <DEDENT> for i in range ( H // 2 , 0 , - 1 ) : h ( i ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , A [ 1 : ] ) ) ) <NEWLINE>
<COMMENT> <NL> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> <NL> if l <= H and A [ l ] > A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <NL> <DEDENT> if r <= H and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def buildMaxHeap ( A ) : <NEWLINE> <INDENT> for i in range ( H / 2 , 0 , - 1 ) : <NEWLINE> <INDENT> maxHeapify ( A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> H = int ( raw_input ( ) ) <NEWLINE> A = map ( int , [ 0 ] + raw_input ( ) . split ( ) ) <NEWLINE> buildMaxHeap ( A ) <NEWLINE> print <STRING> . join ( map ( str , A [ 1 : ] ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> def max_heapify ( ary , nary , i ) : <NEWLINE> <INDENT> left = i * 2 <NEWLINE> right = left + 1 <NEWLINE> if left <= nary and ary [ left ] > ary [ i ] : <NEWLINE> <INDENT> largest = left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if right <= nary and ary [ right ] > ary [ largest ] : <NEWLINE> <INDENT> largest = right <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> tmp = ary [ i ] <NEWLINE> ary [ i ] = ary [ largest ] <NEWLINE> ary [ largest ] = tmp <NEWLINE> max_heapify ( ary , nary , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def build_max_heap ( ary , nary ) : <NEWLINE> <INDENT> for i in reversed ( range ( 1 , nary / 2 + 1 ) ) : <NEWLINE> <INDENT> max_heapify ( ary , nary , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> _nary = int ( sys . stdin . readline ( ) ) <NEWLINE> _ary = [ int ( x ) for x in sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> assert _nary == len ( _ary ) <NEWLINE> _ary . insert ( 0 , - 1 ) <NEWLINE> <NL> build_max_heap ( _ary , _nary ) <NEWLINE> _ary . pop ( 0 ) <NEWLINE> for x in _ary : <NEWLINE> <INDENT> print <STRING> % ( x ) , <NEWLINE> <DEDENT> print <NEWLINE>
n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> <NL> def maxheapify ( a , i ) : <NEWLINE> <INDENT> l = i * 2 + 1 <NEWLINE> r = i * 2 + 2 <NEWLINE> <NL> if l <= n and a [ l ] > a [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= n and a [ r ] > a [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> memo = a [ i ] <NEWLINE> a [ i ] = a [ largest ] <NEWLINE> a [ largest ] = memo <NEWLINE> maxheapify ( a , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> h = ( n - 1 ) // 2 <NEWLINE> for i in reversed ( range ( h ) ) : <NEWLINE> <INDENT> maxheapify ( a , i ) <NEWLINE> <NL> <DEDENT> print ( <STRING> , * a ) <NEWLINE> <NL>
def parent ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) / 2 - 1 <NEWLINE> <NL> <DEDENT> def left ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) * 2 - 1 <NEWLINE> <NL> <DEDENT> def right ( n ) : <NEWLINE> <INDENT> return ( n + 1 ) * 2 <NEWLINE> <NL> <DEDENT> def max_heapify ( A , i ) : <NEWLINE> <INDENT> l = left ( i ) <NEWLINE> r = right ( i ) <NEWLINE> largest = i <NEWLINE> if l < len ( A ) and A [ largest ] < A [ l ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> if r < len ( A ) and A [ largest ] < A [ r ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ largest ] , A [ i ] = A [ i ] , A [ largest ] <NEWLINE> max_heapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def build_max_heap ( A ) : <NEWLINE> <INDENT> for i in reversed ( range ( ( len ( A ) - 1 ) / 2 + 1 ) ) : <NEWLINE> <INDENT> max_heapify ( A , i ) <NEWLINE> <NL> <DEDENT> <DEDENT> H = int ( raw_input ( ) ) <NEWLINE> A = map ( int , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> build_max_heap ( A ) <NEWLINE> print <STRING> . join ( map ( str , A ) ) <NEWLINE>
import sys <NEWLINE> <NL> def get_left ( i ) : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> def get_right ( i ) : <NEWLINE> <INDENT> return 2 * i + 2 <NEWLINE> <NL> <DEDENT> def get_parent ( i ) : <NEWLINE> <INDENT> return int ( ( i - 1 ) / 2 ) <NEWLINE> <NL> <DEDENT> def make_heap_tree ( array , i , item_num ) : <NEWLINE> <INDENT> left = get_left ( i ) <NEWLINE> right = get_right ( i ) <NEWLINE> largest = i <NEWLINE> if ( left < item_num ) and ( array [ left ] > array [ largest ] ) : <NEWLINE> <INDENT> largest = left <NEWLINE> <DEDENT> if ( right < item_num ) and ( array [ right ] > array [ largest ] ) : <NEWLINE> <INDENT> largest = right <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> tmp = array [ i ] <NEWLINE> array [ i ] = array [ largest ] <NEWLINE> array [ largest ] = tmp <NEWLINE> make_heap_tree ( array , largest , item_num ) <NEWLINE> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> size = int ( sys . stdin . readline ( ) . strip ( ) ) <NEWLINE> array = map ( lambda x : int ( x ) , sys . stdin . readline ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> for i in reversed ( range ( 0 , get_parent ( size ) ) ) : <NEWLINE> <INDENT> make_heap_tree ( array , i , size ) <NEWLINE> <DEDENT> print <STRING> . join ( map ( lambda x : str ( x ) , array ) ) . strip ( ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
def upheap ( a , i ) : <NEWLINE> <INDENT> if i == 0 : return <NEWLINE> while i > 0 : <NEWLINE> <INDENT> p = ( i + 1 ) / 2 - 1 <NEWLINE> if a [ p ] < a [ i ] : <NEWLINE> <INDENT> a [ p ] , a [ i ] = a [ i ] , a [ p ] <NEWLINE> <DEDENT> i = p <NEWLINE> <NL> <DEDENT> <DEDENT> def heapify ( a , i ) : <NEWLINE> <INDENT> lid = ( i + 1 ) * 2 - 1 <NEWLINE> rid = ( i + 1 ) * 2 <NEWLINE> maxc = - 1 <NEWLINE> if lid < len ( a ) : <NEWLINE> <INDENT> maxc = lid <NEWLINE> <DEDENT> if rid < len ( a ) : <NEWLINE> <INDENT> if a [ maxc ] < a [ rid ] : <NEWLINE> <INDENT> maxc = rid <NEWLINE> <DEDENT> <DEDENT> if maxc != - 1 : <NEWLINE> <INDENT> if a [ i ] < a [ maxc ] : <NEWLINE> <INDENT> a [ i ] , a [ maxc ] = a [ maxc ] , a [ i ] <NEWLINE> heapify ( a , maxc ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def build_heap ( a ) : <NEWLINE> <INDENT> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> j = len ( a ) - 1 - i <COMMENT> <NEWLINE> heapify ( a , j ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> a = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> build_heap ( a ) <NEWLINE> print <STRING> . join ( map ( str , a ) ) <NEWLINE>
H = int ( input ( ) ) + 1 <NEWLINE> A = [ 0 ] + list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> def h ( i ) : <NEWLINE> <INDENT> l = 2 * i ; r = l + 1 <NEWLINE> g = i <NEWLINE> if r < H and A [ g ] < A [ r ] : g = l if A [ i ] < A [ l ] else r <NEWLINE> else : if l < H and A [ i ] < A [ l ] : g = l <NEWLINE> if g > i : A [ i ] , A [ g ] = A [ g ] , A [ i ] ; h ( g ) <NEWLINE> <DEDENT> for i in range ( H // 2 , 0 , - 1 ) : h ( i ) <NEWLINE> print ( <STRING> + <STRING> . join ( map ( str , A [ 1 : ] ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> def parent ( i ) : <NEWLINE> <INDENT> return ( i + 1 ) / 2 - 1 <NEWLINE> <NL> <DEDENT> def left ( i ) : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> def right ( i ) : <NEWLINE> <INDENT> return 2 * i + 2 <NEWLINE> <NL> <DEDENT> def sibling ( i ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> return i - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( S , k ) : <NEWLINE> <INDENT> S . append ( k ) <NEWLINE> idx = len ( S ) - 1 <NEWLINE> while True : <NEWLINE> <INDENT> p = parent ( idx ) <NEWLINE> if p < 0 or S [ idx ] <= S [ p ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ idx ] , S [ p ] = S [ p ] , S [ idx ] <NEWLINE> idx = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def maxHeapify ( A , i ) : <NEWLINE> <INDENT> l = 2 * i + 1 <NEWLINE> r = 2 * i + 2 <NEWLINE> <NL> if l < len ( A ) and A [ l ] > A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <NL> <DEDENT> if r < len ( A ) and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> def extract ( S ) : <NEWLINE> <INDENT> print S [ 0 ] <NEWLINE> S [ 0 ] = S [ - 1 ] <NEWLINE> S . pop ( ) <NEWLINE> maxHeapify ( S , 0 ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> lines . pop ( ) <NEWLINE> <NL> S = [ ] <NEWLINE> for line in lines : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( S , int ( line [ 7 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> extract ( S ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def parent ( i ) : <NEWLINE> <INDENT> return ( i + 1 ) / 2 - 1 <NEWLINE> <NL> <DEDENT> def left ( i ) : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> def right ( i ) : <NEWLINE> <INDENT> return 2 * i + 2 <NEWLINE> <NL> <DEDENT> def sibling ( i ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> return i - 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return i + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def insert ( S , k ) : <NEWLINE> <INDENT> S . append ( k ) <NEWLINE> idx = len ( S ) - 1 <NEWLINE> while True : <NEWLINE> <INDENT> p = parent ( idx ) <NEWLINE> if p < 0 or S [ idx ] <= S [ p ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ idx ] , S [ p ] = S [ p ] , S [ idx ] <NEWLINE> idx = p <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def extract ( S ) : <NEWLINE> <INDENT> print S [ 0 ] <NEWLINE> S [ 0 ] = S [ - 1 ] <NEWLINE> S . pop ( ) <NEWLINE> size = len ( S ) <NEWLINE> <NL> idx = 0 <NEWLINE> while True : <NEWLINE> <INDENT> l , r = left ( idx ) , right ( idx ) <NEWLINE> if l < size and S [ idx ] < S [ l ] and ( r < size and S [ r ] <= S [ l ] or r >= size : <NEWLINE> <INDENT> S [ idx ] , S [ l ] = S [ l ] , S [ idx ] <NEWLINE> idx = l <NEWLINE> <DEDENT> elif r < size and S [ idx ] < S [ r ] : <NEWLINE> <INDENT> S [ idx ] , S [ r ] = S [ r ] , S [ idx ] <NEWLINE> idx = r <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> lines . pop ( ) <NEWLINE> <NL> S = [ ] <NEWLINE> for line in lines : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( S , int ( line [ 7 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> extract ( S ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> s = set ( ) <NEWLINE> while True : <NEWLINE> <INDENT> cmd = input ( ) . split ( ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> l . add ( int ( cmd [ 1 ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( max ( s ) ) <NEWLINE> l . remove ( max ( s ) ) <NEWLINE> <DEDENT> <DEDENT>
def max_heapify ( A , i ) : <NEWLINE> <INDENT> l = i * 2 <NEWLINE> r = i * 2 + 1 <NEWLINE> largest = i <NEWLINE> if l <= A [ 0 ] and A [ i ] < A [ l ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= A [ 0 ] and A [ largest ] < A [ r ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ largest ] , A [ i ] = A [ i ] , A [ largest ] <NEWLINE> max_heapify ( A , largest ) <NEWLINE> <NL> <DEDENT> <DEDENT> heap = [ 0 ] * 2000000 <NEWLINE> while True : <NEWLINE> <INDENT> c = raw_input ( ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> heap [ 0 ] += 1 <NEWLINE> heap [ heap [ 0 ] ] = int ( c [ 7 : ] ) <NEWLINE> i = heap [ 0 ] <NEWLINE> p = i / 2 <NEWLINE> while p > 0 and heap [ p ] < heap [ i ] : <NEWLINE> <INDENT> heap [ p ] , heap [ i ] = heap [ i ] , heap [ p ] <NEWLINE> i = p <NEWLINE> p = i / 2 <NEWLINE> <DEDENT> <DEDENT> elif c [ 1 ] == <STRING> : <NEWLINE> <INDENT> print heap [ 1 ] <NEWLINE> heap [ 1 ] = heap [ heap [ 0 ] ] <NEWLINE> heap [ 0 ] -= 1 <NEWLINE> max_heapify ( heap , 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def insert ( heap , key ) : <NEWLINE> <INDENT> heap . append ( - 1000000 ) <NEWLINE> heapIncreaseKey ( heap , key ) <NEWLINE> <NL> <DEDENT> def parent ( i ) : <NEWLINE> <INDENT> return ( i - 1 ) // 2 <NEWLINE> <NL> <DEDENT> def heapIncreaseKey ( heap , key ) : <NEWLINE> <INDENT> heap [ len ( heap ) - 1 ] = key <NEWLINE> i = len ( heap ) - 1 <NEWLINE> while i > 0 and heap [ parent ( i ) ] < heap [ i ] : <NEWLINE> <INDENT> heap [ i ] , heap [ parent ( i ) ] = heap [ parent ( i ) ] , heap [ i ] <NEWLINE> i = parent ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> def heapExtractMax ( heap ) : <NEWLINE> <INDENT> if len ( heap ) < 1 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> MAX = heap [ 0 ] <NEWLINE> heap [ 0 ] = heap . pop ( ) <NEWLINE> maxHeapify ( heap , 0 ) <NEWLINE> <NL> return MAX <NEWLINE> <NL> <DEDENT> <DEDENT> def maxHeapify ( heap , i ) : <NEWLINE> <INDENT> left = ( i + 1 ) * 2 - 1 <NEWLINE> right = ( i + 1 ) * 2 <NEWLINE> largest = left if left < len ( heap ) and heap [ left ] > heap [ i ] else i <NEWLINE> largest = right if right < len ( heap ) and heap [ right ] > heap [ largest ] else largest <NEWLINE> if largest != i : <NEWLINE> <INDENT> heap [ i ] , heap [ largest ] = heap [ largest ] , heap [ i ] <NEWLINE> maxHeapify ( heap , largest ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> heap = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( heap , int ( line . split ( ) [ 1 ] ) ) <NEWLINE> <DEDENT> elif line [ 0 : 2 ] == <STRING> : <NEWLINE> <INDENT> print ( str ( heapExtractMax ( heap ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> from heapq import * <NEWLINE> H , O = [ ] , <STRING> <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> if <STRING> == e [ 0 ] : heappush ( H , - int ( e [ 7 : ] ) ) <NEWLINE> elif <STRING> == e [ 2 ] : O += <STRING> ) <NEWLINE> <DEDENT> print ( O [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> from heapq import * <NEWLINE> H , O = [ ] , [ ] <NEWLINE> for e in sys . stdin : <NEWLINE> <INDENT> c = e [ 1 ] <NEWLINE> if <STRING> == c : heappush ( H , - int ( e [ 7 : ] ) ) <NEWLINE> elif <STRING> == c : O += [ - heappop ( H ) ] <NEWLINE> <DEDENT> print ( <STRING> . join ( map ( str , O ) ) ) <NEWLINE>
import sys <NEWLINE> <NL> def insert ( S , k ) : <NEWLINE> <INDENT> S . append ( k ) <NEWLINE> idx = len ( S ) - 1 <NEWLINE> while True : <NEWLINE> <INDENT> p = ( i + 1 ) / 2 - 1 <NEWLINE> if p < 0 or S [ idx ] <= S [ p ] : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S [ idx ] , S [ p ] = S [ p ] , S [ idx ] <NEWLINE> idx = p <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def maxHeapify ( A , i , size ) : <NEWLINE> <INDENT> l = 2 * i + 1 <NEWLINE> r = 2 * i + 2 <NEWLINE> <NL> if l < size and A [ l ] > A [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <NL> <DEDENT> if r < size and A [ r ] > A [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i ] , A [ largest ] = A [ largest ] , A [ i ] <NEWLINE> maxHeapify ( A , largest , size ) <NEWLINE> <NL> <DEDENT> <DEDENT> def extract ( S ) : <NEWLINE> <INDENT> print S [ 0 ] <NEWLINE> S [ 0 ] = S [ - 1 ] <NEWLINE> S . pop ( ) <NEWLINE> maxHeapify ( S , 0 , len ( S ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> lines = sys . stdin . readlines ( ) <NEWLINE> lines . pop ( ) <NEWLINE> <NL> S = [ ] <NEWLINE> for line in lines : <NEWLINE> <INDENT> if line [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( S , int ( line [ 7 : ] ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> extract ( S ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> q = [ 0 ] * int ( 2e+6 ) <NEWLINE> H = 0 <NEWLINE> while ( True ) : <NEWLINE> <INDENT> cmd = map ( str , raw_input ( ) . split ( ) ) <NEWLINE> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> q [ H ] = int ( cmd [ 1 ] ) <NEWLINE> H += 1 <NEWLINE> increase ( q , H ) <NEWLINE> <DEDENT> elif cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> print q [ 0 ] <NEWLINE> q [ 0 ] = q [ H - 1 ] <NEWLINE> H -= 1 <NEWLINE> if H >= 2 : <NEWLINE> <INDENT> maxHeapify ( q , 1 , H ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def increase ( A , i ) : <NEWLINE> <INDENT> p = i / 2 <NEWLINE> if 0 < p : <NEWLINE> <INDENT> if A [ p - 1 ] < A [ i - 1 ] : <NEWLINE> <INDENT> A [ p - 1 ] , A [ i - 1 ] = A [ i - 1 ] , A [ p - 1 ] <NEWLINE> increase ( A , p ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def maxHeapify ( A , i , H ) : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> if l <= H and A [ l - 1 ] > A [ i - 1 ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= H and A [ r - 1 ] > A [ largest - 1 ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> A [ i - 1 ] , A [ largest - 1 ] = A [ largest - 1 ] , A [ i - 1 ] <NEWLINE> maxHeapify ( A , largest , H ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> def parent ( i ) : <NEWLINE> <INDENT> return i // 2 <NEWLINE> <NL> <NL> <DEDENT> def left ( i ) : <NEWLINE> <INDENT> return 2 * i <NEWLINE> <NL> <NL> <DEDENT> def right ( i ) : <NEWLINE> <INDENT> return 2 * i + 1 <NEWLINE> <NL> <DEDENT> class MaxHeap ( list ) : <NEWLINE> <INDENT> def __init__ ( self , H = 0 ) : <NEWLINE> <INDENT> list . __init__ ( self ) <NEWLINE> self . H = H <NEWLINE> self [ : ] = [ None ] <NEWLINE> <NL> <DEDENT> def insert ( self , key ) : <NEWLINE> <INDENT> self . H += 1 <NEWLINE> self . append ( - float ( <STRING> ) ) <NEWLINE> self . heapIncreaseKey ( self . H , key ) <NEWLINE> <NL> <DEDENT> def heapIncreaseKey ( self , i , key ) : <NEWLINE> <INDENT> if key < self [ i ] : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self [ i ] = key <NEWLINE> while i > 1 and self [ parent ( i ) ] < self [ i ] : <NEWLINE> <INDENT> pi = parent ( i ) <NEWLINE> self [ i ] , self [ pi ] = self [ pi ] , self [ i ] <NEWLINE> i = pi <NEWLINE> <NL> <DEDENT> <DEDENT> def heapExtract ( self ) : <NEWLINE> <INDENT> if self . H < 1 : <NEWLINE> <INDENT> raise <STRING> <NEWLINE> <DEDENT> maximum = self [ 1 ] <NEWLINE> self [ 1 ] = self . pop ( ) <NEWLINE> self . H -= 1 <NEWLINE> self . maxHeapify ( 1 ) <NEWLINE> <NL> return maximum <NEWLINE> <NL> <DEDENT> def maxHeapify ( self , i ) : <NEWLINE> <INDENT> l = left ( i ) <NEWLINE> r = right ( i ) <NEWLINE> if l <= self . H and self [ l ] > self [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= self . H and self [ r ] > self [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> self [ i ] , self [ largest ] = self [ largest ] , self [ i ] <NEWLINE> self . maxHeapify ( largest ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> A = MaxHeap ( ) <NEWLINE> while True : <NEWLINE> <INDENT> c = input ( ) . split ( <STRING> ) <NEWLINE> if c [ 0 ] == <STRING> : <NEWLINE> <INDENT> A . insert ( int ( c [ 1 ] ) ) <NEWLINE> <DEDENT> elif c [ 0 ] == <STRING> : <NEWLINE> <INDENT> print ( A . heapExtract ( ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> INF = - 10 ** 10 <NEWLINE> queue = [ - 1 ] <NEWLINE> <NL> <NL> def insert ( queue , key ) : <NEWLINE> <INDENT> h = len ( queue ) - 1 <NEWLINE> queue . append ( INF ) <NEWLINE> heap_increase_key ( queue , h + 1 , key ) <NEWLINE> <NL> <NL> <DEDENT> def heap_increase_key ( queue , i , key ) : <NEWLINE> <INDENT> if key < queue [ i ] : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <DEDENT> queue [ i ] = key <NEWLINE> while i > 1 and queue [ i // 2 ] < queue [ i ] : <NEWLINE> <INDENT> queue [ i ] , queue [ i // 2 ] = queue [ i // 2 ] , queue [ i ] <NEWLINE> i = i // 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def extract_max ( queue ) : <NEWLINE> <INDENT> h = len ( queue ) - 1 <NEWLINE> if h < 1 : <NEWLINE> <INDENT> raise TypeError ( <STRING> ) <NEWLINE> <DEDENT> max = queue [ 1 ] <NEWLINE> queue [ 1 ] = queue . pop ( ) <NEWLINE> h -= 1 <NEWLINE> <NL> i = 1 <NEWLINE> while True : <NEWLINE> <INDENT> l = 2 * i <NEWLINE> r = 2 * i + 1 <NEWLINE> if l <= h and queue [ l ] > queue [ i ] : <NEWLINE> <INDENT> largest = l <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if r <= h and queue [ r ] > queue [ largest ] : <NEWLINE> <INDENT> largest = r <NEWLINE> <NL> <DEDENT> if largest != i : <NEWLINE> <INDENT> queue [ i ] , queue [ largest ] = queue [ largest ] , queue [ i ] <NEWLINE> i = largest <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> return max <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> import sys <NEWLINE> ords = [ line . strip ( ) . split ( ) for line in sys . stdin ] <NEWLINE> <NL> for ord in ords : <NEWLINE> <INDENT> if len ( ord ) > 1 : <NEWLINE> <INDENT> ord , key = ord [ 0 ] , int ( ord [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ord = ord [ 0 ] <NEWLINE> <DEDENT> if ord [ 0 ] == <STRING> : <NEWLINE> <INDENT> insert ( queue , key ) <NEWLINE> <DEDENT> elif len ( ord ) == 7 : <NEWLINE> <INDENT> print ( extract_max ( queue ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin , maxint <NEWLINE> <NL> MININT = - 1 - maxint <NEWLINE> <NL> <NL> def max_heapify ( a , i , heap_size ) : <NEWLINE> <INDENT> L = 2 * i <NEWLINE> R = 2 * i + 1 <NEWLINE> if L <= heap_size and a [ L ] > a [ i ] : <NEWLINE> <INDENT> largest = L <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> largest = i <NEWLINE> <DEDENT> if R <= heap_size and a [ R ] > a [ largest ] : <NEWLINE> <INDENT> largest = R <NEWLINE> <DEDENT> if largest != i : <NEWLINE> <INDENT> a [ i ] , a [ largest ] = a [ largest ] , a [ i ] <NEWLINE> max_heapify ( a , largest , heap_size ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def max_heap_insert ( a , key , heap_size ) : <NEWLINE> <INDENT> heap_size [ 0 ] += 1 <NEWLINE> a [ heap_size [ 0 ] ] = MININT <NEWLINE> heap_increase_key ( a , key , heap_size [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> def heap_increase_key ( a , key , i ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> a [ i ] = key <NEWLINE> half = i // 2 <NEWLINE> while i > 1 and a [ half ] < a [ i ] : <NEWLINE> <INDENT> a [ i ] , a [ half ] = a [ half ] , a [ i ] <NEWLINE> i = i // 2 <NEWLINE> half = i // 2 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def heap_extract_max ( a , heap_size ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> max = a [ 1 ] <NEWLINE> a [ 1 ] = a [ heap_size [ 0 ] ] <NEWLINE> heap_size [ 0 ] -= 1 <NEWLINE> max_heapify ( a , 1 , heap_size [ 0 ] ) <NEWLINE> return max <NEWLINE> <NL> <NL> <DEDENT> heap = [ MININT ] * 2000001 <NEWLINE> heap_size = [ 1 ] <NEWLINE> for cmd in stdin : <NEWLINE> <INDENT> if cmd [ 0 ] == <STRING> : <NEWLINE> <INDENT> key = int ( cmd [ 7 : ] ) <NEWLINE> <COMMENT> <NL> max_heap_insert ( heap , key , heap_size ) <NEWLINE> <DEDENT> elif cmd [ 1 ] == <STRING> : <NEWLINE> <INDENT> print ( heap_extract_max ( heap , heap_size ) ) <NEWLINE> <DEDENT> elif cmd [ 1 ] == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
x1 , y1 , x2 , y2 = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if y1 == y2 or x1 == x2 : <NEWLINE> <INDENT> if y1 == y2 : <NEWLINE> <INDENT> t0 = 0 <NEWLINE> <DEDENT> if x1 == x2 : <NEWLINE> <INDENT> t1 = 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> t0 = ( y2 - y1 ) / ( x2 - x1 ) <NEWLINE> b0 = y1 - t0 * x1 <NEWLINE> t1 = - ( x2 - x1 ) / ( y2 - y1 ) <NEWLINE> <NL> <DEDENT> for i in xrange ( int ( raw_input ( ) ) ) : <NEWLINE> <INDENT> px , py = map ( float , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if t0 == 0 or t1 == 0 : <NEWLINE> <INDENT> if t0 == 0 : <NEWLINE> <INDENT> t1 = - 1 <NEWLINE> a = 1.0 <NEWLINE> b = - t0 <NEWLINE> c = y1 <NEWLINE> d = 0.0 <NEWLINE> e = - t1 <NEWLINE> f = px <NEWLINE> <DEDENT> if t1 == 0 : <NEWLINE> <INDENT> t0 = - 1 <NEWLINE> a = 0.0 <NEWLINE> b = - t0 <NEWLINE> c = x1 <NEWLINE> d = 1.0 <NEWLINE> e = - t0 <NEWLINE> f = py <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> b1 = py - t1 * px <NEWLINE> a , b , c , d , e , f = 1.0 , - t0 , b0 , 1.0 , - t1 , b1 <NEWLINE> <DEDENT> kouten_y = ( c * e - f * b ) / ( a * e - b * d ) <NEWLINE> kouten_x = ( a * f - c * d ) / ( a * e - b * d ) <NEWLINE> print <STRING> . format ( kouten_x , kouten_y ) <NEWLINE> <DEDENT>
class Point ( ) : <NEWLINE> <INDENT> def __init__ ( self , x , y ) : <NEWLINE> <INDENT> self . x = x <NEWLINE> self . y = y <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> output_list = [ ] <NEWLINE> <NL> <NL> init_point = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <NL> p0 = Point ( init_point [ 0 ] , init_point [ 1 ] ) <NEWLINE> p1 = Point ( init_point [ 2 ] , init_point [ 3 ] ) <NEWLINE> <NL> <NL> q = int ( raw_input ( ) ) <NEWLINE> datalist = [ map ( float , raw_input ( ) . split ( ) ) for i in range ( q ) ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> a = ( p0 . y - p1 . y ) / ( p0 . x - p1 . x ) <NEWLINE> <NL> if a != 0 : <NEWLINE> <INDENT> c = - 1 / a <NEWLINE> b = p0 . y - a * p0 . x <NEWLINE> <NL> for data in datalist : <NEWLINE> <INDENT> p2 = Point ( data [ 0 ] , data [ 1 ] ) <NEWLINE> <NL> d = p2 . y - c * p2 . x <NEWLINE> <NL> X = ( - b + d ) / ( a - c ) <NEWLINE> Y = a * X + b <NEWLINE> <NL> output_list . append ( ( X , Y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for data in datalist : <NEWLINE> <INDENT> p2 = Point ( data [ 0 ] , data [ 1 ] ) <NEWLINE> output_list . append ( ( p2 . x , p0 . y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for x , y in output_list : <NEWLINE> <INDENT> print <STRING> % ( x , y ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 = map ( float , input ( ) . split ( ) ) <NEWLINE> if x1 - x0 == 0 : <NEWLINE> <INDENT> if x3 - x2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif y3 - y2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif x3 - x2 == 0 : <NEWLINE> <INDENT> if y1 - y0 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif y1 - y0 == 0 : <NEWLINE> <INDENT> if y3 - y2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x3 - x2 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> elif y3 - y2 == 0 : <NEWLINE> <INDENT> elif x1 - x0 == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> a1 = ( y1 - y0 ) / ( x1 - x0 ) <NEWLINE> a2 = ( y3 - y2 ) / ( x3 - x2 ) <NEWLINE> if a1 * a2 == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a1 == a2 or a1 == - a2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Line : <NEWLINE> <INDENT> def __init__ ( self , p1 , p2 ) : <NEWLINE> <INDENT> if p1 [ 1 ] < p2 [ 1 ] : self . s = p2 ; self . e = p1 <NEWLINE> elif p1 [ 1 ] > p2 [ 1 ] : self . s = p1 ; self . e = p2 <NEWLINE> else : <NEWLINE> <INDENT> if p1 [ 0 ] < p2 [ 0 ] : self . s = p1 ; self . e = p2 <NEWLINE> else : self . s = p2 ; self . e = p1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> def dot ( a , b ) : return a [ 0 ] * b [ 0 ] + a [ 1 ] * b [ 1 ] <NEWLINE> def cross ( a , b ) : return a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] <NEWLINE> def dif ( a , b ) : return [ x - y for x , y in zip ( a , b ) ] <NEWLINE> def InterSection ( l , m ) : <NEWLINE> <INDENT> a = dif ( l . e , l . s ) ; b = dif ( m . e , l . s ) ; c = dif ( m . s , l . s ) <NEWLINE> d = dif ( m . e , m . s ) ; e = dif ( l . e , m . s ) ; f = dif ( l . s , m . s ) <NEWLINE> g = lambda a , b : cross ( a , b ) == 0 and dot ( a , b ) > 0 and dot ( b , b ) < dot ( a , a ) <NEWLINE> if g ( a , b ) or g ( a , c ) or g ( d , e ) or g ( d , f ) : return True <NEWLINE> elif l . s == m . e or l . s == m . s or l . e == m . e or l . e == m . s : return True <NEWLINE> elif cross ( a , b ) * cross ( a , c ) >= 0 or cross ( d , e ) * cross ( d , f ) >= 0 : return False <NEWLINE> else : return True <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 , x2 , y2 , x3 , y3 = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> a = [ x0 , y0 ] ; b = [ x1 , y1 ] ; c = [ x2 , y2 ] ; d = [ x3 , y3 ] <NEWLINE> l1 = Line ( b , 1 ) ; l2 = Line ( b , 1 ) <NEWLINE> if InterSection ( l1 , l2 ) : print ( 1 ) <NEWLINE> else : print ( 0 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from math import isinf <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for each in _v_info : <NEWLINE> <INDENT> source , target , cost = map ( int , each ) <NEWLINE> init_adj_table [ source ] [ target ] = cost <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def bellman_ford ( ) : <NEWLINE> <INDENT> distance [ root ] = 0 <NEWLINE> <NL> for j in range ( vertices - 1 ) : <NEWLINE> <INDENT> for current , current_info in enumerate ( adj_table ) : <NEWLINE> <INDENT> for adj , cost in current_info . items ( ) : <NEWLINE> <INDENT> if distance [ current ] + cost < distance [ adj ] : <NEWLINE> <INDENT> distance [ adj ] = distance [ current ] + cost <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for current , current_info in enumerate ( adj_table ) : <NEWLINE> <INDENT> for adj , cost in current_info . items ( ) : <NEWLINE> <INDENT> if distance [ current ] + cost < distance [ adj ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return list ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return distance <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges , root = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> distance = [ float ( <STRING> ) ] * vertices <NEWLINE> init_adj_table = tuple ( dict ( ) for _ in range ( vertices ) ) <NEWLINE> <NL> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> res = bellman_ford ( ) <NEWLINE> for ele in res : <NEWLINE> <INDENT> if isinf ( ele ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( ele ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Line : <NEWLINE> <INDENT> def __init__ ( self , p1 , p2 ) : <NEWLINE> <INDENT> if p1 [ 1 ] < p2 [ 1 ] : self . s = p2 ; self . e = p1 <NEWLINE> elif p1 [ 1 ] > p2 [ 1 ] : self . s = p1 ; self . e = p2 <NEWLINE> else : <NEWLINE> <INDENT> if p1 [ 0 ] < p2 [ 0 ] : self . s = p1 ; self . e = p2 <NEWLINE> else : self . s = p2 ; self . e = p1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def cross ( a , b ) : return a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] <NEWLINE> def dot ( a , b ) : return a [ 0 ] * b [ 0 ] + a [ 1 ] * b [ 1 ] <NEWLINE> def dif ( a , b ) : return [ x - y for x , y in zip ( a , b ) ] <NEWLINE> def dist ( a , b ) : return ( ( a [ 0 ] - b [ 0 ] ) ** 2 + ( a [ 1 ] - b [ 1 ] ) ** 2 ) ** 0.5 <NEWLINE> def isec ( l , m ) : <NEWLINE> <INDENT> a = dif ( l . e , l . s ) ; b = dif ( m . e , l . s ) ; c = dif ( m . s , l . s ) <NEWLINE> d = dif ( m . e , m . s ) ; e = dif ( l . e , m . s ) ; f = dif ( l . s , m . s ) <NEWLINE> g = lambda a , b : cross ( a , b ) == 0 and dot ( a , b ) > 0 and dot ( b , b ) < dot ( a , a ) <NEWLINE> if g ( a , b ) or g ( a , c ) or g ( d , e ) or g ( d , f ) : return True <NEWLINE> elif l . s == m . e or l . s == m . s or l . e == m . e or l . e == m . s : return True <NEWLINE> elif cross ( a , b ) * cross ( a , c ) >= 0 or cross ( d , e ) * cross ( d , f ) >= 0 : return False <NEWLINE> else : return True <NEWLINE> <DEDENT> def projection ( a , b ) : return [ x * dot ( a , b ) / dot ( a , a ) for x in a ] <NEWLINE> def proj ( A , B , C , D ) : <NEWLINE> <INDENT> AB = dif ( B , A ) ; AC = dif ( C , A ) ; AD = dif ( D , A ) <NEWLINE> CD = dif ( D , C ) ; CA = dif ( A , C ) ; CB = dif ( B , C ) <NEWLINE> _A = projection ( CA , CD ) <NEWLINE> _B = projection ( CB , CD ) <NEWLINE> _C = projection ( AC , AB ) <NEWLINE> _D = projection ( AD , AB ) <NEWLINE> return [ _A , _B , _C , _D ] <NEWLINE> <DEDENT> def Order ( a , b ) : <NEWLINE> <INDENT> crs = cross ( a , b ) <NEWLINE> if crs > 0 : return <STRING> <NEWLINE> elif crs < 0 : return <STRING> <NEWLINE> else : <NEWLINE> <INDENT> if dot ( a , b ) < 0 : return <STRING> <NEWLINE> elif dot ( a , a ) < dot ( b , b ) : return <STRING> <NEWLINE> else : return <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> a , b , c , d , e , f , g , h = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> A = [ a , b ] ; B = [ c , d ] ; C = [ e , f ] ; D = [ g , h ] <NEWLINE> l = Line ( A , B ) ; m = Line ( C , D ) <NEWLINE> if isec ( l , m ) : <NEWLINE> <INDENT> print ( 0.0 ) <NEWLINE> continue <NEWLINE> <DEDENT> _A , _B , _C , _D = proj ( A , B , C , D ) <NEWLINE> AB = dif ( B , A ) ; CD = dif ( D , C ) <NEWLINE> A_C = dif ( _C , A ) ; A_D = dif ( _D , A ) ; C_A = dif ( _A , C ) ; C_B = dif ( _B , C ) <NEWLINE> DIST = [ dist ( A , C ) , dist ( A , D ) , dist ( B , C ) , dist ( B , D ) , dist ( _A , A ) , dist ( _B , B ) , dist ( _C , C ) , dist ( _D , D ) ] <NEWLINE> fun = lambda x : x != <STRING> <NEWLINE> if fun ( Order ( CD , C_A ) ) : DIST [ 4 ] = sys . maxsize <NEWLINE> if fun ( Order ( CD , C_B ) ) : DIST [ 5 ] = sys . maxsize <NEWLINE> if fun ( Order ( AB , A_C ) ) : DIST [ 6 ] = sys . maxsize <NEWLINE> if fun ( Order ( AB , A_D ) ) : DIST [ 7 ] = sys . maxsize <NEWLINE> print ( min ( DIST ) ) <NEWLINE> <DEDENT>
x = range ( int ( input ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> _ = 0 <NEWLINE> for _ in x : P += [ [ int ( i ) for i in input ( ) . split ( ) ] ] <NEWLINE> P += [ P [ 0 ] ] <NEWLINE> for j in x : s += P [ j ] [ 0 ] * P [ j + 1 ] [ 1 ] - P [ j ] [ 1 ] * P [ j + 1 ] [ 0 ] <NEWLINE> print ( s * 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> s = 0 <NEWLINE> for i in range ( n ) : P . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> P . append ( P [ 0 ] ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a = P [ i ] [ 0 ] ; b = P [ i ] [ 1 ] ; c = P [ i + 1 ] [ 0 ] ; P [ i + 1 ] [ 1 ] <NEWLINE> s += a * d - b * c <NEWLINE> <DEDENT> print ( abs ( s ) * 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> s = 0 <NEWLINE> x , y = <NEWLINE> for _ in range ( n ) : P . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> P . append ( P [ 0 ] ) <NEWLINE> for j in range ( n ) : s += P [ j ] [ 0 ] * P [ j + 1 ] [ 1 ] - P [ j ] [ 1 ] * P [ j + 1 ] [ 0 ] <NEWLINE> print ( s * 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = range ( n ) <NEWLINE> P = [ ] <NEWLINE> s = 0 <NEWLINE> for _ in x : P . append ( [ int ( i ) for i in input ( ) . split ( ) ] ) <NEWLINE> P += P [ 0 ] <NEWLINE> for j in x : s += P [ j ] [ 0 ] * P [ j + 1 ] [ 1 ] - P [ j ] [ 1 ] * P [ j + 1 ] [ 0 ] <NEWLINE> print ( s * 0.5 ) <NEWLINE>
x = range ( int ( input ( ) ) ) <NEWLINE> f = lambda a , b , c , d : a * d - b * c <NEWLINE> P = [ ] <NEWLINE> for _ in x : P += [ [ int ( i ) for i in input ( ) . split ( ) ] ] <NEWLINE> _ = 0 <NEWLINE> P += [ P [ 0 ] ] <NEWLINE> for j in x : _ += f ( P [ j ] [ 0 ] , P [ j ] [ 1 ] , , P [ j + 1 ] [ 0 ] P [ j + 1 ] [ 1 ] ) <NEWLINE> print ( _ * 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> s = 0 <NEWLINE> for _ in range ( n ) : P . append ( [ int ( - i ) for i in input ( ) . split ( ) ] ) <NEWLINE> P . append ( P [ 0 ] ) <NEWLINE> for j in range ( n ) : s += P [ j ] [ 1 ] * P [ j + 1 ] [ 0 ] - P [ j ] [ 0 ] * P [ j + 1 ] [ 1 ] <NEWLINE> print ( s * 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> P = [ ] <NEWLINE> s = 0 <NEWLINE> x0 , y0 = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> P . append ( [ x - x0 , y - y0 ] ) <NEWLINE> <DEDENT> for i in range ( n - 2 ) : <NEWLINE> <INDENT> s += P [ i ] [ 0 ] * P [ i + 1 ] [ 1 ] - P [ i ] [ 1 ] * P [ i + 1 ] [ 0 ] <NEWLINE> <DEDENT> print ( abs ( s ) * 0.5 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x = range ( n ) <NEWLINE> P = [ ] <NEWLINE> s = 0 <NEWLINE> for _ in x : P += [ [ int ( i ) for i in input ( ) . split ( ) ] ] <NEWLINE> P += P [ 0 ] <NEWLINE> for j in x : s += P [ j ] [ 0 ] * P [ j + 1 ] [ 1 ] - P [ j ] [ 1 ] * P [ j + 1 ] [ 0 ] <NEWLINE> print ( s * 0.5 ) <NEWLINE>
def cross ( a , b ) : return a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] <NEWLINE> def dif ( a , b ) : return [ x - y for x , y in zip ( a , b ) ] <NEWLINE> <NL> x = range ( int ( input ( ) ) ) <NEWLINE> t = 1 <NEWLINE> P , Q = [ ] , [ ] <NEWLINE> for _ in x : P += [ [ int ( i ) for i in input ( ) . split ( ) ] ] <NEWLINE> for i in x : Q += [ dif ( P [ i ] , P [ i - 1 ] ) ] <NEWLINE> for i in x : if cross ( Q [ i - 1 ] , Q [ i ] ) < 0 : t *= False <NEWLINE> print ( t ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def isCLKWISE ( ph ) : <NEWLINE> <INDENT> return not ( ( ph [ - 1 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 2 ] [ 1 ] ) - ( ph [ - 2 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 1 ] [ 1 ] ) < 0 ) <NEWLINE> <NL> <DEDENT> def ConvexHullScan ( P ) : <NEWLINE> <INDENT> P = sorted ( P ) <NEWLINE> phU = [ P [ 0 ] , P [ 1 ] ] <NEWLINE> for p in P [ 2 : ] : <NEWLINE> <INDENT> phU . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phU ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phU [ - 2 ] <NEWLINE> if len ( phU ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> phL = [ P [ - 1 ] , P [ - 2 ] ] <NEWLINE> for p in P [ - 3 : : - 1 ] : <NEWLINE> <INDENT> phL . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phL ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phL [ - 2 ] <NEWLINE> if len ( phL ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ph = phU + phL [ 1 : - 1 ] <NEWLINE> return ph <NEWLINE> <NL> <DEDENT> n = range ( int ( input ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for i in n : P . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> Q = deque ( ConvexHullScan ( P ) ) <NEWLINE> Q . reverse ( ) <NEWLINE> print ( len ( Q ) ) <NEWLINE> idx = min ( [ [ x [ 1 ] [ 1 ] , x [ 1 ] [ 0 ] , x [ 0 ] ] for x in enumerate ( Q ) ] ) [ 2 ] <NEWLINE> Q . rotate ( idx ) <NEWLINE> for r in Q : print ( q [ 0 ] , q [ 1 ] ) <NEWLINE>
import sys <NEWLINE> <NL> def isCLKWISE ( ph ) : <NEWLINE> <INDENT> if ( ph [ - 1 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 2 ] [ 1 ] ) - ( ph [ - 2 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 1 ] [ 1 ] ) < 0 : return False <NEWLINE> else : return True <NEWLINE> <NL> <DEDENT> def ConvexHullScan ( P ) : <NEWLINE> <INDENT> P = sorted ( P ) <NEWLINE> phU = [ P [ 0 ] , P [ 1 ] ] <NEWLINE> for p in P [ 2 : ] : <NEWLINE> <INDENT> phU . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phU ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phU [ - 2 ] <NEWLINE> if len ( phU ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> phL = [ P [ - 1 ] , P [ - 2 ] ] <NEWLINE> for p in P [ - 3 : : - 1 ] : <NEWLINE> <INDENT> phL . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phL ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phL [ - 2 ] <NEWLINE> if len ( phL ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ph = phU + phL [ 1 : - 1 ] <NEWLINE> return ph <NEWLINE> <NL> <DEDENT> _input = sys . stdin . readlines ( ) <NEWLINE> n = int ( _input [ 0 ] ) <NEWLINE> P = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> Q = ConvexHullScan ( P ) <NEWLINE> Q . reverse ( ) <NEWLINE> print ( len ( Q ) ) <NEWLINE> idx = min ( [ [ x [ 1 ] [ 1 ] , x [ 1 ] [ 0 ] , x [ 0 ] ] for x in enumerate ( Q ) ] ) [ 2 ] <NEWLINE> R = Q [ idx : ] + Q [ : idx ] <NEWLINE> for r in R : <NEWLINE> <INDENT> print ( r [ 0 ] , r [ 1 ] ) <NEWLINE> <DEDENT>
def isCLKWISE ( ph ) : <NEWLINE> <INDENT> return ph [ - 1 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 2 ] [ 1 ] ) - ( ph [ - 2 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 1 ] [ 1 ] ) >= 0 <NEWLINE> <NL> <DEDENT> def ConvexHullScan ( P ) : <NEWLINE> <INDENT> P = sorted ( P ) <NEWLINE> phU = [ P [ 0 ] , P [ 1 ] ] <NEWLINE> for p in P [ 2 : ] : <NEWLINE> <INDENT> phU . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phU ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phU [ - 2 ] <NEWLINE> if len ( phU ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> phL = [ P [ - 1 ] , P [ - 2 ] ] <NEWLINE> for p in P [ - 3 : : - 1 ] : <NEWLINE> <INDENT> phL . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phL ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phL [ - 2 ] <NEWLINE> if len ( phL ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ph = phU + phL [ 1 : - 1 ] <NEWLINE> return ph <NEWLINE> <NL> <DEDENT> n = range ( int ( input ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for i in n : <NEWLINE> <INDENT> P . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> Q = ConvexHullScan ( P ) <NEWLINE> Q . reverse ( ) <NEWLINE> print ( len ( Q ) ) <NEWLINE> idx = min ( [ [ x [ 1 ] [ 1 ] , x [ 1 ] [ 0 ] , x [ 0 ] ] for x in enumerate ( Q ) ] ) [ 2 ] <NEWLINE> R = Q [ idx : ] + Q [ : idx ] <NEWLINE> for r in R : print ( r [ 0 ] , r [ 1 ] ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> pts = [ [ int ( _ ) for _ in raw_input ( ) . split ( ) ] for i in xrange ( n ) ] <NEWLINE> <NL> <NL> def dot ( a , b ) : <NEWLINE> <INDENT> return a [ 0 ] * b [ 0 ] + a [ 1 ] * b [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> def cross ( a , b ) : <NEWLINE> <INDENT> return a [ 0 ] * b [ 1 ] - a [ 1 ] * b [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> def norm ( a ) : <NEWLINE> <INDENT> return dot ( a , a ) <NEWLINE> <NL> <NL> <DEDENT> def dist2 ( a , b ) : <NEWLINE> <INDENT> return norm ( sub ( a , b ) ) <NEWLINE> <NL> <NL> <DEDENT> def sub ( a , b ) : <NEWLINE> <INDENT> return [ a [ 0 ] - b [ 0 ] , a [ 1 ] - b [ 1 ] ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> p = min ( pts , key = lambda p : ( p [ 1 ] , p [ 0 ] ) ) <NEWLINE> ans = [ p ] <NEWLINE> <NL> cur = ans [ 0 ] <NEWLINE> cur_dxdy = ( - 1 , 0 ) <NEWLINE> while True : <NEWLINE> <COMMENT> <NL> <INDENT> q = pts [ 0 ] <NEWLINE> dxdy = sub ( q , cur ) <NEWLINE> d = dist2 ( cur , q ) <NEWLINE> for q_ in pts [ 1 : ] : <NEWLINE> <INDENT> if q_ is cur : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> dxdy_ = sub ( q_ , cur ) <NEWLINE> v = cross ( dxdy , dxdy_ ) <NEWLINE> if v > 0 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d_ = dist2 ( cur , q_ ) <NEWLINE> if v == 0 and d_ < d : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> q = q_ <NEWLINE> dxdy = dxdy_ <NEWLINE> d = d_ <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> mids = [ m for m in pts <NEWLINE> <INDENT> if cross ( dxdy , sub ( m , cur ) ) == 0 and dot ( sub ( m , cur ) , sub ( m , q ) ) < 0 ] <NEWLINE> <DEDENT> mids . sort ( key = lambda m : dist2 ( cur , m ) ) <NEWLINE> ans += mids <NEWLINE> <NL> if p is q : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> ans . append ( q ) <NEWLINE> cur_dxdy = dxdy <NEWLINE> cur = q <NEWLINE> <NL> <DEDENT> print len ( ans ) <NEWLINE> for p in ans : <NEWLINE> <INDENT> print p [ 0 ] , p [ 1 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <COMMENT> <NL> <NL> def convexHull ( points ) : <NEWLINE> <INDENT> assert len ( points ) > 0 <NEWLINE> <NL> points = sorted ( set ( points ) ) <NEWLINE> <NL> <COMMENT> <NL> lower = [ ] <NEWLINE> for p in points : <NEWLINE> <COMMENT> <NL> <INDENT> while len ( lower ) >= 2 and cross ( lower [ - 2 ] , lower [ - 1 ] , p ) <= 0 : <NEWLINE> <INDENT> lower . pop ( ) <NEWLINE> <DEDENT> lower . append ( p ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> upper = [ ] <NEWLINE> for p in points [ : : - 1 ] : <NEWLINE> <INDENT> while len ( upper ) >= 2 and cross ( upper [ - 2 ] , upper [ - 1 ] , p ) <= 0 : <NEWLINE> <INDENT> upper . pop ( ) <NEWLINE> <DEDENT> upper . append ( p ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> return lower [ : - 1 ] + upper [ : - 1 ] <NEWLINE> <NL> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> def cross ( O , A , B ) : <NEWLINE> <INDENT> return ( A [ 0 ] - O [ 0 ] ) * ( B [ 1 ] - O [ 1 ] ) - ( A [ 1 ] - O [ 1 ] ) * ( B [ 0 ] - O [ 0 ] ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> points = int ( _input [ 0 ] ) <NEWLINE> p_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> polygon = [ ( int ( x ) , int ( y ) ) for x , y in p_info ] <NEWLINE> ans = convexHull ( polygon ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> for x , y in ans : <NEWLINE> <INDENT> print ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
def isCLKWISE ( ph ) : <NEWLINE> <INDENT> return not ( ( ph [ - 1 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 2 ] [ 1 ] ) - ( ph [ - 2 ] [ 0 ] - ph [ - 3 ] [ 0 ] ) * ( - ph [ - 3 ] [ 1 ] + ph [ - 1 ] [ 1 ] ) < 0 ) <NEWLINE> <NL> <DEDENT> def ConvexHullScan ( P ) : <NEWLINE> <INDENT> P . sort ( ) <NEWLINE> phU = [ P [ 0 ] , P [ 1 ] ] <NEWLINE> for p in P [ 2 : ] : <NEWLINE> <INDENT> phU . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phU ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phU [ - 2 ] <NEWLINE> if len ( phU ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> phL = [ P [ - 1 ] , P [ - 2 ] ] <NEWLINE> for p in P [ - 3 : : - 1 ] : <NEWLINE> <INDENT> phL . append ( p ) <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if isCLKWISE ( phL ) : break <NEWLINE> else : <NEWLINE> <INDENT> del phL [ - 2 ] <NEWLINE> if len ( phL ) == 2 : break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> ph = phU + phL [ 1 : - 1 ] <NEWLINE> return ph <NEWLINE> <NL> <DEDENT> n = range ( int ( input ( ) ) ) <NEWLINE> P = [ ] <NEWLINE> for i in n : <NEWLINE> <INDENT> P . append ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> <NL> <DEDENT> Q = ConvexHullScan ( P ) . reverse ( ) <NEWLINE> print ( len ( Q ) ) <NEWLINE> idx = min ( [ [ x [ 1 ] [ 1 ] , x [ 1 ] [ 0 ] , x [ 0 ] ] for x in enumerate ( Q ) ] ) [ 2 ] <NEWLINE> R = Q [ idx : ] + Q [ : idx ] <NEWLINE> for r in R : print ( r [ 0 ] , r [ 1 ] ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from operator import attrgetter <NEWLINE> <NL> EPS = 1e-9 <NEWLINE> <NL> <NL> def cross ( a , b ) : <NEWLINE> <INDENT> return a . real * b . imag - a . imag * b . real <NEWLINE> <NL> <NL> <DEDENT> def dot ( a , b ) : <NEWLINE> <INDENT> return a . real * b . real + a . imag * b . imag <NEWLINE> <NL> <NL> <DEDENT> def check_ccw ( p0 , p1 , p2 ) : <NEWLINE> <INDENT> a , b = p1 - p0 , p2 - p0 <NEWLINE> if cross ( a , b ) > EPS : <NEWLINE> <COMMENT> <NL> <INDENT> flag = 1 <NEWLINE> <DEDENT> elif cross ( a , b ) < - 1 * EPS : <NEWLINE> <COMMENT> <NL> <INDENT> flag = - 1 <NEWLINE> <DEDENT> elif dot ( a , b ) < - 1 * EPS : <NEWLINE> <COMMENT> <NL> <INDENT> flag = 2 <NEWLINE> <DEDENT> elif abs ( a ) < abs ( b ) : <NEWLINE> <COMMENT> <NL> <INDENT> flag = - 2 <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> flag = 0 <NEWLINE> <DEDENT> return flag <NEWLINE> <NL> <NL> <DEDENT> def convex_check_Andrew ( _polygon ) : <NEWLINE> <INDENT> upper , lower = list ( ) , list ( ) <NEWLINE> _polygon . sort ( key = attrgetter ( <STRING> , <STRING> ) ) <NEWLINE> <NL> upper . extend ( ( _polygon [ 0 ] , _polygon [ 1 ] ) ) <NEWLINE> lower . extend ( ( _polygon [ - 1 ] , _polygon [ - 2 ] ) ) <NEWLINE> <NL> for i in range ( 2 , points ) : <NEWLINE> <INDENT> n1 = len ( upper ) <NEWLINE> while n1 >= 2 and check_ccw ( upper [ n1 - 2 ] , upper [ n1 - 1 ] , _polygon [ i ] ) == 1 : <NEWLINE> <INDENT> n1 -= 1 <NEWLINE> upper . pop ( ) <NEWLINE> <DEDENT> upper . append ( _polygon [ i ] ) <NEWLINE> <NL> <DEDENT> for j in range ( points - 3 , - 1 , - 1 ) : <NEWLINE> <INDENT> n2 = len ( lower ) <NEWLINE> while n2 >= 2 and check_ccw ( lower [ n2 - 2 ] , lower [ n2 - 1 ] , _polygon [ j ] ) == 1 : <NEWLINE> <INDENT> n2 -= 1 <NEWLINE> lower . pop ( ) <NEWLINE> <DEDENT> lower . append ( _polygon [ j ] ) <NEWLINE> <NL> <DEDENT> lower . reverse ( ) <NEWLINE> lower_min = min ( lower ) <NEWLINE> min_index = lower . index ( lower_min ) <NEWLINE> lower_right = lower [ min_index : ] <NEWLINE> lower_left = lower [ : min_index ] <NEWLINE> <NL> for k in range ( len ( upper ) - 2 , 0 , - 1 ) : <NEWLINE> <INDENT> lower_right . append ( upper [ k ] ) <NEWLINE> <DEDENT> return lower_right + lower_left <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> points = int ( _input [ 0 ] ) <NEWLINE> p_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> polygon = [ int ( x ) + int ( y ) * 1j for x , y in p_info ] <NEWLINE> ans = convex_check_Andrew ( polygon ) <NEWLINE> print ( len ( ans ) ) <NEWLINE> for ele in ans : <NEWLINE> <INDENT> print ( int ( ele . real ) , int ( ele . imag ) ) <NEWLINE> <DEDENT> <DEDENT>
n = input ( ) <NEWLINE> ps = [ map ( int , raw_input ( ) . split ( ) ) for i in xrange ( n ) ] <NEWLINE> def intersection ( p1 , p2 , q1 , q2 ) : <NEWLINE> <INDENT> dx0 = p2 [ 0 ] - p1 [ 0 ] <NEWLINE> dy0 = p2 [ 1 ] - p1 [ 1 ] <NEWLINE> dx1 = q2 [ 0 ] - q1 [ 0 ] <NEWLINE> dy1 = q2 [ 1 ] - q1 [ 1 ] <NEWLINE> a = dy0 * dx1 ; b = dy1 * dx0 ; c = dx0 * dx1 ; d = dy0 * dy1 <NEWLINE> if a == b : return None <NEWLINE> x = ( a * p1 [ 0 ] - b * q1 [ 0 ] + c * ( q1 [ 1 ] - p1 [ 1 ] ) ) / float ( a - b ) <NEWLINE> y = ( c * p1 [ 1 ] - a * q1 [ 1 ] + d * ( q1 [ 0 ] - p1 [ 0 ] ) ) / float ( b - a ) <NEWLINE> return x , y <NEWLINE> <DEDENT> def cross ( a , b , c ) : <NEWLINE> <INDENT> return ( b [ 0 ] - a [ 0 ] ) * ( c [ 1 ] - a [ 1 ] ) - ( b [ 1 ] - a [ 1 ] ) * ( c [ 0 ] - a [ 0 ] ) <NEWLINE> <DEDENT> def calc_area ( ps ) : <NEWLINE> <INDENT> return abs ( sum ( ps [ i ] [ 0 ] * ps [ i - 1 ] [ 1 ] - ps [ i ] [ 1 ] * ps [ i - 1 ] [ 0 ] for i in xrange ( n ) ) ) / 2. <NEWLINE> <DEDENT> for t in xrange ( input ( ) ) : <NEWLINE> <INDENT> vs = [ ] <NEWLINE> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> p1 = ( x1 , y1 ) ; p2 = ( x2 , y2 ) <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> q1 = ps [ i - 1 ] ; q2 = ps [ i ] <NEWLINE> if cross ( p1 , p2 , q1 ) * cross ( p1 , p2 , q2 ) <= 0 : <NEWLINE> <INDENT> r = intersection ( p1 , p2 , q1 , q2 ) <NEWLINE> if r is not None : <NEWLINE> <INDENT> vs . append ( r ) <NEWLINE> <DEDENT> <DEDENT> if cross ( p1 , p2 , q2 ) >= 0 : <NEWLINE> <INDENT> vs . append ( q2 ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> % calc_area ( vs ) <NEWLINE> <DEDENT>
<NL> cx1 , cy1 , r1 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> cx2 , cy2 , r2 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> <NL> import math <NEWLINE> distance = math . sqrt ( math . pow ( cx1 - cx2 , 2 ) + math . pow ( cy1 - cy2 , 2 ) ) <NEWLINE> rsum = r1 + r2 <NEWLINE> rmax = math . max ( r1 , r2 ) <NEWLINE> rmin = math . min ( r1 , r2 ) <NEWLINE> <NL> import sys <NEWLINE> if distance > rsum : <NEWLINE> <INDENT> print ( 4 ) <NEWLINE> <DEDENT> elif abs ( distance - rsum ) < sys . float_info . epsilon : <NEWLINE> <INDENT> print ( 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if rmax < distance + rmin : <NEWLINE> <INDENT> print ( 2 ) <NEWLINE> <DEDENT> elif abs ( rmax - distance - rmin ) < sys . float_info . epsilon : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import collections <NEWLINE> import math <NEWLINE> <NL> <NL> class Vector2 ( collections . namedtuple ( <STRING> , [ <STRING> , <STRING> ] ) ) : <NEWLINE> <NL> <INDENT> def __add__ ( self , other ) : <NEWLINE> <INDENT> return Vector2 ( self . x + other . x , self . y + other . y ) <NEWLINE> <NL> <DEDENT> def __sub__ ( self , other ) : <NEWLINE> <INDENT> return Vector2 ( self . x - other . x , self . y - other . y ) <NEWLINE> <NL> <DEDENT> def __mul__ ( self , scalar ) : <NEWLINE> <INDENT> return Vector2 ( self . x * scalar , self . y * scalar ) <NEWLINE> <NL> <DEDENT> def __neg__ ( self ) : <NEWLINE> <INDENT> return Vector2 ( - self . x , - self . y ) <NEWLINE> <NL> <DEDENT> def __pos__ ( self ) : <NEWLINE> <INDENT> return Vector2 ( + self . x , + self . y ) <NEWLINE> <NL> <DEDENT> def __abs__ ( self ) : <COMMENT> <NEWLINE> <INDENT> return math . sqrt ( float ( self . x * self . x + self . y * self . y ) ) <NEWLINE> <NL> <DEDENT> def __truediv__ ( self , scalar ) : <NEWLINE> <INDENT> return Vector2 ( self . x / scalar , self . y / scalar ) <NEWLINE> <NL> <DEDENT> def abs2 ( self ) : <NEWLINE> <INDENT> return float ( self . x * self . x + self . y * self . y ) <NEWLINE> <NL> <DEDENT> def dot ( self , other ) : <COMMENT> <NEWLINE> <INDENT> return self . x * other . x + self . y * other . y <NEWLINE> <NL> <DEDENT> def cross ( self , other ) : <COMMENT> <NEWLINE> <INDENT> return self . x * other . y - self . y * other . x <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def getDistanceSP ( segment , point ) : <NEWLINE> <INDENT> p = point <NEWLINE> p1 , p2 = segment <NEWLINE> if ( p2 - p1 ) . dot ( p - p1 ) < 0 : <NEWLINE> <INDENT> return abs ( p - p1 ) <NEWLINE> <DEDENT> if ( p1 - p2 ) . dot ( p - p2 ) < 0 : <NEWLINE> <INDENT> return abs ( p - p2 ) <NEWLINE> <DEDENT> return abs ( ( p2 - p1 ) . cross ( p - p1 ) ) / abs ( p2 - p1 ) <NEWLINE> <NL> <NL> <DEDENT> def getDistance ( s1 , s2 ) : <NEWLINE> <INDENT> a , b = s1 <NEWLINE> c , d = s2 <NEWLINE> if intersect ( s1 , s2 ) : <COMMENT> <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> return min ( getDistanceSP ( s1 , c ) , getDistanceSP ( s1 , d ) , getDistanceSP ( s2 , a ) , getDistanceSP ( s2 , b ) ) <NEWLINE> <NL> <NL> <DEDENT> def ccw ( p0 , p1 , p2 ) : <NEWLINE> <INDENT> a = p1 - p0 <NEWLINE> b = p2 - p0 <NEWLINE> if a . cross ( b ) > 0 : <NEWLINE> <INDENT> return 1 <COMMENT> <NEWLINE> <DEDENT> elif a . cross ( b ) < 0 : <NEWLINE> <INDENT> return - 1 <COMMENT> <NEWLINE> <DEDENT> elif a . dot ( b ) < 0 : <NEWLINE> <INDENT> return 2 <COMMENT> <NEWLINE> <DEDENT> elif abs ( a ) < abs ( b ) : <NEWLINE> <INDENT> return - 2 <COMMENT> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <COMMENT> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def intersect ( s1 , s2 ) : <NEWLINE> <INDENT> a , b = s1 <NEWLINE> c , d = s2 <NEWLINE> return ccw ( a , b , c ) * ccw ( a , b , d ) <= 0 and ccw ( c , d , a ) * ccw ( c , d , b ) <= 0 <NEWLINE> <NL> <NL> <DEDENT> def project ( l , p ) : <NEWLINE> <INDENT> p1 , p2 = l <NEWLINE> base = p2 - p1 <NEWLINE> hypo = p - p1 <NEWLINE> return p1 + base * ( hypo . dot ( base ) / abs ( base ) ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> class Circle ( ) : <NEWLINE> <INDENT> def __init__ ( self , c , r ) : <NEWLINE> <INDENT> self . c = c <NEWLINE> self . r = r <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def getCrossPoints ( c , l ) : <NEWLINE> <INDENT> pr = project ( l , c . c ) <NEWLINE> p1 , p2 = l <NEWLINE> e = ( p2 - p1 ) / abs ( p2 - p1 ) ) <NEWLINE> base = math . sqrt ( c . r * c . r - ( pr - c . c ) . abs2 ( ) ) <NEWLINE> return [ pr + e * base , pr - e * base ] <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> a , b , r = map ( int , input ( ) . split ( ) ) <NEWLINE> c = Circle ( Vector2 ( a , b ) , r ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> ps = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l = [ Vector2 ( ps [ 0 ] , ps [ 1 ] ) , Vector2 ( ps [ 2 ] , ps [ 3 ] ) ] <NEWLINE> <NL> ans = getCrossPoints ( c , l ) <NEWLINE> ans = sorted ( ans , key = lambda x : ( x . x , x . y ) ) <NEWLINE> print ( ans [ 0 ] . x , ans [ 0 ] . y , ans [ 1 ] . x , ans [ 1 ] . y ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> def dot ( a , b ) : <NEWLINE> <INDENT> return a . real * b . real + a . imag * b . imag <NEWLINE> <NL> <DEDENT> def projection ( p0 , p1 , p2 ) : <NEWLINE> <INDENT> a = p1 - p0 <NEWLINE> b = p2 - p0 <NEWLINE> pro = a * dot ( a , b ) / ( abs ( a ) ** 2 ) <NEWLINE> t = p0 + pro <NEWLINE> return t <NEWLINE> <NL> <DEDENT> def get_cross_point ( p0 , p1 , p2 ) : <NEWLINE> <INDENT> pro = projection ( p0 , p1 , p2 ) <NEWLINE> e = ( p1 - p0 ) / abs ( p1 - p0 ) <NEWLINE> base = math . sqrt ( r * r - ( abs ( pro - p2 ) ** 2 ) ) <NEWLINE> if pro - e * base . real == pro + e * base . real : <NEWLINE> <INDENT> ans1 = min ( pro - e * base , pro + e * base , key = lambda x : x . image ) <NEWLINE> ans2 = max ( pro - e * base , pro + e * base , key = lambda x : x . image ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ans1 = min ( pro - e * base , pro + e * base , key = lambda x : x . real ) <NEWLINE> ans2 = max ( pro - e * base , pro + e * base , key = lambda x : x . real ) <NEWLINE> <DEDENT> return ans1 . real , ans1 . imag , ans2 . real , ans2 . imag <NEWLINE> <NL> <NL> <DEDENT> cx , cy , r = map ( int , input ( ) . split ( ) ) <NEWLINE> p2 = complex ( cx , cy ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> x0 , y0 , x1 , y1 = map ( int , input ( ) . split ( ) ) <NEWLINE> p0 = complex ( x0 , y0 ) <NEWLINE> p1 = complex ( x1 , y1 ) <NEWLINE> print ( * get_cross_point ( p0 , p1 , p2 ) ) <NEWLINE> <DEDENT>
def calc_t ( i , j ) : <NEWLINE> <INDENT> global t , c <NEWLINE> if i < 0 or j < 0 : <NEWLINE> <INDENT> return n + 2 <NEWLINE> <COMMENT> <NL> <DEDENT> if t [ i ] [ j ] == n + 1 : <NEWLINE> <INDENT> t [ i ] [ j ] = min ( calc_t ( i - 1 , j ) , calc_t ( i , j - c [ i ] ) + 1 ) <NEWLINE> <DEDENT> return t [ i ] [ j ] <NEWLINE> <NL> <DEDENT> ri = raw_input ( ) . split ( <STRING> ) <NEWLINE> n = int ( ri [ 0 ] ) <NEWLINE> m = int ( ri [ 1 ] ) <NEWLINE> ri = raw_input ( ) . split ( <STRING> ) <NEWLINE> c = [ 0 ] * m <NEWLINE> t = [ 0 ] * m <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> c [ i ] = int ( ri [ i ] ) <NEWLINE> t [ i ] = [ 0 ] + [ n + 1 ] * n if i != 0 else range ( n + 1 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> print ( calc_t ( m - 1 , n ) ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> memo = [ - 1 ] * ( n + 1 ) <NEWLINE> def dfs ( rest ) : <NEWLINE> <INDENT> if memo [ rest ] != - 1 : <NEWLINE> <INDENT> return memo [ rest ] <NEWLINE> <DEDENT> if rest == 0 : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> res = n + 1 <NEWLINE> for i in xrange ( m ) : <NEWLINE> <INDENT> if c [ i ] <= rest : <NEWLINE> <INDENT> res = min ( res , 1 + dfs ( rest - c [ i ] ) ) <NEWLINE> <DEDENT> <DEDENT> memo [ rest ] = res <NEWLINE> return res <NEWLINE> <DEDENT> print dfs ( n ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c . reversed ( ) <NEWLINE> su = 0 <NEWLINE> for i in range ( b ) : <NEWLINE> <INDENT> if a >= c [ i ] : <NEWLINE> <INDENT> a %= c [ i ] <NEWLINE> su += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( su ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = map ( int , raw_input ( ) _split ( ) ) <NEWLINE> print 0 <NEWLINE>
def coin ( a , b , c ) : <NEWLINE> <NL> <INDENT> global count <NEWLINE> global m <NEWLINE> <NL> if a % c [ 0 ] == 0 : <NEWLINE> <NL> <INDENT> count = min ( count , b + a // c [ 0 ] ) <NEWLINE> <NL> return count <NEWLINE> <NL> <DEDENT> elif b + a // c [ 0 ] >= count : <NEWLINE> <NL> <INDENT> return n <NEWLINE> <NL> <DEDENT> elif c [ 0 ] < n : <NEWLINE> <NL> <INDENT> return min ( coin ( a - c [ 0 ] , b + 1 , c ) , coin ( a , b , c [ 1 : ] ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <NL> <INDENT> return coin ( a , b , c [ 1 : ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> money = sorted ( list ( map ( int , input ( ) . split ( ) ) ) , reverse = True ) <NEWLINE> <NL> count = n <NEWLINE> <NL> print ( coin ( n , 0 , money ) ) <NEWLINE> <NL>
n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> minimum = [ 50000 ] * ( n + 1 ) <NEWLINE> minimum [ 0 ] = 0 <NEWLINE> <NL> for i in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if c [ j ] <= 2 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( m ) : <NEWLINE> <INDENT> if c [ j ] <= i and minimum [ i - c [ j ] ] + 1 < minimum [ i ] : <NEWLINE> <INDENT> minimum [ i ] = minimum [ i - c [ j ] ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( minimum [ n ] ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dp = [ False for i in range ( n + 1 ) ] <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> if l [ i ] <= n : dp [ l [ i ] ] = True <NEWLINE> <DEDENT> cnt = 1 <NEWLINE> while 1 : <NEWLINE> <INDENT> if dp [ n ] : break <NEWLINE> ndp = [ False for i in range ( n + 1 ) ] <NEWLINE> for i in range ( n + 1 ) : <NEWLINE> <INDENT> if dp [ i ] : <NEWLINE> <INDENT> ndp [ i ] = True <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if i + l [ j ] <= n : ndp [ i + l [ j ] ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> cnt += 1 <NEWLINE> dp = ndp <NEWLINE> <DEDENT> print cnt <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dp = [ float ( <STRING> ) for i in range ( a + 2 ) ] <NEWLINE> <NL> for i in range ( n + 1 ) : <NEWLINE> <INDENT> for j in c : <NEWLINE> <INDENT> if i + j <= n : <NEWLINE> <INDENT> dp [ i + j ] = min ( dp [ i + j ] , dp [ i ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ a ] ) <NEWLINE> <NL> <NL>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> t = [ float ( <STRING> ) for i in range ( n + 1 ) ] <NEWLINE> t [ 0 ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> if c [ i ] > n : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for j in range ( c [ i ] , n + 1 ) : <NEWLINE> <INDENT> t [ j ] = min ( [ t [ j ] , t [ j - c [ i ] ] + 1 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print t [ n ] <NEWLINE>
currency = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> gra = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m ) ] <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <INDENT> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> gra [ i ] [ j ] = j <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if j >= currency [ i ] : <NEWLINE> <INDENT> gra [ i ] [ j ] = min ( gra [ i - 1 ] [ j ] , gra [ i ] [ j - currency [ i ] ] + 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> gra [ i ] [ j ] = gra [ i - 1 ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( gra [ m - 1 ] [ n ] ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> INF = 1000000000 <NEWLINE> <NL> t = [ INF ] * n <NEWLINE> t [ 0 ] = 0 <NEWLINE> <NL> for i in range ( m ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( c [ i ] , n ) : <NEWLINE> <INDENT> t [ j ] = min ( [ t [ j ] , t [ j - c [ i ] ] + 1 ] ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> print ( t [ n - 1 ] ) <NEWLINE> ~ <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ 0 ] * N ; w = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v [ i ] , w [ i ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> value = [ 0 for i in range ( W + 1 ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W + 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> if j < w [ i ] : <NEWLINE> <INDENT> value [ j ] = value [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value [ j ] = max ( value [ j ] , value [ j - w [ i ] ] + v [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( value [ W ] ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ 0 ] * - ~ W <NEWLINE> for _ in [ 0 ] * N : <NEWLINE> <INDENT> v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> t = v + C [ i - w ] <NEWLINE> if t > C [ i ] : C [ j ] = t <NEWLINE> <DEDENT> <DEDENT> print ( C [ W ] ) <NEWLINE>
n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> values = [ 0 ] <NEWLINE> weights = [ 0 ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> value , weight = map ( int , input ( ) . split ( ) ) <NEWLINE> values . append ( value ) <NEWLINE> weights . append ( weight ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for i in range ( w + 1 ) ] for j in range ( len ( values ) + 1 ) ] <NEWLINE> <NL> for i in range ( len ( values ) ) : <NEWLINE> <INDENT> for j in range ( w + 1 ) : <NEWLINE> <INDENT> if weights [ i ] <= j : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = max ( dp [ i ] [ j - weights [ i ] ] + values [ i ] , dp [ i ] [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ j ] = dp [ i ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ w + 1 ] ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> def knappack ( N , W , vs , ws ) : <NEWLINE> <INDENT> dp = [ 0 ] * ( W + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for j in range ( W , ws [ i ] - 1 , - 1 ) : <NEWLINE> <INDENT> dp [ j ] = max ( dp [ j ] , dp [ j - ws [ i ] ] + vs [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return dp [ - 1 ] <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> Nstr , Wstr = line . split ( ) <NEWLINE> N , W = int ( Nstr ) , int ( Wstr ) <NEWLINE> vs , ws = [ ] , [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> line = sys . stdin . readline ( ) <NEWLINE> v , w = line . split ( ) <NEWLINE> v , w = int ( v ) , int ( w ) <NEWLINE> vs . append ( v ) <NEWLINE> ws . append ( w ) <NEWLINE> <DEDENT> print str ( knappack ( N , W , vs , ws ) ) + <STRING> <NEWLINE> <DEDENT>
from sys import * <NEWLINE> <NL> def ans ( ) <NEWLINE> <INDENT> W = int ( input ( ) . split ( ) [ 1 ] ) <NEWLINE> C = [ 0 ] * - ~ W <NEWLINE> <NL> for e in stdin : <NEWLINE> <INDENT> v , w = map ( int , e . split ( ) ) <NEWLINE> <NL> <DEDENT> for i in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> t = v + C [ i - w ] <NEWLINE> <NL> <DEDENT> if t > C [ i ] : <NEWLINE> <INDENT> C [ i ] = t <NEWLINE> <NL> <DEDENT> print ( C [ W ] ) <NEWLINE> <NL> <DEDENT> ans ( ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ [ 0 ] * W for _ in range ( N + 1 ) ] <NEWLINE> weights = list ( ) <NEWLINE> values = list ( ) <NEWLINE> for _ in range ( N ) : <NEWLINE> <INDENT> w , v = map ( int , input ( ) . split ( ) ) <NEWLINE> weights . append ( w ) <NEWLINE> values . append ( v ) <NEWLINE> <NL> <DEDENT> for i in range ( N ) : <NEWLINE> <INDENT> for w in range ( W ) : <NEWLINE> <INDENT> if w >= weights [ i ] : <NEWLINE> <INDENT> dp [ i + 1 ] [ w ] = max ( dp [ i ] [ w - weights [ i ] ] + values [ i ] , dp [ i ] [ w ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i + 1 ] [ w ] = dp [ i ] [ w ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ n ] [ W ] ) <NEWLINE>
<COMMENT> <NL> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> dp = [ [ 0 for i in range ( W + 1 ) ] for j in range ( N + 1 ) ] <NEWLINE> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> value = [ ] <NEWLINE> weight = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> value . append ( v ) <NEWLINE> weight . append ( w ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for j in range ( W + 1 ) : <NEWLINE> <INDENT> if j >= weight [ i - 1 ] : <COMMENT> <NEWLINE> <INDENT> dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , value [ i - 1 ] + dp [ i - 1 ] [ j - weight [ i - 1 ] ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp [ i ] [ j ] = dp [ i - 1 ] [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ N + 1 ] [ W + 1 ] ) <NEWLINE>
<COMMENT> <NL> N , W = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> items = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> items . append ( tuple ( int ( x ) for x in input ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> DP = [ 0 ] * ( W + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v , w = items [ i ] <NEWLINE> for j in range ( W , w - 1 , - 1 ) : <NEWLINE> <INDENT> DP [ j ] = max ( DP [ j ] , v + DP [ j - w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( DP [ - 1 ] [ - 1 ] ) <NEWLINE>
N , W = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> v = [ 0 ] * N <NEWLINE> w = [ 0 ] * N <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> v [ i ] , w [ i ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <NL> <DEDENT> def rec ( i , j ) : <NEWLINE> <INDENT> if i == N : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> elif j < w [ i ] : <NEWLINE> <INDENT> res = rec ( i + 1 , j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = max ( rec ( i + 1 , j ) , rec ( i + 1 , j - w [ i ] ) + v [ i ] ) <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <DEDENT> print ( rec ( 0 , W ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> n , w = map ( int , input ( ) . split ( ) ) <NEWLINE> v = [ 0 ] * ( n + 1 ) <NEWLINE> w = [ 0 ] * ( n + 1 ) <NEWLINE> <NL> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> v [ j ] , w [ j ] = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> dp = [ [ 0 for i in range ( w + 1 ) ] for j in range ( n + 1 ) ] <NEWLINE> <NL> for j in range ( 1 , n + 1 ) : <NEWLINE> <INDENT> for i in range ( 1 , w + 1 ) : <NEWLINE> <INDENT> dp [ j ] [ i ] = max ( dp [ j - 1 ] [ i ] , dp [ j - 1 ] [ i - w [ j ] ] + v [ i ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( max ( dp ) ) <NEWLINE>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp [ ] = [ 0 ] * ( W + 1 ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> n , m = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( W , m - 1 , - 1 ) : <NEWLINE> <INDENT> x = n + dp [ j - m ] <NEWLINE> if x >= dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ W ] ) <NEWLINE>
<COMMENT> <NL> def ramp ( t ) : <NEWLINE> <INDENT> if t >= 0 : <NEWLINE> <INDENT> return t <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> <DEDENT> def heav ( t ) : <NEWLINE> <INDENT> if t >= 0 : <NEWLINE> <INDENT> return ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( 0 ) <NEWLINE> <DEDENT> <DEDENT> N , W = map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> lst = [ ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> l = list ( map ( int , input ( ) . strip ( ) . split ( <STRING> ) ) ) <COMMENT> <NEWLINE> lst . append ( l ) <NEWLINE> <DEDENT> table = [ [ 0 for c in range ( W + 1 ) ] for i in range ( N + 1 ) ] <NEWLINE> for i in range ( 1 , N + 1 ) : <NEWLINE> <INDENT> for c in range ( 1 , W + 1 ) : <NEWLINE> <INDENT> table [ i ] [ c ] = max ( table [ i - 1 ] [ c ] , table [ i - 1 ] [ sgn ( c - lst [ i - 1 ] [ 1 ] ) ] + lst [ i - 1 ] [ 0 ] * heav ( c - lst [ i - 1 ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> print ( table [ N ] [ W ] ) <NEWLINE>
l = [ ] <NEWLINE> n , W = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> W = int ( W ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> item = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> l . append ( [ item [ 1 ] , item [ 0 ] ] ) <NEWLINE> <NL> <DEDENT> dp = [ [ False for j in range ( W ) + 1 ] for i in range ( n ) ] <NEWLINE> <NL> print ( dp ) <NEWLINE> def solve ( i , w ) : <NEWLINE> <INDENT> if dp [ i ] [ w ] == False : <NEWLINE> <INDENT> if i == n : <NEWLINE> <INDENT> res = ( 0 ) <NEWLINE> <DEDENT> elif w - l [ i ] [ 0 ] < 0 : <NEWLINE> <INDENT> res = ( solve ( i + 1 , w ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = solve ( i + 1 , w ) <NEWLINE> b = l [ i ] [ 1 ] + solve ( i + 1 , w - l [ i ] [ 0 ] ) <NEWLINE> if b > a : <NEWLINE> <INDENT> res = ( b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = ( a ) <NEWLINE> <DEDENT> <DEDENT> dp [ i ] [ w ] = res <NEWLINE> return ( res ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( dp [ i ] [ w ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( solve ( 0 , W ) ) <NEWLINE>
<NL> <NL> <NL> def dp ( i , j ) : <NEWLINE> <INDENT> if dp_list [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> return dp_list [ i ] [ j ] <NEWLINE> <DEDENT> if i == len ( lists ) : <NEWLINE> <INDENT> return 0 <NEWLINE> <DEDENT> if j < lists [ i ] [ 1 ] : <NEWLINE> <INDENT> dp_list [ i ] [ j ] = dp ( i + 1 , j ) <NEWLINE> return dp_list [ i ] [ j ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dp_list [ i ] [ j ] = max ( dp ( i + 1 , j ) , dp ( i + 1 , j - lists [ i ] [ 1 ] ) + lists [ i ] [ 0 ] ) <NEWLINE> return dp_list [ i ] [ j ] <NEWLINE> <NL> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> N , W = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> lists = [ ] <NEWLINE> for i in N : <NEWLINE> <INDENT> lists += list ( lambda x : int ( x ) , input ( ) . split ( ) ) <NEWLINE> <DEDENT> dp_list = [ [ - 1 ] * ( W + 1 ) ] * ( N + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <NL> print ( dp ( 0 , W ) ) <NEWLINE> <NL>
N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] * ( W + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( b , W + 1 , b ) : <NEWLINE> <INDENT> x = a + dp [ j - b ] <NEWLINE> if x >= dp [ j ] : <NEWLINE> <INDENT> dp [ j ] = x <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ W + 1 ] ) <NEWLINE> <NL>
<INDENT> N , W = map ( int , input ( ) . split ( ) ) <NEWLINE> dp = [ 0 ] + [ - 1 ] * ( W + 1 ) <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> v , w = map ( int , input ( ) . split ( ) ) <NEWLINE> for j in range ( 0 , W - w + 1 ) : <NEWLINE> <INDENT> if dp [ j ] > - 1 and dp [ j + w ] < dp [ j ] + v : <NEWLINE> <INDENT> dp [ j + w ] = dp [ j ] + v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( max ( dp ) ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> <NL> n , total_wait = map ( int , readline ( ) . split ( ) ) <NEWLINE> value_wait = [ list ( map ( int , readline ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> value_wait . sort ( key = operator . itemgetter ( 1 ) , reverse = True ) <NEWLINE> <NL> dp = [ 0 ] * ( total_wait + 1 ) <NEWLINE> <NL> for ni , ( v , w ) in enumerate ( value_wait ) : <NEWLINE> <INDENT> for tw in range ( w , total_wait + 1 ) : <NEWLINE> <INDENT> if dp [ tw ] < dp [ tw - w ] + v : <NEWLINE> <INDENT> dp [ tw ] = dp [ tw - w ] + v <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] ) <NEWLINE>
import bisect <NEWLINE> a = int ( input ( ) ) <NEWLINE> b = [ int ( input ( ) ) in d in range ( a ) ] <NEWLINE> c = [ b [ 1 ] ] <NEWLINE> for i in b [ 1 : ] : <NEWLINE> <INDENT> if c [ - 1 ] < i : <NEWLINE> <INDENT> c . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c [ bisect . bisect_left ( c , i ) ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> print ( len ( c ) ) <NEWLINE>
from bisect import bisect_left <NEWLINE> import sys <NEWLINE> n = int ( input ( ) ) <NEWLINE> A = [ int ( i . rstrip ( <STRING> ) ) for i in sys . stdin . readlines ( ) ] <NEWLINE> <NL> def LIS ( ) : <NEWLINE> <INDENT> L = A [ : 1 ] <NEWLINE> for i in A [ 1 : ] : <NEWLINE> <INDENT> if L [ - 1 ] < i : <NEWLINE> <INDENT> L . append ( i ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ j ] = i <NEWLINE> <DEDENT> <DEDENT> return len ( L ) <NEWLINE> <NL> <DEDENT> print ( LIS ( ) ) <NEWLINE>
def _input ( n ) : <NEWLINE> <INDENT> return [ int ( raw_input ( ) ) for i in xrange ( n ) ] <NEWLINE> <NL> <DEDENT> def LIS ( arr ) : <NEWLINE> <INDENT> arr = [ 0 ] + arr <NEWLINE> L = [ 0 ] + [ 0 ] * len ( arr ) <NEWLINE> P = [ - 1 ] + [ 0 ] * len ( arr ) <NEWLINE> <NL> for i in xrange ( 1 , len ( arr ) ) : <NEWLINE> <INDENT> k = 0 <NEWLINE> for j in xrange ( 0 , i ) : <NEWLINE> <INDENT> if arr [ j ] < arr [ i ] and L [ j ] > L [ k ] : <NEWLINE> <INDENT> k = j <NEWLINE> <DEDENT> <DEDENT> L [ i ] = L [ k ] + 1 <NEWLINE> P [ i ] = k <NEWLINE> <NL> <DEDENT> return max ( L ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> arr = _input ( n ) <NEWLINE> print LIS ( arr ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import bisect <NEWLINE> def lis ( A ) : <NEWLINE> <INDENT> n = len ( A ) <NEWLINE> L = [ 0 ] * n <NEWLINE> L [ 0 ] = A [ 0 ] <NEWLINE> length = 1 <NEWLINE> <NL> for i in xrange ( 1 , n ) : <NEWLINE> <INDENT> if L [ length - 1 ] < A [ i ] : <NEWLINE> <INDENT> L [ length ] = A [ i ] <NEWLINE> length += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> L [ bisect . bisect_left ( L , A [ i ] ) ] = A [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> return length <NEWLINE> <NL> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> a = [ int ( raw_input ( ) ) for i in xrange ( n ) ] <NEWLINE> print lis ( a ) <NEWLINE>
from bisect import * <NEWLINE> n = input ( ) <NEWLINE> dp = [ n + 1 ] * ( n + 1 ) <NEWLINE> dp [ 0 ] = - 1 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> idx = bisect ( dp , a - 1 ) <NEWLINE> dp [ idx ] = min ( a , dp [ idx ] ) <NEWLINE> <DEDENT> print bisect ( dp , n ) - 1 <NEWLINE>
n = int ( input ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( int ( input ( ) ) ) <NEWLINE> <NL> <NL> <DEDENT> dp = [ 0 for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> dp [ i ] = 1 <NEWLINE> for j in range ( i ) : <NEWLINE> <INDENT> if arr [ i ] > arr [ j ] : <NEWLINE> <INDENT> dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print max ( dp ) <NEWLINE> <NL>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> <NL> if len ( a ) == 0 or len ( b ) == 0 : <NEWLINE> <INDENT> print ( max ( len ( a ) , len ( b ) ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp = [ [ None for i in range ( len ( b ) + 1 ) ] for j in range ( len ( a ) + 1 ) ] <NEWLINE> for i in range ( len ( a ) + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = i <NEWLINE> <DEDENT> for i in range ( len ( b ) + 1 ) : <NEWLINE> <INDENT> dp [ 0 ] [ i ] = i <NEWLINE> <NL> <DEDENT> for i in range ( len ( a ) + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( b ) + 1 ) : <NEWLINE> <INDENT> aaa = dp [ i - 1 ] [ j - 1 ] if a [ i - 1 ] == b [ j - 1 ] else dp [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> dp [ i ] [ j ] = min ( aaa , dp [ i - 1 ] [ j ] + 1 , dp [ i ] [ j - 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE>
s1 = raw_input ( ) <NEWLINE> s2 = raw_input ( ) <NEWLINE> <NL> a = [ [ 0 for i in range ( len ( s1 ) + 1 ) ] for i in range ( len ( s2 ) + 1 ) ] <NEWLINE> for i in range ( len ( s1 ) + 1 ) : <NEWLINE> <INDENT> a [ 0 ] [ i ] = i <NEWLINE> <DEDENT> for i in range ( len ( s2 ) + 1 ) : <NEWLINE> <INDENT> a [ i ] [ 0 ] = i <NEWLINE> <DEDENT> for i in range ( len ( s2 ) ) : <NEWLINE> <INDENT> for j in range ( len ( s1 ) ) : <NEWLINE> <INDENT> if s1 [ i ] == s2 [ j ] : <NEWLINE> <INDENT> a [ j + 1 ] [ i + 1 ] = a [ j ] [ i ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ j + 1 ] [ i + 1 ] = min ( [ a [ j ] [ i + 1 ] , a [ j + 1 ] [ i ] ) + 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print a [ len ( s2 ) ] [ len ( s1 ) ] <NEWLINE>
def L_common ( str1 , str2 ) : <NEWLINE> <INDENT> d = [ 0 for i in range ( len ( str2 ) + 1 ) ] <NEWLINE> <NL> for n1 in str1 : <NEWLINE> <INDENT> tmp = d [ : ] <NEWLINE> for ( j , n2 ) in enumerate ( str2 ) : <NEWLINE> <INDENT> if n1 == n2 : <NEWLINE> <INDENT> d [ j + 1 ] = tmp [ j ] + 1 <NEWLINE> <DEDENT> elif d [ j + 1 ] < d [ j ] : <NEWLINE> <INDENT> d [ j + 1 ] = d [ j ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d [ len ( str2 ) ] <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> stock = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> if len ( x ) > len ( y ) : <NEWLINE> <INDENT> stock . append ( len ( x ) - L_common ( x , y ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> stock . append ( len ( y ) - L_common ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in stock : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
def search ( X , Y ) : <NEWLINE> <NL> <INDENT> n = len ( X ) <NEWLINE> m = len ( Y ) <NEWLINE> p = [ i for i in range ( m + 1 ) ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> q = list ( range ( m + 1 ) ) <NEWLINE> q [ 0 ] = i + 1 <NEWLINE> for j in range ( m ) : <NEWLINE> <INDENT> if X [ i ] == Y [ j ] : <NEWLINE> <INDENT> cost = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> cost = 1 <NEWLINE> <DEDENT> q [ j + 1 ] = min ( p [ j + 1 ] + 1 , q [ j ] + 1 , p [ j ] + cost ) <NEWLINE> <DEDENT> p , q = q , p <NEWLINE> <NL> <DEDENT> return pre [ m ] <NEWLINE> <NL> <NL> <DEDENT> X = input ( ) <NEWLINE> Y = input ( ) <NEWLINE> <NL> print ( search ( X , Y ) ) <NEWLINE> <NL>
<COMMENT> <NL> import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 9 ) <NEWLINE> input = sys . stdin . readline <NEWLINE> <NL> <NL> def leven ( s1 , s2 ) : <NEWLINE> <INDENT> n1 = len ( s1 ) <NEWLINE> n2 = len ( s2 ) <NEWLINE> dp = [ [ 0 ] * ( n1 + 1 ) for _ in range ( n2 + 1 ) ] <NEWLINE> <NL> for i in range ( 1 , n1 + 1 ) : <NEWLINE> <INDENT> dp [ 0 ] [ i ] = i <NEWLINE> <DEDENT> for i in range ( 1 , n2 + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = i <NEWLINE> <NL> <DEDENT> for j in range ( 1 , n2 + 1 ) : <NEWLINE> <INDENT> for k in range ( 1 , n1 + 1 ) : <NEWLINE> <INDENT> m = min ( dp [ j - 1 ] [ k ] + 1 , dp [ j ] [ k - 1 ] ) <NEWLINE> if s1 [ j - 1 ] == s2 [ k - 1 ] : <COMMENT> <NEWLINE> <INDENT> m = min ( m , dp [ j - 1 ] [ k - 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = min ( m , dp [ j - 1 ] [ k - 1 ] + 1 ) <NEWLINE> <DEDENT> dp [ j ] [ k ] = m <NEWLINE> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE> <NL> <NL> <DEDENT> s1 = input ( ) [ : - 1 ] <NEWLINE> s2 = input ( ) [ : - 1 ] <NEWLINE> leven ( s1 , s2 ) <NEWLINE> <NL>
a = list ( input ( ) ) <NEWLINE> b = list ( input ( ) ) <NEWLINE> <NL> if len ( a ) == 0 or len ( b ) == 0 : <NEWLINE> <INDENT> print ( max ( len ( a ) , len ( b ) ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> dp = [ [ None for i in range ( len ( b ) + 1 ) ] for j in range ( len ( a ) + 1 ) ] <NEWLINE> for i in range ( len ( a ) + 1 ) : <NEWLINE> <INDENT> dp [ i ] [ 0 ] = i <NEWLINE> <DEDENT> for i in range ( len ( b ) + 1 ) : <NEWLINE> <INDENT> dp [ 0 ] [ i ] = i <NEWLINE> <NL> <DEDENT> for i in range ( 1 , len ( a ) + 1 ) : <NEWLINE> <INDENT> for j in range ( len ( b ) + 1 ) : <NEWLINE> <INDENT> aaa = dp [ i - 1 ] [ j - 1 ] if a [ i - 1 ] == b [ j - 1 ] else dp [ i - 1 ] [ j - 1 ] + 1 <NEWLINE> dp [ i ] [ j ] = min ( aaa , dp [ i - 1 ] [ j ] + 1 , dp [ i ] [ j - 1 ] + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( dp [ - 1 ] [ - 1 ] ) <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> V , E = map ( int , readline ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in xrange ( V ) ] <NEWLINE> cost = { } <NEWLINE> to = [ 0 ] * V <NEWLINE> for i in xrange ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , readline ( ) . split ( ) ) <NEWLINE> g [ s ] . append ( ( t , d ) ) <NEWLINE> cost [ s , t ] = d <NEWLINE> to [ s ] |= 1 << t <NEWLINE> <DEDENT> get = cost . get <NEWLINE> INF = 10 ** 9 <NEWLINE> ALL = 2 ** V - 1 <NEWLINE> dp = { } <NEWLINE> start = - 1 <NEWLINE> def dfs ( state , v ) : <NEWLINE> <INDENT> key = ( state , v ) <NEWLINE> if key in dp : return dp [ key ] <NEWLINE> if state == ALL : <NEWLINE> <INDENT> res = get ( ( v , start ) , INF ) <NEWLINE> dp [ key ] = res <NEWLINE> return res <NEWLINE> <DEDENT> if state & to [ v ] != to [ v ] : <NEWLINE> <INDENT> res = min ( ( dfs ( state | ( 1 << t ) , t ) + d for t , d in g [ v ] if not state & ( 1 << t ) ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> res = INF <NEWLINE> <DEDENT> dp [ key ] = res <NEWLINE> return res <NEWLINE> <DEDENT> def solve ( v ) : <NEWLINE> <INDENT> global dp , start <NEWLINE> dp = { } <NEWLINE> start = v <NEWLINE> return dfs ( 1 << v , v ) <NEWLINE> <DEDENT> res = min ( solve ( v ) for v in xrange ( V ) ) <NEWLINE> print res if res < INF else - 1 <NEWLINE>
def warshall_floyd ( distance_table , point_size ) : <NEWLINE> <INDENT> for k in range ( point_size ) : <NEWLINE> <INDENT> for i in range ( point_size ) : <NEWLINE> <INDENT> for j in range ( point_size ) : <NEWLINE> <INDENT> if distance_table [ i ] [ j ] > distance_table [ i ] [ k ] + distance_table [ k ] [ j ] : <NEWLINE> <INDENT> distance_table [ i ] [ j ] = distance_table [ i ] [ k ] + distance_table [ k ] [ j ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> class bit : <NEWLINE> <INDENT> def __createtable ( ) : <NEWLINE> <INDENT> table = [ None ] * 64 <NEWLINE> mask64 = ( 1 << 64 ) - 1 <NEWLINE> hash = 0x03F566ED27179461 <NEWLINE> for i in range ( 64 ) : <NEWLINE> <INDENT> table [ hash >> 58 ] = i <NEWLINE> hash = ( hash << 1 ) & mask64 <NEWLINE> <DEDENT> return table <NEWLINE> <NL> <DEDENT> __table = __createtable ( ) <NEWLINE> <NL> def number_of_trailing_zeros ( x ) : <NEWLINE> <INDENT> if x == 0 : return 64 <NEWLINE> mask64 = ( 1 << 64 ) - 1 <NEWLINE> return bit . __table [ ( ( bit . lowest_one ( x ) * 0x03F566ED27179461 ) & mask64 ) >> 58 ] <NEWLINE> <NL> <DEDENT> def lowest_one ( i ) : <NEWLINE> <INDENT> return i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> def ccp ( distance_table , point_size , v ) : <NEWLINE> <INDENT> if v : <NEWLINE> <INDENT> i = bit . number_of_trailing_zeros ( v ) <NEWLINE> v ^= ( 1 << i ) <NEWLINE> return min ( ccp ( distance_table , point_size , v ^ ( 1 << j ) ) + distance_table [ i ] [ j ] for j in range ( point_size ) if v & 1 << j ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> point_size , e = map ( int , readline ( ) . split ( ) ) <NEWLINE> distance_table = [ [ float ( <STRING> ) ] * point_size for _ in range ( point_size ) ] <NEWLINE> cost = 0 <NEWLINE> v = 0 <NEWLINE> for _ in range ( e ) : <NEWLINE> <INDENT> s , t , d = map ( int , readline ( ) . split ( ) ) <NEWLINE> distance_table [ s ] [ t ] = min ( distance_table [ s ] [ t ] , d ) <NEWLINE> distance_table [ t ] [ s ] = min ( distance_table [ t ] [ s ] , d ) <NEWLINE> v ^= 1 << s ^ 1 << t <NEWLINE> cost += d <NEWLINE> <NL> <DEDENT> warshall_floyd ( distance_table , point_size ) <NEWLINE> print ( cost + ccp ( distance_table , point_size , v ) ) <NEWLINE>
from collections import defaultdict <NEWLINE> <NL> v , e = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> links = [ defaultdict ( int ) for _ in range ( v ) ] <NEWLINE> bests = [ None ] * ( 1 << v ) <NEWLINE> <NL> for _ in range ( e ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> links [ s ] [ t ] = max ( links [ s ] [ t ] , d ) <NEWLINE> <NL> <DEDENT> bests [ 0 ] = { 0 : 0 } <NEWLINE> <NL> for visited , best in enumerate ( bests ) : <NEWLINE> <INDENT> if best is None : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for last , cost in best . items ( ) : <NEWLINE> <INDENT> for t , d in links [ last ] . items ( ) : <NEWLINE> <INDENT> new_visited = visited | ( 1 << t ) <NEWLINE> if visited == new_visited : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> new_best = bests [ new_visited ] <NEWLINE> if new_best is None : <NEWLINE> <INDENT> bests [ new_visited ] = defaultdict ( lambda : 15001 , [ ( t , cost + d ) ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> new_best [ t ] = min ( new_best [ t ] , cost + d ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( bests [ - 1 ] [ 0 ] ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> H , W = map ( int , input ( ) . split ( ) ) <NEWLINE> C = [ ] <NEWLINE> dp = [ ] <NEWLINE> for i in range ( H ) : <NEWLINE> <INDENT> l = input ( ) . split ( ) <NEWLINE> C . append ( [ int ( x ) for x in l ] ) <NEWLINE> dp . append ( [ ( int ( x ) + 1 ) % 2 for x in l ] ) <NEWLINE> <NL> <DEDENT> max_width = 1 <NEWLINE> for i in range ( 1 , H ) : <NEWLINE> <INDENT> for j in range ( 1 , W ) : <NEWLINE> <INDENT> if C [ i ] [ j ] == 0 : <NEWLINE> <INDENT> dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] , <NEWLINE> <INDENT> dp [ i - 1 ] [ j - 1 ] ) + 1 <NEWLINE> <DEDENT> max_width = max ( max_width , dp [ i ] [ j ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( max_width ** 2 ) <NEWLINE> <DEDENT> s <NEWLINE>
class LargestSquare ( ) : <NEWLINE> <INDENT> def __init__ ( self , map ) : <NEWLINE> <INDENT> self . max_width = 0 <NEWLINE> self . map = [ ] <NEWLINE> self . dp = [ ] <NEWLINE> for r in map : <NEWLINE> <INDENT> self . dp . append ( [ int ( ( x == 0 ) ) for x in r ] ) <NEWLINE> self . map . append ( r [ : ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self ) : <NEWLINE> <INDENT> for row in range ( 1 , len ( self . dp ) ) : <NEWLINE> <INDENT> for col in range ( 1 , len ( self . dp [ 0 ] ) ) : <NEWLINE> <INDENT> if self . map [ row ] [ col ] == 1 : <NEWLINE> <INDENT> self . dp [ row ] [ col ] = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . dp [ row ] [ col ] = min ( self . dp [ row - 1 ] [ col - 1 ] , min ( self . dp [ row - 1 ] [ col ] , self . dp [ row ] [ col - 1 ] ) ) + 1 <NEWLINE> self . max_width = max ( self . max_width , self . dp [ row ] [ col ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return self . max_width * self . max_width <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> f = open ( <STRING> ) <NEWLINE> height , width = [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( <STRING> ) ] <NEWLINE> map = [ ] <NEWLINE> for _ in range ( height ) : <NEWLINE> <INDENT> map . append ( [ int ( x ) for x in f . readline ( ) . strip ( ) . split ( <STRING> ) ] ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> S = LargestSquare ( map ) <NEWLINE> result = S . find ( ) <NEWLINE> <NL> <COMMENT> <NL> print ( result ) <NEWLINE> <DEDENT>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> _input = sys . stdin . readlines ( ) <NEWLINE> if len ( _input ) < 2 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> n = int ( _input [ 0 ] ) <NEWLINE> li = list ( map ( int , _input [ 1 ] ) ) <NEWLINE> def largest_histogram ( histogram ) : <NEWLINE> <INDENT> if len ( histogram ) == 0 : return 0 <NEWLINE> histogram = list ( histogram ) <NEWLINE> max_h = max ( n , max ( histogram ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( 2 , histogram [ i ] + 1 ) : <NEWLINE> <INDENT> m = 1 <NEWLINE> for k in range ( i + 1 , n ) : <NEWLINE> <INDENT> if histogram [ k ] >= j : <NEWLINE> <INDENT> m += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if max_h < j * m : <NEWLINE> <INDENT> max_h = j * m <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return max_h <NEWLINE> <DEDENT> print ( largest_histogram ( li ) ) <NEWLINE>
import sys <NEWLINE> from collections import defaultdict <NEWLINE> <NL> <NL> def read ( ) : <NEWLINE> <INDENT> n , v = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> a = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> b = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> c = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> d = tuple ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> read ( ) <NEWLINE> mp = defaultdict ( int ) <NEWLINE> for val1 in c : <NEWLINE> <INDENT> for val2 in d : <NEWLINE> <INDENT> mp [ val1 + val2 ] += 1 <NEWLINE> <DEDENT> <DEDENT> print ( sum ( mp [ v - val1 - val2 ] for val1 in a for val2 in b ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
from collections import Counter <NEWLINE> <NL> N , V = map ( int , input ( ) . split ( ) ) <NEWLINE> cnt = 0 <NEWLINE> <NL> a = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> b = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d = tuple ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ab = Counter ( ai + bi for ai in a for bi in b ) <NEWLINE> cd = Counter ( ci + di for ci in c for di in d ) <NEWLINE> <NL> cnt = sum ( ab [ v - i ] * t for i , t in cd . items ( ) if v - i in ab ) <NEWLINE> <NL> print ( cnt ) <NEWLINE>
<NL> <COMMENT> <NL> <COMMENT> <NL> import math <NEWLINE> <NL> n , k = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> def comb1 ( n , r ) : <NEWLINE> <INDENT> if n == 0 or r == 0 : return 1 <NEWLINE> return ( comb1 ( n , r - 1 ) * ( n - r + 1 ) / r ) % 1000000007 <NEWLINE> <NL> <DEDENT> ans = ( comb ( k , n ) ) % 1000000007 <NEWLINE> print ( ans ) <NEWLINE>
n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> arr = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> arr . append ( i ) <NEWLINE> <NL> <DEDENT> def root ( i ) : <NEWLINE> <INDENT> t = i <NEWLINE> while arr [ t ] != t : <NEWLINE> <INDENT> t = arr [ t ] <NEWLINE> <NL> <DEDENT> return t <NEWLINE> <NL> <DEDENT> for i in range ( m ) : <NEWLINE> <INDENT> query , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if query == 0 : <NEWLINE> <INDENT> arr [ root ( y ) ] = x <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print 1 if root ( x ) == root ( y ) else 0 <NEWLINE> <DEDENT> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . rank = [ 0 ] * size <NEWLINE> self . par = range ( size ) <NEWLINE> self . g_num = size <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if x == self . par [ x ] : return x <NEWLINE> self . par [ x ] = self . find ( self . par [ x ] ) <NEWLINE> return self . par [ x ] <NEWLINE> <NL> def same ( self , x , y ) : <NEWLINE> return self . find ( x ) == self . find ( y ) <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> x , y = self . find ( x ) , self . find ( y ) <NEWLINE> if x == y : return <NEWLINE> <NL> self . g_num -= 1 <NEWLINE> if ( self . rank [ x ] > self . rank [ y ] ) : <NEWLINE> <INDENT> self . par [ y ] = x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . par [ x ] = y <NEWLINE> if ( self . rank [ x ] == self . rank [ y ] ) : self . rank [ y ] += 1 <NEWLINE> <NL> def group_num ( self ) : <NEWLINE> <DEDENT> return self . g_num <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> uf = UnionFind ( n ) <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> c , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if c == 0 : uf . unite ( x , y ) <NEWLINE> else : print int ( uf . same ( x , y ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> f_i = sys . stdin <NEWLINE> <NL> n , q = map ( int , f_i . readline ( ) . split ( ) ) <NEWLINE> <NL> S = set ( [ frozenset ( [ i ] ) for i in range ( n ) ] ) <NEWLINE> <NL> def unite ( sets , v1 , v2 ) : <NEWLINE> <INDENT> s1 = None <NEWLINE> s2 = None <NEWLINE> for s in sets : <NEWLINE> <INDENT> if v1 in s and v2 in s : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> elif v1 in s : <NEWLINE> <INDENT> s1 = s <NEWLINE> <DEDENT> elif v2 in s : <NEWLINE> <INDENT> s2 = s <NEWLINE> <DEDENT> if s1 and s2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> sets . discard ( s1 ) <NEWLINE> sets . discard ( s2 ) <NEWLINE> s3 = s1 . union ( s2 ) <NEWLINE> sets . update ( s3 ) <NEWLINE> <NL> <DEDENT> def same ( sets , v1 , v2 ) : <NEWLINE> <INDENT> for s in sets : <NEWLINE> <INDENT> if v1 in s and v2 in s : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> break <NEWLINE> <DEDENT> elif v1 in s or v2 in s : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for l in f_i : <NEWLINE> <INDENT> com , x , y = map ( int , l . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> unite ( S , x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> same ( S , x , y ) <NEWLINE> <DEDENT> <DEDENT>
class node : <NEWLINE> <INDENT> def __init__ ( self , parent ) : <NEWLINE> <INDENT> self . parent = parent <NEWLINE> <NL> <DEDENT> <DEDENT> def findset ( x ) : <NEWLINE> <INDENT> global nodes <NEWLINE> if nodes [ x ] . parent == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nodes [ x ] . parent = findset ( nodes [ x ] . parent ) <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> global rank , nodes <NEWLINE> findset ( x ) <NEWLINE> findset ( y ) <NEWLINE> if rank [ nodes [ x ] . parent ] < rank [ nodes [ y ] . parent ] : <NEWLINE> <INDENT> nodes [ nodes [ x ] . parent ] . parent = nodes [ nodes [ y ] . parent ] . parent <NEWLINE> <DEDENT> elif rank [ nodes [ x ] . parent ] == rank [ nodes [ y ] . parent ] : <NEWLINE> <INDENT> nodes [ nodes [ x ] . parent ] . parent = nodes [ nodes [ y ] . parent ] . parent <NEWLINE> rank [ y ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> nodes [ nodes [ y ] . parent ] . parent = nodes [ nodes [ x ] . parent ] . parent <NEWLINE> <NL> <DEDENT> <DEDENT> def same ( x , y ) : <NEWLINE> <INDENT> global nodes <NEWLINE> findset ( x ) <NEWLINE> findset ( y ) <NEWLINE> if nodes [ x ] . parent == nodes [ y ] . parent : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rank = [ 0 ] * n <NEWLINE> nodes = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> fac = node ( i ) <NEWLINE> nodes . append ( fac ) <NEWLINE> <DEDENT> for i in xrange ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> unite ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> same ( x , y ) <NEWLINE> <DEDENT> <DEDENT>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . parent = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> self . parent [ i ] = i <NEWLINE> <NL> <DEDENT> <DEDENT> def get_root ( self , x ) : <NEWLINE> <INDENT> r = x <NEWLINE> depth = 0 <NEWLINE> while self . parent [ r ] != r : <NEWLINE> <INDENT> r = self . parent [ r ] <NEWLINE> depth += 1 <NEWLINE> <DEDENT> return r , depth <NEWLINE> <NL> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> rx , dx = self . get_root ( x ) <NEWLINE> ry , dy = self . get_root ( y ) <NEWLINE> if rx != ry : <NEWLINE> <INDENT> if dx > dy : <NEWLINE> <INDENT> self . parent [ ry ] = rx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . parent [ rx ] = ry <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , x , y ) : <NEWLINE> <INDENT> rx , _ = self . get_root ( x ) <NEWLINE> ry , _ = self . get_root ( y ) <NEWLINE> if rx == ry : return 1 <NEWLINE> else : return 0 <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , q = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> tree = UnionFind ( n ) <NEWLINE> <NL> answers = [ ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> tree . unite ( x , y ) <NEWLINE> <DEDENT> elif com == 1 : <NEWLINE> <INDENT> answers . append ( tree . same ( x , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> for a in answers : <NEWLINE> <INDENT> print a <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> ds = DisjointSet ( n ) <NEWLINE> <NL> for i in xrange ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if com : <NEWLINE> <INDENT> if ds . root [ x ] == ds . root [ y ] : <NEWLINE> <INDENT> print 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print 0 <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> ds . unite ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> class DisjointSet ( ) : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . n = n <NEWLINE> self . root = range ( n ) <NEWLINE> self . parent = [ - 1 ] * n <NEWLINE> self . rank = [ 0 ] * n <NEWLINE> <NL> <DEDENT> def findSet ( self , x ) : <NEWLINE> <INDENT> if self . parent [ x ] == - 1 : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> p = self . findSet ( self . parent [ x ] ) <NEWLINE> self . parent [ x ] = p <NEWLINE> <NL> <DEDENT> <DEDENT> def unite ( self , x , y ) : <NEWLINE> <INDENT> if self . rank [ x ] > self . rank [ y ] : <NEWLINE> <INDENT> for z in [ u for u in xrange ( self . n ) if self . root [ u ] == self . root [ y ] ] : <NEWLINE> <INDENT> self . parent [ z ] = self . root [ x ] <NEWLINE> self . root [ z ] = self . root [ x ] <NEWLINE> self . rank [ z ] = self . rank [ x ] <NEWLINE> <DEDENT> <DEDENT> elif self . rank [ x ] < self . rank [ y ] : <NEWLINE> <INDENT> for z in [ u for u in xrange ( self . n ) if self . root [ u ] == self . root [ x ] ] : <NEWLINE> <INDENT> self . parent [ z ] = self . root [ y ] <NEWLINE> self . root [ z ] = self . root [ y ] <NEWLINE> self . rank [ z ] = self . rank [ y ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for z in [ u for u in xrange ( self . n ) if self . root [ u ] == self . root [ x ] ] : <NEWLINE> <INDENT> self . parent [ z ] = self . root [ y ] <NEWLINE> self . root [ z ] = self . root [ y ] <NEWLINE> self . rank [ z ] = self . rank [ y ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> class union_find ( object ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , length ) : <NEWLINE> <INDENT> self . length = length <NEWLINE> self . unionnumber = 0 <NEWLINE> self . unionlist = [ [ ] ] <NEWLINE> self . num = list ( - 1 for i in range ( length ) ) <NEWLINE> <NL> <DEDENT> def unite ( self , i , j ) : <NEWLINE> <INDENT> if self . num [ i ] == - 1 : <NEWLINE> <INDENT> if self . num [ j ] == - 1 : <NEWLINE> <INDENT> self . unionlist [ self . unionnumber ] . extend ( [ i , j ] ) <NEWLINE> self . num [ i ] = self . unionnumber <NEWLINE> self . num [ j ] = self . unionnumber <NEWLINE> self . unionnumber += 1 <NEWLINE> self . unionlist . append ( [ ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = i <NEWLINE> i = j <NEWLINE> j = tmp <NEWLINE> <DEDENT> <DEDENT> if self . num [ i ] != - 1 : <NEWLINE> <INDENT> if self . num [ j ] != - 1 : <NEWLINE> <INDENT> if self . num [ i ] == self . num [ j ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . unionlist [ self . num [ i ] ] . extend ( self . unionlist [ self . num [ j ] ] ) <NEWLINE> tmp = self . num [ j ] <NEWLINE> for k in self . unionlist [ self . num [ j ] ] : <NEWLINE> <INDENT> self . num [ k ] = self . num [ i ] <NEWLINE> <DEDENT> self . unionlist [ tmp ] = <STRING> <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> self . num [ j ] = self . num [ i ] <NEWLINE> self . unionlist [ self . num [ i ] ] . append ( j ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def same ( self , i , j ) : <NEWLINE> <INDENT> print ( self . num [ i ] == self . num [ j ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> n , m = input ( ) . split ( ) <NEWLINE> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> l = [ ] <NEWLINE> union = union_find ( n ) <NEWLINE> for i in range ( m ) : <NEWLINE> <INDENT> com , a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if com = <STRING> : <NEWLINE> <INDENT> union . unite ( a , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> union . same ( a , b ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> root_list = [ i for i in range ( n ) ] <NEWLINE> <NL> def root ( x ) : <NEWLINE> <INDENT> path_to_root = [ ] <NEWLINE> while root_list [ x ] != x : <NEWLINE> <INDENT> path_to_root . append ( x ) : <NEWLINE> x = root_list [ x ] <NEWLINE> <DEDENT> for node in path_to_root : <NEWLINE> <INDENT> root_list [ node ] = x <NEWLINE> <DEDENT> return x <NEWLINE> <NL> <DEDENT> def is_same_set ( x , y ) : <NEWLINE> <INDENT> return root ( x ) == root ( y ) <NEWLINE> <NL> <DEDENT> def unite ( x , y ) : <NEWLINE> <INDENT> root_list [ root ( x ) ] = root ( y ) <NEWLINE> <NL> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if com == 0 : <NEWLINE> <COMMENT> <NL> <INDENT> unite ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if is_same_set ( x , y ) : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> A = [ 2 ** 31 - 1 for i in range ( n ) ] <NEWLINE> B = [ 2 ** 31 - 1 ] * 1001 <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> comi , xi , yi = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if comi and abs ( yi - xi ) <= 199 : <NEWLINE> <INDENT> print min ( A [ xi : yi + 1 ] ) <NEWLINE> <DEDENT> elif comi and 200 <= abs ( yi - xi ) : <NEWLINE> <INDENT> print min ( min ( A [ xi : ( xi / 100 + 1 ) * 100 ] ) , min ( B [ xi / 100 + 1 : yi / 100 ] ) , min ( A [ yi / 100 : ] ) ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> A [ xi ] = yi <NEWLINE> B [ xi / 100 ] = min ( B [ xi / 100 ] , yi ) <NEWLINE> <DEDENT> <DEDENT>
n , q = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> answer = [ ] <NEWLINE> <COMMENT> <NL> size = 2 <NEWLINE> <NL> while size < n : <NEWLINE> <INDENT> size *= 2 <NEWLINE> <NL> <DEDENT> size = size * 2 - 1 <NEWLINE> segtree = [ 2 ** 31 - 1 for x in range ( size ) ] <NEWLINE> <NL> <COMMENT> <NL> def update ( i , x ) : <NEWLINE> <INDENT> ind = size // 2 + i <NEWLINE> segtree [ ind ] = x <NEWLINE> <NL> while ind : <NEWLINE> <INDENT> ind = ( ind - 1 ) // 2 <COMMENT> <NEWLINE> ch1 = segtree [ ind * 2 + 1 ] <NEWLINE> ch2 = segtree [ ind * 2 + 2 ] <NEWLINE> segtree [ ind ] = min ( ch1 , ch2 ) <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( s , t , l , r , p ) : <NEWLINE> <INDENT> if s > r or t < l : <NEWLINE> <INDENT> return 2 ** 31 - 1 <NEWLINE> <DEDENT> if s <= l and t >= l : <NEWLINE> <INDENT> return segtree [ p ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> vl = query ( s , t , l , ( l + r ) // 2 , p * 2 + 1 ) <NEWLINE> vr = query ( s , t , ( l + r ) // 2 , r , p * 2 + 2 ) <NEWLINE> <NL> return min ( vl , vr ) <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( q ) : <NEWLINE> <INDENT> com , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if com == 0 : <NEWLINE> <INDENT> update ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> answer . append ( query ( x , y , 0 , size // 2 , 0 ) ) <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> for a in answer : <NEWLINE> <INDENT> print ( a ) <NEWLINE> <NL> <NL> <DEDENT>
import sys <NEWLINE> <COMMENT> <NL> <NL> sys . setrecursionlimit ( 10 ** 5 ) <NEWLINE> <NL> def li ( ) : return map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> def li_ ( ) : return map ( lambda x : int ( x ) - 1 , stdin . readline ( ) . split ( ) ) <NEWLINE> def lf ( ) : return map ( float , stdin . readline ( ) . split ( ) ) <NEWLINE> def ls ( ) : return stdin . readline ( ) . split ( ) <NEWLINE> def ns ( ) : return stdin . readline ( ) . rstrip ( ) <NEWLINE> def lc ( ) : return list ( ns ( ) ) <NEWLINE> def ni ( ) : return int ( stdin . readline ( ) ) <NEWLINE> def nf ( ) : return float ( stdin . readline ( ) ) <NEWLINE> <NL> class SegmentTree : <NEWLINE> <INDENT> def __init__ ( self , func , arr , default ) : <NEWLINE> <INDENT> self . func = func <NEWLINE> self . arr = arr <NEWLINE> self . default = default <NEWLINE> <NL> self . arrlen = len ( self . arr ) <NEWLINE> self . bitlen = ( len ( self . arr ) - 1 ) . bit_length ( ) + 1 <NEWLINE> self . bottomlen = pow ( 2 , self . bitlen - 1 ) <NEWLINE> self . bottomst = pow ( 2 , self . bitlen - 1 ) - 1 <NEWLINE> <NL> self . segtree = [ self . default ] * ( 2 * self . bottomlen - 1 ) <NEWLINE> self . segtree [ self . bottomst : self . bottomst + self . arrlen ] = self . arr <NEWLINE> <NL> for idx in range ( self . bottomst - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> self . segtree [ idx ] = self . func ( self . segtree [ 2 * idx + 1 ] , <NEWLINE> <INDENT> self . segtree [ 2 * idx + 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def update ( self , idx : int , x : int ) : <NEWLINE> <INDENT> idx += self . bottomst <NEWLINE> self . segtree [ idx ] = x <NEWLINE> while idx > 0 : <NEWLINE> <INDENT> idx = ( idx - 1 ) // 2 <NEWLINE> self . segtree [ idx ] = self . func ( self . segtree [ 2 * idx + 1 ] , <NEWLINE> <INDENT> self . segtree [ 2 * idx + 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def query ( self , a : int , b : int , idx : int , l : int , r : int ) : <NEWLINE> <INDENT> if r <= a or b <= l : <NEWLINE> <INDENT> return self . default <NEWLINE> <NL> <DEDENT> elif a <= l and r <= b : <NEWLINE> <INDENT> return self . segtree [ idx ] <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> return self . func ( self . query ( a , b , 2 * idx + 1 , l , ( l + r ) // 2 ) , <NEWLINE> <INDENT> self . query ( a , b , 2 * idx + 2 , ( l + r ) // 2 , r ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> def reset ( self ) : <NEWLINE> <INDENT> self . segtree = [ self . default ] * ( 2 * self . bottomlen - 1 ) <NEWLINE> self . segtree [ self . bottomst : self . bottomst + self . arrlen ] = self . arr <NEWLINE> <NL> for idx in range ( self . bottomst - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> self . segtree [ idx ] = self . func ( self . segtree [ 2 * idx + 1 ] , <NEWLINE> <INDENT> self . segtree [ 2 * idx + 2 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> n , q = li ( ) <NEWLINE> default = pow ( 2 , 31 ) - 1 <NEWLINE> arr = [ default ] * n <NEWLINE> segtree = SegmentTree ( min , arr , default ) <NEWLINE> nbit = pow ( 2 , ( n - 1 ) . bit_length ( ) ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> command , a , b = li ( ) <NEWLINE> <NL> if command == 0 : <NEWLINE> <INDENT> segtree . update ( a , b ) <NEWLINE> <NL> <DEDENT> elif command == 1 : <NEWLINE> <INDENT> print ( segtree . query ( a , b + 1 , 0 , 0 , nbit ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT>
class RMQ : <NEWLINE> <INDENT> def __init__ ( self , length , ini_num = float ( <STRING> ) ) : <NEWLINE> <INDENT> self . length = 1 <NEWLINE> while self . length <= n : <NEWLINE> <INDENT> self . length <<= 1 <NEWLINE> <DEDENT> self . segtree = [ ini_num ] * ( 2 * self . length - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , index , n ) : <NEWLINE> <INDENT> leaf_index = index + self . length - 1 <NEWLINE> self . segtree [ leaf_index ] = n <NEWLINE> while leaf_index > 0 : <NEWLINE> <INDENT> leaf_index = ( leaf_index - 1 ) // 2 <NEWLINE> self . segtree [ leaf_index ] = min ( self . segtree [ leaf_index * 2 + 1 ] , self . segtree [ leaf_index * 2 + 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , a , b , index , l , r ) : <NEWLINE> <INDENT> if a <= l <= r <= b or a == b : <NEWLINE> <INDENT> return self . segtree [ index ] <NEWLINE> <DEDENT> if b <= l or r <= a : <NEWLINE> <INDENT> return float ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return min ( self . find ( a , b , index * 2 + 1 , l , ( l + r ) // 2 ) , self . find ( a , b , index * 2 + 2 , ( l + r ) // 2 , r ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> v_num , query = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> rmq = RMQ ( v_num , 2147483647 ) <NEWLINE> for _ in range ( query ) : <NEWLINE> <INDENT> com , i , n = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> if com == 0 : <NEWLINE> <INDENT> rmq . update ( i , n ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( rmq . find ( i , n , 0 , 0 , rmq . length ) ) <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import time <NEWLINE> import math <NEWLINE> sys . setrecursionlimit ( 20000 ) <NEWLINE> def update ( tree , x , y , N ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> x += N - 1 <NEWLINE> tree [ x ] = y <NEWLINE> <COMMENT> <NL> while x > 0 : <NEWLINE> <INDENT> x = math . floor ( ( x - 1 ) / 2 ) <NEWLINE> left = x * 2 + 1 <NEWLINE> right = x * 2 + 2 <NEWLINE> tree [ x ] = min ( tree [ left ] , tree [ right ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( tree , x , y , k , l , r ) : <NEWLINE> <NL> <INDENT> if ( r <= x or y <= l ) : <NEWLINE> <INDENT> return 2 ** 31 - 1 <NEWLINE> <COMMENT> <NL> <DEDENT> if ( x <= l and r <= y ) : <NEWLINE> <INDENT> return tree [ k ] <NEWLINE> <COMMENT> <NL> <DEDENT> v_left = find ( tree , x , y , k * 2 + 1 , l , int ( ( l + r ) / 2 ) ) <NEWLINE> v_right = find ( tree , x , y , k * 2 + 2 , int ( ( l + r ) / 2 ) , r ) <NEWLINE> return min ( v_left , v_right ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _N , query_num = map ( int , input ( ) . split ( ) ) <NEWLINE> INT_MAX = 2 ** 31 - 1 <NEWLINE> N = 1 <NEWLINE> while True : <NEWLINE> <INDENT> if ( N >= _N ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> N *= 2 <NEWLINE> <COMMENT> <NL> <DEDENT> A_bin_tree = [ INT_MAX ] * ( 2 * N - 1 - 1 ) <NEWLINE> <COMMENT> <NL> for i in range ( query_num ) : <NEWLINE> <INDENT> operate , x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> if ( operate == 0 ) : <NEWLINE> <INDENT> update ( A_bin_tree , x , y , N ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> if ( operate == 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> z = find ( A_bin_tree , x , y + 1 , 0 , 0 , N ) <NEWLINE> print ( z ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> <DEDENT>
<NL> 1 <NEWLINE> 2 <NEWLINE> 3 <NEWLINE> 4 <NEWLINE> 5 <NEWLINE> 6 <NEWLINE> 7 <NEWLINE> 8 <NEWLINE> 9 <NEWLINE> 10 <NEWLINE> 11 <NEWLINE> 12 <NEWLINE> 13 <NEWLINE> 14 <NEWLINE> 15 <NEWLINE> 16 <NEWLINE> 17 <NEWLINE> 18 <NEWLINE> 19 <NEWLINE> 20 <NEWLINE> 21 <NEWLINE> 22 <NEWLINE> 23 <NEWLINE> 24 <NEWLINE> 25 <NEWLINE> 26 <NEWLINE> 27 <NEWLINE> 28 <NEWLINE> 29 <NEWLINE> <COMMENT> <NL> from __future__ import division , print_function <NEWLINE> from sys import stdin <NEWLINE> <NL> <NL> def main ( init = int ( 2 ** 31 - 1 ) , readline = stdin . readline ) : <NEWLINE> <INDENT> n , q = ( int ( s ) for s in readline ( ) . split ( ) ) <NEWLINE> <NL> a = [ init ] * n <NEWLINE> b = [ init ] * ( ( n // 100 ) + 1 ) <NEWLINE> <NL> for _ in range ( q ) : <NEWLINE> <INDENT> com , x , y = ( int ( s ) for s in readline ( ) . split ( ) ) <NEWLINE> if com : <NEWLINE> <INDENT> bx = x - ( x % 100 ) + 100 <NEWLINE> by = y - ( y % 100 ) <NEWLINE> if bx < by : <NEWLINE> <INDENT> m = min ( min ( a [ x : bx ] ) , min ( b [ bx // 100 : by // 100 ] ) , <NEWLINE> <INDENT> min ( a [ by : y + 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> m = min ( a [ x : y + 1 ] ) <NEWLINE> <DEDENT> print ( m ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ x ] = y <NEWLINE> bx = x - ( x % 100 ) <NEWLINE> b [ x // 100 ] = min ( a [ bx : bx + 100 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
class RangeMinQuery : <NEWLINE> <INDENT> inf = 2 ** 31 - 1 <NEWLINE> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . n = 1 <NEWLINE> while self . n < N : self . n *= 2 <NEWLINE> self . dat = [ self . inf ] ( 2 * self . n - 1 ) <NEWLINE> <NL> <DEDENT> def update ( self , k , x ) : <NEWLINE> <INDENT> k += self . n - 1 <NEWLINE> self . dat [ k ] = x <NEWLINE> while ( k > 0 ) : <NEWLINE> <INDENT> k = ( k - 1 ) / 2 <NEWLINE> self . dat [ k ] = min ( self . dat [ 2 * k + 1 ] , self . dat [ 2 * k + 2 ] ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> def query ( self , a , b , k = 0 , l = 0 , r = - 1 ) : <NEWLINE> <INDENT> if r == - 1 : r = self . n <NEWLINE> if r <= a or b <= l : return self . inf <NEWLINE> if a <= l and r <= b : return self . dat [ k ] <NEWLINE> <NL> vl = self . query ( a , b , 2 * k + 1 , l , ( l + r ) / 2 ) <NEWLINE> vr = self . query ( a , b , 2 * k + 2 , ( l + r ) / 2 , r ) <NEWLINE> return min ( vl , vr ) <NEWLINE> <NL> <DEDENT> <DEDENT> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> rmq = RangeMinQuery ( n ) <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> c , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if c == 0 : <NEWLINE> <INDENT> c . update ( x , y ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print c . query ( x , y + 1 ) <NEWLINE> <DEDENT> <DEDENT>
class BIT : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . size = size <NEWLINE> self . bit = [ 0 ] * ( size + 1 ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def sum ( self , i ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> while ( i > 0 ) : <NEWLINE> <INDENT> s += self . bit [ i ] <NEWLINE> i -= i & - i <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def sum_sec ( self , i , j ) : <NEWLINE> <INDENT> return self . sum ( j ) - self . sum ( j ) <NEWLINE> <NL> <DEDENT> def add ( self , i , x ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> while ( i <= self . size ) : <NEWLINE> <INDENT> self . bit [ i ] += x <NEWLINE> i += i & - i <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n , q = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> bit = BIT ( n ) <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> c , x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if c == 0 : bit . add ( x - 1 , y ) <NEWLINE> else : print bit . sum ( x - 1 , y ) <NEWLINE> <DEDENT>
from operator import itemgetter <NEWLINE> import sys <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> keys = map ( lambda i : ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) , xrange ( n ) ) <NEWLINE> kx , ky = zip ( * keys ) <NEWLINE> keys = zip ( kx , ky , xrange ( n ) ) <NEWLINE> keys . sort ( ) <NEWLINE> id_m = len ( keys ) / 2 <NEWLINE> root = Node ( keys [ id_m ] [ 0 ] , keys [ id_m ] [ 1 ] , keys [ id_m ] [ 2 ] ) <NEWLINE> if id_m != 0 : <NEWLINE> <INDENT> recursive_add_Node ( root , keys [ : id_m ] , 1 ) <NEWLINE> <DEDENT> if id_m + 1 != len ( keys ) : <NEWLINE> <INDENT> recursive_add_Node ( root , keys [ id_m + 1 : ] , 1 ) <NEWLINE> <NL> <DEDENT> q = int ( input ( ) ) <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> sx , tx , sy , ty = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> nums = [ ] <NEWLINE> find ( root , sx , sy , tx , ty , 0 , nums ) <NEWLINE> nums . sort ( ) <NEWLINE> map ( lambda n : sys . stdout . write ( <STRING> . format ( n ) ) , nums ) <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( z , sx , sy , tx , ty , d , nums ) : <NEWLINE> <INDENT> if ( sx <= z . key_x <= tx ) and ( sy <= z . key_y <= ty ) : <NEWLINE> <INDENT> nums . append ( z . num ) <NEWLINE> <DEDENT> d += 1 <NEWLINE> if d % 2 : <NEWLINE> <INDENT> if ( z . left != None ) and ( z . key_y >= sy ) : <NEWLINE> <INDENT> find ( z . left , sx , sy , tx , ty , d , nums ) <NEWLINE> <DEDENT> if ( z . right != None ) and ( z . key_y <= ty ) : <NEWLINE> <INDENT> find ( z . right , sx , sy , tx , ty , d , nums ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if ( z . left != None ) and ( z . key_x >= sx ) : <NEWLINE> <INDENT> find ( z . left , sx , sy , tx , ty , d , nums ) <NEWLINE> <DEDENT> if ( z . right != None ) and ( z . key_x <= tx ) : <NEWLINE> <INDENT> find ( z . right , sx , sy , tx , ty , d , nums ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def add_Node ( root , kx , ky , n ) : <NEWLINE> <INDENT> y = None <NEWLINE> x = root <NEWLINE> d = 0 <NEWLINE> xy = 0 <NEWLINE> while ( x != None ) : <NEWLINE> <INDENT> d += 1 <NEWLINE> xy = d % 2 <NEWLINE> y = x <NEWLINE> if xy == 0 : <NEWLINE> <INDENT> if x . key_x > kx : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if x . key_y > ky : <NEWLINE> <INDENT> x = x . left <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> x = x . right <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> z = Node ( kx , ky , n ) <NEWLINE> <NL> if xy == 0 : <NEWLINE> <INDENT> if y . key_x > kx : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> if y . key_y > ky : <NEWLINE> <INDENT> y . left = z <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> y . right = z <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def recursive_add_Node ( root , k , d ) : <NEWLINE> <INDENT> k . sort ( key = itemgetter ( d % 2 ) ) <NEWLINE> len_k = len ( k ) <NEWLINE> id_m = len_k / 2 <NEWLINE> add_Node ( root , k [ id_m ] [ 0 ] , k [ id_m ] [ 1 ] , k [ id_m ] [ 2 ] ) <NEWLINE> if id_m != 0 : <NEWLINE> <INDENT> recursive_add_Node ( root , k [ : id_m ] , d + 1 ) <NEWLINE> <DEDENT> if id_m + 1 != len_k : <NEWLINE> <INDENT> recursive_add_Node ( root , k [ id_m + 1 : ] , d + 1 ) <NEWLINE> <NL> <DEDENT> <DEDENT> class Node ( ) : <NEWLINE> <INDENT> def __init__ ( self , x , y , n ) : <NEWLINE> <INDENT> self . key_x = x <NEWLINE> self . key_y = y <NEWLINE> self . num = n <NEWLINE> self . left = None <NEWLINE> self . right = None <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import sys <NEWLINE> INF = ( sys . maxint ) / 3 <NEWLINE> <NL> def SmallestWindow ( S , a_list ) : <NEWLINE> <INDENT> i = 0 <NEWLINE> j = 0 <NEWLINE> tmpS = 0 <NEWLINE> res = INF <NEWLINE> while 1 : <NEWLINE> <INDENT> while tmpS < S and i < len ( a_list ) : <NEWLINE> <INDENT> i += 1 <NEWLINE> tmpS += a_list [ i ] <NEWLINE> <DEDENT> if ( tmpS < S ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> res = min ( res , i - j ) <NEWLINE> j += 1 <NEWLINE> tmpS -= a_list [ j ] <NEWLINE> <DEDENT> if res == INF : <NEWLINE> <INDENT> res = 0 <NEWLINE> <DEDENT> return res <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> N , S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a_list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print SmallestWindow ( S , a_list ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
N , S = map ( int , input ( ) . split ( ) ) <NEWLINE> As = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> i = 0 <NEWLINE> j = 0 <NEWLINE> sum = 0 <NEWLINE> m_l = float ( <STRING> ) <NEWLINE> <STRING> <NEWLINE> while j < N : <NEWLINE> <INDENT> sum += As [ j ] <NEWLINE> j += 1 <NEWLINE> if sum < s : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> while i <= j and sum >= S : <NEWLINE> <INDENT> m_l = min ( j - i , m_l ) <NEWLINE> sum -= As [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> print ( m_l if m_l != float ( <STRING> ) else 0 ) <NEWLINE>
n , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> arr = [ 0 for i in range ( t + 1 ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> start , end = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> arr [ start ] += 1 <NEWLINE> arr [ end ] -= 1 <NEWLINE> <DEDENT> import numpy as np <NEWLINE> <NL> cs = np . cumsum ( arr ) <NEWLINE> <NL> print max ( cs ) <NEWLINE>
from collections import defaultdict <NEWLINE> import heapq <NEWLINE> <NL> <NL> vertice , edge , source = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> link = defaultdict ( dict ) <NEWLINE> weight = defaultdict ( dict ) <NEWLINE> answer = [ - 1 ] * vertice <NEWLINE> for e in range ( edge ) : <NEWLINE> <INDENT> i , j , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> link [ i ] = link . get ( i , set ( ) ) | { j } <NEWLINE> weight [ i ] . update ( { j : w } ) <NEWLINE> <DEDENT> goal = v <NEWLINE> queue = [ ] <NEWLINE> heapq . heappush ( queue , ( 0 , source ) ) <NEWLINE> heapq . heapify ( queue ) <NEWLINE> while queue : <NEWLINE> <COMMENT> <NL> <INDENT> now_cost , here = heapq . heappop ( queue ) <NEWLINE> <COMMENT> <NL> if answer [ here ] > - 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> answer [ here ] = now_cost <NEWLINE> <NL> <COMMENT> <NL> for nw in link [ here ] : <NEWLINE> <INDENT> if answer [ nw ] == - 1 : <NEWLINE> <INDENT> heapq . heappush ( queue , ( now_cost + weight [ here ] [ nw ] , nw ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for a in answer : <NEWLINE> <INDENT> print ( a if a != - 1 else <STRING> ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from heapq import heappop , heappush <NEWLINE> from math import isinf <NEWLINE> <NL> V , E , r = map ( int , input ( ) ) <NEWLINE> <NL> e = defaultdict ( list ) <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , length = map ( int , input ( ) ) <NEWLINE> e [ s ] . append ( ( length , t ) ) <NEWLINE> <NL> <DEDENT> distance = [ float ( <STRING> ) ] * v <COMMENT> <NEWLINE> distance [ r ] = 0 <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> heap = [ ( distance [ r ] , r ) ] <NEWLINE> while heap : <NEWLINE> <INDENT> du , u = heappop ( heap ) <NEWLINE> for length , v in e [ u ] : <NEWLINE> <INDENT> if distance [ v ] > e [ u ] + length : <NEWLINE> <INDENT> distance [ v ] = e [ u ] + length <NEWLINE> heappush ( heap , ( distance [ v ] , v ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for d in distance : <NEWLINE> <INDENT> print ( <STRING> if math . isinf ( di ) else di ) <NEWLINE> <DEDENT>
V , E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ ] <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> tmp = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> edges . append ( tmp ) <NEWLINE> <NL> <DEDENT> d = [ float ( <STRING> ) for _ in range ( V ) ] <NEWLINE> d [ r ] = 0 <NEWLINE> <NL> for _ in range ( V - 1 ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> for x in edges : <NEWLINE> <INDENT> s , t , d = x <NEWLINE> if d [ t ] > d [ s ] + d : <NEWLINE> <INDENT> count += 1 <NEWLINE> d [ t ] = d [ s ] + d <NEWLINE> <DEDENT> <DEDENT> if count == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for x in d : <NEWLINE> <INDENT> if x == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( x ) <NEWLINE> <DEDENT> <DEDENT>
from __future__ import division <NEWLINE> from collections import defaultdict <NEWLINE> from heapq import heappush , heappop <NEWLINE> <NL> class UnionFindSet : <NEWLINE> <INDENT> def __init__ ( self , nodes ) : <NEWLINE> <INDENT> self . fa = { } <NEWLINE> for n in nodes : <NEWLINE> <INDENT> self . fa [ n ] = n <NEWLINE> <NL> <DEDENT> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> if self . fa [ x ] == x : <NEWLINE> <INDENT> return x <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . fa [ x ] = self . find ( self . fa [ x ] ) <NEWLINE> return self . fa [ x ] <NEWLINE> <NL> <DEDENT> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> fx = self . find ( x ) <NEWLINE> fy = self . find ( y ) <NEWLINE> if fx == fy : <NEWLINE> <INDENT> return fx <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . fa [ fx ] = fy <NEWLINE> return fy <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <STRING> <NEWLINE> <NL> def kruscal ( graph ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ufset = UnionFindSet ( graph [ <STRING> ] ) <NEWLINE> <NL> ret = 0 <NEWLINE> <NL> for ( x , y , w ) in sorted ( graph [ <STRING> ] , key = lambda x : x [ - 1 ] ) : <NEWLINE> <INDENT> fx = ufset . find ( x ) <NEWLINE> fy = ufset . find ( y ) <NEWLINE> if fx != fy : <NEWLINE> <INDENT> ret += w <NEWLINE> ufset . union ( fx , fy ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <NL> <DEDENT> def dijkstra ( graph , root ) : <NEWLINE> <INDENT> dis , vis = { } , { } <NEWLINE> for n in graph [ <STRING> ] : <NEWLINE> <INDENT> dis [ n ] = 10 ** 9 <NEWLINE> vis [ n ] = False <NEWLINE> <NL> <DEDENT> heap = [ ] <NEWLINE> dis [ root ] = 0 <NEWLINE> heappush ( heap , ( 0 , root ) ) <NEWLINE> <NL> while heap : <NEWLINE> <INDENT> _ , n = heappop ( heap ) <NEWLINE> vis [ n ] = True <NEWLINE> for ( y , w ) in graph [ <STRING> ] [ n ] : <NEWLINE> <INDENT> if not vis [ y ] : <NEWLINE> <INDENT> dis [ y ] = min ( dis [ y ] , dis [ n ] + w ) <NEWLINE> heappush ( heap , ( dis [ y ] , y ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return dis <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> V , E , root = map ( int , raw_input ( ) . strip ( ) . split ( ) ) <NEWLINE> graph = { } <NEWLINE> graph [ <STRING> ] = [ i for i in range ( V ) ] <NEWLINE> graph [ <STRING> ] = [ ] <NEWLINE> graph [ <STRING> ] = defaultdict ( list ) <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> x , y , w = map ( int , raw_input ( ) . strip ( ) . split ( ) ) <NEWLINE> graph [ <STRING> ] . append ( ( x , y , w ) ) <NEWLINE> graph [ <STRING> ] [ x ] . append ( ( y , w ) ) <NEWLINE> <NL> <DEDENT> dis = dijkstra ( graph , root ) <NEWLINE> <NL> for n in graph [ <STRING> ] : <NEWLINE> <INDENT> print dis [ n ] if dis [ n ] < 10 ** 9 else <STRING> <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> from collections import defaultdict <NEWLINE> from collections import deque <NEWLINE> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> start = time . clock ( ) <NEWLINE> fl = input ( ) . split ( <STRING> ) <NEWLINE> V = int ( fl [ 0 ] ) <NEWLINE> E = int ( fl [ 1 ] ) <NEWLINE> R = int ( fl [ 2 ] ) <NEWLINE> <COMMENT> <NL> G = defaultdict ( list ) <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , w = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> G [ s ] . append ( ( t , w ) ) <NEWLINE> <COMMENT> <NL> <DEDENT> d = { } <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> nodes_list = range ( V ) <NEWLINE> for i in nodes_list : <NEWLINE> <INDENT> d [ i ] = INF <NEWLINE> <DEDENT> d [ R ] = 0 <NEWLINE> <COMMENT> <NL> q = deque ( [ R ] ) <NEWLINE> while q : <NEWLINE> <COMMENT> <NL> <INDENT> u = q . popleft ( ) <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if d [ v [ 0 ] ] > d [ u ] + v [ 1 ] : <NEWLINE> <INDENT> d [ v [ 0 ] ] = d [ u ] + v [ 1 ] <NEWLINE> <COMMENT> <NL> q . append ( v [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for k in nodes_list : <NEWLINE> <INDENT> if d [ k ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d [ k ] ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> fl = input ( ) . split ( <STRING> ) <NEWLINE> V = int ( fl [ 0 ] ) <NEWLINE> E = int ( fl [ 1 ] ) <NEWLINE> R = int ( fl [ 2 ] ) <NEWLINE> <COMMENT> <NL> G = defaultdict ( list ) <NEWLINE> for i in range ( int ( E ) ) : <NEWLINE> <INDENT> s , t , w = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> d = { } <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( V ) : <NEWLINE> <INDENT> d [ i ] = INF <NEWLINE> <DEDENT> d [ R ] = 0 <NEWLINE> q = [ R ] <NEWLINE> while q : <NEWLINE> <INDENT> u = q . pop ( 0 ) <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if d [ v [ 0 ] ] > d [ u ] + v [ 1 ] : <NEWLINE> <INDENT> d [ v [ 0 ] ] = d [ u ] + v [ 1 ] <NEWLINE> q . append ( v [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for k in d . keys ( ) : <NEWLINE> <INDENT> if d [ k ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d [ k ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<STRING> <NEWLINE> <NL> import queue <NEWLINE> v , e , s = map ( int , input ( ) . split ( ) ) <NEWLINE> edge = [ ] <NEWLINE> inf = 1000000100 <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> edge . append ( [ ] ) <NEWLINE> <NL> <DEDENT> for i in range ( e ) : <NEWLINE> <INDENT> vs , vt , d = map ( int , input ( ) . split ( ) ) <NEWLINE> edge [ vs ] . append ( ( vt , d ) ) <NEWLINE> <NL> <DEDENT> dis = [ ] <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> dis . append ( inf ) <NEWLINE> <NL> <DEDENT> dis [ s ] = 0 <NEWLINE> <NL> q = queue . PriorityQueue ( ) <NEWLINE> q . put ( ( 0 , s ) ) <NEWLINE> <NL> <STRING> <NEWLINE> finished = 0 <NEWLINE> while ( finished < v and not q . empty ( ) ) : <NEWLINE> <INDENT> now = q . get ( ) <NEWLINE> nowv = now [ 1 ] <NEWLINE> if now [ 0 ] > dis [ nowv ] continue ; <NEWLINE> for ( vt , d ) in edge [ nowv ] : <NEWLINE> <INDENT> if dis [ vt ] > dis [ nowv ] + d : <NEWLINE> <INDENT> dis [ vt ] = dis [ nowv ] + d <NEWLINE> q . put ( ( dis [ vt ] , vt ) ) <NEWLINE> <DEDENT> <DEDENT> finished += 1 <NEWLINE> <NL> <DEDENT> for i in range ( v ) : <NEWLINE> <INDENT> if dis [ i ] >= inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dis [ i ] ) <NEWLINE> <DEDENT> <DEDENT>
INF = 1000000000 <NEWLINE> class Edge : <NEWLINE> <INDENT> def __init__ ( self , to , cost ) : <NEWLINE> <INDENT> self . to = to <NEWLINE> self . cost = cost <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def dijkstra ( graph , start ) : <NEWLINE> <INDENT> V = len ( graph ) <NEWLINE> d = [ INF for _ in xrange ( V ) ] <NEWLINE> d [ start ] = 0 <NEWLINE> <NL> done = [ False for _ in xrange ( V ) ] <NEWLINE> while True : <NEWLINE> <INDENT> mini = INF <NEWLINE> min_i = - 1 <NEWLINE> for i , node in enumerate ( graph ) : <NEWLINE> <INDENT> if done [ i ] == False : <NEWLINE> <INDENT> if d [ i ] < mini : <NEWLINE> <INDENT> min_i = i <NEWLINE> mini = d [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if min_i == - 1 : <NEWLINE> <INDENT> return d <NEWLINE> <NL> <DEDENT> done [ min_i ] = True <NEWLINE> <NL> node = graph [ min_i ] <NEWLINE> for edge in node : <NEWLINE> <INDENT> if d [ min_i ] + edge . cost < d [ edge . to ] : <NEWLINE> <INDENT> d [ edge . to ] = d [ min_i ] + edge . cost <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> V , E , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in xrange ( V ) ] <NEWLINE> for i in xrange ( E ) : <NEWLINE> <INDENT> _s , _t , _c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> graph [ _s ] . append ( Edge ( _t , _c ) ) <NEWLINE> <NL> <NL> <DEDENT> distance = dijkstra ( graph , r ) <NEWLINE> for d in distance : <NEWLINE> <INDENT> if d == INF : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print d <NEWLINE> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import heapq <NEWLINE> <NL> <NL> class Edge : <NEWLINE> <INDENT> def __init__ ( self , dst , weight ) : <NEWLINE> <INDENT> self . dst , self . weight = dst , weight <NEWLINE> <NL> <DEDENT> def __lt__ ( self , e ) : <NEWLINE> <INDENT> return self . weight > e . weight <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class Graph : <NEWLINE> <INDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> self . V = V <NEWLINE> self . E = [ [ ] for _ in range ( V ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , src , dst , weight ) : <NEWLINE> <INDENT> self . E [ src ] . append ( Edge ( dst , weight ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> class ShortestPath : <NEWLINE> <INDENT> <STRING> <NEWLINE> <NL> def __init__ ( self , G , INF = 10 ** 9 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . G , self . INF = G , INF <NEWLINE> <NL> <DEDENT> class Node : <NEWLINE> <INDENT> def __init__ ( self , v , cost ) : <NEWLINE> <INDENT> self . v , self . cost = v , cost <NEWLINE> <NL> <DEDENT> def __lt__ ( self , n ) : <NEWLINE> <INDENT> return self . cost < n . cost <NEWLINE> <NL> <DEDENT> <DEDENT> def dijkstra ( self , start , goal = None ) : <NEWLINE> <INDENT> que = list ( ) <NEWLINE> self . dist = [ self . INF ] * self . G . V <COMMENT> <NEWLINE> self . prev = [ - 1 ] * self . G . V <COMMENT> <NEWLINE> self . dist [ start ] = 0 <NEWLINE> heapq . heappush ( que , self . Node ( start , 0 ) ) <NEWLINE> <NL> while len ( que ) > 0 : <NEWLINE> <INDENT> cost , v = heapq . heappop ( que ) <NEWLINE> if self . dist [ v ] < cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> if goal is not None and v == goal : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> for e in self . E [ v ] : <NEWLINE> <INDENT> if self . dist [ v ] + e . weight < self . dist [ e . dst ] : <NEWLINE> <INDENT> self . dist [ e . dst ] = self . dist [ v ] + e . weight <NEWLINE> heapq . heappush ( que , self . Node ( e . dst , self . dist [ e . dst ] ) ) <NEWLINE> self . prev [ e . dst ] = v <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def getPath ( self , end ) : <NEWLINE> <INDENT> path = [ end ] <NEWLINE> while self . prev [ end ] != - 1 : <NEWLINE> <INDENT> end = self . prev [ end ] <NEWLINE> <DEDENT> return path [ : : - 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> V , E , start = map ( int , input ( ) . split ( ) ) <NEWLINE> G = Graph ( V ) <NEWLINE> for _ in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> G . add_edge ( s , t , d ) <NEWLINE> <DEDENT> INF = 10 ** 9 <NEWLINE> sp = ShortestPath ( G , INF ) <NEWLINE> sp . dijkstra ( start ) <NEWLINE> for i in range ( G . V ) : <NEWLINE> <INDENT> print ( <STRING> if sp . dist [ i ] == INF else sp . dist [ i ] ) <NEWLINE> <DEDENT>
from heapq import heappush , heappop <NEWLINE> V , E , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for i in xrange ( V ) ] <NEWLINE> for i in xrange ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g [ s ] . append ( ( t , d ) ) <NEWLINE> <NL> <DEDENT> INF = 10 ** 10 <NEWLINE> dist = [ INF ] * V <NEWLINE> que = [ ( 0 , r ) ] <NEWLINE> dist [ r ] = 0 <NEWLINE> while que : <NEWLINE> <INDENT> c , v = heappop ( que ) <NEWLINE> if dist [ v ] < c : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for t , cost in g [ v ] : <NEWLINE> <INDENT> if dist [ v ] + cost < dist [ t ] : <NEWLINE> <INDENT> dist [ t ] = dist [ v ] + cost <NEWLINE> heappush ( que , ( t , dist [ t ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> for i in xrange ( V ) : <NEWLINE> <INDENT> print dist [ i ] if dist [ i ] < INF else <STRING> <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> from heapq import heappush , heappop , heapify <NEWLINE> from sys import stdin <NEWLINE> <COMMENT> <NL> <NL> def sp ( G , R , V ) : <NEWLINE> <INDENT> d = { } <NEWLINE> q = [ ( 0 , R ) ] <NEWLINE> d [ R ] = 0 <NEWLINE> heapify ( q ) <NEWLINE> while q : <NEWLINE> <INDENT> ( cost , v ) = heappop ( q ) <NEWLINE> for ( next , c ) in G [ v ] . items ( ) : <NEWLINE> <INDENT> if v not in d : <NEWLINE> <INDENT> d [ v ] = c <NEWLINE> <DEDENT> elif d [ next ] > d [ v ] + c : <NEWLINE> <INDENT> d [ next ] = d [ v ] + c <NEWLINE> heappush ( q , ( d [ next ] , next ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> V , E , R = [ int ( x ) for x in stdin . readline ( ) . split ( ) ] <NEWLINE> G = defaultdict ( dict ) <NEWLINE> for case in range ( E ) : <NEWLINE> <INDENT> s , t , w = [ int ( x ) for x in stdin <NEWLINE> . readline ( ) . split ( ) ] <NEWLINE> G [ s ] [ t ] = w <NEWLINE> <DEDENT> d = sp ( G , R , V ) <NEWLINE> for k in range ( V ) : <NEWLINE> <INDENT> if k not in d : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d [ k ] ) <NEWLINE> <COMMENT> <NL> <NEWLINE> <DEDENT> <DEDENT>
inf = 0x11111111 <NEWLINE> def solve ( G , start ) : <NEWLINE> <INDENT> cost = [ inf ] * V <NEWLINE> visited = [ 0 ] * V <NEWLINE> cost [ start ] = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> visited [ start ] = 1 <NEWLINE> next = - 1 <NEWLINE> min = inf <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> if visited [ i ] : continue <NEWLINE> if G [ start ] [ i ] > - 1 : <NEWLINE> <INDENT> d = cost [ start ] + G [ start ] [ i ] <NEWLINE> if d < cost [ i ] : <NEWLINE> <INDENT> cost [ i ] = d <NEWLINE> <DEDENT> <DEDENT> if min > cost [ i ] : <NEWLINE> <INDENT> min = cost [ i ] <NEWLINE> next = i <NEWLINE> <DEDENT> <DEDENT> start = next <NEWLINE> if next == - 1 : break <NEWLINE> <DEDENT> return cost <NEWLINE> <NL> <DEDENT> V , E , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> G = [ [ - 1 ] * V for i in range ( V ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> G [ s ] [ t ] = d <NEWLINE> <NL> <DEDENT> cost = solve ( G , r ) <NEWLINE> for i in cost : print i if i < inf else <STRING> <NEWLINE>
<COMMENT> <NL> <NL> class Dijkstra ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> class Edge ( ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> def __init__ ( self , _to , _cost ) : <NEWLINE> <INDENT> self . to = _to <NEWLINE> self . cost = _cost <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self , V ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . G = [ [ ] for i in range ( V ) ] <COMMENT> <NEWLINE> self . _E = 0 <COMMENT> <NEWLINE> self . _V = V <COMMENT> <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def E ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _E <NEWLINE> <NL> <DEDENT> @ property <NEWLINE> def V ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> return self . _V <NEWLINE> <NL> <DEDENT> def add ( self , _from , _to , _cost ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . G [ _from ] . append ( self . Edge ( _to , _cost ) ) <NEWLINE> self . _E += 1 <NEWLINE> <NL> <DEDENT> def shortest_path ( self , s ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> import heapq <NEWLINE> que = [ ] <COMMENT> <NEWLINE> d = [ float ( <STRING> ) ] * self . V <NEWLINE> d [ s ] = 0 <NEWLINE> heapq . heappush ( que , ( 0 , s ) ) <COMMENT> <NEWLINE> <NL> while len ( que ) != 0 : <NEWLINE> <INDENT> prov_cost , v = heapq . heappop ( que ) <COMMENT> <NEWLINE> <COMMENT> <NL> if d [ v ] < prov_cost : continue <NEWLINE> <NL> <COMMENT> <NL> for i in range ( len ( self . G [ v ] ) ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> <STRING> <NEWLINE> cost = self . G [ v ] [ i ] <COMMENT> <NEWLINE> if d [ i ] > d [ v ] + cost : <NEWLINE> <INDENT> d [ i ] = d [ v ] + cost <COMMENT> <NEWLINE> heapq . heappush ( que , ( d [ i ] , i ) ) <COMMENT> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> V , E , s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> v_set = set ( ) <COMMENT> <NEWLINE> djk = Dijkstra ( V ) <NEWLINE> if V == 1 : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> exit ( ) <NEWLINE> <NL> <DEDENT> if E == 0 : <NEWLINE> <INDENT> for i in range ( V - 1 ) : <NEWLINE> <INDENT> djk . add ( i , i + 1 , float ( <STRING> ) ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( E ) : <NEWLINE> <INDENT> _from , to , cost = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> djk . add ( _from , to , cost ) <NEWLINE> v_set . add ( _from ) <NEWLINE> v_set . add ( to ) <NEWLINE> <NL> <DEDENT> for i in range ( V ) : <NEWLINE> <COMMENT> <NL> <INDENT> if not i in v_set : <NEWLINE> <INDENT> djk . add ( i , 0 , float ( <STRING> ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> d = djk . shortest_path ( s ) <NEWLINE> <NL> for i in range ( V ) : <NEWLINE> <INDENT> if i >= len ( d ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> continue <NEWLINE> <NL> <DEDENT> cost = d [ i ] <NEWLINE> if cost == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( cost ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT>
import heapq <NEWLINE> <NL> class Dijkstra ( object ) : <NEWLINE> <INDENT> def dijkstra ( self , adj , start , goal = None ) : <NEWLINE> <INDENT> num = len ( adj ) <NEWLINE> dist = [ float ( <STRING> ) for i in range ( num ) ] <NEWLINE> prev = [ float ( <STRING> ) for i in range ( num ) ] <NEWLINE> <NL> dist [ start ] = 0 <NEWLINE> q = [ ] <NEWLINE> heapq . heappush ( q , ( 0 , start ) ) <NEWLINE> <NL> while len ( q ) != 0 : <NEWLINE> <INDENT> prov_const , src = heapq . heappop ( q ) <NEWLINE> <NL> if dist [ src ] < prov_const : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for dest in range ( num ) : <NEWLINE> <INDENT> cost = adj [ src ] [ dest ] <NEWLINE> if cost != float ( <STRING> ) and dist [ dest ] > dist [ src ] + cost : <NEWLINE> <INDENT> dist [ dest ] = dist [ src ] + cost <NEWLINE> heapq . heappush ( q , ( dist [ dest ] , dest ) ) <NEWLINE> prev [ dest ] = src <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if goal is not None : <NEWLINE> <INDENT> return self . get_path ( goal , prev ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dist <NEWLINE> <NL> <DEDENT> <DEDENT> def get_path ( self , goal , prev ) : <NEWLINE> <INDENT> path = [ goal ] <NEWLINE> dest = goal <NEWLINE> <NL> while prev [ dest ] != float ( <STRING> ) : <NEWLINE> <INDENT> path . append ( prev [ dest ] ) <NEWLINE> dest = prev [ dest ] <NEWLINE> <NL> <DEDENT> return list ( reversed ( path ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> p_inf = float ( <STRING> ) <NEWLINE> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> V , E , r = l [ 0 ] , l [ 1 ] , l [ 2 ] <NEWLINE> <NL> adj = [ [ p_inf ] * V for i in range ( V ) ] <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> adj [ i ] [ i ] = 0 <NEWLINE> <DEDENT> for i in range ( E ) : <NEWLINE> <INDENT> l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s , t , d = l [ 0 ] , l [ 1 ] , l [ 2 ] <NEWLINE> adj [ s ] [ t ] = d <NEWLINE> <NL> <DEDENT> d = Dijkstra ( ) <NEWLINE> result = d . dijkstra ( adj , r ) <NEWLINE> for i in result : <NEWLINE> <INDENT> if i == p_inf : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print i <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
def main ( ) : <NEWLINE> <COMMENT> <NL> <INDENT> fl = input ( ) . split ( <STRING> ) <NEWLINE> V = int ( fl [ 0 ] ) <NEWLINE> E = int ( fl [ 1 ] ) <NEWLINE> R = int ( fl [ 2 ] ) <NEWLINE> <COMMENT> <NL> G = defaultdict ( list ) <NEWLINE> for i in range ( int ( E ) ) : <NEWLINE> <INDENT> s , t , w = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> G [ s ] . append ( ( t , w ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> d = { } <NEWLINE> INF = float ( <STRING> ) <NEWLINE> <COMMENT> <NL> for i in range ( V ) : <NEWLINE> <INDENT> d [ i ] = INF <NEWLINE> <DEDENT> d [ R ] = 0 <NEWLINE> q = [ R ] <NEWLINE> while q : <NEWLINE> <COMMENT> <NL> <INDENT> u = q . pop ( 0 ) <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if d [ v [ 0 ] ] > d [ u ] + v [ 1 ] : <NEWLINE> <INDENT> d [ v [ 0 ] ] = d [ u ] + v [ 1 ] <NEWLINE> <COMMENT> <NL> q . append ( v [ 0 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> for k in d . keys ( ) : <NEWLINE> <INDENT> if d [ k ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d [ k ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> INF = 1000000 <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> V , E , r = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( V ) ] <COMMENT> <NEWLINE> <NL> for i in xrange ( E ) : <NEWLINE> <INDENT> a , b , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> edges [ a ] . append ( { <STRING> : b , <STRING> : w } ) <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> distance = [ INF ] * V <NEWLINE> visited = [ False ] * V <NEWLINE> <NL> distance [ r ] = 0 <NEWLINE> for i in range ( V ) : <NEWLINE> <INDENT> min_v = - 1 <NEWLINE> for v in range ( V ) : <NEWLINE> <INDENT> if not visited [ v ] and ( min_v == - 1 or distance [ v ] < distance [ min_v ] ) : <NEWLINE> <INDENT> min_v = v <NEWLINE> <NL> <DEDENT> <DEDENT> visited [ min_v ] = True <NEWLINE> for e in edges [ min_v ] : <NEWLINE> <INDENT> distance [ e [ <STRING> ] ] = min ( distance [ min_v ] + e [ <STRING> ] , distance [ e [ <STRING> ] ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> for d in distance : <NEWLINE> <INDENT> if d >= INF : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print d <NEWLINE> <DEDENT> <DEDENT>
import sys <NEWLINE> import queue <NEWLINE> <NL> <NL> class Dijkstra : <NEWLINE> <INDENT> class Edge : <NEWLINE> <INDENT> def __init__ ( self , end , cost ) : <NEWLINE> <INDENT> self . to = end <NEWLINE> self . cost = cost <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self , node_size , inf ) : <NEWLINE> <INDENT> self . _node = node_size <NEWLINE> self . _graph = [ [ ] for _ in range ( self . _node ) ] <NEWLINE> self . inf = inf <NEWLINE> self . dist = [ self . inf for _ in range ( self . _node ) ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , st , ed , cs ) : <NEWLINE> <INDENT> self . _graph [ st ] . append ( self . Edge ( ed , cs ) ) <NEWLINE> <NL> <DEDENT> def solve ( self , start ) : <NEWLINE> <INDENT> que = queue . PriorityQueue ( ) <NEWLINE> self . dist [ start ] = 0 <NEWLINE> que . put ( ( 0 , start ) ) <NEWLINE> while que : <NEWLINE> <INDENT> cur_cost , cur_vertex = que . get ( ) <NEWLINE> if self . dist [ cur_vertex ] < cur_cost : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for e in self . _graph [ cur_vertex ] : <NEWLINE> <INDENT> if self . dist [ e . to ] > cur_cost + e . cost : <NEWLINE> <INDENT> self . dist [ e . to ] = cur_cost + e . cost <NEWLINE> que . put ( ( self . dist [ e . to ] , e . to ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> V , E , r = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> dk = Dijkstra ( V , 10 ** 10 ) <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> dk . add_edge ( s , t , d ) <NEWLINE> <DEDENT> dk . solve ( r ) <NEWLINE> for value in dk . dist : <NEWLINE> <INDENT> if value == dk . inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( value ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import queue <NEWLINE> <NL> def Dijkstra ( vertex , edges , start ) : <NEWLINE> <INDENT> weight = [ 0 if i == start else float ( <STRING> ) for i in range ( vertex ) ] <NEWLINE> Q = queue . PriorityQueue ( ) <NEWLINE> Q . put ( ( weight [ start ] , start ) ) <NEWLINE> <NL> while ( not Q . Empty ( ) ) : <NEWLINE> <INDENT> cur = Q . get ( ) <NEWLINE> if weight [ cur [ 1 ] ] < cur [ 0 ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for j in range ( len ( edges [ cur [ 1 ] ] ) ) : <NEWLINE> <INDENT> if weight [ edges [ cur [ 1 ] ] [ j ] [ 1 ] ] > weight [ cur [ 1 ] ] + edges [ cur [ 1 ] ] [ j ] [ 2 ] : <NEWLINE> <INDENT> weight [ edges [ cur [ 1 ] ] [ j ] [ 1 ] ] = weight [ cur [ 1 ] ] + edges [ cur [ 1 ] ] [ j ] [ 2 ] <NEWLINE> Q . put ( ( weight [ edges [ cur [ 1 ] ] [ j ] [ 1 ] ] , edges [ cur [ 1 ] ] [ j ] [ 1 ] ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return weight <NEWLINE> <NL> <DEDENT> V , E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> edges = [ [ ] for i in range ( V ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> edges [ data [ 0 ] ] . append ( data ) <NEWLINE> <DEDENT> edges . sort ( ) <NEWLINE> w = Dijkstra ( V , edges , r ) <NEWLINE> for i in range ( len ( w ) ) : <NEWLINE> <INDENT> print ( w [ i ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> from math import isinf <NEWLINE> <NL> V , E , r = map ( int , input ( ) . split ( ) ) <NEWLINE> vertices = [ float ( <STRING> ) ] * V <NEWLINE> vertices [ r ] = 0 <NEWLINE> edges = [ ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> edges . append ( ( s , t , d ) ) <NEWLINE> <NL> <DEDENT> for i in range ( V - 1 ) : <NEWLINE> <INDENT> for s , t , d in edges : <NEWLINE> <INDENT> if vertices [ t ] > vertices [ s ] + d : <NEWLINE> <INDENT> vertices [ t ] = vertices [ s ] + d <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> for s , t , d in edges : <NEWLINE> <INDENT> if vertices [ t ] > vertices [ s ] + d : <NEWLINE> <INDENT> neg = True <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if not neg : <NEWLINE> <INDENT> for v in vertices : <NEWLINE> <INDENT> print ( <STRING> if isinf ( v ) else v ) <NEWLINE> <DEDENT> <DEDENT>
class exist_negative_cycle ( Exception ) : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> def bellman_ford ( g , size , start = 0 ) : <NEWLINE> <INDENT> d = [ float ( <STRING> ) ] * size <NEWLINE> d [ start ] = 0 <NEWLINE> <NL> for _ in range ( size ) : <NEWLINE> <INDENT> for u in g : <NEWLINE> <INDENT> for length , v in g [ u ] : <NEWLINE> <INDENT> if d [ v ] > d [ u ] + length : <NEWLINE> <INDENT> d [ v ] = d [ u ] + length <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> for u in g : <NEWLINE> <INDENT> for length , v in g [ u ] : <NEWLINE> <INDENT> if d [ v ] > d [ u ] + length : <NEWLINE> <INDENT> raise exist_negative_cycle <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return d <NEWLINE> <DEDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> from collections import defaultdict <NEWLINE> <NL> vertex , edge , r = map ( int , readline ( ) . split ( ) ) <NEWLINE> <NL> g = defaultdict ( list ) <NEWLINE> for i in range ( edge ) : <NEWLINE> <INDENT> s , t , length = map ( int , readline ( ) . split ( ) ) <NEWLINE> g [ s ] . append ( ( length , t ) ) <NEWLINE> <DEDENT> try : <NEWLINE> <INDENT> d = bellman_ford ( g , vertex , r ) <NEWLINE> for di in d : <NEWLINE> <INDENT> print ( <STRING> if math . isinf ( di ) else di ) <NEWLINE> <DEDENT> <DEDENT> except exist_negative_cycle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
V , E , root = map ( int , input ( ) . split ( ) ) <NEWLINE> visited = [ False ] * V <NEWLINE> nodes = [ [ ] for i in range ( V ) ] <NEWLINE> cost = [ [ ] for i in range ( V ) ] <NEWLINE> for i in range ( E ) : <NEWLINE> <INDENT> s , t , d = map ( int , input ( ) . split ( ) ) <NEWLINE> nodes [ s ] . append ( t ) <NEWLINE> cost [ s ] . append ( d ) <NEWLINE> <NL> <DEDENT> dist = [ float ( <STRING> ) ] * V <NEWLINE> dist [ root ] = 0 <NEWLINE> <NL> negative_cycle = False <NEWLINE> <NL> for k in range ( V ) : <NEWLINE> <INDENT> for i in range ( V ) : <NEWLINE> <INDENT> for j in range ( nodes [ i ] ) : <NEWLINE> <INDENT> if dist [ nodes [ i ] [ j ] ] > dist [ i ] + cost [ i ] [ j ] : <NEWLINE> <INDENT> dist [ nodes [ i ] [ j ] ] = dist [ i ] + cost [ i ] [ j ] <NEWLINE> if k == n - 1 : <NEWLINE> <INDENT> dist [ nodes [ i ] [ j ] ] = - float ( <STRING> ) <NEWLINE> negative_cycle = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if negative_cycle : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for i in range ( V ) : <NEWLINE> <INDENT> if dist [ i ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( dist [ i ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
import sys <NEWLINE> <NL> def shortestPath ( graph , s ) : <NEWLINE> <INDENT> n = len ( graph ) <NEWLINE> dist = [ inf for _ in range ( n ) ] <NEWLINE> dist [ s ] = 0 <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for u in range ( n ) : <NEWLINE> <INDENT> for v , cost in graph [ u ] : <NEWLINE> <INDENT> newDist = dist [ u ] + cost <NEWLINE> if dist [ u ] != inf and newDist < dist [ v ] : <NEWLINE> <INDENT> if i == n - 1 : <NEWLINE> <INDENT> return None <NEWLINE> <DEDENT> dist [ v ] = newDist <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return dist <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> v , e , s = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> graph = [ [ ] for _ in range ( v ) ] <NEWLINE> <NL> for i in range ( e ) : <NEWLINE> <INDENT> a , b , cost = map ( int , input ( ) . split ( ) ) <NEWLINE> graph [ a ] . append ( ( b , cost ) ) <NEWLINE> <NL> <DEDENT> dist = shortestPath ( graph , s ) <NEWLINE> <NL> if not dist : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for d in dist : <NEWLINE> <INDENT> if d >= inf : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( d ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> main ( ) <NEWLINE>
from collections import defaultdict <NEWLINE> vertices , edges = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> cost_dp = [ [ float ( <STRING> ) if n != m else 0 for n in range ( vertices ) ] for m in range ( vertices ) ] <NEWLINE> for e in range ( edges ) : <NEWLINE> <INDENT> v1 , v2 , weight = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect [ v1 ] . append ( [ v2 , weight ] ) <NEWLINE> connect [ v2 ] . append ( [ v1 , weight ] ) <NEWLINE> cost_dp [ v1 ] [ v2 ] = weight <NEWLINE> <DEDENT> for neg in range ( 2 ) : <NEWLINE> <INDENT> updated = 0 <NEWLINE> for t in range ( vertices ) : <NEWLINE> <INDENT> for i in range ( vertices ) : <NEWLINE> <INDENT> for k in range ( vertices ) : <NEWLINE> <INDENT> if cost_dp [ i ] [ k ] > cost_dp [ i ] [ t ] + cost_dp [ t ] [ k ] : <NEWLINE> <INDENT> updated = 1 <NEWLINE> cost_dp [ i ] [ k ] = cost_dp [ i ] [ t ] + cost_dp [ t ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if neg == 1 and updated : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> for ve in range ( vertices ) : <NEWLINE> <INDENT> ans = [ <STRING> if n == float ( <STRING> ) else n for n in cost_dp [ ve ] ] <NEWLINE> print ( * ans ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> <NL> vertice , edge = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> cost = [ [ 0 if m == n else float ( <STRING> ) for n in range ( vertice ) ] for m in range ( vertice ) ] <NEWLINE> link = defaultdict ( dict ) <NEWLINE> weight = defaultdict ( dict ) <NEWLINE> <NL> for e in range ( edge ) : <NEWLINE> <INDENT> i , j , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> link [ i ] = link . get ( i , set ( ) ) | { j } <NEWLINE> weight [ i ] . update ( { j : w } ) <NEWLINE> <NL> <DEDENT> vertice_cnt = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> if vertice_cnt >= vertice : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> break <NEWLINE> <DEDENT> update = False <NEWLINE> for source in range ( vertice ) : <NEWLINE> <INDENT> for k , value in link . items ( ) : <NEWLINE> <INDENT> for v in value : <NEWLINE> <INDENT> if cost [ source ] [ v ] > cost [ source ] [ k ] + weight [ k ] [ v ] : <NEWLINE> <INDENT> cost [ source ] [ v ] = cost [ source ] [ k ] + weight [ k ] [ v ] <NEWLINE> update = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if not update : <NEWLINE> <INDENT> for o in range ( vertice ) : <NEWLINE> <NL> <INDENT> print ( * ( [ n if n != float ( <STRING> ) else <STRING> for n in cost [ o ] ] ) ) <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> vertice_cnt += 1 <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import heapq <NEWLINE> def aaa ( ) <NEWLINE> <INDENT> vertices , edges = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> link = defaultdict ( dict ) <NEWLINE> weight = defaultdict ( dict ) <NEWLINE> way = [ float ( <STRING> ) ] * vertices <NEWLINE> for e in range ( edges ) : <NEWLINE> <INDENT> source , target , w = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> link [ source ] = link . get ( source , set ( ) ) | { target } <NEWLINE> link [ target ] = link . get ( target , set ( ) ) | { source } <NEWLINE> weight [ source ] . update ( { target : w } ) <NEWLINE> weight [ target ] . update ( { source : w } ) <NEWLINE> <DEDENT> queue = [ ] <NEWLINE> heapq . heapify ( queue ) <NEWLINE> heapq . heappush ( queue , [ 0 , 0 ] ) <NEWLINE> went = [ 0 ] * vertices <NEWLINE> now_weight = 0 <NEWLINE> way [ 0 ] = 0 <NEWLINE> <NL> while len ( went ) < vertices : <NEWLINE> <INDENT> here_weight , here = heapq . heappop ( queue ) <NEWLINE> if here in went : <NEWLINE> <INDENT> continue <NEWLINE> <COMMENT> <NL> <DEDENT> went [ here ] = 1 <NEWLINE> now_weight += here_weight <NEWLINE> can_go = link . get ( here , set ( ) ) - went <NEWLINE> min_weight , next_t = float ( <STRING> ) , - 1 <NEWLINE> for c in can_go : <NEWLINE> <COMMENT> <NL> <INDENT> if c not in went and way [ c ] > weight [ here ] [ c ] : <NEWLINE> <INDENT> heapq . heappush ( queue , [ weight [ here ] [ c ] , c ] ) <NEWLINE> way [ c ] = weight [ here ] [ c ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> print ( now_weight ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> import heapq <NEWLINE> vertices , edges = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> conn = defaultdict ( set ) <NEWLINE> weight = defaultdict ( dict ( ) ) <NEWLINE> for i in range ( edges ) : <NEWLINE> <INDENT> v1 , v2 , w = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> conn [ v1 ] |= { v2 } <NEWLINE> conn [ v2 ] |= { v1 } <NEWLINE> weight [ v1 ] [ v2 ] = w <NEWLINE> weight [ v2 ] [ v1 ] = w <NEWLINE> <NL> <DEDENT> queue = [ ] <NEWLINE> heapq . heapify ( queue ) <NEWLINE> heapq . heappush ( queue , [ 0 , 0 ] ) <NEWLINE> went = set ( ) <NEWLINE> went_vertices = 0 <NEWLINE> answer_weight = 0 <NEWLINE> while went_vertices < vertices : <NEWLINE> <INDENT> here_v , here_weight = heapq . heappop ( queue ) <NEWLINE> if here_v in went : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> went |= { here_v } <NEWLINE> for c in conn [ here_v ] : <NEWLINE> <INDENT> if c not in went : <NEWLINE> <INDENT> heapq . heappush ( queue , [ c , weight [ here_v ] [ c ] ] ) <NEWLINE> <DEDENT> <DEDENT> answer_weight += here_weight <NEWLINE> went_vertices += 1 <NEWLINE> <DEDENT> print ( answer_weight ) <NEWLINE>
class UnionFind : <NEWLINE> <INDENT> def __init__ ( self , size ) : <NEWLINE> <INDENT> self . table = [ - 1 for _ in xrange ( size ) ] <NEWLINE> <NL> <DEDENT> def find ( self , x ) : <NEWLINE> <INDENT> while self . table [ x ] >= 0 : x = self . table [ x ] <NEWLINE> return x <NEWLINE> <NL> <DEDENT> def union ( self , x , y ) : <NEWLINE> <INDENT> s1 = self . find ( x ) <NEWLINE> s2 = self . find ( y ) <NEWLINE> if s1 != s2 : <NEWLINE> <INDENT> if self . table [ s1 ] >= self . table [ s2 ] : <NEWLINE> <INDENT> self . table [ s1 ] += self . table [ s2 ] <NEWLINE> self . table [ s2 ] = s1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . table [ s2 ] += self . table [ s1 ] <NEWLINE> self . table [ s1 ] = s2 <NEWLINE> <DEDENT> return True <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def hash ( n , s , g ) : <NEWLINE> <INDENT> return n * s + g <NEWLINE> <NL> <DEDENT> def dehash ( n , hs ) : <NEWLINE> <INDENT> return [ ( hs - hs % n ) / n , hs % n ] <NEWLINE> <NL> <DEDENT> def kruskal ( n , path ) : <NEWLINE> <INDENT> path = sorted ( path . items ( ) , key = lambda x : x [ 1 ] ) <NEWLINE> selected = { } <NEWLINE> union = UnionFind ( n ) <NEWLINE> for i in xrange ( len ( path ) ) : <NEWLINE> <INDENT> k , v = path [ i ] <NEWLINE> s , g = dehash ( n , k ) <NEWLINE> if union . union ( s , g ) : <NEWLINE> <INDENT> selected [ k ] = v <NEWLINE> <DEDENT> <DEDENT> return selected <NEWLINE> <NL> <DEDENT> V , E = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> path = { } <NEWLINE> for _ in xrange ( E ) : <NEWLINE> <INDENT> s , t , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> path [ hash ( V , s , t ) ] = w <NEWLINE> <DEDENT> result = kruskal ( V , path ) <NEWLINE> sumcost = 0 <NEWLINE> for v in result . values ( ) : <NEWLINE> <INDENT> sumcost += v <NEWLINE> <DEDENT> print sumcost <NEWLINE>
import sys <NEWLINE> from union_find import UnionFind <NEWLINE> from operator import attrgetter <NEWLINE> <NL> class Kruskal : <NEWLINE> <NL> <INDENT> class Edge : <NEWLINE> <INDENT> def __init__ ( self , u , v , cost ) : <NEWLINE> <INDENT> self . u , self . v , self . cost = u , v , cost <NEWLINE> <NL> <DEDENT> def __lt__ ( self , another ) : <NEWLINE> <INDENT> return self . cost < another . cost <NEWLINE> <NL> <DEDENT> <DEDENT> def __init__ ( self , node_size ) : <NEWLINE> <INDENT> self . _node = node_size <NEWLINE> self . _edge_list = [ ] <NEWLINE> <NL> <DEDENT> def add_edge ( self , u , v , cost ) : <NEWLINE> <INDENT> self . _edge_list . append ( self . Edge ( u , v , cost ) ) <NEWLINE> <NL> <DEDENT> def solve ( self ) : <NEWLINE> <INDENT> uf = UnionFind ( self . _node ) <NEWLINE> res = 0 <NEWLINE> edge_count = 0 <NEWLINE> sorted_edge_list = sorted ( self . _edge_list ) <NEWLINE> for e in sorted_edge_list : <NEWLINE> <INDENT> if not uf . same ( e . u , e . v ) : <NEWLINE> <INDENT> uf . unite ( e . u , e . v ) <NEWLINE> res += e . cost <NEWLINE> edge_count += 1 <NEWLINE> if edge_count == self . _node - 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return res <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n , m = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> kr = Kruskal ( n ) <NEWLINE> for _ in range ( m ) : <NEWLINE> <INDENT> s , t , w = map ( int , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> kr . add_edge ( s , t , w ) <NEWLINE> <DEDENT> print ( kr . solve ( ) ) <NEWLINE> <NL> <DEDENT>
import array <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> <NL> AdjacentVertex = collections . namedtuple ( <STRING> , <STRING> ) <NEWLINE> INF = 2 ** 31 - 1 <NEWLINE> NO_VERTEX = - 1 <NEWLINE> <NL> <COMMENT> <NL> def compute_mst_prim ( max_v , adj_list ) : <NEWLINE> <COMMENT> <NL> <INDENT> pred = collections . defaultdict ( lambda : NO_VERTEX ) <NEWLINE> <COMMENT> <NL> key = collections . defaultdict ( lambda : INF ) <NEWLINE> key [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> pq = [ ( key [ v ] , v ) for v in range ( max_v ) ] <NEWLINE> heapq . heapify ( pq ) <NEWLINE> <COMMENT> <NL> in_pq = array . array ( <STRING> , ( True for _ in range ( max_v ) ) ) <NEWLINE> while pq : <NEWLINE> <INDENT> _ , u = heapq . heappop ( pq ) <NEWLINE> in_pq [ u ] = False <NEWLINE> for v , v_cost in adj_list [ u ] : <NEWLINE> <INDENT> if in_pq [ v ] : <NEWLINE> <INDENT> weight = v_cost <NEWLINE> if weight < key [ v ] : <NEWLINE> <INDENT> pred [ v ] = u <NEWLINE> key [ v ] = weight <NEWLINE> heapq . heappush ( pq , ( weight , v ) ) <NEWLINE> in_pq [ v ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ( pred , key ) <NEWLINE> <NL> <DEDENT> max_v , max_e = map ( int , input ( ) . split ( ) ) <NEWLINE> adjacency_list = collections . defaultdict ( set ) <NEWLINE> for _ in range ( max_e ) : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( ) ) <NEWLINE> adjacency_list [ s ] . add ( AdjacentVertex ( t , w ) ) <NEWLINE> adjacency_list [ t ] . add ( AdjacentVertex ( s , w ) ) <NEWLINE> <DEDENT> ( _ , key ) = compute_mst_prim ( max_v , adjacency_list ) <NEWLINE> <NL> print ( sum ( key . values ( ) ) ) import array <NEWLINE> import collections <NEWLINE> import heapq <NEWLINE> <NL> AdjacentVertex = collections . namedtuple ( <STRING> , <STRING> ) <NEWLINE> INF = 2 ** 31 - 1 <NEWLINE> NO_VERTEX = - 1 <NEWLINE> <NL> <COMMENT> <NL> def compute_mst_prim ( max_v , adj_list ) : <NEWLINE> <COMMENT> <NL> <INDENT> pred = collections . defaultdict ( lambda : NO_VERTEX ) <NEWLINE> <COMMENT> <NL> key = collections . defaultdict ( lambda : INF ) <NEWLINE> key [ 0 ] = 0 <NEWLINE> <COMMENT> <NL> pq = [ ( key [ v ] , v ) for v in range ( max_v ) ] <NEWLINE> heapq . heapify ( pq ) <NEWLINE> <COMMENT> <NL> in_pq = array . array ( <STRING> , ( True for _ in range ( max_v ) ) ) <NEWLINE> while pq : <NEWLINE> <INDENT> _ , u = heapq . heappop ( pq ) <NEWLINE> in_pq [ u ] = False <NEWLINE> for v , v_cost in adj_list [ u ] : <NEWLINE> <INDENT> if in_pq [ v ] : <NEWLINE> <INDENT> weight = v_cost <NEWLINE> if weight < key [ v ] : <NEWLINE> <INDENT> pred [ v ] = u <NEWLINE> key [ v ] = weight <NEWLINE> heapq . heappush ( pq , ( weight , v ) ) <NEWLINE> in_pq [ v ] = True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return ( pred , key ) <NEWLINE> <NL> <DEDENT> max_v , max_e = map ( int , input ( ) . split ( ) ) <NEWLINE> adjacency_list = collections . defaultdict ( set ) <NEWLINE> for _ in range ( max_e ) : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( ) ) <NEWLINE> adjacency_list [ s ] . add ( AdjacentVertex ( t , w ) ) <NEWLINE> adjacency_list [ t ] . add ( AdjacentVertex ( s , w ) ) <NEWLINE> <DEDENT> ( _ , key ) = compute_mst_prim ( max_v , adjacency_list ) <NEWLINE> <NL> print ( sum ( key . values ( ) ) ) <NEWLINE>
mport heapq <NEWLINE> from collections import defaultdict <NEWLINE> <NL> INF = float ( <STRING> ) <NEWLINE> <NL> <NL> V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj_list = defaultdict ( set ) <NEWLINE> <NL> for i in range ( E ) : <NEWLINE> <INDENT> s , t , w = map ( int , input ( ) . split ( ) ) <NEWLINE> Adj_list [ s ] . add ( ( t , w ) ) <NEWLINE> Adj_list [ t ] . add ( ( s , w ) ) <NEWLINE> <NL> <DEDENT> def prim ( x ) : <NEWLINE> <INDENT> d = [ INF ] * x <NEWLINE> d [ 0 ] = 0 <NEWLINE> hq = [ ( 0 , 0 ) ] <NEWLINE> <NL> while hq : <NEWLINE> <INDENT> val , u = heapq . heappop ( hq ) <NEWLINE> if val > d [ u ] : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> for v , c in Adj_list [ u ] : <NEWLINE> <INDENT> if d [ v ] > c : <NEWLINE> <INDENT> d [ v ] = c <NEWLINE> heapq . heappush ( hq , ( c , v ) ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return sum ( d ) <NEWLINE> <NL> <DEDENT> print ( prim ( V ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> <NL> sys . setrecursionlimit ( int ( 3e6 ) ) <NEWLINE> UNVISITED , VISITED_IN_STACK , POPPED_OUT = 0 , 1 , 2 <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <COMMENT> <NL> init_adj_table [ v_to ] . append ( v_from ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def graph_dfs ( current , prev ) : <NEWLINE> <INDENT> global timer <NEWLINE> pre_v [ current ] = lowest_v [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> color [ current ] = VISITED_IN_STACK <NEWLINE> <NL> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if color [ adj ] is UNVISITED : <NEWLINE> <INDENT> parent_v [ adj ] = current <NEWLINE> <NL> <COMMENT> <NL> graph_dfs ( adj , current ) <NEWLINE> <NL> lowest_v [ current ] = min ( lowest_v [ current ] , lowest_v [ adj ] ) <NEWLINE> <DEDENT> elif adj is not prev : <NEWLINE> <INDENT> lowest_v [ current ] = min ( lowest_v [ current ] , pre_v [ adj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def art_points ( ) : <NEWLINE> <INDENT> graph_dfs ( dfs_root , - 1 ) <NEWLINE> <NL> np = 0 <NEWLINE> for v in range ( 1 , vertices ) : <NEWLINE> <INDENT> parent = parent_v [ v ] <NEWLINE> if parent is dfs_root : <NEWLINE> <INDENT> np += 1 <NEWLINE> <DEDENT> elif pre_v [ parent ] <= lowest_v [ v ] : <NEWLINE> <INDENT> ans . add ( parent ) <NEWLINE> <NL> <DEDENT> <DEDENT> if np > 1 : <NEWLINE> <INDENT> ans . add ( dfs_root ) <NEWLINE> <NL> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> with open ( <STRING> , <STRING> ) as _in : <NEWLINE> <INDENT> _input = _in . readlines ( ) <NEWLINE> <DEDENT> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> pre_v , parent_v , lowest_v = ( [ 0 ] * vertices for _ in range ( 3 ) ) <NEWLINE> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> <NL> timer = 1 <NEWLINE> <COMMENT> <NL> dfs_root = 0 <NEWLINE> <NL> ans = set ( ) <NEWLINE> color = [ UNVISITED ] * vertices <NEWLINE> <NL> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> res = art_points ( ) <NEWLINE> if not res : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <COMMENT> <NL> <INDENT> print ( * sorted ( res ) , sep = <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> import sys <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def seq ( ) : <NEWLINE> <INDENT> a = 1 <NEWLINE> while True : <NEWLINE> <INDENT> yield a <NEWLINE> a += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( here , went , connect , discovery , low , answer , seq ) : <NEWLINE> <INDENT> went |= { here } <NEWLINE> discovery [ here ] = low [ here ] = next ( seq ) <NEWLINE> child = 0 <NEWLINE> for con in connect [ here ] : <NEWLINE> <INDENT> if con not in went : <NEWLINE> <INDENT> parent [ con ] = here <NEWLINE> child += 1 <NEWLINE> dfs ( con , went , connect , discovery , low , answer , seq ) <NEWLINE> low [ here ] = min ( low [ here ] , low [ con ] ) <NEWLINE> if discovery [ here ] < low [ con ] : <NEWLINE> <INDENT> answer [ min ( here , con ) ] . append ( max ( here , con ) ) <NEWLINE> <DEDENT> <DEDENT> elif parent [ here ] != con : <NEWLINE> <INDENT> low [ here ] = min ( low [ here ] , discovery [ con ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> vertices , edges = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> for _ in range ( edges ) : <NEWLINE> <INDENT> v1 , v2 = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect [ v1 ] . append ( v2 ) <NEWLINE> connect [ v2 ] . append ( v1 ) <NEWLINE> <DEDENT> answer = defaultdict ( list ) <NEWLINE> new_seq = seq ( ) <NEWLINE> went = set ( ) <NEWLINE> discovery = [ 0 for n in range ( vertices ) ] <NEWLINE> low = [ float ( <STRING> ) for n in range ( vertices ) ] <NEWLINE> parent = [ None for n in range ( vertices ) ] <NEWLINE> dfs ( 0 , went , connect , discovery , low , answer , new_seq ) <NEWLINE> <NL> for k in range ( answer . keys ( ) ) : <NEWLINE> <INDENT> for n in range ( answer [ k ] ) : <NEWLINE> <INDENT> print ( k , n ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> sys . setrecursionlimit ( int ( 1e10 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <COMMENT> <NL> init_adj_table [ v_to ] . append ( v_from ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def graph_dfs ( u , visited , parent , low , disc ) : <NEWLINE> <INDENT> global Time <NEWLINE> <COMMENT> <NL> children = 0 <NEWLINE> <NL> <COMMENT> <NL> visited [ u ] = True <NEWLINE> <NL> <COMMENT> <NL> disc [ u ] = Time <NEWLINE> low [ u ] = Time <NEWLINE> Time += 1 <NEWLINE> <NL> <COMMENT> <NL> for v in adj_table [ u ] : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> parent [ v ] = u <NEWLINE> children += 1 <NEWLINE> graph_dfs ( v , visited , parent , low , disc ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> low [ u ] = min ( low [ u ] , low [ v ] ) <NEWLINE> <NL> <STRING> <NEWLINE> if low [ v ] > disc [ u ] : <NEWLINE> <INDENT> ans . append ( sorted ( [ u , v ] ) ) <NEWLINE> <DEDENT> <DEDENT> elif v != parent [ u ] : <COMMENT> <NEWLINE> <INDENT> low [ u ] = min ( low [ u ] , disc [ v ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def bridge ( ) : <NEWLINE> <INDENT> visited = [ False ] * vertices <NEWLINE> disc = [ float ( <STRING> ) ] * vertices <NEWLINE> low = [ float ( <STRING> ) ] * vertices <NEWLINE> parent = [ - 1 ] * vertices <NEWLINE> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> if not visited [ v ] : <NEWLINE> <INDENT> graph_dfs ( v , visited , parent , low , disc ) <NEWLINE> <NL> <DEDENT> <DEDENT> return ans <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> Time = 0 <NEWLINE> ans = [ ] <NEWLINE> <NL> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> res = bridge ( ) <NEWLINE> res . sort ( ) <NEWLINE> for ele in res : <NEWLINE> <INDENT> print ( * ele ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque <NEWLINE> sys . setrecursionlimit ( 1000000 ) <NEWLINE> <NL> <NL> def dfs ( current , prev ) : <NEWLINE> <INDENT> global time <NEWLINE> <COMMENT> <NL> ord [ current ] = time <NEWLINE> low [ current ] = time <NEWLINE> time += 1 <NEWLINE> color [ current ] = BLACK <NEWLINE> <NL> for next in G [ current ] : <NEWLINE> <INDENT> if color [ next ] == WHITE : <NEWLINE> <COMMENT> <NL> <INDENT> parent [ next ] = current <NEWLINE> dfs ( next , current ) <NEWLINE> <NL> <COMMENT> <NL> low [ current ] = min ( low [ current ] , low [ next ] ) <NEWLINE> <DEDENT> elif next != prev : <NEWLINE> <COMMENT> <NL> <INDENT> low [ current ] = min ( low [ current ] , ord [ next ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def bridge ( ) : <NEWLINE> <INDENT> global time <NEWLINE> time = 1 <NEWLINE> dfs ( 0 , - 1 ) <COMMENT> <NEWLINE> for u , v in edges : <NEWLINE> <INDENT> if ord [ u ] < low [ v ] or ord [ v ] < low [ u ] : <NEWLINE> <INDENT> br . add ( ( u , v ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> G = { } <NEWLINE> edges = set ( [ ] ) <NEWLINE> br = set ( [ ] ) <NEWLINE> v , n = map ( int , input ( ) . split ( ) ) <NEWLINE> for i in range ( 0 , v ) : <NEWLINE> <INDENT> G [ i ] = [ ] <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> G [ s ] . append ( t ) <NEWLINE> G [ t ] . append ( s ) <NEWLINE> edges . add ( ( s , t ) ) <NEWLINE> <DEDENT> WHITE = 0 <NEWLINE> BLACK = 2 <NEWLINE> <NL> color = [ WHITE ] * ( v ) <NEWLINE> parent = [ 0 ] * ( v ) <NEWLINE> ord = [ 0 ] * ( v ) <NEWLINE> low = [ 0 ] * ( v ) <NEWLINE> parent = [ 0 ] * ( v ) <NEWLINE> bridge ( ) <NEWLINE> if br : <NEWLINE> <INDENT> for ans in sorted ( br ) : <NEWLINE> <INDENT> print ( * ans , sep = <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT>
def add_edge ( frm , to ) : <NEWLINE> <INDENT> g [ frm ] . append ( to ) <NEWLINE> rg [ to ] . append ( frm ) <NEWLINE> <NL> <DEDENT> def dfs ( now , used , back_track ) : <NEWLINE> <INDENT> used [ now ] = True <NEWLINE> for nx in g [ now ] : <NEWLINE> <INDENT> if not used [ nx ] : dfs ( nx , used , back_track ) <NEWLINE> <DEDENT> back_track . append ( now ) <NEWLINE> <NL> <DEDENT> def rdfs ( now , num_cmp , used , cmp ) : <NEWLINE> <INDENT> used [ now ] = True <NEWLINE> cmp [ now ] = num_cmp <NEWLINE> for nx in rg [ now ] : <NEWLINE> <INDENT> if not used [ nx ] : rdfs ( nx , num_cmp , used , cmp ) <NEWLINE> <NL> <DEDENT> <DEDENT> def scc ( n ) : <NEWLINE> <INDENT> used = [ False ] * n <NEWLINE> back_track = [ ] <NEWLINE> cmp = [ - 1 ] * n <NEWLINE> for v in xrange ( n ) : <NEWLINE> <INDENT> if not used [ v ] : dfs ( v , used , back_track ) <NEWLINE> <DEDENT> used = [ False ] * n <NEWLINE> num_cmp = 0 <NEWLINE> for v in back_track [ : : - 1 ] : <NEWLINE> <INDENT> if not used [ v ] : <NEWLINE> <INDENT> rdfs ( v , num_cmp , used , cmp ) <NEWLINE> num_cmp += 1 <NEWLINE> <DEDENT> <DEDENT> return num_cmp , cmp <NEWLINE> <NL> <DEDENT> n , m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> g = [ [ ] for _ in xrange ( n ) ] <NEWLINE> rg = [ [ ] for _ in xrange ( n ) ] <NEWLINE> <NL> for i in xrange ( m ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> add_edge ( s , t ) <NEWLINE> <NL> <DEDENT> num , cmp = scc ( n ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> for i in xrange ( q ) : <NEWLINE> <INDENT> u , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if cmp [ u ] == cmp [ v ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> from collections import Counter <NEWLINE> def search ( g , v ) : <NEWLINE> <INDENT> visited = set ( ) <NEWLINE> lowest = [ None ] * v <NEWLINE> parent = [ None ] * v <NEWLINE> prenum = [ None ] * v <NEWLINE> child = defaultdict ( list ) <NEWLINE> backtrack = defaultdict ( set ) <NEWLINE> <NL> for root in range ( v ) : <NEWLINE> <INDENT> if root in visited : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> route = Stack ( ) <NEWLINE> route . push ( None ) <NEWLINE> dfs_stack = [ ( root , route [ - 1 ] ) ] <NEWLINE> while dfs_stack : <NEWLINE> <INDENT> u , prev = dfs_stack . pop ( ) <NEWLINE> if u in visited : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> parent [ u ] = prev <NEWLINE> if prev is not None : <NEWLINE> <INDENT> child [ prev ] . append ( u ) <NEWLINE> <DEDENT> visited |= { u } <NEWLINE> prenum [ u ] = lowest [ u ] = len ( visited ) <NEWLINE> <NL> while route [ - 1 ] != prev : <NEWLINE> <INDENT> route . pop ( ) <NEWLINE> <DEDENT> backtrack [ u ] = route & g [ u ] <NEWLINE> route . push ( u ) <NEWLINE> <NL> dfs_stack . extend ( ( v , u ) for v in g [ u ] - visited ) <NEWLINE> <NL> <DEDENT> from heapq import heappush , heappop <NEWLINE> heap = [ ] <NEWLINE> for i in range ( v ) : <NEWLINE> <INDENT> if backtrack [ i ] : <NEWLINE> <INDENT> heappush ( heap , ( prenum [ i ] , i ) ) <NEWLINE> <DEDENT> <DEDENT> while heap : <NEWLINE> <INDENT> _ , i = heappop ( heap ) <NEWLINE> low , bi = min ( ( lowest [ bi ] , bi ) for bi in backtrack [ i ] ) <NEWLINE> while i != bi : <NEWLINE> <INDENT> lowest [ i ] = low <NEWLINE> i = parent [ i ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return prenum , lowest <NEWLINE> <NL> <DEDENT> from sys import stdin <NEWLINE> readline = stdin . readline <NEWLINE> <NL> def main ( ) : <NEWLINE> <INDENT> v , e = map ( int , readline ( ) . split ( ) ) <NEWLINE> from collections import defaultdict <NEWLINE> g = defaultdict ( set ) <NEWLINE> <NL> for _ in range ( e ) : <NEWLINE> <INDENT> s , t = map ( int , readline ( ) . split ( ) ) <NEWLINE> g [ s ] |= { t } <NEWLINE> <NL> <DEDENT> prenum , lowest = search ( g , v ) <NEWLINE> q = int ( readline ( ) ) <NEWLINE> for u , v in [ map ( int , readline ( ) . split ( ) ) for _ in range ( q ) ] : <NEWLINE> <INDENT> print ( 1 if lowest [ u ] == lowest [ v ] else 0 ) <NEWLINE> <NL> <DEDENT> <DEDENT> main ( ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from math import isinf <NEWLINE> <NL> sys . setrecursionlimit ( int ( 1e6 ) ) <NEWLINE> <NL> <NL> def generate_adj_table ( _v_info ) : <NEWLINE> <INDENT> for v_detail in _v_info : <NEWLINE> <INDENT> v_from , v_to = map ( int , v_detail ) <NEWLINE> init_adj_table [ v_from ] . append ( v_to ) <NEWLINE> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> def Tarjan ( current , low , disc , visited , scc_stack , in_scc_stack ) : <NEWLINE> <INDENT> global timer <NEWLINE> disc [ current ] = low [ current ] = timer <NEWLINE> timer += 1 <NEWLINE> <NL> visited [ current ] = True <NEWLINE> scc_stack . append ( current ) <NEWLINE> in_scc_stack [ current ] = True <NEWLINE> <NL> current_scc_set = set ( ) <NEWLINE> for adj in adj_table [ current ] : <NEWLINE> <INDENT> if not isinf ( disc [ adj ] ) : <NEWLINE> <INDENT> Tarjan ( adj , low , disc , visited , scc_stack , in_scc_stack ) <NEWLINE> low [ current ] = min ( low [ current ] , low [ adj ] ) <NEWLINE> <NL> <DEDENT> elif in_scc_stack [ adj ] : <NEWLINE> <INDENT> low [ current ] = min ( low [ current ] , disc [ adj ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> scc_candidate = - 1 <NEWLINE> if disc [ current ] == low [ current ] : <NEWLINE> <INDENT> while scc_candidate != current : <NEWLINE> <INDENT> scc_candidate = scc_stack . pop ( ) <NEWLINE> current_scc_set . add ( scc_candidate ) <NEWLINE> visited [ scc_candidate ] = False <NEWLINE> in_scc_stack [ scc_candidate ] = False <NEWLINE> <NL> <DEDENT> init_scc_sets_list . append ( current_scc_set ) <NEWLINE> <NL> <DEDENT> return None <NEWLINE> <NL> <NL> <DEDENT> def scc ( ) : <NEWLINE> <INDENT> disc = [ float ( <STRING> ) ] * vertices <NEWLINE> low = [ float ( <STRING> ) ] * vertices <NEWLINE> visited = [ False ] * vertices <NEWLINE> scc_stack = list ( ) <NEWLINE> in_scc_stack = [ False ] * vertices <NEWLINE> <NL> for v in range ( vertices ) : <NEWLINE> <INDENT> if isinf ( disc [ v ] ) : <NEWLINE> <INDENT> Tarjan ( v , low , disc , visited , scc_stack , in_scc_stack ) <NEWLINE> <NL> <DEDENT> <DEDENT> return init_scc_sets_list <NEWLINE> <NL> <NL> <DEDENT> def solve ( ) : <NEWLINE> <INDENT> for question in q_list : <NEWLINE> <INDENT> flag = False <NEWLINE> ele1 , ele2 = map ( int , question ) <NEWLINE> for each in scc_sets_list : <NEWLINE> <INDENT> if ( ele1 in each ) and ( ele2 in each ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> return scc_sets_list <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> vertices , edges = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> v_info = map ( lambda x : x . split ( ) , _input [ 1 : edges + 1 ] ) <NEWLINE> q_num = int ( _input [ edges + 1 ] ) <NEWLINE> q_list = map ( lambda x : x . split ( ) , _input [ edges + 2 : ] ) <NEWLINE> <NL> init_adj_table = tuple ( [ ] for _ in range ( vertices ) ) <NEWLINE> adj_table = generate_adj_table ( v_info ) <NEWLINE> <NL> timer = 0 <NEWLINE> init_scc_sets_list = [ ] <NEWLINE> scc_sets_list = scc ( ) <NEWLINE> res = solve ( ) <NEWLINE> <DEDENT>
from collections import defaultdict <NEWLINE> sys . setrecursionlimit ( 100000 ) <NEWLINE> <NL> def counter ( ) : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> while True : <NEWLINE> <INDENT> yield cnt <NEWLINE> cnt += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> def dfs ( here , visited , track , count , connect ) : <NEWLINE> <INDENT> visited |= { here } <NEWLINE> for c in connect [ here ] : <NEWLINE> <INDENT> if c not in visited : <NEWLINE> <INDENT> dfs ( c , visited , track , count , connect ) <NEWLINE> <DEDENT> <DEDENT> track [ here ] = next ( count ) <NEWLINE> <NL> <DEDENT> def kosaraju ( here , visited , track , count , connect ) : <NEWLINE> <INDENT> visited |= { here } <NEWLINE> for c in connect [ here ] : <NEWLINE> <INDENT> if c not in visited : <NEWLINE> <INDENT> kosaraju ( c , visited , track , count , connect ) <NEWLINE> <DEDENT> <DEDENT> track [ here ] = count <NEWLINE> <NL> <DEDENT> vertices , edges = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> reversed_connect = defaultdict ( list ) <NEWLINE> for _ in range ( edges ) : <NEWLINE> <INDENT> v1 , v2 = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect [ v1 ] . append ( v2 ) <NEWLINE> reversed_connect [ v2 ] . append ( v1 ) <NEWLINE> <NL> <DEDENT> visited = set ( ) <NEWLINE> track_gen = counter ( ) <NEWLINE> track = [ - 1 for n in range ( vertices ) ] <NEWLINE> for v in range ( vertices ) : <NEWLINE> <INDENT> if v not in visited : <NEWLINE> <INDENT> dfs ( v , visited , track , track_gen , connect ) <NEWLINE> <NL> <DEDENT> <DEDENT> visited = set ( ) <NEWLINE> track_gen = counter ( ) <NEWLINE> strongly_con = [ - 1 for n in range ( vertices ) ] <NEWLINE> for v in range ( vertices - 1 , - 1 , - 1 ) : <NEWLINE> <INDENT> here = track . index ( v ) <NEWLINE> if here not in visited : <NEWLINE> <INDENT> num = next ( track_gen ) <NEWLINE> kosaraju ( here , visited , strongly_con , num , reversed_connect ) <NEWLINE> <NL> <DEDENT> <DEDENT> q_num = int ( input ( ) ) <NEWLINE> for _ in range ( q_num ) : <NEWLINE> <INDENT> v1 , v2 = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> if strongly_con [ v1 ] == strongly_con [ v2 ] : <NEWLINE> <INDENT> print ( 1 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
from collections import deque , defaultdict <NEWLINE> <NL> def topological_sort ( V , E ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> indeg = { v : 0 for v in V } <NEWLINE> for ends in E . values ( ) : <NEWLINE> <INDENT> for v in ends : <NEWLINE> <INDENT> indeg [ v ] += 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = deque ( [ v for v in V if indeg [ v ] == 0 ] ) <NEWLINE> top_sorted = [ ] <NEWLINE> while q : <NEWLINE> <INDENT> v = q . popleft ( ) <NEWLINE> top_sorted . append ( v ) <NEWLINE> <NL> for u in E [ v ] : <NEWLINE> <INDENT> indeg [ u ] -= 1 <NEWLINE> if indeg [ u ] == 0 : <NEWLINE> <INDENT> q . append ( u ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> if len ( top_sorted ) == len ( V ) : <COMMENT> <NEWLINE> <INDENT> return top_sorted <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> return None <NEWLINE> <NL> <DEDENT> <DEDENT> N , M = map ( int , input ( ) . split ( ) ) <NEWLINE> E = defaultdict ( list ) <NEWLINE> for _ in range ( M ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> E [ s ] . append ( t ) <NEWLINE> <DEDENT> print ( * topological_sort ( V , E ) , sep = <STRING> ) <NEWLINE>
def topologicalSortBfs ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> color [ i ] = WHITE <NEWLINE> <NL> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> if indeg [ i ] == 0 and color [ i ] == WHITE : <NEWLINE> <INDENT> bfs ( i ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def bfs ( s ) : <NEWLINE> <INDENT> Q . appendleft ( s ) <NEWLINE> color [ s ] = GRAY <NEWLINE> while Q : <NEWLINE> <INDENT> u = Q . popleft ( ) <NEWLINE> <NL> out . append ( u ) <NEWLINE> <NL> for v in G [ u ] : <NEWLINE> <INDENT> indeg [ v ] -= 1 <NEWLINE> if indeg [ v ] == 0 and color [ v ] == WHITE : <NEWLINE> <INDENT> color [ v ] = GRAY <NEWLINE> Q . append ( v ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def topologicalSortDfs ( n ) : <NEWLINE> <INDENT> for i in range ( n ) : <NEWLINE> <INDENT> color [ i ] = WHITE <NEWLINE> <NL> <DEDENT> for s in range ( 0 , n ) : <NEWLINE> <INDENT> if color [ s ] == WHITE : <NEWLINE> <INDENT> dfs ( s ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def dfs ( u ) : <NEWLINE> <INDENT> color [ u ] = GRAY <NEWLINE> for v in G [ u ] : <NEWLINE> <INDENT> if color [ v ] == WHITE : <NEWLINE> <INDENT> dfs ( v ) <NEWLINE> <DEDENT> <DEDENT> out . appendleft ( u ) <NEWLINE> <NL> <NL> <DEDENT> n , e = map ( int , input ( ) . split ( ) ) <NEWLINE> G = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> G [ i ] = [ ] <NEWLINE> <DEDENT> indeg = [ 0 ] * n <NEWLINE> for i in range ( e ) : <NEWLINE> <INDENT> s , t = map ( int , input ( ) . split ( ) ) <NEWLINE> indeg [ t ] += 1 <NEWLINE> G [ s ] . append ( t ) <NEWLINE> <DEDENT> color = [ None ] * n <NEWLINE> out = deque ( [ ] ) <NEWLINE> WHITE = 0 <NEWLINE> GRAY = 1 <NEWLINE> Q = deque ( [ ] ) <NEWLINE> <NL> topologicalSortDfs ( n ) <NEWLINE> print ( * out ) <NEWLINE>
from collections import deque <NEWLINE> <NL> def Topologicalsort ( ) : <NEWLINE> <INDENT> for i in xrange ( v ) : <NEWLINE> <INDENT> if indeg [ i ] == 0 and color [ i ] == 0 : <NEWLINE> <INDENT> bfs ( i ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def bfs ( s ) : <NEWLINE> <INDENT> color [ s ] = 2 <NEWLINE> q . append ( s ) <NEWLINE> while len ( q ) > 0 : <NEWLINE> <INDENT> i = q . popleft ( ) <NEWLINE> ans . append ( i ) <NEWLINE> for j in xrange ( v ) : <NEWLINE> <INDENT> if m [ i ] [ j ] != - 1 : <NEWLINE> <INDENT> indeg [ j ] -= 1 <NEWLINE> if indeg [ j ] == 0 and color [ j ] == 0 : <NEWLINE> <INDENT> q . append ( m [ i ] [ j ] ) <NEWLINE> color [ j ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> v , e = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = [ [ - 1 ] * v for i in xrange ( v ) ] <NEWLINE> indeg = [ 0 ] * v <NEWLINE> color = [ 0 ] * v <NEWLINE> ans = deque ( ) <NEWLINE> q = deque ( ) <NEWLINE> for i in xrange ( e ) : <NEWLINE> <INDENT> s , t = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m [ s ] [ t ] = t <NEWLINE> indeg [ t ] += 1 <NEWLINE> <DEDENT> Topologicalsort ( ) <NEWLINE> for i in ans : <NEWLINE> <INDENT> print ( i ) <NEWLINE> <DEDENT>
from sys import stdin <NEWLINE> from collections import deque <NEWLINE> V , E = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> adj_list = [ [ ] for _ in [ ] * V ] <NEWLINE> is_visited = [ False ] * V <NEWLINE> for _ in [ 0 ] * E : <NEWLINE> <INDENT> s , t = map ( int , stdin . readline ( ) . split ( ) ) <NEWLINE> adj_list [ s ] . append ( t ) <NEWLINE> <DEDENT> out = deque ( ) <NEWLINE> def dfs ( u ) : <NEWLINE> <INDENT> is_visited [ u ] = True <NEWLINE> for v in adj_list [ u ] : <NEWLINE> <INDENT> if not is_visited [ v ] : <NEWLINE> <INDENT> dfs ( v ) <NEWLINE> <DEDENT> <DEDENT> out . appendleft ( u ) <NEWLINE> <DEDENT> for s in range ( V ) : <NEWLINE> <INDENT> if not is_visited [ s ] : <NEWLINE> <INDENT> dfs ( s ) <NEWLINE> <DEDENT> <DEDENT> print ( * out , sep = <STRING> ) <NEWLINE>
import sys <NEWLINE> sys . setrecursionlimit ( 10 ** 6 ) <NEWLINE> n = input ( ) <NEWLINE> G = [ [ ] for i in xrange ( n ) ] <NEWLINE> for i in xrange ( n - 1 ) : <NEWLINE> <INDENT> s , t , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> G [ s ] . append ( ( t , w ) ) <NEWLINE> G [ t ] . append ( ( s , w ) ) <NEWLINE> <NL> <DEDENT> def dfs ( s , prev ) : <NEWLINE> <INDENT> if prev != - 1 and len ( G [ s ] ) == 1 : <NEWLINE> <INDENT> return ( 0 , s ) <NEWLINE> <DEDENT> res = ( 0 , s ) <NEWLINE> for t , w in G [ s ] : <NEWLINE> <INDENT> if t == prev : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> cost , v = dfs ( t , s ) <NEWLINE> res = max ( res , ( cost + w , v ) ) <NEWLINE> <DEDENT> return res <NEWLINE> <DEDENT> co , t = dfs ( 0 , - 1 ) <NEWLINE> print dfs ( t , - 1 ) [ 0 ] <NEWLINE>
import sys <NEWLINE> readline = sys . stdin . readline <NEWLINE> from collections import deque <NEWLINE> from math import isinf <NEWLINE> INF = float ( <STRING> ) <NEWLINE> sys . setrecursionlimit ( 200000 ) <NEWLINE> n = int ( readline ( ) ) <NEWLINE> G = [ [ ] for _ in range ( n ) ] <NEWLINE> for _ in [ 0 ] * ( n - 1 ) : <NEWLINE> <INDENT> s , t , w = map ( int , readline ( ) . split ( ) ) <NEWLINE> G [ s ] . append ( [ t , w ] ) <NEWLINE> G [ t ] . append ( [ s , w ] ) <NEWLINE> <DEDENT> def bfs ( s , D ) : <NEWLINE> <INDENT> dq = deque ( [ s ] ) <NEWLINE> D = [ INF ] * n <NEWLINE> D [ s ] = 0 <NEWLINE> while dq : <NEWLINE> <INDENT> u = dq . popleft ( ) <NEWLINE> for i in range ( len ( G [ u ] ) ) : <NEWLINE> <INDENT> e = G [ u ] [ i ] <NEWLINE> if isinf ( D [ e [ 0 ] ] ) : <NEWLINE> <INDENT> D [ e [ 0 ] ] = D [ u ] + e [ 1 ] <NEWLINE> dq . append ( e [ 0 ] ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return D <NEWLINE> <DEDENT> D = bfs ( 0 , D ) <NEWLINE> D = bfs ( max ( [ i for i in range ( n ) if not isinf ( D [ i ] ) and 0 < D [ i ] ] ) ) <NEWLINE> print ( max ( D [ i ] for i in range ( n ) if not isinf ( D [ i ] ) ) ) <NEWLINE>
import sys <NEWLINE> if sys . version [ 0 ] == <STRING> : <NEWLINE> <INDENT> range , input = xrange , raw_input <NEWLINE> <NL> <NL> <DEDENT> class HeavyLightDecomposition : <NEWLINE> <INDENT> def __init__ ( self , g , root = 0 ) : <NEWLINE> <INDENT> self . g = g <NEWLINE> self . vid , self . head , self . heavy , self . parent = [ 0 ] * len ( g ) , [ - 1 ] * len ( g ) , [ - 1 ] * len ( g ) , [ - 1 ] * len ( g ) <NEWLINE> self . dfs ( root ) <NEWLINE> self . bfs ( root ) <NEWLINE> <NL> <DEDENT> def dfs ( self , root ) : <NEWLINE> <INDENT> stack = [ ( root , - 1 , False ) ] <NEWLINE> sub , max_sub = [ 1 ] * len ( self . g ) , [ ( 0 , - 1 ) ] * len ( self . g ) <NEWLINE> while stack : <NEWLINE> <INDENT> v , par , flag = stack . pop ( ) <NEWLINE> if not flag : <NEWLINE> <INDENT> self . parent [ v ] = par <NEWLINE> stack . append ( ( v , par , True ) ) <NEWLINE> stack . extend ( ( c , v , False ) for c in self . g [ v ] if c != par ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if par != - 1 : <NEWLINE> <INDENT> sub [ par ] += sub [ v ] <NEWLINE> if sub [ v ] > max_sub [ 0 ] : <NEWLINE> <INDENT> max_sub [ par ] = ( sub [ v ] , v ) <NEWLINE> <DEDENT> <DEDENT> self . heavy [ v ] = max_sub [ v ] [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def bfs ( self , root = 0 ) : <NEWLINE> <INDENT> from collections import deque <NEWLINE> k , que = 0 , deque ( [ root ] ) <NEWLINE> while que : <NEWLINE> <INDENT> r = v = que . popleft ( ) <NEWLINE> while v != - 1 : <NEWLINE> <INDENT> self . vid [ v ] , self . head [ v ] = k , r <NEWLINE> for c in self . g [ v ] : <NEWLINE> <INDENT> if c != self . parent [ v ] and c != self . heavy [ v ] : <NEWLINE> <INDENT> que . append ( c ) <NEWLINE> <DEDENT> <DEDENT> k += 1 <NEWLINE> v = self . heavy [ v ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def lca ( self , u , v ) : <NEWLINE> <INDENT> while self . head [ u ] != self . head [ v ] : <NEWLINE> <INDENT> if self . vid [ u ] > self . vid [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> v = self . parent [ self . head [ v ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if self . vid [ u ] > self . vid [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> <DEDENT> return u <NEWLINE> <NL> <DEDENT> <DEDENT> N = int ( input ( ) ) <NEWLINE> g = [ [ ] for _ in range ( N ) ] <NEWLINE> for i in range ( N ) : <NEWLINE> <INDENT> for c in map ( int , input ( ) . split ( ) [ 1 : ] ) : <NEWLINE> <INDENT> g [ i ] . append ( c ) <NEWLINE> g [ c ] . append ( i ) <NEWLINE> <DEDENT> <DEDENT> hld = HeavyLightDecomposition ( g ) <NEWLINE> Q = int ( input ( ) ) <NEWLINE> for _ in range ( Q ) : <NEWLINE> <INDENT> u , v = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( hld . lca ( u , v ) ) <NEWLINE> <DEDENT>
from collections import deque <NEWLINE> n = input ( ) <NEWLINE> <NL> C = [ None ] * n <NEWLINE> P = [ None ] * n <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> ipt = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> C [ i ] = ipt [ 1 : ] <NEWLINE> for c in C [ i ] : <NEWLINE> <INDENT> P [ c ] = i <NEWLINE> <DEDENT> <DEDENT> LEV = ( n + 1 ) . bit_length ( ) <NEWLINE> parent = [ [ None ] * ( LEV + 1 ) for i in xrange ( n ) ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> parent [ i ] [ 0 ] = P [ i ] <NEWLINE> <DEDENT> for k in xrange ( 1 , LEV ) : <NEWLINE> <INDENT> for i in xrange ( n ) : <NEWLINE> <INDENT> if parent [ i ] [ k ] is None : <NEWLINE> <INDENT> parent [ i ] [ k + 1 ] = None <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> parent [ i ] [ k + 1 ] = parent [ parent [ i ] [ k ] ] [ k ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> depth = [ None ] * n <NEWLINE> deq = deque ( ) <NEWLINE> deq . append ( 0 ) <NEWLINE> depth [ 0 ] = 0 <NEWLINE> while deq : <NEWLINE> <INDENT> v = deq . popleft ( ) <NEWLINE> for c in C [ v ] : <NEWLINE> <INDENT> deq . append ( c ) <NEWLINE> depth [ c ] = depth [ v ] + 1 <NEWLINE> <NL> <DEDENT> <DEDENT> q = input ( ) <NEWLINE> for t in xrange ( q ) : <NEWLINE> <INDENT> u , v = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if not depth [ u ] < depth [ v ] : <NEWLINE> <INDENT> u , v = v , u <NEWLINE> <DEDENT> for k in xrange ( LEV + 1 ) : <NEWLINE> <INDENT> if ( ( depth [ v ] - depth [ u ] ) >> k ) & 1 : <NEWLINE> <INDENT> v = parent [ v ] [ k ] <NEWLINE> <DEDENT> <DEDENT> if u == v : <NEWLINE> <INDENT> print u <NEWLINE> continue <NEWLINE> <NL> <DEDENT> for k in xrange ( LEV , - 1 , - 1 ) : <NEWLINE> <INDENT> if parent [ u ] [ k ] != parent [ v ] [ k ] : <NEWLINE> <INDENT> u = parent [ u ] [ k ] <NEWLINE> v = parent [ v ] [ k ] <NEWLINE> <DEDENT> <DEDENT> print parent [ u ] [ 0 ] <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def graph_bfs ( source , target , parent ) : <NEWLINE> <INDENT> visited = [ False ] * v_num <NEWLINE> queue = deque ( ) <NEWLINE> queue . appendleft ( source ) <NEWLINE> visited [ source ] = True <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> current = queue . popleft ( ) <NEWLINE> for adj , cp in adj_table [ current ] . items ( ) : <NEWLINE> <INDENT> if cp and not visited [ adj ] : <NEWLINE> <INDENT> queue . append ( adj ) <NEWLINE> visited [ adj ] = True <NEWLINE> parent [ adj ] = current <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return True if visited [ target ] else False <NEWLINE> <NL> <NL> <DEDENT> def graphFordFulkerson ( source , sink ) : <NEWLINE> <INDENT> parent = [ - 1 ] * v_num <NEWLINE> max_flow = 0 <NEWLINE> <NL> while graph_bfs ( source , sink , parent ) : <NEWLINE> <INDENT> path_flow = float ( <STRING> ) <NEWLINE> <NL> bk_1 = sink <NEWLINE> while bk_1 is not source : <NEWLINE> <INDENT> path_flow = min ( path_flow , adj_table [ parent [ bk_1 ] ] [ bk_1 ] ) <NEWLINE> bk_1 = parent [ bk_1 ] <NEWLINE> <NL> <DEDENT> max_flow += path_flow <NEWLINE> <NL> bk_2 = sink <NEWLINE> while bk_2 is not source : <NEWLINE> <INDENT> parent_bk_2 = parent [ bk_2 ] <NEWLINE> assert parent_bk_2 != - 1 <NEWLINE> adj_table [ parent_bk_2 ] . setdefault ( bk_2 , 0 ) <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> adj_table [ parent_bk_2 ] [ bk_2 ] -= path_flow <NEWLINE> adj_table [ bk_2 ] [ parent_bk_2 ] += path_flow <NEWLINE> bk_2 = parent [ bk_2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return max_flow <NEWLINE> <NL> <NL> <DEDENT> def generate_adj_table ( _edges ) : <NEWLINE> <INDENT> for edge in _edges : <NEWLINE> <INDENT> source , target , cp = map ( int , edge ) <NEWLINE> init_adj_table [ source ] [ target ] = cp <NEWLINE> <NL> <DEDENT> return init_adj_table <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> v_num , e_num = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> edges = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> init_adj_table = [ dict ( ) for _ in range ( v_num ) ] <NEWLINE> adj_table = generate_adj_table ( edges ) <NEWLINE> ans = graphFordFulkerson ( source = 0 , sink = v_num - 1 ) <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <STRING> <NEWLINE> <NL> import sys <NEWLINE> from collections import deque <NEWLINE> <NL> <NL> def bfs ( source , target ) : <NEWLINE> <INDENT> queue = deque ( ) <NEWLINE> queue . appendleft ( source ) <NEWLINE> visited [ source ] = True <NEWLINE> <NL> while queue : <NEWLINE> <INDENT> current = queue . popleft ( ) <NEWLINE> for adj , cp in adj_table [ current ] . items ( ) : <NEWLINE> <INDENT> if cp and not visited [ adj ] : <NEWLINE> <INDENT> queue . append ( adj ) <NEWLINE> visited [ adj ] = True <NEWLINE> parent [ adj ] = current <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> return True if visited [ target ] else False <NEWLINE> <NL> <NL> <DEDENT> def graph_FordFulkerson ( source , sink ) : <NEWLINE> <INDENT> max_flow = 0 <NEWLINE> <NL> while bfs ( source , sink ) : <NEWLINE> <INDENT> path_flow = float ( <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> bk_1 = sink <NEWLINE> while bk_1 != source : <NEWLINE> <INDENT> parent_bk_1 = parent [ bk_1 ] <NEWLINE> assert parent_bk_1 != - 1 <NEWLINE> path_flow = min ( path_flow , adj_table [ parent_bk_1 ] [ bk_1 ] ) <NEWLINE> bk_1 = parent [ bk_1 ] <NEWLINE> <NL> <DEDENT> max_flow += path_flow <NEWLINE> <NL> <COMMENT> <NL> bk_2 = sink <NEWLINE> while bk_2 != source : <NEWLINE> <INDENT> parent_bk_2 = parent [ bk_2 ] <NEWLINE> assert parent_bk_2 != - 1 <NEWLINE> adj_table [ bk_2 ] . setdefault ( parent_bk_2 , 0 ) <NEWLINE> adj_table [ parent_bk_2 ] [ bk_2 ] -= path_flow <NEWLINE> adj_table [ bk_2 ] [ parent_bk_2 ] += path_flow <NEWLINE> bk_2 = parent [ bk_2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> return max_flow <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> _input = sys . stdin . readlines ( ) <NEWLINE> v_num , e_num = map ( int , _input [ 0 ] . split ( ) ) <NEWLINE> edges = map ( lambda x : x . split ( ) , _input [ 1 : ] ) <NEWLINE> <NL> adj_table = tuple ( dict ( ) for _ in range ( v_num ) ) <NEWLINE> for edge in edges : <NEWLINE> <INDENT> s , t , c = map ( int , edge ) <NEWLINE> adj_table [ s ] [ t ] = c <NEWLINE> <NL> <DEDENT> parent = [ - 1 ] * v_num <NEWLINE> visited = [ False ] * v_num <NEWLINE> <NL> print ( graph_FordFulkerson ( source = 0 , sink = v_num - 1 ) ) <NEWLINE> <DEDENT>
V , E = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> import collections <NEWLINE> import queue <NEWLINE> <NL> <NL> class Dinic ( ) : <NEWLINE> <INDENT> def __init__ ( self , N ) : <NEWLINE> <INDENT> self . N = N <NEWLINE> self . edges = collections . defaultdict ( list ) <NEWLINE> self . level = [ 0 ] * N <NEWLINE> self . iter = [ 0 ] * N <NEWLINE> <NL> <DEDENT> def add ( self , u , v , c , directed = True ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> if directed : <NEWLINE> <INDENT> self . edges [ u ] . append ( [ v , c , len ( self . edges [ v ] ) ] ) <NEWLINE> self . edges [ v ] . append ( [ u , c , len ( self . edges [ u ] ) - 1 ] ) <NEWLINE> <DEDENT> else : <COMMENT> <NEWLINE> <INDENT> self . edges [ u ] . append ( [ v , c , len ( self . edges [ u ] ) ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def bfs ( self , s ) : <NEWLINE> <INDENT> self . level = [ - 1 ] * self . N <NEWLINE> self . level [ s ] = 0 <NEWLINE> que = queue . Queue ( ) <NEWLINE> que . put ( s ) <NEWLINE> while not que . empty ( ) : <NEWLINE> <INDENT> v = que . get ( a ) <NEWLINE> for i in range ( len ( self . edges [ v ] ) ) : <NEWLINE> <INDENT> e = self . edges [ v ] [ i ] <NEWLINE> if e [ 1 ] > 0 and self . level [ e [ 0 ] ] < 0 : <NEWLINE> <INDENT> self . level [ e [ 0 ] ] = self . level [ v ] + 1 <NEWLINE> que . put ( e [ 0 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def dfs ( self , v , t , f ) : <NEWLINE> <INDENT> if v == t : <NEWLINE> <INDENT> return f <NEWLINE> <DEDENT> for i in range ( self . iter [ v ] , len ( self . edges [ v ] ) ) : <NEWLINE> <INDENT> self . iter [ v ] = i <NEWLINE> e = self . edges [ v ] [ i ] <NEWLINE> if e [ 1 ] > 0 and self . level [ v ] < self . level [ e [ 0 ] ] : <NEWLINE> <INDENT> d = self . dfs ( e [ 0 ] , t , min ( f , e [ 1 ] ) ) <NEWLINE> if d > 0 : <NEWLINE> <INDENT> e [ 1 ] -= d <NEWLINE> self . edges [ e [ 0 ] ] [ e [ 2 ] ] [ 1 ] += d <NEWLINE> return d <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> def maxFlow ( self , s , t ) : <NEWLINE> <INDENT> flow = 0 <NEWLINE> while True : <NEWLINE> <INDENT> self . bfs ( s ) <NEWLINE> if self . level [ t ] < 0 : <NEWLINE> <INDENT> return flow <NEWLINE> <DEDENT> self . iter = [ 0 ] * ( self . N ) <NEWLINE> f = self . dfs ( s , t , float ( <STRING> ) ) <NEWLINE> while f > 0 : <NEWLINE> <INDENT> flow += f <NEWLINE> f = self . dfs ( s , t , float ( <STRING> ) ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> graph = Dinic ( V ) <NEWLINE> <NL> for i in range ( E ) : <NEWLINE> <INDENT> u , v , c = map ( int , input ( ) . split ( ) ) <NEWLINE> graph . add ( u , v , c ) <NEWLINE> <NL> <DEDENT> print ( graph . maxFlow ( 0 , V - 1 ) ) <NEWLINE>
v_num , e_num , flow = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> edges = defaultdict ( list ) <NEWLINE> for _ in range ( e_num ) : <NEWLINE> <INDENT> s1 , t1 , cap , cost = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> edges [ s1 ] . append ( [ t1 , cap , cost , len ( edges [ t1 ] ) ] ) <NEWLINE> edges [ t1 ] . append ( [ s1 , cap , cost , len ( edges [ s1 ] ) ] ) <NEWLINE> <DEDENT> answer = 0 <NEWLINE> before_vertice = [ float ( <STRING> ) for n in range ( v_num ) ] <NEWLINE> before_edge = [ float ( <STRING> ) for n in range ( v_num ) ] <NEWLINE> sink = v_num - 1 <NEWLINE> while True : <NEWLINE> <INDENT> distance = [ float ( <STRING> ) for n in range ( v_num ) ] <NEWLINE> distance [ 0 ] = 0 <NEWLINE> updated = 1 <NEWLINE> while updated : <NEWLINE> <INDENT> updated = 0 <NEWLINE> for v in range ( v_num ) : <NEWLINE> <INDENT> if distance [ v ] == float ( <STRING> ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> for i , ( target , cap , cost , trace_i ) in enumerate ( edges [ v ] ) : <NEWLINE> <INDENT> if cap > 0 and distance [ target ] > distance [ v ] + cost : <NEWLINE> <INDENT> distance [ target ] = distance [ v ] + cost <NEWLINE> before_vertice [ target ] = v <NEWLINE> before_edge [ target ] = i <NEWLINE> updated = 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if distance [ sink ] == float ( <STRING> ) : <NEWLINE> <INDENT> print ( - 1 ) <NEWLINE> break <NEWLINE> <DEDENT> decreased = flow <NEWLINE> trace_i = sink <NEWLINE> while trace_i != 0 : <NEWLINE> <INDENT> decreased = min ( decreased , edges [ before_vertice [ trace_i ] ] [ before_edge [ trace_i ] ] [ 1 ] ) <NEWLINE> trace_i = before_vertice [ trace_i ] <NEWLINE> <DEDENT> flow -= decreased <NEWLINE> answer += decreased * distance [ sink ] <NEWLINE> trace_i = sink <NEWLINE> while trace_i != 0 : <NEWLINE> <INDENT> this_edge = edges [ before_vertice [ trace_i ] ] [ before_edge [ trace_i ] ] <NEWLINE> this_edge [ 1 ] -= decreased <NEWLINE> trace_i = before_vertice [ trace_i ] <NEWLINE> edges [ trace_i ] [ this_edge [ 3 ] ] [ 1 ] += decreased <NEWLINE> <DEDENT> if flow <= 0 : <NEWLINE> <INDENT> print ( answer ) <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT>
from collections import defaultdict <NEWLINE> def dfs ( here , used , match , connect ) : <NEWLINE> <INDENT> used [ here ] = 1 <NEWLINE> for near in connect [ here ] : <NEWLINE> <INDENT> m = match [ near ] <NEWLINE> if m < 0 or ( not used [ m ] and dfs ( m , used , match , connect ) ) : <NEWLINE> <INDENT> match [ here ] = near <NEWLINE> match [ near ] = here <NEWLINE> return 1 <NEWLINE> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> a_num , b_num , e_num = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> connect = defaultdict ( list ) <NEWLINE> all_v = a_num + b_num <NEWLINE> match = [ - 1 for n in range ( all_v ) ] <NEWLINE> for _ in range ( e_num ) : <NEWLINE> <INDENT> v1 , v2 = ( int ( n ) for n in input ( ) . split ( <STRING> ) ) <NEWLINE> v2 += a_num <NEWLINE> connect [ v1 ] . append ( v2 ) <NEWLINE> connect [ v2 ] . append ( v1 ) <NEWLINE> <DEDENT> answer = 0 <NEWLINE> for i in range ( all_v ) : <NEWLINE> <INDENT> if match [ i ] < 0 : <NEWLINE> <INDENT> if dfs ( i , used , match , connect ) : <NEWLINE> <INDENT> used = [ 0 for n in range ( all_v ) ] <NEWLINE> answer += 1 <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( answer ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x , y = x2 - x1 , y2 - y1 <NEWLINE> print math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE>
imort math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> d = math . sqrt ( pow ( x1 - x2 , 2 ) + pow ( y1 - y2 , 2 ) ) <NEWLINE> print ( d ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = input ( ) . split ( ) <NEWLINE> <NL> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE>
import math <NEWLINE> <NL> ( x1 , y1 , x2 , y2 ) = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <COMMENT> <NL> distance - math . hypot ( ( x2 - x1 ) , ( y2 - y1 ) ) <NEWLINE> print ( <STRING> . format ( distance ) ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( raw_input ( ) . split ( ) ) <NEWLINE> print sqrt ( ( float ( x2 ) - float ( x1 ) ) ** 2 + ( float ( y2 ) - float ( y1 ) ) ** 2 ) <NEWLINE>
import math <NEWLINE> <NL> point = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x1 = point [ 0 ] <NEWLINE> y1 = point [ 1 ] <NEWLINE> x2 = point [ 2 ] <NEWLINE> y2 = point [ 3 ] <NEWLINE> <NL> distance = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> print distance <NEWLINE>
a = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( ( ( a [ 0 ] - a [ 2 ] ) ** 2 + ( a [ 1 ] - a [ 3 ] ) ** 2 ) ** 0.5 ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> x = abs ( x1 - x2 ) ; <NEWLINE> y = abs ( y1 - y2 ) ; <NEWLINE> a = y / math . sin ( math . radians ( 45 ) ) <NEWLINE> print a <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> array = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x1 = array [ 0 ] <NEWLINE> y1 = array [ 1 ] <NEWLINE> x2 = array [ 2 ] <NEWLINE> y2 = array [ 3 ] <NEWLINE> answer = math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) ) <NEWLINE> print answer <NEWLINE> <NL>
import math <NEWLINE> <NL> ( x1 , y1 , x2 , y2 ) = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> distance = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - u1 ) ** 2 ) <NEWLINE> print ( <STRING> . format ( distance ) ) <NEWLINE>
from math import * <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> distance = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) <NEWLINE> print distance <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> p = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> dis = math . sqrt ( ( abs ( p [ 2 ] ) - abs ( p [ 0 ] ) ) ^ 2 + ( abs ( p [ 3 ] ) - abs ( p [ 1 ] ) ) ^ 2 ) <NEWLINE> <NL> print ( round ( dis , 8 ) ) <NEWLINE> <NL>
import math <NEWLINE> x = map ( int , ( raw_input ( ) ) . split ( <STRING> ) ) <NEWLINE> <NL> print math . sqrt ( ( x [ 2 ] - x [ 0 ] ) * ( x [ 2 ] - x [ 0 ] ) + ( x [ 3 ] - x [ 1 ] ) * ( x [ 3 ] - x [ 1 ] ) ) <NEWLINE>
( n , m , o , p ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( ( n - o ) ** 2 + ( m - p ) ** 2 ) ** 0.5 <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ** 0.5 ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> line = [ ] <NEWLINE> for l in sys . stdin : <NEWLINE> <INDENT> for i in l . split ( <STRING> ) : <NEWLINE> <INDENT> line . append ( float ( i ) ) <NEWLINE> <DEDENT> <DEDENT> a = math . sqrt ( ( line [ 0 ] - line [ 2 ] ) ** 2 + ( line [ 1 ] - line [ 3 ] ) ** 2 ) <NEWLINE> print <STRING> % a <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> num = ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) <NEWLINE> xi = num <NEWLINE> for _ in range ( 100 ) : <NEWLINE> <INDENT> xi = ( xi + ( num / xi ) ) / 2.0 <NEWLINE> <DEDENT> print xi <NEWLINE>
from math import * <NEWLINE> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print sqrt ( fabs ( x1 - x2 ) ** 2 + fabs ( y1 - y2 ) ** 2 ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> import math <NEWLINE> print ( <STRING> . format ( math . sqrt ( x1 * x2 + y1 * y2 ) ) ) <NEWLINE>
def distance ( p1 , p2 ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> ( x1 , y1 ) = p1 <NEWLINE> ( x2 , y2 ) = p2 <NEWLINE> return math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE> <NL> <NL> <DEDENT> def run ( ) : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( <STRING> . format ( distance ( ( x1 , y1 ) , ( x2 , y2 ) ) ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> run ( ) <NEWLINE> <DEDENT>
x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x = x2 - x1 <NEWLINE> y = y2 - y1 <NEWLINE> print ( x ** 2 + y ** 2 ) ** 0.5 <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) <NEWLINE>
x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( sqrt ( ( x1 - x2 ) ** 2.0 + ( y1 - y2 ) ** 2.0 ) ) ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = ( float ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> d = math . sqrt ( ( x2 - x1 ) ^ 2.0 + ( y2 - y1 ) ^ 2.0 ) <NEWLINE> print ( d ) <NEWLINE>
import sys <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> x1 , y1 , x2 , y2 = line . strip ( <STRING> ) . split ( ) <NEWLINE> x1 , y1 , x2 , y2 = float ( x1 ) , float ( y1 ) , float ( x2 ) , float ( y2 ) <NEWLINE> print ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> data = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> dx = data [ 2 ] - data [ 0 ] <NEWLINE> dy = data [ 3 ] - data [ 1 ] <NEWLINE> <NL> print math . sqrt ( dx ** 2 + dy ** 2 ) <NEWLINE>
from math import sqrt <NEWLINE> x1 , x2 , y1 , y2 = map ( float , print ( ) . split ( ) ) <NEWLINE> a = abs ( x1 - y1 ) <NEWLINE> b = abs ( x2 - y2 ) <NEWLINE> s = sqrt ( a + b ) <NEWLINE> print ( s ) <NEWLINE>
import math <NEWLINE> <NL> [ x1 , y1 , x2 , y2 ] = [ float ( x ) for x in raw_input ( ) . split ( ) ] <NEWLINE> print ( math . sqrt ( ( x2 - x1 ) ** 2.0 + ( y2 - y1 ) ** 2.0 ) <NEWLINE>
from math import * <NEWLINE> PI = 3.1415926535898 <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> a , b , x , y = map ( float , raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> print pow ( ( a - x ) * ( a - x ) + ( b - y ) * ( b - y ) , 0.5 ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) <NEWLINE>
from math import sqrt <NEWLINE> x_1 , y_1 , x_2 , y_2 = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> print sqrt ( ( x_1 - x_2 ) ** 2 + ( y_1 - y_2 ) ** 2 ) <NEWLINE>
import math <NEWLINE> <NL> x1 , y1 , x2 , y2 = raw_input ( ) . split ( ) <NEWLINE> <NL> tei = x2 - x1 <NEWLINE> taka = y2 - y1 <NEWLINE> <NL> if tei == taka : <NEWLINE> <INDENT> st = math . sqrt ( 2 ) <NEWLINE> answ = st * tei <NEWLINE> print answ <NEWLINE> <DEDENT> if tei != taka : <NEWLINE> <INDENT> answ = ( tei * tei ) + ( taka * taka ) <NEWLINE> print math . sqrt ( answ ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> import math <NEWLINE> <NL> printf = sys . stdout . write <NEWLINE> <NL> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> X = x2 - x1 <NEWLINE> Y = y2 - y1 <NEWLINE> printf ( str ( math . sqrt ( X ** 2 + Y ** 2 ) ) ) <NEWLINE>
from math import sqrt <NEWLINE> x1 , y1 , x2 , y2 = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( int ( <STRING> . format ( sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) ) ) <NEWLINE>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> print ( math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ) <NEWLINE>
import math <NEWLINE> <NL> def floatinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = float ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a = numinput ( ) <NEWLINE> x1 = a [ 0 ] ; y1 = a [ 1 ] ; x2 = a [ 2 ] ; y2 = a [ 3 ] <NEWLINE> print ( math . sqrt ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
lst = input ( ) . split ( ) <NEWLINE> lst = list ( map ( lambda i : float ( i ) , lst ) ) <NEWLINE> x_1 = lst [ 0 ] <NEWLINE> x_2 = lst [ 1 ] <NEWLINE> y_1 = lst [ 2 ] <NEWLINE> y_2 = lst [ 3 ] <NEWLINE> dis = ( ( x_1 - x_2 ) ** 2 + ( y_1 - y_2 ) ** 2 ) ** ( 1 / 2 ) <NEWLINE> print ( <STRING> . format ( dis ) ) <NEWLINE> <NL> <NL>
import math <NEWLINE> <NL> l = [ input ( ) for x in range ( 4 ) ] <NEWLINE> dist = math . sqrt ( ( l [ 0 ] - l [ 2 ] ) ** 2 + ( l [ 1 ] - l [ 3 ] ) ** 2 ) <NEWLINE> print dist <NEWLINE>
using namespace std ; <NEWLINE> <NL> int main ( ) <NEWLINE> { <NEWLINE> <INDENT> double x1 , x2 , y1 , y2 ; <NEWLINE> <NL> cin >> x1 >> y1 >> x2 >> y2 ; <NEWLINE> <NL> cout << fixed << setprecision ( 6 ) << sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) << endl ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
from math import sort <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> <INDENT> print ( math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> p = raw_input ( ) . split ( ) <NEWLINE> x = math . fabs ( int ( p [ 0 ] ) - int ( p [ 2 ] ) ) <NEWLINE> y = math . fabs ( int ( p [ 1 ] ) - int ( p [ 3 ] ) ) <NEWLINE> print <STRING> % math . sqrt ( x ** 2 + y ** 2 ) <NEWLINE>
from math import sqrt <NEWLINE> def main ( ) : <NEWLINE> <NL> <INDENT> x1 , y1 , x2 , y2 = map ( float , input ( ) ) <NEWLINE> print ( sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> x1 , y1 , x2 , y2 = map ( float , input ( ) . split ( ) ) <NEWLINE> x2 = x2 - x1 <NEWLINE> y2 = y2 - y1 <NEWLINE> x1 , y1 = 0 , 0 <NEWLINE> dis = ( x2 ** 2 + y2 ** 2 ) <NEWLINE> print ( math . sqrt ( dis ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> import math <NEWLINE> <NL> a , b , C = map ( int , input ( ) . split ( ) ) <NEWLINE> C = math . radian ( C ) <NEWLINE> h = b * math . sin ( C ) <NEWLINE> S = a * h / 2 <NEWLINE> L = a + b + math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( C ) ) <NEWLINE> print ( <STRING> . format ( S , L , h ) ) <NEWLINE>
import math <NEWLINE> a , b , c = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> cc = math . radians ( c ) <NEWLINE> h = b * math . sin ( cc ) <NEWLINE> S = a * h / 2 <NEWLINE> L = a + b + math . sqrt ( h ** 2 + ( a - b * math . cos ( cc ) ) ** 2 ) <NEWLINE> print ( <STRING> . format ( S , L , h ) ) <NEWLINE>
import math <NEWLINE> a , b , C = map ( float , input ( ) . split ( ) <NEWLINE> C_rad = math . radians ( C ) <NEWLINE> c = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( C_rad ) ) <NEWLINE> S = a * b * math . sin ( C_rad ) / 2 <NEWLINE> L = a + b + c <NEWLINE> h = b * math . sin ( C_rad ) <NEWLINE> print ( <STRING> . format ( S , L , h ) ) <NEWLINE>
import sys <NEWLINE> import math <NEWLINE> <NL> for line in sys . stdin : <NEWLINE> <INDENT> if len ( line ) > 1 : <NEWLINE> <INDENT> a , b , c = line . strip ( <STRING> ) . split ( ) <NEWLINE> a , b , c = int ( a ) , int ( b ) , int ( c ) <NEWLINE> print a * b * math . sin ( radians ( c ) ) <NEWLINE> <DEDENT> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> def floatinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = float ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> data = floatinput ( ) <NEWLINE> a = data [ 0 ] ; b = data [ 1 ] ; C = data [ 2 ] <NEWLINE> S = a * b * 0.5 * math . cos ( math . radians ( C ) ) <NEWLINE> c = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( C ) ) ) <NEWLINE> L = a + b + c <NEWLINE> h = b * math . sin ( math . radians ( C ) ) <NEWLINE> print ( S ) ; print ( L ) : print ( h ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> a , b , C = map ( int , input ( ) . split ( ) ) <NEWLINE> C2 = math . radians ( C ) <NEWLINE> sin = math . sin ( C2 ) <NEWLINE> cos = math . cos ( C2 ) <NEWLINE> S = 0.5 * a * b * sin <NEWLINE> L = a + b + ( math . sqrt ( ( a ** 2 + b ** 2 ) - ( 2 * a * b * cos ) ) ) <NEWLINE> H = ( a * b * sin / 2 ) ( a / 2 ) <NEWLINE> print ( <STRING> . format ( S ) ) <NEWLINE> print ( <STRING> . format ( L ) ) <NEWLINE> print ( <STRING> . format ( H ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> a , b , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = a * b * math . sin ( C * math . pi / 180 ) * ( 1 / 2 ) <NEWLINE> L = a + b + math . sqrt ( a * a + b * b - 2 * a * b * math . cos ( C * math . pi / 180 ) ) <NEWLINE> h = 2 * S / a <NEWLINE> <NL> print ( <STRING> % s , L , h ) <NEWLINE>
import math <NEWLINE> <NL> a , b , C = map ( int , raw_input ( ) ) <NEWLINE> c = math . sqrt ( a * a + b * b - 2 * a * b * math . cos ( math . radians ( C ) ) ) <NEWLINE> L = a + b + c <NEWLINE> S = ( a * b * math . sin ( math . radians ( C ) ) ) / 2 <NEWLINE> h = ( S * 2 ) / a <NEWLINE> print ( <STRING> % ( S , ) ) <NEWLINE> print ( <STRING> % ( L , ) ) <NEWLINE> print ( <STRING> % ( h , ) ) <NEWLINE>
import math <NEWLINE> <NL> a , b , c = map ( float , raw_input ( ) ) <NEWLINE> <NL> print a * b * math . sin ( c ) / 2 <NEWLINE> print a + b + math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( c ) ) <NEWLINE> print b * math . sin ( c ) <NEWLINE>
import math <NEWLINE> from math import radians <NEWLINE> from cmath import sqrt <NEWLINE> a , b , c = map ( int , raw_input ( ) . split ) <NEWLINE> s = ( a * b * math . sin ( radians ( c ) ) ) / 2 <NEWLINE> c = sqrt ( pow ( a , 2 ) + pow ( b , 2 ) - 2 * a * b * math . cos ( radians ( c ) ) ) <NEWLINE> print s <NEWLINE> print a + b + c <NEWLINE> print s * 2 / a <NEWLINE>
import math <NEWLINE> a , b , C = map ( int , input ( ) . split ( ) ) <NEWLINE> C_rad = math . pi * C / 180 <NEWLINE> S = ( 1 / 2 ) * a * b * math . sin ( C_rad ) <NEWLINE> L = a + b + math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * cos ( C_rad ) ) <NEWLINE> h = 2 * S / a <NEWLINE> print ( <STRING> . format ( S ) ) <NEWLINE> print ( <STRING> . format ( L ) ) <NEWLINE> print ( <STRING> . format ( h ) ) <NEWLINE>
import math <NEWLINE> <NL> def triangle ( a , b , deg ) : <NEWLINE> <INDENT> result = { } <NEWLINE> rad = math . radians ( deg ) // 余弦定理 <NEWLINE> c = math . sqrt ( a * a + b * b - ( 2 * a * b * math . cos ( rad ) ) ) <NEWLINE> s = ( a + b + c ) / 2 <NEWLINE> result [ <STRING> ] = math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) <NEWLINE> result [ <STRING> ] = a + b + c <NEWLINE> result [ <STRING> ] = result [ <STRING> ] * 2 / a <NEWLINE> return result <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a , b , deg = map ( int , input ( ) . split ( ) ) <NEWLINE> triangle = triangle ( a , b , deg ) <NEWLINE> print ( triangle [ <STRING> ] ) <NEWLINE> print ( triangle [ <STRING> ] ) <NEWLINE> print ( triangle [ <STRING> ] ) <NEWLINE> <NL> <DEDENT>
import math <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> sinc = round ( math . sin ( math . radians ( c ) ) ) <NEWLINE> s = 1 / 2 * a * b * sinc <NEWLINE> l = math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * cosc ) + a + b <NEWLINE> h = s * 2 / a <NEWLINE> print ( s ) <NEWLINE> print ( l ) <NEWLINE> print ( h ) <NEWLINE>
a , b , C = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> rad = math . radians ( C ) <NEWLINE> c = ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( rad ) ) ** 0.5 <NEWLINE> h = b * math . sin ( rad ) <NEWLINE> print h * a / 2 <NEWLINE> print a + b + c <NEWLINE> print h <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> A , B , DEGREE = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> RADIAN = math . radians ( DEGREE ) <NEWLINE> <NL> C = sqrt ( pow ( A , 2 ) * pow ( B , 2 ) - 2 * A * B * math . cos ( RADIAN ) ) <NEWLINE> S = A * B * math . sin ( RADIAN ) / 2 <NEWLINE> H = A * math . sin ( RADIAN ) <NEWLINE> <NL> print ( <STRING> % ( S , A + B + C , h ) ) <NEWLINE>
from math import sin , cos , pi , sqrt <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a * b * sin ( pi * c / 180 ) / 2 <NEWLINE> c = sqrt ( a ** 2 + b ** 2 - a * b * 2 * cos ( pi * c / 180 ) ) <NEWLINE> h = 2 * S / a <NEWLINE> print ( s ) <NEWLINE> print ( a + b + c ) <NEWLINE> print ( h ) <NEWLINE>
import math <NEWLINE> <NL> a , b , C = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> S = a * b * math . sin ( C ) * 0.5 <NEWLINE> <NL> c2 = a ** 2 + b ** 2 - 2 * a * b * math . cos ( C ) <NEWLINE> <NL> c = sqrt ( c2 ) <NEWLINE> <NL> L = a + b + c <NEWLINE> <NL> h = 2 * S / a <NEWLINE> <NL> print ( S ) <NEWLINE> print ( L ) <NEWLINE> print ( h ) <NEWLINE>
lst = input ( ) . split ( ) <NEWLINE> lst = list ( map ( lambda i : int ( i ) , lst ) ) <NEWLINE> a , b , C = lst [ 0 ] , lst [ 1 ] , lst [ 2 ] <NEWLINE> S = ( 1 / 2 ) * a * b * math . sin ( math . radians ( C ) ) <NEWLINE> <NL>
from math import * <NEWLINE> a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> c = radians ( c ) <NEWLINE> S = a * b * sin ( c ) / 2 <NEWLINE> print ( <STRING> % ( S , sqrt ( a * a + b * b - 2 * a * b * cos ( c ) ) , 2 * S / a ) ) ) <NEWLINE>
import math <NEWLINE> a , b , c = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> c = c / 180 * math . pi <NEWLINE> <NL> print <STRING> % float ( a * b * math . sin ( c ) / 2 ) <NEWLINE> print <STRING> % float ( a + b + math . sqrt ( a ** 2 + b ** 2 ) * cos ( c ) ) <NEWLINE> print <STRING> % float ( b * math . sin ( c ) ) <NEWLINE>
import math <NEWLINE> a , b , c = [ float ( i ) for i in input ( ) . split ( ) ] <NEWLINE> cos ( math . radians ( c ) ) <NEWLINE> print ( a * b * math . sin ( math . radians ( c ) ) / 2 ) <NEWLINE> print ( a + b + math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( math . radians ( c ) ) ) ) <NEWLINE> print ( b * math . sin ( math . radians ( c ) ) ) <NEWLINE>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> m = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> % ( math . sqrt ( sum ( [ ( m [ i ] - ( sum ( m ) / len ( m ) ) ) ** 2 for i in range ( n ) ] ) / n ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> <NL> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> s = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> mean = sum ( s ) / len ( s ) <NEWLINE> <NL> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> s [ i ] = ( s [ i ] - sum ) * ( s [ i ] - sum ) <NEWLINE> <NL> <DEDENT> variance = sum ( s ) / len ( s ) <NEWLINE> stdev = math . sqrt ( variance ) <NEWLINE> <NL> print ( stdev ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = sum ( data ) / n <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> for i in data : <NEWLINE> <INDENT> b += pow ( i - a , 2 ) <NEWLINE> <DEDENT> c = sqrt ( b / 2 ) <NEWLINE> <NL> print ( c ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> <NL> while True : <NEWLINE> <INDENT> s = int ( input ( ) ) <NEWLINE> if s == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> lst = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <DEDENT> print ( <STRING> . format ( statitics . pstdev ( lst ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ave = sum ( x ) / n <NEWLINE> <DEDENT> std = ( sum ( [ ( e - ave ) ** 2 for e in x ] ) / n ) ** 0.5 <NEWLINE> print std <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> cnt = int ( input ( ) ) <NEWLINE> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if cnt == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> ave = sum ( li ) / cnt <NEWLINE> n_var = 0.0 <NEWLINE> for i in range ( cnt ) : <NEWLINE> <INDENT> n_var += ( li [ i ] - ave ) ** 2 <NEWLINE> <NL> <DEDENT> var = n_var / cnt <NEWLINE> <COMMENT> <NL> print ( <STRING> . format ( math . sqrt ( var ) ) ) <NEWLINE> <DEDENT>
from statistics import pstdev <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if input ( ) == 0 : break <NEWLINE> v_list = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> print ( pstdev ( v_list ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> n = input ( ) <NEWLINE> while n != 0 : <NEWLINE> <INDENT> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> tmp = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> sum = 0 <NEWLINE> for i in xrange ( len ( tmp ) ) : <NEWLINE> <INDENT> sum += tmp [ i ] <NEWLINE> <DEDENT> ave = sum / n <NEWLINE> u = 0 <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> u += ( tmp [ i ] - ave ) ** 2 <NEWLINE> <DEDENT> u = u / n <NEWLINE> print <STRING> % math . sqrt ( u ) <NEWLINE> n = input ( ) <NEWLINE> <DEDENT> ~ <NEWLINE>
daviations = [ ] <NEWLINE> <NL> while True : <NEWLINE> <NL> <INDENT> num = int ( input ( ) ) <NEWLINE> <NL> if num == 0 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> scores = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( num ) : <NEWLINE> <INDENT> scores [ i ] = float ( scores [ i ] ) <NEWLINE> <NL> <DEDENT> avr = sum ( scores ) / num <NEWLINE> <NL> daviation = 0 <NEWLINE> <NL> for a in scores : <NEWLINE> <INDENT> disp = ( a - avr ) ** 2 / num <NEWLINE> daviation += disp <NEWLINE> <NL> <NL> <NL> <DEDENT> daviations . append ( round ( math . sqrt ( daviation ) , 8 ) ) <NEWLINE> <NL> <DEDENT> for b in daviations : <NEWLINE> <INDENT> print ( b ) <NEWLINE> <DEDENT>
import numpy as np <NEWLINE> import math <NEWLINE> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> if n == 0 : break <NEWLINE> s = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> var = np . var ( s ) <NEWLINE> print math . sqrt ( var ) <NEWLINE> <DEDENT>
import math <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> m += s [ i ] <NEWLINE> <DEDENT> si2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> si2 += ( s [ i ] - m ) ** 2 <NEWLINE> <DEDENT> print ( math . sqrt ( si2 ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> m = sum ( s ) / n <NEWLINE> print ( <STRING> . format ( math . sqrt ( sum ( [ ( x - m ) ** 2 for x in s ] ) / n ) <NEWLINE> <DEDENT>
scores = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> l = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> scores . append ( l ) <NEWLINE> <NL> <DEDENT> for score in scores : <NEWLINE> <INDENT> print ( pstdev ( score ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> while ( True ) : <NEWLINE> <INDENT> if input ( ) == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( a ) / len ( a ) <NEWLINE> b = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> b += ( i - m ) ** 2.0 <NEWLINE> <DEDENT> stddev = math . sqrt ( b / n ) <NEWLINE> print ( stddev ) <NEWLINE> <DEDENT>
import statistics <NEWLINE> data = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> data . append ( input ( ) . split ( ) ) <NEWLINE> if [ <STRING> ] in data : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> data = data [ : - 1 ] <NEWLINE> data_i = [ ] <NEWLINE> def a ( ) : <NEWLINE> <NL> for i in data : <NEWLINE> <INDENT> data_i . append ( list ( map ( lambda i : int ( i ) , i ) ) ) <NEWLINE> <DEDENT> for i in data_i : <NEWLINE> <INDENT> if len ( i ) == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( statistics . pstdev ( i ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = sum ( a ) / float ( n ) <NEWLINE> print ( <STRING> . format ( math . sqrt ( sum ( [ ( x - m ) ** 2 / n for x in a ] ) ) ) ) <NEWLINE> <DEDENT> <DEDENT>
import statistics <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> if a == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( statistics . pstdev ( num ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> <NL> if n == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> score = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( score ) / len ( score ) <NEWLINE> for i in range ( len ( score ) ) : <NEWLINE> <INDENT> score [ i ] = ( score [ i ] - m ) ** 2 <NEWLINE> <DEDENT> <DEDENT> answer = math . sqrt ( sum ( score ) / len ( socre ) ) <NEWLINE> print ( answer ) <NEWLINE> <DEDENT>
from statistics import pstdev <NEWLINE> while True : <NEWLINE> <INDENT> data_count = int ( input ( ) ) <NEWLINE> if data_count == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> print ( pstdev ( sum ( int ( x ) for x in input ( ) . split ( ) ) ) ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> ave = sum ( s ) / n <NEWLINE> dev = math . sqrt ( sum ( ( ave - si ) ** 2 for si in s ) / n ) <NEWLINE> <NL> print ( dev ) <NEWLINE> <DEDENT>
while input ( ) > 0 : <NEWLINE> <INDENT> s = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = len ( s ) <NEWLINE> a = sum ( s ) / n <NEWLINE> print ( ( sum ( [ x * x for x in s ] ) / n - a * a ) ** .5 ) <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> sn = [ int ( s ) for s in input ( ) . split ( ) ] <NEWLINE> m = sum ( sn ) / n <NEWLINE> a2 = 0.0 <NEWLINE> for s in sn : <NEWLINE> <INDENT> a2 += pow ( s - m , 2 ) <NEWLINE> <DEDENT> print ( math . sqrt ( a2 / n ) <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> a_2 = 0 <NEWLINE> n = int ( input ( ) ) <NEWLINE> if n == 0 <NEWLINE> break <NEWLINE> <NL> score = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> m = some ( score ) / len ( score ) <NEWLINE> <NL> for i in range ( len ( score ) ) : <NEWLINE> a += ( score [ i ] - m ) * ( score [ i ] - m ) / n <NEWLINE> <NL> print ( <STRING> , a ) <NEWLINE> <DEDENT>
<COMMENT> <NL> import statistics as st <NEWLINE> <NL> while True : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N = 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> buf = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> sd = st . pstdev ( buf ) <NEWLINE> print ( <STRING> % sd ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import io <NEWLINE> import re <NEWLINE> import math <NEWLINE> <NL> while True : <NEWLINE> <COMMENT> <NL> <INDENT> n = int ( raw_input ( ) ) <NEWLINE> l = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> <COMMENT> <NL> avg = sum ( l ) / len ( l ) <NEWLINE> naka = 0 <NEWLINE> for i in l : <NEWLINE> <INDENT> naka += ( i - avg ) ** 2 <NEWLINE> <DEDENT> hyo2 = naka / n <NEWLINE> print ( hyo2 ) ** 0.5 <NEWLINE> <DEDENT>
import math <NEWLINE> <NL> def hensa ( n , S ) : <NEWLINE> <INDENT> m = sum ( S ) / n <NEWLINE> x = 0 <NEWLINE> for i in S : <NEWLINE> <INDENT> x += ( i - m ) ** 2 <NEWLINE> <DEDENT> hensa = math . sqrt ( x / n ) <NEWLINE> return hensa <NEWLINE> <NL> <DEDENT> n = 1 <NEWLINE> while n != 0 : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> S = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( hensa ( n , S ) ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> def intinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> data = intinput ( ) <NEWLINE> sum_1 = 0 <COMMENT> <NEWLINE> sum_2 = 0 <COMMENT> <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum_1 += data [ i ] ; sum_2 += data [ i ] ** 2 <NEWLINE> <DEDENT> sigma = math . sqrt ( ( sum_2 - ( sum_1 ** 2 ) ) / n ) <NEWLINE> print ( sigma ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
import math <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : break <NEWLINE> s = list ( map ( float , raw_input ( ) . split ( ) ) ) <NEWLINE> t = sum ( s ) <NEWLINE> a = t / n <NEWLINE> b = sum ( map ( lambda x : ( x - a ) ** 2 , s ) ) <NEWLINE> print ( math . sqrt ( b / n ) ) <NEWLINE> <DEDENT>
from math import * <NEWLINE> while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> sco = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ave = 0.0 <NEWLINE> for i in sco : <NEWLINE> <INDENT> ave += i <NEWLINE> <DEDENT> ave /= n <NEWLINE> <NL> dev = 0.0 <NEWLINE> for i in sco : <NEWLINE> <INDENT> dev += ( i - ave ) * ( i - ave ) <NEWLINE> <DEDENT> dev /= n <NEWLINE> <NL> print sqrt ( dev ) <NEWLINE> <DEDENT> <DEDENT>
while 1 : <NEWLINE> <INDENT> N = int ( input ( ) ) <NEWLINE> if N == 0 : <NEWLINE> <INDENT> break <NEWLINE> print ( 0 ) <NEWLINE> <DEDENT> <DEDENT>
import statistics <NEWLINE> while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if x == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> ls = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( <STRING> . format ( statistics . pstdev ( ls ) ) ) <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> data = input ( ) . split ( ) <NEWLINE> import math <NEWLINE> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> sum = sum + int ( data [ i ] ) <NEWLINE> average = sum / n <NEWLINE> a = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> a = a + ( int ( data [ i ] ) - average ) ** 2 <NEWLINE> print ( <STRING> . format ( math . sqrt ( a / n ) ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> vector1 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> vector2 = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> for i in range ( 1 , 4 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( sum ( [ abs ( a - b ) ** p for a , b in zip ( vector1 , vector2 ) ] ) ** ( 1 / i ) ) ) <NEWLINE> print ( <STRING> . format ( max ( [ abs ( a - b ) for a , b in zip ( vector1 , vector2 ) ] ) ) ) <NEWLINE> <DEDENT>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> for p in range ( 1 , 4 ) : <NEWLINE> <INDENT> sum = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> sum += math . fabs ( x [ i ] - y [ i ] ) ** p <NEWLINE> <DEDENT> print ( sum ** ( 1 / p ) ) <NEWLINE> <NL> <DEDENT> a = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a . append ( math . fabs ( x [ i ] - y [ i ] ) ) <NEWLINE> <DEDENT> a = a . sort ( ) <NEWLINE> print ( a [ n - 1 ] ) <NEWLINE>
import math <NEWLINE> ni = int ( input ( ) ) <NEWLINE> xi = map ( int , raw_input ( ) . split ( <NEWLINE> yi = map ( int , raw_input ( ) . split ( <NEWLINE> <NL> p1 = [ ] <NEWLINE> p2 = [ ] <NEWLINE> p3 = [ ] <NEWLINE> p4 = [ ] <NEWLINE> for x , y in zip ( xi , yi ) : <NEWLINE> <INDENT> p1 . append ( abs ( x - y ) ) <NEWLINE> p2 . append ( abs ( x - y ) ** 2 ) <NEWLINE> p3 . append ( abs ( x - y ) ** 3 ) <NEWLINE> p4 . append ( abs ( x - y ) ) <NEWLINE> <NL> <DEDENT> print <STRING> % reduce ( lambda x , <NEWLINE> print <STRING> % reduce ( lambda x , <NEWLINE> print <STRING> % reduce ( lambda x , <NEWLINE> print <STRING> % max ( p4 ) <NEWLINE>
<COMMENT> <NL> <NL> import math <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> x = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( float , input ( ) . split ( ) ) ) <NEWLINE> abs_xy = [ ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> abs_xy . append ( abs ( x [ i ] - y [ i ] ) ) <NEWLINE> <NL> <DEDENT> d1 = sum ( abs_xy ) <NEWLINE> <NL> d2 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d2 += abs_xy * abs_xy <NEWLINE> <DEDENT> d2 = math . sqrt ( d2 ) <NEWLINE> <NL> d3 = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d3 += abs_xy * abs_xy * abs_xy <NEWLINE> <DEDENT> d3 = math . pow ( d3 , 1 / 3 ) <NEWLINE> <NL> d = max ( abs_xy ) <NEWLINE> <NL> print ( d1 ) <NEWLINE> print ( d2 ) <NEWLINE> print ( d3 ) <NEWLINE> print ( d ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> x , y = [ list ( map ( int , input ( ) . split ( ) ) ) for in range ( 2 ) ] <NEWLINE> d = [ abs ( s - t ) for s , t in zip ( x , y ) ] <NEWLINE> f = lambda n : sum ( [ s ** n for s in d ] ) ** ( 1 / n ) <NEWLINE> print ( f ( 1 ) , f ( 2 ) , f ( 3 ) , max ( d ) , sep = <STRING> ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> x = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> y = list ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> t1 = t2 = t3 = ti = 0.0 <NEWLINE> for a , b in zip ( x , y ) : <NEWLINE> <INDENT> d1 = abs ( a - b ) <NEWLINE> ti = max ( ti , d1 ) <NEWLINE> t1 += d1 <NEWLINE> t2 += d1 ** 2 <NEWLINE> t3 += d1 ** 3 <NEWLINE> <DEDENT> print ( t1 ) <NEWLINE> print ( math . sqrt ( t2 ) ) <NEWLINE> print ( t3 ** ( 1.0 / 3 ) ) <NEWLINE> print ( ti ) <NEWLINE>
import math <NEWLINE> def mink ( x , y , p ) : <NEWLINE> <INDENT> return ( sum ( [ math . fabs ( _x - _y ) ** p for _x , _y in zip ( x , y ) ] ) ) ** ( 1 / p ) <NEWLINE> <DEDENT> n = int ( input ( ) ) <NEWLINE> x = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( mink ( x , y , 1 ) ) <NEWLINE> print ( mink ( x , y , 2 ) ) <NEWLINE> print ( mink ( x , y , 3 ) ) <NEWLINE> print ( mink ( x , y , 10 ** 9 ) ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> xs = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> ys = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( sum ( [ abs ( x - y ) for x , y in zip ( xs , ys ) ] ) ) <NEWLINE> print ( math . sqrt ( sum ( [ ( x - y ) ** 2 for x , y in zip ( xs , ys ) ] ) ) ) <NEWLINE> print ( ( sum ( [ ( x - y ) ** 3 for x , y in zip ( xs , ys ) ] ) ) ** ( 1 / 3 ) ) <NEWLINE> print ( max ( [ abs ( x - y ) for x , y in zip ( xs , ys ) ] ) ) <NEWLINE>
import math <NEWLINE> n = int ( input ( ) ) <NEWLINE> xli = list ( map ( float , input ( ) . split ( ) ) <NEWLINE> yli = list ( map ( float , input ( ) . split ( ) ) <NEWLINE> a = 0 <NEWLINE> b = 0 <NEWLINE> c = 0 <NEWLINE> d = 0 <NEWLINE> <NL> for x , y in zip ( xli , yli ) : <NEWLINE> <INDENT> base = math . fabs ( x - y ) <NEWLINE> a += base <NEWLINE> b += base ** 2 <NEWLINE> c += base ** 3 <NEWLINE> if d < base : d = base <NEWLINE> <NL> <DEDENT> print ( a ) <NEWLINE> print ( b ** ( 1 / 2 ) ) <NEWLINE> print ( c ** ( 1 / 3 ) ) <NEWLINE> print ( d ) <NEWLINE>
import math <NEWLINE> <NL> input ( ) <NEWLINE> <NL> vx = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> vy = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> Dxy = [ ] <NEWLINE> for p in range ( 1 , 4 ) : <NEWLINE> <INDENT> Dxy . append ( sum ( [ abs ( xv [ i ] - vy [ i ] ) ** p for i in range ( len ( vx ) ) ] ) ** ( 1 / p ) ) <NEWLINE> <NL> <DEDENT> Dxy . append ( max ( [ abs ( vx [ i ] - vy [ i ] ) for i in range ( len ( vx ) ) ] ) ) <NEWLINE> <NL> for res in Dxy : <NEWLINE> <INDENT> print ( <STRING> . format ( res ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> inf = float ( <STRING> ) <NEWLINE> <NL> def distance ( p , n , x , y ) : <NEWLINE> <INDENT> D = 0 <NEWLINE> s = [ ] <NEWLINE> for i in range ( 0 , n ) : <NEWLINE> <INDENT> s . append ( x [ i ] - y [ i ] ) <NEWLINE> if s [ i ] < 0.0 : <NEWLINE> <INDENT> s [ i ] *= - 1.0 <NEWLINE> <DEDENT> D += s [ i ] ** p <NEWLINE> <NL> <DEDENT> if p == inf : <NEWLINE> <INDENT> return max ( s ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return D ** ( 1.0 / p ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> x = [ ] <NEWLINE> y = [ ] <NEWLINE> <NL> for i in range ( 0 , n ) : <NEWLINE> <INDENT> x . append ( int ( input ( ) ) ) <NEWLINE> <DEDENT> for i in range ( 0 , n ) : <NEWLINE> <INDENT> y . append ( int ( input ( ) ) ) <NEWLINE> <NL> <DEDENT> print float ( distance ( 1 , n , x , y ) ) <NEWLINE> print float ( distance ( 2 , n , x , y ) ) <NEWLINE> print float ( distance ( 3 , n , x , y ) ) <NEWLINE> print float ( distance ( inf , n , x , y ) ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> X = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> Y = [ int ( i ) for i in input ( ) . split ( <STRING> ) ] <NEWLINE> <NL> for p in range ( 1 , 4 ) : <NEWLINE> <INDENT> print ( <STRING> . format ( sum ( [ abs ( a - b ) ** p ) for a , b in zip ( X , Y ) ] ) ** ( 1 / p ) ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( max ( [ abs ( a - b ) for a , b in zip ( X , Y ) ] ) ) ) <NEWLINE>
<COMMENT> <NL> n = int ( input ( ) ) <NEWLINE> x = float ( ) . split ( <STRING> ) <NEWLINE> y = float ( ) . split ( <STRING> ) <NEWLINE> <NL> d1 = 0.0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d1 += abs ( x [ i ] - y [ i ] ) <NEWLINE> <DEDENT> print ( d1 ) <NEWLINE> <NL> d2 = 0.0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d2 += ( x [ i ] - y [ i ] ) ** 2 <NEWLINE> <DEDENT> print ( d2 ** 0.5 ) <NEWLINE> <NL> d3 = 0.0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> d3 += ( x [ i ] - y [ i ] ) ** 3 <NEWLINE> <DEDENT> print ( d3 ** ( 1.0 / 3.0 ) ) <NEWLINE> <NL> d_inf = 0.0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if abs ( x [ i ] - y [ i ] ) > d_inf : <NEWLINE> <INDENT> d_inf = x [ i ] - y [ i ] <NEWLINE> <DEDENT> <DEDENT> print ( d_inf ) <NEWLINE>
def min_dist ( x_b , y_b ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for x , y in zip ( x_b , y_b ) : <NEWLINE> <INDENT> s += abs ( x - y ) <NEWLINE> <DEDENT> return s <NEWLINE> <NL> <DEDENT> def man_dist ( x_b , y_b ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for x , y in zip ( x_b , y_b ) : <NEWLINE> <INDENT> s += ( abs ( x - y ) ) ** 2 <NEWLINE> <DEDENT> return s ** 0.5 <NEWLINE> <NL> <DEDENT> def che_dist ( x_b , y_b ) : <NEWLINE> <INDENT> s = 0 <NEWLINE> for x , y in zip ( x_b , y_b ) : <NEWLINE> <INDENT> s += ( abs ( x - y ) ) ** 3 <NEWLINE> <DEDENT> return s ** ( 1 / 3 ) <NEWLINE> <NL> <DEDENT> def anf_dist ( x_b , y_b ) : <NEWLINE> <INDENT> s = [ abs ( x - y ) for x , y in zip ( x_b , y_b ) ] <NEWLINE> return max ( s ) <NEWLINE> <NL> <DEDENT> n = int ( input ( ) ) <NEWLINE> y_b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( min_dist ( x_b , y_b ) ) <NEWLINE> print ( man_dist ( x_b , y_b ) ) <NEWLINE> print ( che_dist ( x_b , y_b ) ) <NEWLINE> print ( anf_dist ( x_b , y_b ) ) <NEWLINE>
<COMMENT> <NL> import math <NEWLINE> <NL> chebyshev = [ ] <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> <NL> x = input ( ) . split ( ) <NEWLINE> y = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> x [ i ] = int ( x [ i ] ) <NEWLINE> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> y [ i ] = int ( y [ i ] ) <NEWLINE> <NL> <DEDENT> for p in range ( 3 ) : <NEWLINE> <INDENT> total = 0 <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> total += ( math . fabs ( x [ i ] - y [ i ] ) ) ** ( p + 1 ) <NEWLINE> <DEDENT> distance = total ** ( 1 / ( p + 1 ) ) <NEWLINE> print ( <STRING> % distance ) <NEWLINE> <NL> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> chebyshev . append ( math . abs ( x [ i ] - y [ i ] ) ) <NEWLINE> <DEDENT> print ( <STRING> % max ( chebyshev ) ) <NEWLINE>
while True : <NEWLINE> <INDENT> n = int ( input ( ) ) <NEWLINE> if n == 0 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> m = sum ( a ) / n <NEWLINE> s = 0 <NEWLINE> for i in a : <NEWLINE> <INDENT> s += ( i - m ) ** 2 <NEWLINE> <DEDENT> print ( ( s / n ) ** 0.5 ) <NEWLINE> <DEDENT>
n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> x1 , y1 , x2 , y2 = map ( float , raw_input ( ) . split ( ) ) <NEWLINE> print ( ( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) ** 0.5 <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , list = map ( str , range ( 1 , 7 ) ) ) : <NEWLINE> <INDENT> self . top = list [ 0 ] <NEWLINE> self . front = list [ 1 ] <NEWLINE> self . right = list [ 2 ] <NEWLINE> self . left = list [ 3 ] <NEWLINE> self . back = list [ 4 ] <NEWLINE> self . bottom = list [ 5 ] <NEWLINE> <NL> <DEDENT> def print_all ( self ) : <NEWLINE> <INDENT> print <STRING> + self . top <NEWLINE> print <STRING> + self . front <NEWLINE> print <STRING> + self . right <NEWLINE> print <STRING> + self . left <NEWLINE> print <STRING> + self . back <NEWLINE> print <STRING> + self . bottom <NEWLINE> <NL> <DEDENT> def roll_N ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . front <NEWLINE> self . front = self . bottom <NEWLINE> self . bottom = self . back <NEWLINE> self . back = temp <NEWLINE> <NL> <DEDENT> def roll_S ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . back <NEWLINE> self . back = self . bottom <NEWLINE> self . bottom = self . front <NEWLINE> self . front = temp <NEWLINE> <NL> <DEDENT> def roll_W ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . right <NEWLINE> self . right = self . bottom <NEWLINE> self . bottom = self . left <NEWLINE> self . left = temp <NEWLINE> <NL> <DEDENT> def roll_E ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . left <NEWLINE> self . left = self . bottom <NEWLINE> self . bottom = self . right <NEWLINE> self . right = temp <NEWLINE> <NL> <DEDENT> <DEDENT> my_dice = dice . Dice ( raw_input ( ) . split ( <STRING> ) ) <NEWLINE> order = raw_input ( ) <NEWLINE> for i in xrange ( len ( order ) ) : <NEWLINE> <INDENT> if order [ i ] == <STRING> : <NEWLINE> <INDENT> my_dice . roll_E ( ) <NEWLINE> <DEDENT> elif order [ i ] == <STRING> : <NEWLINE> <INDENT> my_dice . roll_N ( ) <NEWLINE> <DEDENT> elif order [ i ] == <STRING> : <NEWLINE> <INDENT> my_dice . roll_S ( ) <NEWLINE> <DEDENT> elif order [ i ] == <STRING> : <NEWLINE> <INDENT> my_dice . roll_W ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <NL> <DEDENT> <DEDENT> print my_dice . top <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import collections <NEWLINE> import unittest <NEWLINE> <NL> def top_face_after_rolling_dice ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> faces = [ int ( num ) for num in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> rollings = input ( ) . rstrip ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return __input_error ( ) <NEWLINE> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <DEDENT> rollings += <STRING> <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> <STRING> <NEWLINE> def __input_error ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> class __TestValueClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def testEqual ( self , func , tuples , eff_digit = math . nan , print_success = False ) : <NEWLINE> <INDENT> self . testFunction ( self . assertEqual , func , tuples , eff_digit , print_success ) <NEWLINE> <NL> <DEDENT> def testFunction ( self , assertfunc , func , tuples , eff_digit , print_success ) : <NEWLINE> <COMMENT> <NL> <INDENT> for item in tuples : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> if isinstance ( item [ 0 ] , collections . Iterable ) : <NEWLINE> <INDENT> value = func ( * item [ 0 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value = func ( item [ 0 ] ) <NEWLINE> <NL> <DEDENT> if math . isnan ( eff_digit ) : <NEWLINE> <INDENT> assertfunc ( value , item [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> format_str = <STRING> + str ( eff_digit ) + <STRING> <NEWLINE> assertfunc ( format_str . format ( value ) , format_str . format ( item [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> except Exception as msg : <NEWLINE> <INDENT> swidth = 15 <NEWLINE> print ( <STRING> * 50 ) <NEWLINE> print ( <STRING> + func . __name__ + <STRING> ) <NEWLINE> info = [ ] <NEWLINE> info . append ( [ <STRING> , item [ 0 ] ] ) <NEWLINE> info . append ( [ <STRING> , item [ 1 ] ] ) <NEWLINE> info . append ( [ <STRING> , <STRING> + msg ] ) <NEWLINE> for state in info : <NEWLINE> <INDENT> print ( state [ 0 ] . ljust ( swidth ) + <STRING> , state [ 1 ] ) <NEWLINE> <DEDENT> sys . exit ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if print_success : <NEWLINE> <INDENT> print ( func . __name__ , <STRING> ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> top_face_after_rolling_dice ( ) <NEWLINE> <DEDENT>
class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , List ) : <NEWLINE> <INDENT> self . face = List <NEWLINE> <NL> <DEDENT> def n_spin ( List ) : <NEWLINE> <INDENT> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 1 ] <NEWLINE> List [ 1 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 4 ] <NEWLINE> List [ 4 ] = temp <NEWLINE> <NL> <DEDENT> def s_spin ( List ) : <NEWLINE> <INDENT> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 4 ] <NEWLINE> List [ 4 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 1 ] <NEWLINE> List [ 1 ] = temp <NEWLINE> <NL> <DEDENT> def e_spin ( lList ) : <NEWLINE> <INDENT> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 3 ] <NEWLINE> List [ 3 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 2 ] <NEWLINE> List [ 2 ] = temp <NEWLINE> <NL> <DEDENT> def w_spin ( lList ) : <NEWLINE> <INDENT> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 2 ] <NEWLINE> List [ 2 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 3 ] <NEWLINE> List [ 3 ] = temp <NEWLINE> <NL> <DEDENT> <DEDENT> dice = Dice ( map ( int , raw_input ( ) . split ( ) ) <NEWLINE> command = list ( raw_input ( ) ) <NEWLINE> for k in command : <NEWLINE> <INDENT> if k == <STRING> : <NEWLINE> <INDENT> dice . n_spin ( dice . face ) <NEWLINE> <DEDENT> elif k == <STRING> : <NEWLINE> <INDENT> dice . s_spin ( dice . face ) <NEWLINE> <DEDENT> elif k == <STRING> : <NEWLINE> <INDENT> dice . e_spin ( dice . face ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice . w_spin ( dice . face ) <NEWLINE> <DEDENT> <DEDENT> print dice . face [ 0 ] <NEWLINE>
class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , top , south , east , west , north , bottom ) : <NEWLINE> <INDENT> self . top = top <NEWLINE> self . south = south <NEWLINE> self . east = east <NEWLINE> self . west = west <NEWLINE> self . north = north <NEWLINE> self . bottom = bottom <NEWLINE> <DEDENT> def rollN ( self ) : <NEWLINE> <INDENT> prevN = self . north <NEWLINE> prevB = self . bottom <NEWLINE> prevS = self . south <NEWLINE> self . north = self . top <NEWLINE> self . bottom = prevN <NEWLINE> self . south = prevB <NEWLINE> self . top = prevS <NEWLINE> <DEDENT> def rollS ( self ) : <NEWLINE> <INDENT> prevS = self . south <NEWLINE> prevB = self . bottom <NEWLINE> prevN = self . north <NEWLINE> self . south = top <NEWLINE> self . bottom = prevS <NEWLINE> self . north = prevB <NEWLINE> self . top = prevN <NEWLINE> <DEDENT> def rollE ( self ) : <NEWLINE> <INDENT> prevE = self . east <NEWLINE> prevB = self . bottom <NEWLINE> prevW = self . west <NEWLINE> self . east = self . top <NEWLINE> self . bottom = prevE <NEWLINE> self . west = prevB <NEWLINE> self . top = prevW <NEWLINE> <DEDENT> def rollW ( self ) : <NEWLINE> <INDENT> prevW = self . west <NEWLINE> prevB = self . bottom <NEWLINE> prevE = self . east <NEWLINE> self . west = top <NEWLINE> self . bottom = prevW <NEWLINE> self . east = prevB <NEWLINE> self . top = prevE <NEWLINE> <NL> <DEDENT> <DEDENT> diceInit = [ int ( n ) for n in raw_input ( ) . split ( ) ] [ : 6 : ] <NEWLINE> instruction = raw_input ( ) <NEWLINE> <NL> diceI = Dice ( diceInit [ 0 ] , diceInit [ 1 ] , diceInit [ 2 ] , diceInit [ 3 ] , diceInit [ 4 ] , diceInit [ 5 ] ) <NEWLINE> <NL> for item in instruction : <NEWLINE> <INDENT> if item == <STRING> : <NEWLINE> <INDENT> diceI . rollN ( ) <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> diceI . rollE ( ) <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> diceI . rollW ( ) <NEWLINE> <DEDENT> elif item == <STRING> : <NEWLINE> <INDENT> diceI . rollS ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print diceI . top <NEWLINE>
d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> O = input ( ) <NEWLINE> <NL> class Dice ( ) : <NEWLINE> <INDENT> def __init__ ( self , d ) : <NEWLINE> <INDENT> self . dice = d <NEWLINE> <DEDENT> def S ( self ) : <NEWLINE> <INDENT> one = self . dice [ 4 ] <NEWLINE> two = self . dice [ 0 ] <NEWLINE> five = self . dice [ 5 ] <NEWLINE> six = self . dice [ 1 ] <NEWLINE> InsSN ( one , two , five , six ) <NEWLINE> <NL> <DEDENT> def InsSN ( self , one , two , five , six ) : <NEWLINE> <INDENT> self . dice [ 0 ] = one <NEWLINE> self . dice [ 1 ] = two <NEWLINE> self . dice [ 4 ] = five <NEWLINE> self . dice [ 5 ] = six <NEWLINE> <NL> <DEDENT> def N ( self ) : <NEWLINE> <INDENT> one = self . dice [ 1 ] <NEWLINE> two = self . dice [ 5 ] <NEWLINE> five = self . dice [ 0 ] <NEWLINE> six = self . dice [ 4 ] <NEWLINE> InsSN ( one , two , five , six ) <NEWLINE> <NL> <DEDENT> def InsWE ( self , one , three , four , six ) : <NEWLINE> <INDENT> self . dice [ 0 ] = one <NEWLINE> self . dice [ 2 ] = three <NEWLINE> self . dice [ 4 ] = four <NEWLINE> self . dice [ 5 ] = six <NEWLINE> <NL> <DEDENT> def W ( self ) : <NEWLINE> <INDENT> one = self . dice [ 2 ] <NEWLINE> three = self . dice [ 5 ] <NEWLINE> four = self . dice [ 0 ] <NEWLINE> six = self . dice [ 3 ] <NEWLINE> InsWE ( one , three , four , six ) <NEWLINE> <NL> <DEDENT> def E ( self ) : <NEWLINE> <INDENT> one = self . dice [ 3 ] <NEWLINE> three = self . dice [ 0 ] <NEWLINE> four = self . dice [ 5 ] <NEWLINE> six = self . dice [ 2 ] <NEWLINE> InsWE ( one , three , four , six ) <NEWLINE> <NL> <DEDENT> <DEDENT> d = Dice ( d ) <NEWLINE> <NL> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> if O [ i ] == <STRING> : <NEWLINE> <INDENT> d . S ( ) <NEWLINE> <DEDENT> elif O [ i ] == <STRING> : <NEWLINE> <INDENT> d . N ( ) <NEWLINE> <DEDENT> elif O [ i ] == <STRING> : <NEWLINE> <INDENT> d . E ( ) <NEWLINE> <DEDENT> elif O [ i ] == <STRING> : <NEWLINE> <INDENT> d . W ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d . dice [ 0 ] ) <NEWLINE> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL> <NL>
class Cube : <NEWLINE> <INDENT> def __init__ ( self , u , s , e , w , n , d ) : <NEWLINE> <INDENT> self . u = u <NEWLINE> self . s = s <NEWLINE> self . e = e <NEWLINE> self . w = w <NEWLINE> self . n = n <NEWLINE> self . d = d <NEWLINE> <NL> <DEDENT> def rotate ( self , dic ) : <NEWLINE> <INDENT> if dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . s <NEWLINE> self . s = self . d <NEWLINE> self . d = self . n <NEWLINE> self . n = tmp <NEWLINE> <DEDENT> elif dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . w <NEWLINE> self . w = self . d <NEWLINE> self . d = self . e <NEWLINE> self . e = tmp <NEWLINE> <DEDENT> elif dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . e <NEWLINE> self . e = self . d <NEWLINE> self . d = self . w <NEWLINE> self . w = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . n <NEWLINE> self . n = self . d <NEWLINE> self . d = self . s <NEWLINE> self . s = tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> u , s , e , w , n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> O = input ( ) <NEWLINE> <NL> cube = Cube ( u , s , e , w , n , d ) <NEWLINE> for i in range ( len ( O ) ) : <NEWLINE> <INDENT> cube . rotate ( O [ i ] ) <NEWLINE> <DEDENT> print ( cube . u ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> <NL> <DEDENT> def move ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] = self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] = self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] = self . data [ 4 ] , self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] = self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] , self . data [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def getTop ( self ) : <NEWLINE> <INDENT> return self . data [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> dice = Dice . Dice ( input ( ) . split ( ) ) <NEWLINE> cmd = input ( ) <NEWLINE> for i in range ( len ( cmd ) ) : <NEWLINE> <INDENT> dice . move ( cmd [ i ] ) <NEWLINE> <DEDENT> print ( dice . getTop ( ) ) <NEWLINE>
num = ( int , input ( ) . split ( ) ) <NEWLINE> dice = { <STRING> : ( 2 , 6 , 3 , 4 , 1 , 5 ) , <STRING> : ( 4 , 2 , 1 , 6 , 5 , 3 ) , <STRING> : ( 3 , 2 , 6 , 1 , 5 , 4 ) , <STRING> : ( 5 , 1 , 3 , 4 , 6 , 2 ) } <NEWLINE> for alf in input ( ) : <NEWLINE> <INDENT> num = [ num [ i ] for i in dice [ alf - 1 ] ] <NEWLINE> <DEDENT> print ( num [ 0 ] ) <NEWLINE> <NL>
ef north ( list ) : <NEWLINE> <INDENT> List = [ ] <NEWLINE> List . append ( list [ 1 ] ) <NEWLINE> List . append ( list [ 5 ] ) <NEWLINE> List . append ( list [ 2 ] ) <NEWLINE> List . append ( list [ 3 ] ) <NEWLINE> List . append ( list [ 0 ] ) <NEWLINE> List . append ( list [ 4 ] ) <NEWLINE> return List <NEWLINE> <NL> <DEDENT> def west ( list ) : <NEWLINE> <INDENT> List = [ ] <NEWLINE> List . append ( list [ 2 ] ) <NEWLINE> List . append ( list [ 1 ] ) <NEWLINE> List . append ( list [ 5 ] ) <NEWLINE> List . append ( list [ 0 ] ) <NEWLINE> List . append ( list [ 4 ] ) <NEWLINE> List . append ( list [ 3 ] ) <NEWLINE> return List <NEWLINE> <NL> <DEDENT> def south ( list ) : <NEWLINE> <INDENT> List = [ ] <NEWLINE> List . append ( list [ 4 ] ) <NEWLINE> List . append ( list [ 0 ] ) <NEWLINE> List . append ( list [ 2 ] ) <NEWLINE> List . append ( list [ 3 ] ) <NEWLINE> List . append ( list [ 5 ] ) <NEWLINE> List . append ( list [ 1 ] ) <NEWLINE> return List <NEWLINE> <NL> <DEDENT> def east ( list ) : <NEWLINE> <INDENT> List = [ ] <NEWLINE> List . append ( list [ 3 ] ) <NEWLINE> List . append ( list [ 1 ] ) <NEWLINE> List . append ( list [ 0 ] ) <NEWLINE> List . append ( list [ 5 ] ) <NEWLINE> List . append ( list [ 4 ] ) <NEWLINE> List . append ( list [ 2 ] ) <NEWLINE> return List <NEWLINE> <NL> <DEDENT> dice = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> x = str ( input ( ) ) <NEWLINE> y = list ( x ) <NEWLINE> for i in range ( len ( x ) ) : <NEWLINE> <INDENT> if y [ i ] == <STRING> : <NEWLINE> <INDENT> dice [ 0 : 5 ] = north ( dice ) <NEWLINE> <DEDENT> elif y [ i ] == <STRING> : <NEWLINE> <INDENT> dice [ 0 : 5 ] = west ( dice ) <NEWLINE> <DEDENT> elif y [ i ] == <STRING> : <NEWLINE> <INDENT> dice [ 0 : 5 ] = south ( dice ) <NEWLINE> <DEDENT> elif y [ i ] == <STRING> : <NEWLINE> <INDENT> dice [ 0 : 5 ] = east ( dice ) <NEWLINE> <DEDENT> <DEDENT> print ( dice [ 0 ] ) <NEWLINE> <NL>
def whatIsRight ( u , f ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if u == 1 : <NEWLINE> <INDENT> if f == 2 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif f == 3 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 5 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 2 : <NEWLINE> <INDENT> if f == 6 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif f == 3 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 3 : <NEWLINE> <INDENT> if f == 5 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 2 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif f == 6 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 4 : <NEWLINE> <INDENT> if f == 6 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 2 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif f == 5 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 5 : <NEWLINE> <INDENT> if f == 3 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif f == 6 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 3 <NEWLINE> return r <NEWLINE> <NL> <DEDENT> <DEDENT> if u == 6 : <NEWLINE> <INDENT> if f == 5 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif f == 3 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 2 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ ] <NEWLINE> <NL> for j in range ( len ( m ) ) : <NEWLINE> <INDENT> for k in range ( len ( n ) ) : <NEWLINE> <INDENT> if m [ j ] == n [ k ] : <NEWLINE> <INDENT> num . append ( k + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n [ whatIsRight ( num [ 0 ] , num [ 1 ] ) - 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> D = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> Os = input ( ) <NEWLINE> for i in range ( len ( Os ) ) : <NEWLINE> <INDENT> if Os [ i ] == <STRING> : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 1 ] <NEWLINE> D [ 1 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 4 ] <NEWLINE> D [ 4 ] = t <NEWLINE> <DEDENT> elif Os [ i ] == <STRING> : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 4 ] <NEWLINE> D [ 4 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 1 ] <NEWLINE> D [ 1 ] = t <NEWLINE> <DEDENT> <DEDENT> elif Os [ i ] == <STRING> : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 3 ] <NEWLINE> D [ 3 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 2 ] <NEWLINE> D [ 2 ] = t <NEWLINE> <DEDENT> elif Os [ i ] == <STRING> : <NEWLINE> <INDENT> t = D [ 0 ] <NEWLINE> D [ 0 ] = D [ 2 ] <NEWLINE> D [ 2 ] = D [ 5 ] <NEWLINE> D [ 5 ] = D [ 3 ] <NEWLINE> D [ 3 ] = t <NEWLINE> <DEDENT> print ( D [ 0 ] ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , f ) : <NEWLINE> <INDENT> self . f = f <NEWLINE> <COMMENT> <NL> <NL> <NL> <DEDENT> dict = { <STRING> : ( 4 , 0 , 2 , 3 , 5 , 1 ) , <STRING> : ( 3 , 1 , 0 , 5 , 4 , 2 ) , <STRING> : ( 3 , 1 , 2 , 3 , 4 , 5 ) , <STRING> : ( 1 , 5 , 2 , 3 , 0 , 4 ) } <NEWLINE> <NL> def turn ( self , c ) : <NEWLINE> <COMMENT> <NL> <INDENT> for i in range ( len ( c ) ) : <NEWLINE> <INDENT> f = [ f [ j ] for j in dict [ c [ i ] ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> face = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) <NEWLINE> Dice ( face ) . turn ( input ( ) ) <NEWLINE> print ( face [ 0 ] ) <NEWLINE>
class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . upside = 1 <NEWLINE> self . frontside = 2 <NEWLINE> self . rightside = 3 <NEWLINE> self . backside = 4 <NEWLINE> self . leftside = 5 <NEWLINE> self . downside = 6 <NEWLINE> <NL> <DEDENT> def throwDice ( self , dir ) : <NEWLINE> up = self . upside <NEWLINE> front = self . frontside <NEWLINE> left = self . leftside <NEWLINE> if dir == <STRING> : <NEWLINE> <INDENT> self . frontside = up <NEWLINE> self . backside = 7 - up <NEWLINE> self . downside = front <NEWLINE> <INDENT> self . upside = 7 - front <NEWLINE> <NL> elif dir == <STRING> : <NEWLINE> <DEDENT> self . frontside = 7 - up <NEWLINE> self . backside = up <NEWLINE> self . downside = 7 - front <NEWLINE> self . upside = front <NEWLINE> <NL> elif dir == <STRING> : <NEWLINE> self . rightside = up <NEWLINE> self . leftside = 7 - up <NEWLINE> self . upside = left <NEWLINE> self . downside = 7 - left <NEWLINE> <NL> elif dir == <STRING> : <NEWLINE> self . rightside = 7 - up <NEWLINE> self . leftside = up <NEWLINE> self . upside = 7 - left <NEWLINE> self . downside = left <NEWLINE> <NL> <DEDENT> def getUpside ( self ) : <NEWLINE> <INDENT> return self . upside <NEWLINE> <NL> <DEDENT> <DEDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> com = list ( input ( ) ) <NEWLINE> <NL> dice = Dice ( ) <NEWLINE> for i in range ( len ( com ) ) : <NEWLINE> <INDENT> dice . throwDice ( com [ i ] ) <NEWLINE> <NL> <DEDENT> print ( n [ dice . getUpside ( ) - 1 ] ) <NEWLINE> <NL> <NL> <NL>
<NL> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> <NL> <DEDENT> def move ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] = self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 4 ] , self . data [ 5 ] , self . data [ 1 ] = self . data [ 1 ] , self . data [ 0 ] , self . data [ 4 ] , self . data [ 5 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] = self . data [ 4 ] , self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] = self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] , self . data [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def getTop ( self ) : <NEWLINE> <INDENT> return self . data [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> dice = Dice ( input ( ) . split ( ) ) <NEWLINE> cmd = input ( ) <NEWLINE> for i in range ( len ( cmd ) ) : <NEWLINE> <INDENT> dice . move ( cmd [ i ] ) <NEWLINE> print ( dice . getTop ( ) ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <NL> <INDENT> def __init__ ( self , faces ) : <NEWLINE> <INDENT> self . faces = tuple ( faces ) <NEWLINE> <NL> <DEDENT> def roll_north ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 1 ] , self . faces [ 5 ] , self . faces [ 2 ] , <NEWLINE> <INDENT> self . faces [ 3 ] , self . faces [ 0 ] , self . faces [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_south ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 4 ] , self . faces [ 0 ] , self . faces [ 2 ] , <NEWLINE> <INDENT> self . faces [ 3 ] , self . faces [ 5 ] , self . faces [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_west ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 2 ] , self . faces [ 1 ] , self . faces [ 5 ] , <NEWLINE> <INDENT> self . faces [ 0 ] , self . faces [ 4 ] , self . faces [ 3 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_east ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 3 ] , self . faces [ 1 ] , self . faces [ 0 ] , <NEWLINE> <INDENT> self . faces [ 5 ] , self . faces [ 4 ] , self . faces [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def number ( self , face_id ) : <NEWLINE> <INDENT> return self . faces [ face_id - 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dice = Dice ( list ( map ( int , input ( ) . split ) ) ) <NEWLINE> commands = input ( ) <NEWLINE> <NL> for c in commands : <NEWLINE> <INDENT> if c == <STRING> : <NEWLINE> <INDENT> dice . roll_north ( ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> dice . roll_south ( ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> dice . roll_west ( ) <NEWLINE> <DEDENT> elif c == <STRING> : <NEWLINE> <INDENT> dice . roll_east ( ) <NEWLINE> <DEDENT> <DEDENT> print ( dice . number ( 1 ) ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . dice = [ 1 , 2 , 3 , 4 , 5 , 6 ] <COMMENT> <NEWLINE> <DEDENT> def set ( self , l ) : <NEWLINE> <INDENT> self . dice = l <NEWLINE> <DEDENT> def roll ( self , s ) : <NEWLINE> <INDENT> import copy <NEWLINE> mat = ( ( 1 , 4 , 3 , 2 ) , ( 5 , 0 , 1 , 1 ) , ( 2 , 2 , 0 , 5 ) , ( 3 , 3 , 5 , 0 ) , ( 0 , 5 , 4 , 4 ) , ( 4 , 1 , 2 , 3 ) ) <NEWLINE> l = copy . deepcopy ( self . dice ) <NEWLINE> if s == <STRING> : c = 0 <NEWLINE> if s == <STRING> : c = 1 <NEWLINE> if s == <STRING> : c = 2 <NEWLINE> if s == <STRING> : c = 3 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> print ( <STRING> % ( i , c , mat [ i ] [ c ] , self . dice [ i ] , l [ mat [ i ] [ c ] ] ) ) <NEWLINE> self . dice [ i ] = l [ mat [ i ] [ c ] ] <NEWLINE> <DEDENT> <DEDENT> def get ( self ) : <NEWLINE> <INDENT> return self . dice <NEWLINE> <NL> <DEDENT> <DEDENT> d = Dice ( ) <NEWLINE> d . set ( list ( map ( int , input ( ) . split ) ) ) <NEWLINE> s = input ( ) <NEWLINE> for i in range ( len ( s ) ) : <NEWLINE> <INDENT> d . roll ( s [ i ] ) <NEWLINE> <DEDENT> print ( d . get ( ) [ 0 ] ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> n = raw_input ( ) <NEWLINE> ans = chk = 0 <NEWLINE> <NL> <NL> def rolling ( word , dice ) : <NEWLINE> <INDENT> if word == <STRING> : <NEWLINE> <INDENT> dice [ 0 ] , dice [ 1 ] , dice [ 5 ] , dice [ 4 ] = dice [ 4 ] , dice [ 0 ] , dice [ 1 ] , dice [ 5 ] <NEWLINE> <DEDENT> elif word == <STRING> : <NEWLINE> <INDENT> dice [ 0 ] , dice [ 1 ] , dice [ 5 ] , dice [ 4 ] = dice [ 1 ] , dice [ 5 ] , dice [ 4 ] , dice [ 0 ] <NEWLINE> <DEDENT> elif word == <STRING> : <NEWLINE> <INDENT> dice [ 0 ] , dice [ 2 ] , dice [ 5 ] , dice [ 3 ] = dice [ 2 ] , dice [ 5 ] , dice [ 3 ] , dice [ 0 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice [ 0 ] , dice [ 2 ] , dice [ 5 ] , dice [ 3 ] = dice [ 3 ] , dice [ 0 ] , dice [ 2 ] , dice [ 5 ] <NEWLINE> <DEDENT> return dice <NEWLINE> <NL> <DEDENT> for i in n : <NEWLINE> <INDENT> l = rolling ( i , l ) <NEWLINE> <DEDENT> print l [ 0 ] <NEWLINE>
class dice : <NEWLINE> <INDENT> def __init__ ( self , label ) : <NEWLINE> <INDENT> self . d = label <NEWLINE> <DEDENT> def roll ( self , op ) : <NEWLINE> <INDENT> d = self . d <NEWLINE> if op == <STRING> : self . d = [ d [ 1 ] , d [ 5 ] , d [ 2 ] , d [ 3 ] , d [ 0 ] , d [ 4 ] ] <NEWLINE> elif op == <STRING> : self . d = [ d [ 3 ] , d [ 1 ] , d [ 0 ] , d [ 5 ] , d [ 4 ] , d [ 2 ] ] <NEWLINE> elif op == <STRING> : self . d = [ d [ 2 ] , d [ 1 ] , d [ 5 ] , d [ 0 ] , d [ 4 ] , d [ 3 ] ] <NEWLINE> elif op == <STRING> : self . d = [ d [ 4 ] , d [ 0 ] , d [ 2 ] , d [ 3 ] , d [ 5 ] , d [ 1 ] ] <NEWLINE> <DEDENT> def print ( self ) : <NEWLINE> <INDENT> print ( self . d [ 0 ] ) <NEWLINE> <DEDENT> def print_r_side ( self , t , f ) : <NEWLINE> <INDENT> d = self . d <NEWLINE> if ( t , f ) == ( d [ 0 ] , d [ 1 ] ) : print ( d [ 2 ] ) <NEWLINE> elif ( t , f ) == ( d [ 0 ] , d [ 2 ] ) : print ( d [ 4 ] ) <NEWLINE> elif ( t , f ) == ( d [ 0 ] , d [ 3 ] ) : print ( d [ 1 ] ) <NEWLINE> elif ( t , f ) == ( d [ 0 ] , d [ 4 ] ) : print ( d [ 3 ] ) <NEWLINE> elif ( t , f ) == ( d [ 1 ] , d [ 0 ] ) : print ( d [ 3 ] ) <NEWLINE> elif ( t , f ) == ( d [ 1 ] , d [ 2 ] ) : print ( d [ 0 ] ) <NEWLINE> elif ( t , f ) == ( d [ 1 ] , d [ 3 ] ) : print ( d [ 5 ] ) <NEWLINE> elif ( t , f ) == ( d [ 1 ] , d [ 5 ] ) : print ( d [ 2 ] ) <NEWLINE> elif ( t , f ) == ( d [ 2 ] , d [ 0 ] ) : print ( d [ 1 ] ) <NEWLINE> elif ( t , f ) == ( d [ 2 ] , d [ 1 ] ) : print ( d [ 5 ] ) <NEWLINE> elif ( t , f ) == ( d [ 2 ] , d [ 4 ] ) : print ( d [ 0 ] ) <NEWLINE> elif ( t , f ) == ( d [ 2 ] , d [ 5 ] ) : print ( d [ 4 ] ) <NEWLINE> elif ( t , f ) == ( d [ 3 ] , d [ 0 ] ) : print ( d [ 4 ] ) <NEWLINE> elif ( t , f ) == ( d [ 3 ] , d [ 1 ] ) : print ( d [ 0 ] ) <NEWLINE> elif ( t , f ) == ( d [ 3 ] , d [ 4 ] ) : print ( d [ 5 ] ) <NEWLINE> elif ( t , f ) == ( d [ 3 ] , d [ 5 ] ) : print ( d [ 1 ] ) <NEWLINE> elif ( t , f ) == ( d [ 4 ] , d [ 0 ] ) : print ( d [ 2 ] ) <NEWLINE> elif ( t , f ) == ( d [ 4 ] , d [ 2 ] ) : print ( d [ 5 ] ) <NEWLINE> elif ( t , f ) == ( d [ 4 ] , d [ 3 ] ) : print ( d [ 0 ] ) <NEWLINE> elif ( t , f ) == ( d [ 4 ] , d [ 5 ] ) : print ( d [ 3 ] ) <NEWLINE> elif ( t , f ) == ( d [ 5 ] , d [ 1 ] ) : print ( d [ 3 ] ) <NEWLINE> elif ( t , f ) == ( d [ 5 ] , d [ 2 ] ) : print ( d [ 1 ] ) <NEWLINE> elif ( t , f ) == ( d [ 5 ] , d [ 3 ] ) : print ( d [ 4 ] ) <NEWLINE> elif ( t , f ) == ( d [ 5 ] , d [ 4 ] ) : print ( d [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> label = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> d0 = dice ( label ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> t , f = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d0 . print_r_side ( t , f ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> import collections <NEWLINE> import unittest <NEWLINE> <NL> def top_face_after_rolling_dice ( ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> faces = [ int ( num ) for num in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> rollings = input ( ) . rstrip ( ) <NEWLINE> <DEDENT> except : <NEWLINE> <INDENT> return __input_error ( ) <NEWLINE> <NL> <DEDENT> dice = CubicArbitraryValueDice ( faces [ 0 ] , faces [ 1 ] , faces [ 2 ] , faces [ 3 ] , faces [ 4 ] , faces [ 5 ] ) <NEWLINE> dice . put ( dice . TOP , dice . SOUTH , dice . EAST , dice . WEST , dice . NORTH , dice . BOTTOM ) <NEWLINE> <NL> for direction in rollings : <NEWLINE> <INDENT> dice . roll ( direction ) <NEWLINE> <NL> <DEDENT> print ( dice . faces [ dice . direction [ dice . TOP ] ] ) <NEWLINE> <NL> <DEDENT> class CubicArbitraryValueDice ( ) : <NEWLINE> <INDENT> TOP = <STRING> <NEWLINE> BOTTOM = <STRING> <NEWLINE> EAST = <STRING> <NEWLINE> WEST = <STRING> <NEWLINE> SOUTH = <STRING> <NEWLINE> NORTH = <STRING> <NEWLINE> OPOSITE_DIRECTION_PAIRS = ( ( EAST , WEST ) , ( SOUTH , NORTH ) ) <NEWLINE> <NL> <COMMENT> <NL> def __init__ ( self , n_f0 , n_f1 , n_f2 , n_f3 , n_f4 , n_f5 ) : <NEWLINE> <INDENT> self . faces = [ n_f0 , n_f1 , n_f2 , n_f3 , n_f4 , n_f5 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def put ( self , dir_f0 , dir_f1 , dir_f2 , dir_f3 , dir_f4 , dir_f5 ) : <COMMENT> <NEWLINE> <INDENT> self . direction = { dir_fi : i for i , dir_fi in enumerate ( [ dir_f0 , dir_f1 , dir_f2 , dir_f3 , dir_f4 , dir_f5 ] ) } <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def roll ( self , direction ) : <COMMENT> <NEWLINE> <INDENT> for pair in self . OPOSITE_DIRECTION_PAIRS : <NEWLINE> <INDENT> if direction in pair : <NEWLINE> <INDENT> oposite = pair [ 0 ] if ( pair [ 1 ] == direction ) else pair [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> current = { } <NEWLINE> for direct in ( self . TOP , self . BOTTOM , direction , oposite ) : <NEWLINE> <INDENT> current . update ( { direct : self . direction [ direct ] } ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for pair in ( ( direction , self . BOTTOM ) , ( self . BOTTOM , oposite ) , ( oposite , self . TOP ) , ( self . TOP , direction ) ) : <NEWLINE> <INDENT> self . direction [ pair [ 1 ] ] = current [ pair [ 0 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def __input_error ( ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return - 1 <NEWLINE> <NL> <DEDENT> class __TestValueClass ( unittest . TestCase ) : <NEWLINE> <INDENT> def testEqual ( self , func , tuples , eff_digit = math . nan , print_success = False ) : <NEWLINE> <INDENT> self . testFunction ( self . assertEqual , func , tuples , eff_digit , print_success ) <NEWLINE> <NL> <DEDENT> def testFunction ( self , assertfunc , func , tuples , eff_digit , print_success ) : <NEWLINE> <COMMENT> <NL> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT> <STRING> <NEWLINE> <COMMENT> <NL> if __name__ == <STRING> : <NEWLINE> <COMMENT> <NL> <INDENT> top_face_after_rolling_dice ( ) <NEWLINE> <DEDENT>
<NL> <INDENT> GNU nano 2.9 .3 a . py <NEWLINE> <NL> <DEDENT> class Dice ( ) : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . number = data <NEWLINE> <NL> <DEDENT> def rota_S ( self ) : <NEWLINE> <INDENT> self . number [ 0 ] , self . number [ 1 ] , self . number [ 5 ] , self . number [ 4 ] = self . number [ 1 ] , self . number [ 5 ] , self . number [ 4 ] , self . number [ 0 ] <NEWLINE> <DEDENT> def rota_E ( self ) : <NEWLINE> <INDENT> self . number [ 0 ] , self . number [ 2 ] , self . number [ 5 ] , self . number [ 3 ] = self . number [ 2 ] , self . number [ 5 ] , self . number [ 3 ] , self . number [ 0 ] <NEWLINE> <DEDENT> def rota_W ( self ) : <NEWLINE> <INDENT> self . number [ 0 ] , self . number [ 3 ] , self . number [ 5 ] , self . number [ 2 ] = self . number [ 3 ] , self . number [ 5 ] , self . number [ 2 ] , self . number [ 0 ] <NEWLINE> <DEDENT> def rota_N ( self ) : <NEWLINE> <INDENT> self . number [ 0 ] , self . number [ 4 ] , self . number [ 5 ] , self . number [ 1 ] = self . number [ 4 ] , self . number [ 5 ] , self . number [ 1 ] , self . number [ 0 ] <NEWLINE> <NL> <DEDENT> def get_top ( self ) : <NEWLINE> <INDENT> return self . number [ 0 ] <NEWLINE> <DEDENT> <DEDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> opt = input ( ) <NEWLINE> <NL> mydice = Dice ( data ) <NEWLINE> print ( mydice . number ) <NEWLINE> for c in range ( len ( opt ) ) : <NEWLINE> <INDENT> print ( opt [ c ] ) <NEWLINE> if ( opt [ c ] == <STRING> ) : mydice . rota_S ( ) <NEWLINE> elif ( opt [ c ] == <STRING> ) : mydice . rota_E ( ) <NEWLINE> elif ( opt [ c ] == <STRING> ) : mydice . rota_W ( ) <NEWLINE> elif ( opt [ c ] == <STRING> ) : mydice . rota_N ( ) <NEWLINE> else : print ( <STRING> ) <NEWLINE> <DEDENT> print ( mydice . get_top ( ) ) <NEWLINE> <NL> <NL>
<COMMENT> <NL> <COMMENT> <NL> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , nums ) : <NEWLINE> <INDENT> self . top , self . front , self . right , self . left , self . back , self . bottom = nums <NEWLINE> <NL> <DEDENT> def roll ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . top , self . right , self . left , self . bottom = self . left , self . top , self . bottom , self . right <NEWLINE> return <NEWLINE> <NL> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . top , self . front , self . back , self . bottom = self . front , self . bottom , self . top , self . back <NEWLINE> return <NEWLINE> <NL> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . top , self . front , self . back , self . bottom = self . back , self . top , self . bottom , self . front <NEWLINE> return <NEWLINE> <NL> <DEDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . top , self . right , self . left , self . bottom = self . right , self . bottom , self . top , self . left <NEWLINE> return <NEWLINE> <NL> <DEDENT> <DEDENT> def get_top ( self ) : <NEWLINE> <INDENT> return self . top <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> nums = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> directions = input ( ) <NEWLINE> <NL> d = Dice ( nums ) <NEWLINE> for i in len ( directions ) : <NEWLINE> <INDENT> d . roll ( directions [ i ] ) <NEWLINE> <NL> <DEDENT> print ( d . get_top ( ) ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . x = [ 2 , 5 ] <NEWLINE> self . y = [ 3 , 4 ] <NEWLINE> self . z = [ 1 , 6 ] <NEWLINE> SN = { <STRING> : 0 , <STRING> : 1 } <NEWLINE> WE = { <STRING> : 0 , <STRING> : 1 } <NEWLINE> pass <NEWLINE> <NL> <DEDENT> def rotate ( self , _dir ) : <NEWLINE> <INDENT> def rot ( _k , _r ) : <NEWLINE> <INDENT> return list ( reversed ( _r ) ) , _k <NEWLINE> <NL> <DEDENT> if _dir == <STRING> : <NEWLINE> <INDENT> self . x , self . z = rot ( self . x , self . z ) <NEWLINE> <DEDENT> elif _dir == <STRING> : <NEWLINE> <INDENT> self . z , self . x = rot ( self . z , self . x ) <NEWLINE> <DEDENT> elif _dir == <STRING> : <NEWLINE> <INDENT> self . z , self . y = rot ( self . z , self . y ) <NEWLINE> <DEDENT> elif _dir == <STRING> : <NEWLINE> <INDENT> self . y , self . z = rot ( self . y , self . z ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return self . z [ 0 ] <NEWLINE> <NL> <DEDENT> def view ( self ) : <NEWLINE> <INDENT> print ( <STRING> , self . x , self . y , self . z ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> val = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice = Dice ( ) <NEWLINE> dr = input ( ) <NEWLINE> for d in dr : <NEWLINE> <INDENT> dice . rotate ( d ) <NEWLINE> <DEDENT> print ( val ( dice . top ( ) ) ) <NEWLINE> <DEDENT>
dice = input ( ) . split ( ) <NEWLINE> direction = list ( input ( ) ) <NEWLINE> dice2 = [ ] <NEWLINE> for i in range ( len ( direction ) ) : <NEWLINE> <INDENT> dice2 = dice <NEWLINE> print ( dice2 ) <NEWLINE> if direction [ i ] == <STRING> : <NEWLINE> <INDENT> dice = [ dice2 [ 3 ] , dice2 [ 1 ] , dice2 [ 0 ] , dice2 [ 5 ] , dice2 [ 4 ] , dice2 [ 2 ] ] <NEWLINE> print ( dice ) <NEWLINE> <DEDENT> elif direction [ i ] == <STRING> : <NEWLINE> <INDENT> dice = [ dice2 [ 1 ] , dice2 [ 5 ] , dice2 [ 2 ] , dice2 [ 3 ] , dice2 [ 0 ] , dice2 [ 4 ] ] <NEWLINE> print ( dice ) <NEWLINE> <DEDENT> elif direction [ i ] == <STRING> : <NEWLINE> <INDENT> dice = [ dice2 [ 4 ] , dice2 [ 0 ] , dice2 [ 2 ] , dice2 [ 3 ] , dice2 [ 5 ] , dice2 [ 1 ] ] <NEWLINE> print ( dice ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice = [ dice2 [ 2 ] , dice2 [ 1 ] , dice2 [ 5 ] , dice2 [ 0 ] , dice2 [ 4 ] , dice2 [ 3 ] ] <NEWLINE> print ( dice ) <NEWLINE> <DEDENT> <DEDENT> print ( <STRING> . format ( int ( dice [ 0 ) ] ) ) <NEWLINE>
class Dice : <NEWLINE> <NL> u , s , e , w , n , b = map ( int , input ( ) . split ( ) ) <NEWLINE> roll = input ( ) <NEWLINE> for i in roll : <NEWLINE> <INDENT> if i == E : <NEWLINE> <INDENT> tmp = e <NEWLINE> e = u <NEWLINE> u = w <NEWLINE> w = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> elif i == S : <NEWLINE> <INDENT> tmp = s <NEWLINE> s = u <NEWLINE> u = n <NEWLINE> n = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> elif i == W : <NEWLINE> <INDENT> tmp = w <NEWLINE> w = u <NEWLINE> u = e <NEWLINE> e = b <NEWLINE> b = tmp <NEWLINE> <DEDENT> elif i == N : <NEWLINE> <INDENT> tmp = n <NEWLINE> n = u <NEWLINE> u = s <NEWLINE> s = b <NEWLINE> b = tmp <NEWLINE> <NL> <DEDENT> <DEDENT> print ( u ) <NEWLINE>
d = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> c = list ( input ( ) ) <NEWLINE> <NL> class dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , d ) : <NEWLINE> <INDENT> self . d = d <NEWLINE> <NL> <DEDENT> def roll ( self , com ) : <NEWLINE> <INDENT> a1 , a2 , a3 , a4 , a5 , a6 = self . d <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> self . d = [ a4 , a2 , a1 , a6 , a5 , a3 ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . d = [ a3 , a2 , a6 , a1 , a5 , a4 ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . d = [ a5 , a1 , a3 , a4 , a6 , a2 ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . d = [ a2 , a6 , a3 , a4 , a1 , a5 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dice1 = dice ( d ) <NEWLINE> for com in c : <NEWLINE> <INDENT> roll ( com ) <NEWLINE> <DEDENT> print ( dice1 . d [ 0 ] ) <NEWLINE>
class Dice ( ) : <NEWLINE> <INDENT> def __init__ ( self , numbers ) : <NEWLINE> <INDENT> self . top = numbers [ 0 ] <NEWLINE> self . s = numbers [ 1 ] <NEWLINE> self . e = numbers [ 2 ] <NEWLINE> self . w = numbers [ 3 ] <NEWLINE> self . n = numbers [ 4 ] <NEWLINE> self . bot = numbers [ 5 ] <NEWLINE> <DEDENT> def rot ( self , dir ) : <NEWLINE> <INDENT> top , s , e , w , n , bot = ( self . top , self . s , self . e , self . w , self . b , self . bot ) <NEWLINE> if dir == <STRING> : <NEWLINE> <INDENT> self . top = s <NEWLINE> self . s = bot <NEWLINE> self . e = e <NEWLINE> self . w = w <NEWLINE> self . n = top <NEWLINE> self . bot = n <NEWLINE> <DEDENT> elif dir == <STRING> : <NEWLINE> <INDENT> self . top = n <NEWLINE> self . s = top <NEWLINE> self . e = e <NEWLINE> self . w = w <NEWLINE> self . n = bot <NEWLINE> self . bot = s <NEWLINE> <DEDENT> elif dir == <STRING> : <NEWLINE> <INDENT> self . top = w <NEWLINE> self . s = s <NEWLINE> self . e = top <NEWLINE> self . w = bot <NEWLINE> self . n = n <NEWLINE> self . bot = e <NEWLINE> <DEDENT> elif dir == <STRING> : <NEWLINE> <INDENT> self . top = e <NEWLINE> self . s = s <NEWLINE> self . e = bot <NEWLINE> self . w = top <NEWLINE> self . n = n <NEWLINE> self . bot = w <NEWLINE> <DEDENT> <DEDENT> def getTop ( self ) : <NEWLINE> <INDENT> return self . top <NEWLINE> <NL> <DEDENT> <DEDENT> li = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> D = Dice ( li ) <NEWLINE> command = input ( ) <NEWLINE> for dir in command : <NEWLINE> <INDENT> D . rot ( dir ) <NEWLINE> <DEDENT> print ( D . getTop ( ) ) <NEWLINE>
class Dice2 ( Dice1 ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , v ) : <COMMENT> <NEWLINE> <INDENT> super ( ) . __init__ ( v ) <NEWLINE> <NL> self . dTFR = { } <NEWLINE> for i , j , k in ( ( ii , ( ii + + 2 ) % 6 , ( ii + 4 ) % 6 ) for ii in range ( 6 ) ) : <NEWLINE> <INDENT> self . dTFR [ self . view [ i ] ] = [ self . view [ v ] for v in ( j , k , 5 - j , 5 - k , j ) ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> d2 , q = Dice2 ( list ( map ( int , input ( ) . split ( ) ) ) ) , int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> t , f = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( d2 . dTFR [ t ] [ d2 . dTFR [ t ] . index ( f ) + 1 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> class Die : <NEWLINE> <INDENT> def __init__ ( self , pips ) : <NEWLINE> <INDENT> self . pips = pips <NEWLINE> <NL> <DEDENT> def move_die ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 1 ] <NEWLINE> self . pips [ 1 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 4 ] <NEWLINE> self . pips [ 4 ] = tmp <NEWLINE> del tmp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 4 ] <NEWLINE> self . pips [ 4 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 1 ] <NEWLINE> self . pips [ 1 ] = tmp <NEWLINE> del tmp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 3 ] <NEWLINE> self . pips [ 3 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 2 ] <NEWLINE> self . pips [ 2 ] = tmp <NEWLINE> del tmp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 2 ] <NEWLINE> self . pips [ 2 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 3 ] <NEWLINE> self . pips [ 3 ] = tmp <NEWLINE> del tmp <NEWLINE> <NL> <DEDENT> <DEDENT> def spin_die_clockwise ( self ) : <NEWLINE> <INDENT> tmp = self . pips [ 1 ] <NEWLINE> self . pips [ 1 ] = self . pips [ 2 ] <NEWLINE> self . pips [ 2 ] = self . pips [ 4 ] <NEWLINE> self . pips [ 4 ] = self . pips [ 3 ] <NEWLINE> self . pips [ 3 ] = tmp <NEWLINE> del tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def init_die ( ) : <NEWLINE> <INDENT> pips = [ int ( pip ) for pip in sys . stdin . readline ( ) . strip ( <STRING> ) . split ( ) ] <NEWLINE> die = Die ( pips ) <NEWLINE> <NL> return die <NEWLINE> <NL> <NL> <DEDENT> def roll_die ( die ) : <NEWLINE> <INDENT> directions = list ( sys . stdin . readline ( ) . strip ( <STRING> ) ) <NEWLINE> <NL> for direction in directions : <NEWLINE> <INDENT> die . move_die ( direction ) <NEWLINE> <NL> <DEDENT> return die <NEWLINE> <NL> <NL> <DEDENT> def question_rightside ( die ) : <NEWLINE> <INDENT> q = int ( sys . stdin . readline ( ) . strip ( <STRING> ) ) <NEWLINE> <NL> for question in range ( q ) : <NEWLINE> <INDENT> q_pips = [ int ( pip ) for pip in sys . stdin . readline ( ) . strip ( <STRING> ) . split ( ) ] <NEWLINE> <NL> if q_pips [ 0 ] == die . pips [ 1 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 2 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 3 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 4 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 5 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> die . move_die ( <STRING> ) <NEWLINE> <NL> <DEDENT> while die . get_frontside ( ) != q_pips [ 1 ] : <NEWLINE> <INDENT> die . spin_die_clockwise ( ) <NEWLINE> <NL> <DEDENT> return die . get_rightside ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> die = init_die ( ) <NEWLINE> print ( question_rightside ( die ) ) <NEWLINE> <NL> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> <NL> class Die : <NEWLINE> <INDENT> def __init__ ( self , pips ) : <NEWLINE> <INDENT> self . pips = pips <NEWLINE> <NL> <DEDENT> def move_die ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 1 ] <NEWLINE> self . pips [ 1 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 4 ] <NEWLINE> self . pips [ 4 ] = tmp <NEWLINE> del tmp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 4 ] <NEWLINE> self . pips [ 4 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 1 ] <NEWLINE> self . pips [ 1 ] = tmp <NEWLINE> del tmp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 3 ] <NEWLINE> self . pips [ 3 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 2 ] <NEWLINE> self . pips [ 2 ] = tmp <NEWLINE> del tmp <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> tmp = self . pips [ 0 ] <NEWLINE> self . pips [ 0 ] = self . pips [ 2 ] <NEWLINE> self . pips [ 2 ] = self . pips [ 5 ] <NEWLINE> self . pips [ 5 ] = self . pips [ 3 ] <NEWLINE> self . pips [ 3 ] = tmp <NEWLINE> del tmp <NEWLINE> <NL> <DEDENT> <DEDENT> def spin_die_clockwise ( self ) : <NEWLINE> <INDENT> tmp = self . pips [ 1 ] <NEWLINE> self . pips [ 1 ] = self . pips [ 2 ] <NEWLINE> self . pips [ 2 ] = self . pips [ 4 ] <NEWLINE> self . pips [ 4 ] = self . pips [ 3 ] <NEWLINE> self . pips [ 3 ] = tmp <NEWLINE> del tmp <NEWLINE> <NL> <DEDENT> def get_upside ( self ) : <NEWLINE> <INDENT> return self . pips [ 0 ] <NEWLINE> <NL> <DEDENT> def get_frontside ( self ) : <NEWLINE> <INDENT> return self . pips [ 1 ] <NEWLINE> <NL> <DEDENT> def get_rightside ( self ) : <NEWLINE> <INDENT> return self . pips [ 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def init_die ( ) : <NEWLINE> <INDENT> pips = [ int ( pip ) for pip in sys . stdin . readline ( ) . strip ( <STRING> ) . split ( ) ] <NEWLINE> die = Die ( pips ) <NEWLINE> return die <NEWLINE> <NL> <NL> <DEDENT> def roll_die ( die ) : <NEWLINE> <INDENT> directions = list ( sys . stdin . readline ( ) . strip ( <STRING> ) ) <NEWLINE> <NL> for direction in directions : <NEWLINE> <INDENT> die . move_die ( direction ) <NEWLINE> <NL> <DEDENT> return die <NEWLINE> <NL> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> die = init_die ( ) <NEWLINE> q = int ( sys . stdin . readline ( ) . strip ( <STRING> ) ) <NEWLINE> <NL> for question in range ( q ) : <NEWLINE> <INDENT> q_pips = [ int ( pip ) for pip in sys . stdin . readline ( ) . strip ( <STRING> ) . split ( ) ] <NEWLINE> <NL> if q_pips [ 0 ] == die . pips [ 0 ] : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 1 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 2 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 3 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 4 ] : <NEWLINE> <INDENT> die . move_die ( <STRING> ) <NEWLINE> <DEDENT> elif q_pips [ 0 ] == die . pips [ 5 ] : <NEWLINE> <DEDENT> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , ls ) : <NEWLINE> <INDENT> self . a = ls [ 1 - 1 ] <COMMENT> <NEWLINE> self . b = ls [ 2 - 1 ] <COMMENT> <NEWLINE> self . c = ls [ 3 - 1 ] <COMMENT> <NEWLINE> self . d = ls [ 4 - 1 ] <COMMENT> <NEWLINE> self . e = ls [ 5 - 1 ] <COMMENT> <NEWLINE> self . f = ls [ 6 - 1 ] <COMMENT> <NEWLINE> <NL> <DEDENT> def E ( self ) : <NEWLINE> <INDENT> self . a , self . c , self . f , self . d = self . d , self . a , self . c , self . f <NEWLINE> <DEDENT> def W ( self ) : <NEWLINE> <INDENT> self . a , self . c , self . f , self . d = self . c , self . f , self . d , self . a <NEWLINE> <DEDENT> def S ( self ) : <NEWLINE> <INDENT> self . a , self . b , self . f , self . e = self . e , self . a , self . b , self . f <NEWLINE> <DEDENT> def N ( self ) : <NEWLINE> <INDENT> self . a , self . b , self . f , self . e = self . b , self . f , self . e , self . a <NEWLINE> <NL> <DEDENT> <DEDENT> import random <NEWLINE> ls = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> dice = Dice ( ls ) <NEWLINE> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> while dice . a != a or dice . b != b : <NEWLINE> <INDENT> random . choice ( [ dice . E ( ) , dice . W ( ) , dice . S ( ) , dice . N ( ) ] ) <NEWLINE> <NL> <DEDENT> print dice . c <NEWLINE> <DEDENT>
from typing import List <NEWLINE> <NL> <NL> class Dice : <NEWLINE> <NL> <INDENT> sur = [ i for i in range ( 6 ) ] <NEWLINE> <NL> def __init__ ( self , s : List [ int ] ) : <NEWLINE> <INDENT> self . s = s <COMMENT> <NEWLINE> <NL> <COMMENT> <NL> self . sur [ 0 ] = [ 1 , 2 , 4 , 3 ] <NEWLINE> self . sur [ 1 ] = [ 0 , 3 , 5 , 2 ] <NEWLINE> self . sur [ 2 ] = [ 1 , 5 , 4 , 0 ] <NEWLINE> self . sur [ 3 ] = [ 1 , 0 , 4 , 5 ] <NEWLINE> self . sur [ 4 ] = [ 0 , 2 , 5 , 3 ] <NEWLINE> self . sur [ 5 ] = [ 1 , 3 , 4 , 2 ] <NEWLINE> <NL> <DEDENT> def get_right_face_num ( self , upper_num : int , front_num : int ) -> int : <NEWLINE> <INDENT> for i , value in enumerate ( self . sur [ upper_num ] ) : <NEWLINE> <INDENT> if value == front_num : <NEWLINE> <INDENT> return self . sur [ upper_num ] [ ( i + 1 ) % 4 ] <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_value ( self , face_num ) -> int : <NEWLINE> <INDENT> return self . s [ face_num ] <NEWLINE> <NL> <DEDENT> def get_face_num ( self , value ) -> int : <NEWLINE> <INDENT> for i in range ( len ( self . s ) ) : <NEWLINE> <INDENT> if value == self . s [ i ] : <NEWLINE> <INDENT> return i <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> raise ValueError ( <STRING> ) <NEWLINE> <NL> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> data = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> N = int ( input ( ) ) <NEWLINE> dice = Dice ( data ) <NEWLINE> for _i in range ( N ) : <NEWLINE> <INDENT> upper_value , front_value = map ( int , input ( ) . split ( ) ) <NEWLINE> upper_num = dice . get_face_num ( upper_value ) <NEWLINE> front_num = dice . get_face_num ( front_value ) <NEWLINE> ans_num = dice . get_right_face_num ( upper_num , front_num ) <NEWLINE> print ( dice . get_value ( ans_num ) ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> with open ( <STRING> , mode = <STRING> , encoding = <STRING> ) as fin : <NEWLINE> <INDENT> data = [ int ( i ) for i in next ( fin ) . split ( ) ] <NEWLINE> N = int ( next ( fin ) ) <NEWLINE> dice = Dice ( data ) <NEWLINE> for _i in range ( N ) : <NEWLINE> <INDENT> upper_value , front_value = map ( int , next ( fin ) . split ( ) ) <NEWLINE> upper_num = dice . get_face_num ( upper_value ) <NEWLINE> front_num = dice . get_face_num ( front_value ) <NEWLINE> ans_num = dice . get_right_face_num ( upper_num , front_num ) <NEWLINE> print ( dice . get_value ( ans_num ) ) <NEWLINE> <NL> <DEDENT> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> self . dice = ( 2 , 5 ) , ( 3 , 4 ) , ( 1 , 6 ) <COMMENT> <NEWLINE> self . ax = [ [ 0 , False ] , [ 1 , False ] , [ 2 , False ] ] <NEWLINE> self . axmap = [ 0 , 1 , 2 ] <NEWLINE> self . mm = { <STRING> : ( 0 , 2 ) , <STRING> : ( 2 , 0 ) , <STRING> : ( 1 , 2 ) , <STRING> : ( 2 , 1 ) , <STRING> : ( 0 , 1 ) , <STRING> : ( 1 , 0 ) } <NEWLINE> <NL> <DEDENT> def rotate ( self , dir ) : <NEWLINE> <INDENT> def rot ( k , r ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> t = self . axmap [ r ] <NEWLINE> self . axmap [ k ] , self . axmap [ r ] = t , self . axmap [ k ] <NEWLINE> self . ax [ t ] [ 1 ] = not self . ax [ t ] [ 1 ] <NEWLINE> <NL> <DEDENT> rot ( * self . mm [ dir ] ) <NEWLINE> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> z = self . ax [ self . axmap [ 2 ] ] <NEWLINE> return self . dice [ z [ 0 ] ] [ z [ 1 ] ] <NEWLINE> <NL> <DEDENT> def right ( self ) : <NEWLINE> <INDENT> y = self . ax [ self . axmap [ 1 ] ] <NEWLINE> return self . dice [ y [ 0 ] ] [ y [ 1 ] ] <NEWLINE> <NL> <DEDENT> def front ( self ) : <NEWLINE> <INDENT> x = self . ax [ self . axmap [ 0 ] ] <NEWLINE> return self . dice [ x [ 0 ] ] [ x [ 1 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dice = Dice ( ) <NEWLINE> labels = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> p = labels . index ( a ) + 1 <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> if p == dice . top ( ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice . rotate ( <STRING> ) <NEWLINE> <DEDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> if p == dice . top ( ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice . rotate ( <STRING> ) <NEWLINE> <NL> <DEDENT> p = labels . index ( b ) + 1 <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> if p == dice . front ( ) : <NEWLINE> <INDENT> break ; <NEWLINE> <DEDENT> dice . rotate ( <STRING> ) <NEWLINE> <NL> <DEDENT> print ( labels ( dice . right ( ) - 1 ) ) <NEWLINE> <DEDENT> <DEDENT>
from Dice import Dice <NEWLINE> <NL> dice = Dice ( input ( ) . split ( ) ) <NEWLINE> count = int ( input ( ) ) <NEWLINE> result = [ ] <NEWLINE> <NL> for i in range ( count ) : <NEWLINE> <INDENT> ( top , front ) = [ i for i in input ( ) . split ( ) ] <NEWLINE> dice . moveTopTo ( top ) <NEWLINE> dice . moveFrontTo ( front ) <NEWLINE> result . append ( dice . getRight ( ) ) <NEWLINE> <NL> <DEDENT> for s in result : <NEWLINE> <INDENT> print ( s ) <NEWLINE> <DEDENT>
mask = [ range ( 6 ) , ( 1 , 5 , 2 , 3 , 0 , 4 ) , ( 2 , 1 , 5 , 0 , 4 , 3 ) , ( 3 , 1 , 0 , 5 , 4 , 2 ) , ( 4 , 0 , 2 , 3 , 5 , 1 ) ] <NEWLINE> mask += [ mask [ 1 ] [ i ] for i in mask [ 1 ] ] <NEWLINE> <NL> TOP , FRONT , RIGHT , LEFT , BACK , BOTTOM = mask [ 0 ] <NEWLINE> <NL> def set_top ( dice , top ) : <NEWLINE> <INDENT> return [ dice [ i ] for i in mask [ top ] ] <NEWLINE> <NL> <DEDENT> def set_front ( dice , front ) : <NEWLINE> <INDENT> twist = ( 0 , 3 , 1 , 4 , 2 , 5 ) <NEWLINE> while dice [ FRONT ] != front : <NEWLINE> <INDENT> dice = [ dice [ i ] for i in twist ] <NEWLINE> <DEDENT> return dice <NEWLINE> <NL> <DEDENT> label = input ( ) . split ( ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> top , front = map ( label . index , input ( ) . split ( ) ) <NEWLINE> dice = set_top ( mask [ 0 ] , top ) <NEWLINE> dice = set_front ( dice , front ) <NEWLINE> print ( label [ dice [ RIGHT ] ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . dice = ( 2 , 5 ) , ( 3 , 4 ) , ( 1 , 6 ) <COMMENT> <NEWLINE> self . ax = [ [ 0 , False ] , [ 1 , False ] , [ 2 , False ] ] <NEWLINE> self . axmap = [ 0 , 1 , 2 ] <NEWLINE> self . mm = { <STRING> : ( 0 , 2 ) , <STRING> : ( 2 , 0 ) , <STRING> : ( 1 , 2 ) , <STRING> : ( 2 , 1 ) , <STRING> : ( 0 , 1 ) , <STRING> : ( 1 , 0 ) } <NEWLINE> <NL> <DEDENT> def rotate ( self , dir ) : <NEWLINE> <INDENT> def rot ( k , r ) : <NEWLINE> <INDENT> t = self . axmap [ r ] <NEWLINE> self . axmap [ k ] , self . axmap [ r ] = t , self . axmap [ k ] <NEWLINE> self . ax [ t ] [ 1 ] = not self . ax [ t ] [ 1 ] <NEWLINE> <NL> <DEDENT> rot ( * self . mm [ dir ] ) <NEWLINE> <NL> <DEDENT> def front ( self ) : return self . value ( 0 , True ) <NEWLINE> def rear ( self ) : return self . value ( 0 , False ) <NEWLINE> def right ( self ) : return self . value ( 1 , True ) <NEWLINE> def left ( self ) : return self . value ( 1 , False ) <NEWLINE> def top ( self ) : return self . value ( 2 , True ) <NEWLINE> def bottom ( self ) : return self . value ( 2 , False ) <NEWLINE> def value ( self , ax , d ) : <NEWLINE> <INDENT> a = self . ax [ self . axmap [ ax ] ] <NEWLINE> return self . dice [ a [ 0 ] ] [ a [ 1 ] if d else not a [ 1 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dice = Dice ( ) <NEWLINE> labels = raw_input ( ) . split ( ) <NEWLINE> q = int ( raw_input ( ) ) <NEWLINE> def tf ( p , f , d ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> if p == f ( ) : break <NEWLINE> dice . rotate ( d ) <NEWLINE> <NL> <DEDENT> <DEDENT> for _ in range ( q ) : <NEWLINE> <INDENT> a , b = raw_input ( ) . split ( ) <NEWLINE> p = labels . index ( a ) + 1 <NEWLINE> f = dice . top <NEWLINE> tf ( p , f , <STRING> ) <NEWLINE> tf ( p , f , <STRING> ) <NEWLINE> <NL> p = labels . index ( b ) + 1 <NEWLINE> f = dice . front <NEWLINE> tf ( p , f , <STRING> ) <NEWLINE> <NL> print ( labels [ dice . right ( ) - 1 ] ) <NEWLINE> <DEDENT> <DEDENT>
A , B , C = ( 0 , 1 , 5 , 4 ) , ( 1 , 2 , 4 , 3 ) , ( 2 , 0 , 3 , 5 ) <NEWLINE> D = ( - 1 , 3 ) <NEWLINE> <NL> f = input ( ) . split ( ) <NEWLINE> input ( ) <NEWLINE> while True : <NEWLINE> <INDENT> t , s = map ( f . index , input ( ) . split ( ) ) <NEWLINE> if t in A and s in A : <NEWLINE> <INDENT> print ( f [ 2 ] ) if A . index ( t ) - A . index ( s ) in D else print ( f [ 3 ] ) <NEWLINE> <DEDENT> if t in B and s in B : <NEWLINE> <INDENT> print ( f [ 0 ] ) if B . index ( t ) - B . index ( s ) in D else print ( f [ 5 ] ) <NEWLINE> <DEDENT> if t in C and s in C : <NEWLINE> <INDENT> print ( f [ 1 ] ) if C . index ( t ) - C . index ( s ) in D else print ( f [ 4 ] ) <NEWLINE> <DEDENT> <DEDENT>
dice = { v : k for k , v in enumerate ( list ( map ( int , input ( ) . split ( ) ) ) ) } <NEWLINE> adjacent = { k : v for k , v in enumerate ( sorted ( dice . keys ( ) ) ) } <NEWLINE> q = int ( input ( ) ) <NEWLINE> p = [ ( - 1 , 2 , 4 , 1 , 3 , - 1 ) , ( 3 , - 1 , 0 , 5 , - 1 , 2 ) , ( 1 , 5 , - 1 , - 1 , 0 , 4 ) , ( 4 , 0 , - 1 , - 1 , 5 , 1 ) , ( 2 , - 1 , 5 , 0 , - 1 , 3 ) , ( - 1 , 3 , 1 , 4 , 2 , - 1 ) ] <NEWLINE> for _ in range ( q ) : <NEWLINE> <INDENT> top , front = map ( int , input ( ) . split ( ) ) <NEWLINE> x = dice [ top ] <NEWLINE> y = dice [ front - 1 ] <NEWLINE> print ( adjacent [ p [ x ] [ y ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> <NL> class Dice ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , label ) : <NEWLINE> <INDENT> self . label = label <NEWLINE> <NL> <DEDENT> def _rotateS ( self ) : <NEWLINE> <INDENT> s1 , s2 , s3 , s4 , s5 , s6 = self . label <NEWLINE> self . label = [ s5 , s1 , s3 , s4 , s6 , s2 ] <NEWLINE> <NL> <DEDENT> def _rotateN ( self ) : <NEWLINE> <INDENT> s1 , s2 , s3 , s4 , s5 , s6 = self . label <NEWLINE> self . label = [ s2 , s6 , s3 , s4 , s1 , s5 ] <NEWLINE> <NL> <DEDENT> def _rotateE ( self ) : <NEWLINE> <INDENT> s1 , s2 , s3 , s4 , s5 , s6 = self . label <NEWLINE> self . label = [ s4 , s2 , s1 , s6 , s5 , s3 ] <NEWLINE> <NL> <DEDENT> def _rotateW ( self ) : <NEWLINE> <INDENT> s1 , s2 , s3 , s4 , s5 , s6 = self . label <NEWLINE> self . label = [ s3 , s2 , s6 , s1 , s5 , s4 ] <NEWLINE> <NL> <DEDENT> def rotate ( self , r ) : <NEWLINE> <INDENT> if r == <STRING> : <NEWLINE> <INDENT> self . _rotateS ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateN ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateE ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateW ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> + r + <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> def _spinPos ( self ) : <NEWLINE> <INDENT> s1 , s2 , s3 , s4 , s5 , s6 = self . label <NEWLINE> self . label = [ s1 , s4 , s2 , s5 , s4 , s6 ] <NEWLINE> <NL> <DEDENT> def _spinNeg ( self ) : <NEWLINE> <INDENT> s1 , s2 , s3 , s4 , s5 , s6 = self . label <NEWLINE> self . label = [ s1 , s3 , s5 , s2 , s4 , s6 ] <NEWLINE> <NL> <NL> <DEDENT> def getTopLabel ( self ) : <NEWLINE> <INDENT> return self . label [ 0 ] <NEWLINE> <NL> <DEDENT> def match ( self , top , front ) : <NEWLINE> <INDENT> iTop = self . label . index ( top ) + 1 <NEWLINE> if iTop == 1 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif iTop == 2 : <NEWLINE> <INDENT> self . _rotateN ( ) <NEWLINE> <DEDENT> elif iTop == 3 : <NEWLINE> <INDENT> self . _rotateW ( ) <NEWLINE> <DEDENT> elif iTop == 4 : <NEWLINE> <INDENT> self . _rotateE ( ) <NEWLINE> <DEDENT> elif iTop == 5 : <NEWLINE> <INDENT> self . _rotateS ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . _rotateS ( ) <NEWLINE> self . _rotateS ( ) <NEWLINE> <NL> <DEDENT> iFront = self . label . index ( front ) + 1 <NEWLINE> if iFront == 2 : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> elif iFront == 3 : <NEWLINE> <INDENT> self . _spinNeg ( ) <NEWLINE> <DEDENT> elif iFront == 4 : <NEWLINE> <INDENT> self . _spinPos ( ) <NEWLINE> <DEDENT> elif iFront == 5 : <NEWLINE> <INDENT> self . _spinPos ( ) <NEWLINE> self . _spinPos ( ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> d = Dice ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> n = input ( ) <NEWLINE> for _ in xrange ( n ) : <NEWLINE> <INDENT> top , front = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> d . match ( top , front ) <NEWLINE> print d . label [ 2 ] <NEWLINE> <DEDENT> <DEDENT>
rot = ( ( 1 , 2 , 4 , 3 ) , ( 2 , 0 , 3 , 5 ) , ( 0 , 1 , 5 , 4 ) ) <NEWLINE> f = input ( ) . split ( ) <NEWLINE> <NL> for i in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> t , s = map ( f . index , input ( ) . split ( ) ) <NEWLINE> for j in rot : <NEWLINE> <INDENT> if ( t in j ) * ( s in j ) : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> d = rot . index ( j ) <NEWLINE> if ( j . index ( t ) - j . index ( s ) ) % 4 == 1 : <NEWLINE> <INDENT> d -= 5 <NEWLINE> <DEDENT> <DEDENT> print ( f [ abs ( d ) ] ) <NEWLINE> <DEDENT>
class Dice2 ( ) : <NEWLINE> <INDENT> def front ( self , up , front , dice ) : <NEWLINE> <COMMENT> <NL> <INDENT> if ( up == dice [ 2 ] and front == dice [ 1 ] ) <NEWLINE> or ( up == dice [ 1 ] and front == dice [ 3 ] ) <NEWLINE> or ( up == dice [ 3 ] and front == dice [ 4 ] ) <NEWLINE> or ( up == dice [ 4 ] and front == dice [ 2 ] ) : <NEWLINE> <INDENT> return dice [ 5 ] <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( up == dice [ 0 ] and front == dice [ 2 ] ) <NEWLINE> or ( up == dice [ 2 ] and front == dice [ 5 ] ) <NEWLINE> or ( up == dice [ 5 ] and front == dice [ 3 ] ) <NEWLINE> or ( up == dice [ 3 ] and front == dice [ 0 ] ) : <NEWLINE> <INDENT> return dice [ 4 ] <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( front == dice [ 5 ] and up == dice [ 4 ] ) <NEWLINE> or ( front == dice [ 4 ] and up == dice [ 0 ] ) <NEWLINE> or ( front == dice [ 0 ] and up == dice [ 1 ] ) <NEWLINE> or ( front == dice [ 1 ] and up == dice [ 5 ] ) : <NEWLINE> <INDENT> return dice [ 3 ] <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( up == dice [ 5 ] and front == dice [ 4 ] ) <NEWLINE> or ( up == dice [ 4 ] and front == dice [ 0 ] ) <NEWLINE> or ( up == dice [ 0 ] and front == dice [ 1 ] ) <NEWLINE> or ( up == dice [ 1 ] and front == dice [ 5 ] ) : <NEWLINE> <INDENT> return dice [ 2 ] <NEWLINE> <COMMENT> <NL> <DEDENT> elif ( front == dice [ 0 ] and up == dice [ 2 ] ) <NEWLINE> or ( front == dice [ 2 ] and up == dice [ 5 ] ) <NEWLINE> or ( front == dice [ 5 ] and up == dice [ 3 ] ) <NEWLINE> or ( front == dice [ 3 ] and up == dice [ 0 ] ) : <NEWLINE> <INDENT> return dice [ 1 ] <NEWLINE> <COMMENT> <NL> <DEDENT> else : <NEWLINE> <INDENT> return dice [ 0 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dice = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> p = int ( input ( ) ) <NEWLINE> dc2 = Dice2 ( ) <NEWLINE> ans = [ ] <NEWLINE> for i in range ( p ) : <NEWLINE> <INDENT> up , front = map ( int , input ( ) . split ( ) ) <NEWLINE> ans . append ( dc2 . front ( up , front , dice ) ) <NEWLINE> <DEDENT> for i in range ( p ) : <NEWLINE> <INDENT> print ( ans [ i ] ) <NEWLINE> <DEDENT>
class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , top , south , east , west , north , bottom ) : <NEWLINE> <INDENT> self . top = top <NEWLINE> self . south = south <NEWLINE> self . east = east <NEWLINE> self . west = west <NEWLINE> self . north = north <NEWLINE> self . bottom = bottom <NEWLINE> <NL> <DEDENT> def get_face ( self , face ) : <NEWLINE> <INDENT> if face == <STRING> : <NEWLINE> <INDENT> return self . top <NEWLINE> <DEDENT> elif face == <STRING> : <NEWLINE> <INDENT> return self . south <NEWLINE> <DEDENT> elif face == <STRING> : <NEWLINE> <INDENT> return self . east <NEWLINE> <DEDENT> elif face == <STRING> : <NEWLINE> <INDENT> return self . west <NEWLINE> <DEDENT> elif face == <STRING> : <NEWLINE> <INDENT> return self . north <NEWLINE> <DEDENT> elif face == <STRING> : <NEWLINE> <INDENT> return self . bottom <NEWLINE> <NL> <DEDENT> <DEDENT> def rotate ( self , directions ) : <NEWLINE> <INDENT> for direction in directions : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . north <NEWLINE> self . north = self . bottom <NEWLINE> self . bottom = self . south <NEWLINE> self . south = self . prev_top <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . west <NEWLINE> self . west = self . bottom <NEWLINE> self . bottom = self . east <NEWLINE> self . east = self . prev_top <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . east <NEWLINE> self . east = self . bottom <NEWLINE> self . bottom = self . west <NEWLINE> self . west = self . prev_top <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . south <NEWLINE> self . south = self . bottom <NEWLINE> self . bottom = self . north <NEWLINE> self . north = self . prev_top <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dice = Dice ( * map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = input ( ) <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> top , south = map ( int , input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> for direction in <STRING> : <NEWLINE> <INDENT> if dice . get_face ( <STRING> ) == top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice . rotate ( direction ) <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> for directions in [ <STRING> ] * 3 : <NEWLINE> <INDENT> if dice . get_face ( <STRING> ) == south : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> for direction in directions : <NEWLINE> <INDENT> dice . rotate ( direction ) <NEWLINE> <DEDENT> <DEDENT> print ( dice . get_face ( <STRING> ) ) <NEWLINE> <DEDENT>
<NL> class Dice : <NEWLINE> <NL> <INDENT> def __init__ ( self , faces ) : <NEWLINE> <INDENT> self . t = faces [ 0 ] <NEWLINE> self . s = faces [ 1 ] <NEWLINE> self . e = faces [ 2 ] <NEWLINE> self . w = faces [ 3 ] <NEWLINE> self . n = faces [ 4 ] <NEWLINE> self . b = faces [ 5 ] <NEWLINE> <NL> <DEDENT> def roll ( self , drct ) : <NEWLINE> <INDENT> t_ = self . t <NEWLINE> s_ = self . s <NEWLINE> e_ = self . e <NEWLINE> w_ = self . w <NEWLINE> n_ = self . n <NEWLINE> b_ = self . b <NEWLINE> if drct == <STRING> : <NEWLINE> <INDENT> self . t = def set_top ( self , face ) : <NEWLINE> <DEDENT> if self . t == face : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif self . s == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif self . e == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif self . w == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif self . n == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> self . roll ( <STRING> ) _ <NEWLINE> self . s = t_ <NEWLINE> self . n = b_ <NEWLINE> self . b = s_ <NEWLINE> <DEDENT> elif drct == <STRING> : <NEWLINE> <INDENT> self . t = s_ <NEWLINE> self . s = b_ <NEWLINE> self . n = t_ <NEWLINE> self . b = n_ <NEWLINE> <DEDENT> elif drct == <STRING> : <NEWLINE> <INDENT> self . t = w_ <NEWLINE> self . e = t_ <NEWLINE> self . w = b_ <NEWLINE> self . b = e_ <NEWLINE> <DEDENT> elif drct == <STRING> : <NEWLINE> <INDENT> self . t = e_ <NEWLINE> self . e = b_ <NEWLINE> self . w = t_ <NEWLINE> self . b = w_ <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return <NEWLINE> <NL> <DEDENT> <DEDENT> def set_top ( self , face ) : <NEWLINE> <INDENT> if self . t == face : <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> elif self . s == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif self . e == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif self . w == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif self . n == face : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> self . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def get_right_face ( self , f ) : <NEWLINE> <INDENT> if self . s == f : <NEWLINE> <INDENT> return self . e <NEWLINE> <DEDENT> elif self . e == f : <NEWLINE> <INDENT> return self . n <NEWLINE> <DEDENT> elif self . w == f : <NEWLINE> <INDENT> return self . s <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return self . w <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> faces = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice = Dice ( faces ) <NEWLINE> <NL> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> t , f = map ( int , input ( ) . split ( ) ) <NEWLINE> dice . set_top ( t ) <NEWLINE> print ( dice . get_right_face ( f ) ) <NEWLINE> <NL> <DEDENT>
def face ( x , y , dice ) : <NEWLINE> <INDENT> if ( x == dice [ 5 ] and y == dice [ 4 ] ) or ( x == dice [ 4 ] and y == dice [ 0 ] ) or ( x == dice [ 0 ] and y == dice [ 1 ] ) or ( x == dice [ 1 ] and y == dice [ 5 ] ) : <NEWLINE> <INDENT> return dice [ 2 ] <NEWLINE> <DEDENT> elif ( x == dice [ 0 ] and y == dice [ 2 ] ) or ( x == dice [ 2 ] and y == dice [ 5 ] ) or ( x == dice [ 5 ] and y == dice [ 3 ] ) or ( x == dice [ 3 ] and y == dice [ 0 ] ) : <NEWLINE> <INDENT> return dice [ 4 ] <NEWLINE> <DEDENT> elif ( y == dice [ 5 ] and x == dice [ 4 ] ) or ( y == dice [ 4 ] and x == dice [ 0 ] ) or ( y == dice [ 0 ] and x == dice [ 1 ] ) or ( y == dice [ 1 ] and x == dice [ 5 ] ) : <NEWLINE> <INDENT> return dice [ 3 ] <NEWLINE> <DEDENT> elif ( y == dice [ 0 ] and x == dice [ 2 ] ) or ( y == dice [ 2 ] and x == dice [ 5 ] ) or ( y == dice [ 5 ] and x == dice [ 3 ] ) or ( y == dice [ 3 ] and x == dice [ 0 ] ) : <NEWLINE> <INDENT> return dice [ 1 ] <NEWLINE> <DEDENT> elif ( x == dice [ 2 ] and y == dice [ 1 ] ) or ( x == dice [ 1 ] and y == dice [ 3 ] ) or ( x == dice [ 3 ] and y == dice [ 4 ] ) or ( x == dice [ 4 ] and y == dice [ 2 ] ) : <NEWLINE> <INDENT> return dice [ 5 ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return dice [ 0 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> for i in range ( n ) : <NEWLINE> <INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print face ( a , b , l ) <NEWLINE> <DEDENT>
def whatIsRight ( u , f ) : <NEWLINE> <INDENT> r = 0 <NEWLINE> if u == 1 : <NEWLINE> <INDENT> if f == 2 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif f == 3 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 5 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 2 : <NEWLINE> <INDENT> if f == 6 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif f == 3 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 3 : <NEWLINE> <INDENT> if f == 5 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 2 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif f == 6 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 4 : <NEWLINE> <INDENT> if f == 6 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 2 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> elif f == 5 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> if u == 5 : <NEWLINE> <INDENT> if f == 3 : <NEWLINE> <INDENT> r = 6 <NEWLINE> <DEDENT> elif f == 6 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 1 <NEWLINE> <DEDENT> elif f == 1 : <NEWLINE> <INDENT> r = 3 <NEWLINE> return r <NEWLINE> <NL> <DEDENT> <DEDENT> if u == 6 : <NEWLINE> <INDENT> if f == 5 : <NEWLINE> <INDENT> r = 3 <NEWLINE> <DEDENT> elif f == 3 : <NEWLINE> <INDENT> r = 2 <NEWLINE> <DEDENT> elif f == 2 : <NEWLINE> <INDENT> r = 4 <NEWLINE> <DEDENT> elif f == 4 : <NEWLINE> <INDENT> r = 5 <NEWLINE> <DEDENT> return r <NEWLINE> <NL> <DEDENT> <DEDENT> n = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> N = int ( input ( ) ) <NEWLINE> <NL> for i in range ( N ) : <NEWLINE> <INDENT> m = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> num = [ ] <NEWLINE> <NL> for j in range ( len ( m ) ) : <NEWLINE> <INDENT> for k in range ( len ( n ) ) : <NEWLINE> <INDENT> if m [ j ] == n [ k ] : <NEWLINE> <INDENT> num . append ( k + 1 ) <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( n [ whatIsRight ( num [ 0 ] , num [ 1 ] ) - 1 ] ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> <NL> class Cube : <NEWLINE> <INDENT> def __init__ ( self , u , s , e , w , n , d ) : <NEWLINE> <INDENT> self . u = u <NEWLINE> self . s = s <NEWLINE> self . e = e <NEWLINE> self . w = w <NEWLINE> self . n = n <NEWLINE> self . d = d <NEWLINE> <NL> <DEDENT> def rotate ( self , dic ) : <NEWLINE> <INDENT> if dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . s <NEWLINE> self . s = self . d <NEWLINE> self . d = self . n <NEWLINE> self . n = tmp <NEWLINE> <DEDENT> elif dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . w <NEWLINE> self . w = self . d <NEWLINE> self . d = self . e <NEWLINE> self . e = tmp <NEWLINE> <DEDENT> elif dic == <STRING> : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . e <NEWLINE> self . e = self . d <NEWLINE> self . d = self . w <NEWLINE> self . w = tmp <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = self . u <NEWLINE> self . u = self . n <NEWLINE> self . n = self . d <NEWLINE> self . d = self . s <NEWLINE> self . s = tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> u , s , e , w , n , d = map ( int , input ( ) . split ( ) ) <NEWLINE> cube = Cube ( u , s , e , w , n , d ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> for i in range ( q ) : <NEWLINE> <INDENT> upper , front = map ( int , input ( ) . split ( ) ) <NEWLINE> while True : <NEWLINE> <INDENT> cube . rotate ( random . choice ( <STRING> ) ) <NEWLINE> if upper == cube . u and front == cube . s : <NEWLINE> <INDENT> print ( cube . e ) <NEWLINE> break <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( <NEWLINE> <DEDENT>
class dice : <NEWLINE> <INDENT> def __init__ ( self , pip ) : <NEWLINE> <INDENT> self . pip = pip <NEWLINE> <NL> <DEDENT> def move ( self , dir ) : <NEWLINE> <INDENT> if str ( dir ) == <STRING> : <NEWLINE> <INDENT> self . pip [ 0 ] , self . pip [ 2 ] , self . pip [ 3 ] , self . pip [ 5 ] = self . pip [ 3 ] , self . pip [ 0 ] , self . pip [ 5 ] , self . pip [ 2 ] <NEWLINE> <DEDENT> elif str ( dir ) == <STRING> : <NEWLINE> <INDENT> self . pip [ 0 ] , self . pip [ 2 ] , self . pip [ 3 ] , self . pip [ 5 ] = self . pip [ 2 ] , self . pip [ 5 ] , self . pip [ 0 ] , self . pip [ 3 ] <NEWLINE> <DEDENT> elif str ( dir ) == <STRING> : <NEWLINE> <INDENT> self . pip [ 0 ] , self . pip [ 1 ] , self . pip [ 4 ] , self . pip [ 5 ] = self . pip [ 1 ] , self . pip [ 5 ] , self . pip [ 0 ] , self . pip [ 4 ] <NEWLINE> <DEDENT> elif str ( dir ) == <STRING> : <NEWLINE> <INDENT> self . pip [ 0 ] , self . pip [ 1 ] , self . pip [ 4 ] , self . pip [ 5 ] = self . pip [ 4 ] , self . pip [ 0 ] , self . pip [ 5 ] , self . pip [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> d = dice ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <NL> <INDENT> top , front = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> for op in <STRING> <NEWLINE> <INDENT> d . move ( op ) <NEWLINE> if d . pip [ 0 ] == top and d . pip [ 1 ] == front : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( d . pip [ 2 ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int n , a , b ; <NEWLINE> int c [ 6 ] = { } ; <NEWLINE> for ( int i = 0 ; i < 6 ; i + + ) { <NEWLINE> <INDENT> cin >> c [ i ] ; <NEWLINE> <DEDENT> } <NEWLINE> cin >> n ; <NEWLINE> for ( int i = 0 ; i < n ; i + + ) { <NEWLINE> <INDENT> cin >> a >> b ; <NEWLINE> if ( a == c [ 0 ] ) { <NEWLINE> <INDENT> if ( b == c [ 1 ] ) { <NEWLINE> <INDENT> cout << c [ 2 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 2 ] ) { <NEWLINE> <INDENT> cout << c [ 4 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 3 ] ) { <NEWLINE> <INDENT> cout << c [ 1 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 4 ] ) { <NEWLINE> <INDENT> cout << c [ 3 ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } else if ( a == c [ 1 ] ) { <NEWLINE> <INDENT> if ( b == c [ 0 ] ) { <NEWLINE> <INDENT> cout << c [ 3 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 2 ] ) { <NEWLINE> <INDENT> cout << c [ 0 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 3 ] ) { <NEWLINE> <INDENT> cout << c [ 5 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 5 ] ) { <NEWLINE> <INDENT> cout << c [ 2 ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } else if ( a == c [ 2 ] ) { <NEWLINE> <INDENT> if ( b == c [ 0 ] ) { <NEWLINE> <INDENT> cout << c [ 1 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 1 ] ) { <NEWLINE> <INDENT> cout << c [ 5 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 4 ] ) { <NEWLINE> <INDENT> cout << c [ 0 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 5 ] ) { <NEWLINE> <INDENT> cout << c [ 4 ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } else if ( a == c [ 3 ] ) { <NEWLINE> <INDENT> if ( b == c [ 0 ] ) { <NEWLINE> <INDENT> cout << c [ 4 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 1 ] ) { <NEWLINE> <INDENT> cout << c [ 0 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 4 ] ) { <NEWLINE> <INDENT> cout << c [ 5 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 5 ] ) { <NEWLINE> <INDENT> cout << c [ 1 ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } else if ( a == c [ 4 ] ) { <NEWLINE> <INDENT> if ( b == c [ 0 ] ) { <NEWLINE> <INDENT> cout << c [ 2 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 2 ] ) { <NEWLINE> <INDENT> cout << c [ 5 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 3 ] ) { <NEWLINE> <INDENT> cout << c [ 0 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 5 ] ) { <NEWLINE> <INDENT> cout << c [ 3 ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } else if ( a == c [ 5 ] ) { <NEWLINE> <INDENT> if ( b == c [ 1 ] ) { <NEWLINE> <INDENT> cout << c [ 3 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 2 ] ) { <NEWLINE> <INDENT> cout << c [ 1 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 3 ] ) { <NEWLINE> <INDENT> cout << c [ 4 ] << endl ; <NEWLINE> <DEDENT> } else if ( b == c [ 4 ] ) { <NEWLINE> <INDENT> cout << c [ 2 ] << endl ; <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
<COMMENT> <NL> <NL> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , n ) : <NEWLINE> <INDENT> self . upper = n [ 0 ] <NEWLINE> self . backward = n [ 1 ] <NEWLINE> self . right = n [ 2 ] <NEWLINE> self . left = n [ 3 ] <NEWLINE> self . ahead = n [ 4 ] <NEWLINE> self . bottom = n [ 5 ] <NEWLINE> <NL> <DEDENT> def roll_north ( self ) : <NEWLINE> <INDENT> self . upper , self . ahead , self . bottom , self . backward = self . backward , self . upper , self . ahead , self . bottom <NEWLINE> <NL> <DEDENT> def roll_south ( self ) : <NEWLINE> <INDENT> self . upper , self . ahead , self . bottom , self . backward = self . ahead , self . bottom , self . backward , self . upper <NEWLINE> <NL> <DEDENT> def roll_east ( self ) : <NEWLINE> <INDENT> self . upper , self . right , self . bottom , self . left = self . left , self . upper , self . right , self . bottom <NEWLINE> <NL> <DEDENT> def roll_west ( self ) : <NEWLINE> <INDENT> self . upper , self . right , self . bottom , self . left = self . right , self . bottom , self . left , self . upper <NEWLINE> <NL> <DEDENT> def roll_side ( self ) : <NEWLINE> <INDENT> self . ahead , self . right , self . backward , self . left = self . left , self . ahead , self . right , self . backward <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dice_info = Dice ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> q = int ( input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> upper , ahead = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> while not ( upper == dice_info . upper or ahead == dice_info . ahead ) : <NEWLINE> <INDENT> dice_info . roll_north ( ) <NEWLINE> dice_info . roll_side ( ) <NEWLINE> <NL> <DEDENT> while upper != dice_info . upper : <NEWLINE> <INDENT> dice_info . roll_east ( ) <NEWLINE> <NL> <DEDENT> while ahead != dice_info . ahead : <NEWLINE> <INDENT> dice_info . roll_side ( ) <NEWLINE> <NL> <DEDENT> print ( dice_info . left ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , men ) : <NEWLINE> <INDENT> self . men = men <NEWLINE> <NL> <DEDENT> def throw ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 3 ] <NEWLINE> men [ 1 ] = pmen [ 1 ] <NEWLINE> men [ 2 ] = pmen [ 0 ] <NEWLINE> men [ 3 ] = pmen [ 5 ] <NEWLINE> men [ 4 ] = pmen [ 4 ] <NEWLINE> men [ 5 ] = pmen [ 2 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 2 ] <NEWLINE> men [ 1 ] = pmen [ 1 ] <NEWLINE> men [ 2 ] = pmen [ 5 ] <NEWLINE> men [ 3 ] = pmen [ 0 ] <NEWLINE> men [ 4 ] = pmen [ 4 ] <NEWLINE> men [ 5 ] = pmen [ 3 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 4 ] <NEWLINE> men [ 1 ] = pmen [ 0 ] <NEWLINE> men [ 2 ] = pmen [ 2 ] <NEWLINE> men [ 3 ] = pmen [ 3 ] <NEWLINE> men [ 4 ] = pmen [ 5 ] <NEWLINE> men [ 5 ] = pmen [ 1 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 1 ] <NEWLINE> men [ 1 ] = pmen [ 5 ] <NEWLINE> men [ 2 ] = pmen [ 2 ] <NEWLINE> men [ 3 ] = pmen [ 3 ] <NEWLINE> men [ 4 ] = pmen [ 0 ] <NEWLINE> men [ 5 ] = pmen [ 4 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def printUe ( self ) : <NEWLINE> <INDENT> print ( self . men ) [ 0 ] <NEWLINE> <NL> <DEDENT> def printMigi ( self ) : <NEWLINE> <INDENT> print ( self . men ) [ 2 ] <NEWLINE> <NL> <DEDENT> def printMen ( self ) : <NEWLINE> <INDENT> print self . men <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> men = map ( int , ( raw_input ( ) ) . split ( <STRING> ) ) <NEWLINE> d = Dice ( men ) <NEWLINE> <NL> q = int ( raw_input ( ) ) <NEWLINE> <NL> for i in range ( q ) : <NEWLINE> <INDENT> Q = map ( int , ( raw_input ( ) ) . split ( <STRING> ) ) <NEWLINE> print Q <NEWLINE> if ( d . men [ 2 ] == Q [ 1 ] or d . men [ 3 ] == Q [ 1 ] ) : <NEWLINE> <INDENT> while ( d . men [ 1 ] != Q [ 1 ] ) : <NEWLINE> <INDENT> d . throw ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> while ( d . men [ 1 ] != Q [ 1 ] ) : <NEWLINE> <INDENT> d . throw ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> while ( d . men [ 0 ] != Q [ 0 ] ) : <NEWLINE> <INDENT> d . throw ( <STRING> ) <NEWLINE> <NL> <DEDENT> d . printMigi ( ) <NEWLINE> <DEDENT>
import copy <NEWLINE> class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , List ) : <NEWLINE> <INDENT> self . face = List <NEWLINE> <NL> <DEDENT> def n_spin ( self , a_List ) : <NEWLINE> <INDENT> List = copy . copy ( a_List ) <NEWLINE> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 1 ] <NEWLINE> List [ 1 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 4 ] <NEWLINE> List [ 4 ] = <NEWLINE> return List <NEWLINE> <NL> <DEDENT> def s_spin ( self , a_List ) : <NEWLINE> <INDENT> List = copy . copy ( a_List ) <NEWLINE> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 4 ] <NEWLINE> List [ 4 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 1 ] <NEWLINE> List [ 1 ] = temp <NEWLINE> return List <NEWLINE> <NL> <DEDENT> def e_spin ( self , a_List ) : <NEWLINE> <INDENT> List = copy . copy ( a_List ) <NEWLINE> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 3 ] <NEWLINE> List [ 3 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 2 ] <NEWLINE> List [ 2 ] = temp <NEWLINE> return List <NEWLINE> <NL> <DEDENT> def w_spin ( self , a_List ) : <NEWLINE> <INDENT> List = copy . copy ( a_List ) <NEWLINE> temp = List [ 0 ] <NEWLINE> List [ 0 ] = List [ 2 ] <NEWLINE> List [ 2 ] = List [ 5 ] <NEWLINE> List [ 5 ] = List [ 3 ] <NEWLINE> List [ 3 ] = temp <NEWLINE> return List <NEWLINE> <NL> <DEDENT> <DEDENT> dice = Dice ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> emer = copy . copy ( dice . face ) <NEWLINE> face_storage = [ ] <NEWLINE> face_storage . append ( emer ) <NEWLINE> q = input ( ) <NEWLINE> for a in range ( q ) : <NEWLINE> <INDENT> question = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for a in range ( 24 ) : <NEWLINE> <INDENT> face_storage . append ( dice . n_spin ( face_storage [ a ] ) ) <NEWLINE> face_storage . append ( dice . s_spin ( face_storage [ a ] ) ) <NEWLINE> face_storage . append ( dice . w_spin ( face_storage [ a ] ) ) <NEWLINE> face_storage . append ( dice . e_spin ( face_storage [ a ] ) ) <NEWLINE> <DEDENT> for c in face_storage : <NEWLINE> <INDENT> if c [ 0 ] == question [ 0 ] and c [ 1 ] == question [ 1 ] : <NEWLINE> <INDENT> print c [ 2 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Dice ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , d ) : <NEWLINE> <NL> <INDENT> self . rows = [ d [ 0 ] , d [ 4 ] , d [ 5 ] , d [ 1 ] ] <NEWLINE> self . cols = [ d [ 0 ] , d [ 2 ] , d [ 5 ] , d [ 3 ] ] <NEWLINE> <NL> <DEDENT> def __move_next ( self , x , y ) : <NEWLINE> <INDENT> temp = y . pop ( 0 ) <NEWLINE> y . append ( temp ) <NEWLINE> x [ 0 ] = y [ 0 ] <NEWLINE> x [ 2 ] = y [ 2 ] <NEWLINE> <NL> <DEDENT> def __move_prev ( self , x , y ) : <NEWLINE> <INDENT> temp = y . pop ( 3 ) <NEWLINE> y . insert ( 0 , temp ) <NEWLINE> x [ 0 ] = y [ 0 ] <NEWLINE> x [ 2 ] = y [ 2 ] <NEWLINE> <NL> <DEDENT> def execute ( self , c ) : <NEWLINE> <INDENT> for i in self . c : <NEWLINE> <INDENT> self . __move ( i , self . rows , self . cols ) <NEWLINE> <NL> <DEDENT> <DEDENT> def __move ( self , com , x , y ) : <NEWLINE> <INDENT> if com == <STRING> : <NEWLINE> <INDENT> self . __move_prev ( y , x ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . __move_next ( y , x ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . __move_prev ( x , y ) <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . __move_next ( x , y ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_top ( self ) : <NEWLINE> <INDENT> print ( self . rows [ 0 ] ) <NEWLINE> <NL> <DEDENT> def execute2 ( self , a , b ) : <NEWLINE> <NL> <INDENT> while self . rows [ 0 ] == b : <NEWLINE> <INDENT> self . __move_next ( self . rows , self . cols ) <NEWLINE> <NL> <DEDENT> while self . rows [ 0 ] == a and self . rows [ 1 ] == b : <NEWLINE> <INDENT> self . __move_next ( self . cols , self . rows ) <NEWLINE> <NL> <DEDENT> <DEDENT> def print_right_side ( self ) : <NEWLINE> <INDENT> print ( self . cols [ 4 ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> d = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> c = input ( ) <NEWLINE> dice = Dice2 ( d ) <NEWLINE> <NL> for i in range ( c ) : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> dice . execute2 ( a , b ) <NEWLINE> dice . print_right_side ( ) <NEWLINE> <NL> <DEDENT>
class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , top , south , east , west , north , bottom ) : <NEWLINE> <INDENT> self . top = top <NEWLINE> self . south = south <NEWLINE> self . east = east <NEWLINE> self . west = west <NEWLINE> self . north = north <NEWLINE> self . bottom = bottom <NEWLINE> <NL> <DEDENT> def get_top ( self ) : <NEWLINE> <INDENT> return self . top <NEWLINE> <NL> <DEDENT> def rotate ( self , directions ) : <NEWLINE> <INDENT> for direction in directions : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . north <NEWLINE> self . north = self . bottom <NEWLINE> self . bottom = self . south <NEWLINE> self . south = self . prev_top <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . west <NEWLINE> self . west = self . bottom <NEWLINE> self . bottom = self . east <NEWLINE> self . east = self . prev_top <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . east <NEWLINE> self . east = self . bottom <NEWLINE> self . bottom = self . west <NEWLINE> self . west = self . prev_top <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . prev_top = self . top <NEWLINE> self . top = self . south <NEWLINE> self . south = self . bottom <NEWLINE> self . bottom = self . north <NEWLINE> self . north = self . prev_top <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> dice = Dice ( * map ( int , input ( ) . split ( ) ) ) <NEWLINE> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> a , b = input ( ) . split ( ) <NEWLINE> if dice . east == b or dice . west == b : <NEWLINE> <INDENT> dice . rotate ( <STRING> ) <NEWLINE> <DEDENT> while a != dice . top : <NEWLINE> <INDENT> dice . rotate ( <STRING> ) <NEWLINE> <DEDENT> while b != dice . south : <NEWLINE> <INDENT> dice . rotate ( <STRING> ) <NEWLINE> <DEDENT> print ( dice . east ) <NEWLINE> <DEDENT>
d = input ( ) . split ( ) <NEWLINE> n = { 0 : ( 1 , 2 , 4 , 3 , 1 ) , 1 : ( 0 , 3 , 5 , 2 , 0 ) , 2 : ( 0 , 1 , 5 , 4 , 0 ) , 3 : ( 1 , 0 , 4 , 5 , 1 ) , 4 : ( 0 , 2 , 5 , 3 , 0 ) , 5 : ( 1 , 3 , 4 , 2 , 1 ) } <NEWLINE> for _ in range ( int ( input ( ) ) ) : <NEWLINE> <INDENT> t , f = [ d . index ( s ) for s in input ( ) . split ( ) ] <NEWLINE> n = n [ int ( t ) ] <NEWLINE> print ( d [ n [ n . index ( int ( f ) ) + 1 ] ] ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> import random <NEWLINE> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , top , s , e , w , n , bottom ) : <NEWLINE> <INDENT> self . top = top <NEWLINE> self . s = s <NEWLINE> self . e = e <NEWLINE> self . w = w <NEWLINE> self . n = n <NEWLINE> self . bottom = bottom <NEWLINE> <NL> <DEDENT> def rotate ( self , dist ) : <NEWLINE> <INDENT> if dist == <STRING> : <NEWLINE> <INDENT> self . top , self . s , self . n , self . bottom = self . s , self . bottom , self . top , self . n <NEWLINE> <DEDENT> elif dist == <STRING> : <NEWLINE> <INDENT> self . s , self . bottom , self . top , self . n = self . top , self . s , self . n , self . bottom <NEWLINE> <DEDENT> elif dist == <STRING> : <NEWLINE> <INDENT> self . top , self . e , self . w , self . bottom = self . w , self . top , self . bottom , self . e <NEWLINE> <DEDENT> elif dist == <STRING> : <NEWLINE> <INDENT> self . w , self . top , self . bottom , self . e = self . top , self . e , self . w , self . bottom <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dice1 = Dice ( * map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> dice2 = Dice ( * map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> <NL> ref1 = set ( ) <NEWLINE> ref2 = set ( ) <NEWLINE> while len ( ref1 ) < 24 : <NEWLINE> <INDENT> ref1 . add ( ( dice1 . top , dice1 . s , dice1 . e ) ) <NEWLINE> ref2 . add ( ( dice2 . top , dice2 . s , dice2 . e ) ) <NEWLINE> <NL> dist = <STRING> [ random . randint ( 0 , 3 ) ] <NEWLINE> dice1 . rotate ( dist ) <NEWLINE> dice2 . rotate ( dist ) <NEWLINE> <NL> <DEDENT> print <STRING> if ref1 == ref2 else <STRING> <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> import sys <NEWLINE> rolls1 = raw_input ( ) . split ( ) <NEWLINE> rolls2 = raw_input ( ) . split ( ) <NEWLINE> testpare = ( rolls1 [ 0 ] , rolls1 [ 5 ] ) <NEWLINE> testparerev = ( rolls1 [ 5 ] , rolls1 [ 0 ] ) <NEWLINE> rolls2pare = [ ( rolls2 [ 0 ] , rolls2 [ 5 ] ) , ( rolls2 [ 2 ] , rolls2 [ 3 ] ) , ( rolls2 [ 1 ] , rolls2 [ 4 ] ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if testpare in rolls2pare : <NEWLINE> <INDENT> pareps = rolls2pare . index ( testpare ) <NEWLINE> revflag = False <NEWLINE> <DEDENT> elif testparerev in rolls2pare : <NEWLINE> <INDENT> pareps = rolls2pare . index ( testparerev ) <NEWLINE> revflag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> sys . exit ( 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> li1 = [ rolls1 [ 1 ] , rolls1 [ 2 ] , rolls1 [ 4 ] , rolls1 [ 3 ] ] <NEWLINE> <COMMENT> <NL> if pareps == 0 : <NEWLINE> <INDENT> if revflag : <NEWLINE> <INDENT> tmp = rolls2 [ 2 ] <NEWLINE> rolls2 [ 2 ] = rolls2 [ 3 ] <NEWLINE> rolls2 [ 3 ] = tmp <NEWLINE> <DEDENT> li2 = [ rolls2 [ 1 ] , rolls2 [ 2 ] , rolls2 [ 4 ] , rolls2 [ 3 ] ] <NEWLINE> <DEDENT> elif pareps == 1 : <NEWLINE> <INDENT> if revflag : <NEWLINE> <INDENT> tmp = rolls2 [ 1 ] <NEWLINE> rolls2 [ 1 ] = rolls2 [ 4 ] <NEWLINE> rolls2 [ 4 ] = tmp <NEWLINE> li2 = [ rolls2 [ 0 ] , rolls2 [ 1 ] , rolls2 [ 5 ] , rolls2 [ 4 ] ] <NEWLINE> <DEDENT> <DEDENT> elif pareps == 2 : <NEWLINE> <INDENT> if revflag : <NEWLINE> <INDENT> tmp = rolls2 [ 0 ] <NEWLINE> rolls2 [ 0 ] = rolls2 [ 5 ] <NEWLINE> rolls2 [ 5 ] = tmp <NEWLINE> <DEDENT> li2 = [ rolls2 [ 0 ] , rolls2 [ 3 ] , rolls2 [ 5 ] , rolls2 [ 2 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> sys . exit ( 0 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> i = 0 <NEWLINE> j = li2 . index ( li1 [ 0 ] ) <NEWLINE> matchflag = True <COMMENT> <NEWLINE> for x in xrange ( 4 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if li1 [ i ] == li2 [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> matchflag = False <NEWLINE> break <NEWLINE> <DEDENT> if i > 3 : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> if j > 3 : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> <DEDENT> if matchflag : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <NL> class dice_class : <NEWLINE> <INDENT> def __init__ ( self , list ) : <NEWLINE> <INDENT> self . num = list <NEWLINE> <NL> <DEDENT> def sut ( self , top ) : <COMMENT> <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if self . num [ 0 ] == top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> if self . num [ 0 ] == top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def suf ( self , front ) : <COMMENT> <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if self . num [ 1 ] == front : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def roll ( self , s ) : <NEWLINE> <INDENT> for i in s : <NEWLINE> <INDENT> if i == <STRING> : <NEWLINE> <INDENT> self . rollE ( ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> self . rollN ( ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> self . rollS ( ) <NEWLINE> <DEDENT> elif i == <STRING> : <NEWLINE> <INDENT> self . rollW ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def rollE ( self ) : <NEWLINE> <INDENT> self . num = [ self . num [ 3 ] , self . num [ 1 ] , self . num [ 0 ] , self . num [ 5 ] , self . num [ 4 ] , self . num [ 2 ] ] <NEWLINE> <NL> <DEDENT> def rollN ( self ) : <NEWLINE> <INDENT> self . num = [ self . num [ 1 ] , self . num [ 5 ] , self . num [ 2 ] , self . num [ 3 ] , self . num [ 0 ] , self . num [ 4 ] ] <NEWLINE> <NL> <DEDENT> def rollS ( self ) : <NEWLINE> <INDENT> self . num = [ self . num [ 4 ] , self . num [ 0 ] , self . num [ 2 ] , self . num [ 3 ] , self . num [ 5 ] , self . num [ 1 ] ] <NEWLINE> <NL> <DEDENT> def rollW ( self ) : <NEWLINE> <INDENT> self . num = [ self . num [ 2 ] , self . num [ 1 ] , self . num [ 5 ] , self . num [ 0 ] , self . num [ 4 ] , self . num [ 3 ] ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> dice1 = dice_class ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> dice2 = dice_class ( map ( int , raw_input ( ) . split ( ) ) ) <NEWLINE> flg = False <NEWLINE> <NL> for i in range ( 6 ) : <NEWLINE> <INDENT> if i % 2 : <NEWLINE> <INDENT> dice1 . roll ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice1 . roll ( <STRING> ) <NEWLINE> <DEDENT> dice2 . sut ( dice1 . num [ 0 ] ) <NEWLINE> dice2 . suf ( dice1 . num [ 1 ] ) <NEWLINE> if dice1 . num == dice2 . num : <NEWLINE> <INDENT> flg = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flg : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , nums ) : <NEWLINE> <INDENT> self . face = nums <NEWLINE> <NL> <DEDENT> def rolltoTopIndex ( self , faceindex ) : <NEWLINE> <INDENT> if faceindex == 1 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif faceindex == 2 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif faceindex == 3 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif faceindex == 4 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif faceindex == 5 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll ( self , actions ) : <NEWLINE> <INDENT> for act in actions : <NEWLINE> <INDENT> t = 0 <NEWLINE> if act == <STRING> : <NEWLINE> <INDENT> t = self . face [ 0 ] <NEWLINE> self . face [ 0 ] = self . face [ 3 ] <NEWLINE> self . face [ 3 ] = self . face [ 5 ] <NEWLINE> self . face [ 5 ] = self . face [ 2 ] <NEWLINE> self . face [ 2 ] = t <NEWLINE> <DEDENT> elif act == <STRING> : <NEWLINE> <INDENT> t = self . face [ 0 ] <NEWLINE> self . face [ 0 ] = self . face [ 1 ] <NEWLINE> self . face [ 1 ] = self . face [ 5 ] <NEWLINE> self . face [ 5 ] = self . face [ 4 ] <NEWLINE> self . face [ 4 ] = t <NEWLINE> <DEDENT> elif act == <STRING> : <NEWLINE> <INDENT> t = self . face [ 0 ] <NEWLINE> self . face [ 0 ] = self . face [ 4 ] <NEWLINE> self . face [ 4 ] = self . face [ 5 ] <NEWLINE> self . face [ 5 ] = self . face [ 1 ] <NEWLINE> self . face [ 1 ] = t <NEWLINE> <DEDENT> elif act == <STRING> : <NEWLINE> <INDENT> t = self . face [ 0 ] <NEWLINE> self . face [ 0 ] = self . face [ 2 ] <NEWLINE> self . face [ 2 ] = self . face [ 5 ] <NEWLINE> self . face [ 5 ] = self . face [ 3 ] <NEWLINE> self . face [ 3 ] = t <NEWLINE> <DEDENT> elif act == <STRING> : <NEWLINE> <INDENT> t = self . face [ 1 ] <NEWLINE> self . face [ 1 ] = self . face [ 2 ] <NEWLINE> self . face [ 2 ] = self . face [ 4 ] <NEWLINE> self . face [ 4 ] = self . face [ 3 ] <NEWLINE> self . face [ 3 ] = t <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> diceface = [ int ( val ) for val in input ( ) . split ( <STRING> ) ] <NEWLINE> dice1 = Dice ( diceface ) <NEWLINE> diceface = [ int ( val ) for val in input ( ) . split ( <STRING> ) ] <NEWLINE> dice2 = Dice ( diceface ) <NEWLINE> <NL> <NL> cnt = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if dice1 . face [ 0 ] == dice2 . face [ i ] : <NEWLINE> <INDENT> dice2 . rolltoTopIndex ( i ) <NEWLINE> for j in range ( 1 , 5 ) <NEWLINE> <INDENT> if dice1 . face [ 1 ] == dice2 . face [ 1 ] : <NEWLINE> <INDENT> cnt = 0 <NEWLINE> for k in range ( 6 ) : <NEWLINE> <INDENT> if dice1 . face [ k ] == dice2 . face [ k ] : <NEWLINE> <INDENT> cnt += 1 <NEWLINE> <DEDENT> <DEDENT> if cnt == 6 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> dice2 . roll ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> if cnt == 6 <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> dice2 . face = diceface <NEWLINE> <NL> <NL> <DEDENT> if cnt == 6 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
d , e = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 2 ) ] <NEWLINE> e [ 3 ] , e [ 4 ] = e [ 4 ] , e [ 3 ] <NEWLINE> t = 0 <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> m = { 0 : <STRING> , 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } [ i ] <NEWLINE> f = [ d [ int ( j ) ] for j in m ] ; f [ 3 ] , f [ 4 ] = f [ 4 ] , f [ 3 ] <NEWLINE> if f [ 0 ] == e [ 0 ] : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if f [ 1 : 5 ] * 2 [ j : j + 4 ] == e [ 1 : 5 ] : t = 1 ; break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( ( <STRING> , <STRING> ) [ t == 1 ] ) <NEWLINE>
import random <NEWLINE> class Dice : <NEWLINE> <INDENT> def __init__ ( self , top , front , right , left , back , bottom ) : <NEWLINE> <INDENT> self . top , self . bottom = top , bottom <NEWLINE> self . right , self . left = right , left <NEWLINE> self . front , self . back = front , back <NEWLINE> <NL> <DEDENT> def rot ( self , d ) : <NEWLINE> <INDENT> if d == <STRING> : <NEWLINE> <INDENT> ( ( self . top , self . back , self . bottom , self . front ) = <NEWLINE> <INDENT> ( self . front , self . top , self . back , self . bottom ) ) <NEWLINE> <DEDENT> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> ( ( self . top , self . back , self . bottom , self . front ) = <NEWLINE> <INDENT> ( self . back , self . bottom , self . front , self . top ) ) <NEWLINE> <DEDENT> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> ( ( self . top , self . right , self . bottom , self . left ) = <NEWLINE> <INDENT> ( self . left , self . top , self . right , self . bottom ) ) <NEWLINE> <DEDENT> <DEDENT> elif d == <STRING> : <NEWLINE> <INDENT> ( ( self . top , self . right , self . bottom , self . left ) = <NEWLINE> <INDENT> ( self . right , self . bottom , self . left , self . top ) ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> <DEDENT> def same ( a , b ) : <NEWLINE> <INDENT> if ( ( a . top , a . bottom , a . right , a . left , a . front , a . back ) == <NEWLINE> <INDENT> ( b . top , b . bottom , b . right , b . left , b . front , b . back ) ) : <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> ref = { } <NEWLINE> ls1 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> ls2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> dice1 = Dice ( ls1 [ 0 ] , ls1 [ 1 ] , ls1 [ 2 ] , ls1 [ 3 ] , ls1 [ 4 ] , ls1 [ 5 ] ) <NEWLINE> dice2 = Dice ( ls2 [ 0 ] , ls2 [ 1 ] , ls2 [ 2 ] , ls2 [ 3 ] , ls2 [ 4 ] , ls2 [ 5 ] ) <NEWLINE> for i in xrange ( 1000 ) : <NEWLINE> <INDENT> d = <STRING> [ random . randint ( 0 , 3 ) ] <NEWLINE> dice1 . rot ( d ) <NEWLINE> if same ( dice1 , dice2 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> <NL> <DEDENT> def __eq__ ( self , value ) : <NEWLINE> <INDENT> for a in range ( 0 , 6 , 5 ) : <NEWLINE> <INDENT> self . moveTopTo ( self . getSortedList ( ) [ a ] ) <NEWLINE> value . moveTopTo ( value . getSortedList ( ) [ a ] ) <NEWLINE> for b in range ( 4 ) : <NEWLINE> <INDENT> print ( self . data , value . data ) <NEWLINE> if self . data == value . data : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> value . move ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def move ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] = self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 4 ] , self . data [ 5 ] , self . data [ 1 ] = self . data [ 1 ] , self . data [ 0 ] , self . data [ 4 ] , self . data [ 5 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] = self . data [ 4 ] , self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] = self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 1 ] , self . data [ 2 ] , self . data [ 4 ] , self . data [ 3 ] = self . data [ 3 ] , self . data [ 1 ] , self . data [ 2 ] , self . data [ 4 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 1 ] , self . data [ 2 ] , self . data [ 4 ] , self . data [ 3 ] = self . data [ 2 ] , self . data [ 4 ] , self . data [ 3 ] , self . data [ 1 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def moveTopTo ( self , target ) : <NEWLINE> <INDENT> for a in range ( 4 ) : <NEWLINE> <INDENT> if self . data [ 0 ] == target : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> <DEDENT> if self . data [ 4 ] == target : <NEWLINE> <INDENT> self . move ( <STRING> ) <NEWLINE> <DEDENT> elif self . data [ 1 ] == target : <NEWLINE> <INDENT> self . move ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def moveFrontTo ( self , target ) : <NEWLINE> <INDENT> for a in range ( 4 ) : <NEWLINE> <INDENT> if self . data [ 1 ] == target : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getTop ( self ) : <NEWLINE> <INDENT> return self . data [ 0 ] <NEWLINE> <NL> <DEDENT> def getRight ( self ) : <NEWLINE> <INDENT> return self . data [ 2 ] <NEWLINE> <NL> <DEDENT> def getSortedList ( self ) : <NEWLINE> <INDENT> tmp = self . data [ : ] <NEWLINE> tmp . sort ( ) <NEWLINE> return tmp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> from Dice import Dice <NEWLINE> a = Dice ( input ( ) . split ( ) ) <NEWLINE> b = Dice ( input ( ) . split ( ) ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import random <NEWLINE> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , list = map ( str , range ( 1 , 7 ) ) ) : <NEWLINE> <INDENT> self . top = list [ 0 ] <NEWLINE> self . front = list [ 1 ] <NEWLINE> self . right = list [ 2 ] <NEWLINE> self . left = list [ 3 ] <NEWLINE> self . back = list [ 4 ] <NEWLINE> self . bottom = list [ 5 ] <NEWLINE> <NL> self . dic = { } <NEWLINE> for i in xrange ( 6 ) : <NEWLINE> <INDENT> if list [ i ] in self . dic : <NEWLINE> <INDENT> self . dic [ list [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . dic [ list [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def print_all ( self ) : <NEWLINE> <INDENT> print <STRING> + self . top + <STRING> + self . front + <STRING> + self . right + <STRING> + self . left + <STRING> + self . back + <STRING> + self . bottom <NEWLINE> <NL> <DEDENT> def roll_N ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . front <NEWLINE> self . front = self . bottom <NEWLINE> self . bottom = self . back <NEWLINE> self . back = temp <NEWLINE> <NL> <DEDENT> def roll_S ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . back <NEWLINE> self . back = self . bottom <NEWLINE> self . bottom = self . front <NEWLINE> self . front = temp <NEWLINE> <NL> <DEDENT> def roll_W ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . right <NEWLINE> self . right = self . bottom <NEWLINE> self . bottom = self . left <NEWLINE> self . left = temp <NEWLINE> <NL> <DEDENT> def roll_E ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . left <NEWLINE> self . left = self . bottom <NEWLINE> self . bottom = self . right <NEWLINE> self . right = temp <NEWLINE> <NL> <DEDENT> def roll_C ( self ) : <NEWLINE> <INDENT> temp = self . front <NEWLINE> self . front = self . right <NEWLINE> self . right = self . back <NEWLINE> self . back = self . left <NEWLINE> self . left = temp <NEWLINE> <NL> <DEDENT> def random_roll ( self ) : <NEWLINE> <INDENT> ram = random . randint ( 1 , 4 ) <NEWLINE> if ram == 1 : <NEWLINE> <INDENT> self . roll_E ( ) <NEWLINE> <DEDENT> elif ram == 2 : <NEWLINE> <INDENT> self . roll_N ( ) <NEWLINE> <DEDENT> elif ram == 3 : <NEWLINE> <INDENT> self . roll_S ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll_W ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getDifference ( self , dice ) : <NEWLINE> <INDENT> same_list = [ ] <NEWLINE> different_list = [ ] <NEWLINE> if self . top == dice . top : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . front == dice . front : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . left == dice . left : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . back == dice . back : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . right == dice . right : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . bottom == dice . bottom : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> result_list = [ same_list , different_list ] <NEWLINE> return result_list <NEWLINE> <NL> <DEDENT> def getList ( self ) : <NEWLINE> <INDENT> list = [ self . top , self . front , self . right , self . left , self . back , self . bottom ] <NEWLINE> return list <NEWLINE> <NL> <DEDENT> <DEDENT> first_dice = Dice ( raw_input ( ) . split ( <STRING> ) ) <NEWLINE> second_dice = Dice ( raw_input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> def print_dices ( ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> first_dice . print_all ( ) <NEWLINE> print <STRING> <NEWLINE> second_dice . print_all ( ) <NEWLINE> <NL> <DEDENT> num = 0 <NEWLINE> while num < 4 : <NEWLINE> <INDENT> dic1_keys = first_dice . dic . keys ( ) <NEWLINE> for i in xrange ( len ( dic1_keys ) ) : <NEWLINE> <INDENT> if first_dice . dic [ dic1_keys [ i ] ] != second_dice . dic [ dic1_keys [ i ] ] : <NEWLINE> <INDENT> num = 4 <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> diferece = first_dice . getDifference ( second_dice ) <NEWLINE> <COMMENT> <NL> <NL> if len ( diferece [ 0 ] ) == 6 : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> if <STRING> in diferece [ 0 ] and <STRING> in diferece [ 0 ] : <NEWLINE> <INDENT> first_dice . roll_W ( ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> elif <STRING> in diferece [ 0 ] and <STRING> in diferece [ 0 ] : <NEWLINE> <INDENT> first_dice . roll_S ( ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> elif <STRING> in diferece [ 0 ] and <STRING> in diferece [ 0 ] : <NEWLINE> <INDENT> first_dice . roll_C ( ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first_dice . random_roll ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if num == 4 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
Dice1 = list ( input ( ) . split ( ) ) <NEWLINE> Dice2 = list ( input ( ) . split ( ) ) <NEWLINE> a = list <NEWLINE> b = 1 <NEWLINE> <NL> for q in range ( 3 ) : <NEWLINE> <INDENT> if Dice1 [ q ] == Dice2 [ q ] : <NEWLINE> <INDENT> a [ q ] = 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a [ q ] = - 1 <NEWLINE> <NL> <DEDENT> <DEDENT> for q in range ( 3 ) : <NEWLINE> <INDENT> b = b * a [ q ] <NEWLINE> <NL> <DEDENT> if b == 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b == - 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n1 = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> n2 = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> <NL> class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , num ) : <NEWLINE> <INDENT> self . n = num [ 4 ] <NEWLINE> self . e = num [ 2 ] <NEWLINE> self . w = num [ 3 ] <NEWLINE> self . s = num [ 1 ] <NEWLINE> self . center = num [ 0 ] <NEWLINE> self . back = num [ 5 ] <NEWLINE> <NL> <DEDENT> def number ( self ) : <NEWLINE> <INDENT> number = [ self . center , self . s , self . e , self . w , self . n , self . back ] <NEWLINE> return number <NEWLINE> <NL> <DEDENT> def move ( self , str ) : <NEWLINE> <INDENT> if str == <STRING> : <NEWLINE> <INDENT> x = self . n <NEWLINE> self . n = self . center <NEWLINE> self . center = self . s <NEWLINE> self . s = self . back <NEWLINE> self . back = x <NEWLINE> return self . center <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> x = self . s <NEWLINE> self . s = self . center <NEWLINE> self . center = self . n <NEWLINE> self . n = self . back <NEWLINE> self . back = x <NEWLINE> return self . center <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> x = self . e <NEWLINE> self . e = self . center <NEWLINE> self . center = self . w <NEWLINE> self . w = self . back <NEWLINE> self . back = x <NEWLINE> return self . center <NEWLINE> <DEDENT> elif str == <STRING> : <NEWLINE> <INDENT> x = self . w <NEWLINE> self . w = self . center <NEWLINE> self . center = self . e <NEWLINE> self . e = self . back <NEWLINE> self . back = x <NEWLINE> return self . center <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dice1 = Dice ( n1 ) <NEWLINE> dice2 = Dice ( n2 ) <NEWLINE> bool1 = False <NEWLINE> bool2 = False <NEWLINE> status = dice1 . center <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if dice1 . number == dice2 . number : <NEWLINE> <INDENT> bool1 = True <NEWLINE> break <NEWLINE> <DEDENT> dice1 . move ( <STRING> ) <NEWLINE> if status == dice1 . center : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if dice1 . number == dice2 . number : <NEWLINE> <INDENT> bool1 = True <NEWLINE> break <NEWLINE> <DEDENT> dice1 . move ( <STRING> ) <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> dice1 = Dice ( n1 ) <NEWLINE> dice2 = Dice ( n2 ) <NEWLINE> status = dice1 . center <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if dice1 . number == dice2 . number : <NEWLINE> <INDENT> bool2 = True <NEWLINE> break <NEWLINE> <DEDENT> dice1 . move ( <STRING> ) <NEWLINE> if status == dice1 . center : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> if dice1 . number == dice2 . number : <NEWLINE> <INDENT> bool2 = True <NEWLINE> break <NEWLINE> <DEDENT> dice1 . move ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) if bool1 == True or bool2 == True else print ( <STRING> ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . data = data <NEWLINE> <NL> <DEDENT> def __eq__ ( self , value ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if self . data [ 0 ] == value . data [ 0 ] : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if self . data == value . data : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> self . move ( <STRING> ) <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> def move ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] = self . data [ 3 ] , self . data [ 5 ] , self . data [ 2 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] = self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] , self . data [ 4 ] = self . data [ 4 ] , self . data [ 0 ] , self . data [ 1 ] , self . data [ 5 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 0 ] , self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] = self . data [ 2 ] , self . data [ 5 ] , self . data [ 3 ] , self . data [ 0 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> self . data [ 1 ] , self . data [ 2 ] , self . data [ 4 ] , self . data [ 3 ] = self . data [ 2 ] , self . data [ 4 ] , self . data [ 3 ] , self . data [ 1 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def getTop ( self ) : <NEWLINE> <INDENT> return self . data [ 0 ] <NEWLINE> <NL> <DEDENT> def getRight ( self , top , front ) : <NEWLINE> <INDENT> if self . data [ 0 ] != top : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if self . data [ 0 ] == top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> if self . data [ 0 ] == top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . move ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> if self . data [ 1 ] != front : <NEWLINE> <INDENT> for i in range ( 3 ) : <NEWLINE> <INDENT> self . move ( <STRING> ) <NEWLINE> if self . data [ 1 ] == front and self . data [ 0 ] == top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return self . data [ 2 ] <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> dice = Dice ( input ( ) . split ( ) ) <NEWLINE> hoge = [ i for i in input ( ) . split ( ) ] <NEWLINE> <NL> print ( dice . judge ( hoge ) ) <NEWLINE>
class Dice ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , label ) : <NEWLINE> <INDENT> self . label = label <NEWLINE> <NL> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> self . change ( [ 2 , 6 , 3 , 4 , 1 , 5 ] ) <NEWLINE> <NL> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> self . change ( [ 3 , 2 , 6 , 1 , 5 , 4 ] ) <NEWLINE> <NL> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> self . change ( [ 4 , 2 , 1 , 6 , 5 , 3 ] ) <NEWLINE> <NL> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> self . change ( [ 5 , 1 , 3 , 4 , 6 , 2 ] ) <NEWLINE> <NL> <DEDENT> def change ( self , convert ) : <NEWLINE> <INDENT> num = [ ] <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> num . append ( self . label [ convert [ i ] - 1 ] ) <NEWLINE> <DEDENT> self . label = num <NEWLINE> <NL> <DEDENT> def is_same_dice ( self , another_dice ) : <NEWLINE> <INDENT> for i in range ( 6 ) : <NEWLINE> <INDENT> if i % 2 == 0 : <NEWLINE> <INDENT> self . north ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . west ( ) <NEWLINE> <DEDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> self . rotate ( ) <NEWLINE> if self . label == another_dice : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> <DEDENT> return False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> f = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> s = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if Dice ( f ) . is_same_dice ( s ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Dice : <NEWLINE> <NL> <INDENT> def __init__ ( self , faces ) : <NEWLINE> <INDENT> self . faces = tuple ( faces ) <NEWLINE> <NL> <DEDENT> def roll_north ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 1 ] , self . faces [ 5 ] , self . faces [ 2 ] , <NEWLINE> <INDENT> self . faces [ 3 ] , self . faces [ 0 ] , self . faces [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_south ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 4 ] , self . faces [ 0 ] , self . faces [ 2 ] , <NEWLINE> <INDENT> self . faces [ 3 ] , self . faces [ 5 ] , self . faces [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_west ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 2 ] , self . faces [ 1 ] , self . faces [ 5 ] , <NEWLINE> <INDENT> self . faces [ 0 ] , self . faces [ 4 ] , self . faces [ 3 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_east ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 3 ] , self . faces [ 1 ] , self . faces [ 0 ] , <NEWLINE> <INDENT> self . faces [ 5 ] , self . faces [ 4 ] , self . faces [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def number ( self , face_id ) : <NEWLINE> <INDENT> return self . faces [ face_id - 1 ] <NEWLINE> <NL> <DEDENT> def issame ( self , other_dice ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if self . faces == other_dice . faces : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> self . rotate ( ) <NEWLINE> <DEDENT> self . roll_north ( ) <NEWLINE> <DEDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> if self . faces == other_dice . faces : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> self . rotate ( ) <NEWLINE> <DEDENT> self . roll_east ( ) <NEWLINE> <DEDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> dice1 = Dice ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> dice2 = Dice ( list ( map ( int , input ( ) . split ( ) ) ) ) <NEWLINE> <NL> print ( <STRING> if dice1 . issame ( dice2 ) else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> <NL> class Dice ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , list_ ) : <NEWLINE> <INDENT> self . label = list_ <NEWLINE> <NL> <DEDENT> def getLabel ( self , i ) : <NEWLINE> <INDENT> return self . label [ i - 1 ] <NEWLINE> <NL> <DEDENT> def _rotateS ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 5 , 1 , 3 , 4 , 6 , 2 ] ] <NEWLINE> <NL> <DEDENT> def _rotateN ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 2 , 6 , 3 , 4 , 1 , 5 ] ] <NEWLINE> <NL> <DEDENT> def _rotateE ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 4 , 2 , 1 , 6 , 5 , 3 ] ] <NEWLINE> <NL> <DEDENT> def _rotateW ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 3 , 2 , 6 , 1 , 5 , 4 ] ] <NEWLINE> <NL> <DEDENT> def _spinPos ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 1 , 4 , 2 , 5 , 3 , 6 ] ] <NEWLINE> <NL> <DEDENT> def _spinNeg ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 1 , 3 , 5 , 2 , 4 , 6 ] ] <NEWLINE> <NL> <DEDENT> def rotate ( self , rotates ) : <NEWLINE> <INDENT> for r in rotates : <NEWLINE> <INDENT> if r == <STRING> : <NEWLINE> <INDENT> self . _rotateS ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateN ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateE ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateW ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _spinPos ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _spinNeg ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def matchTopFront ( self , top , front ) : <NEWLINE> <INDENT> iTop = self . label . index ( top ) + 1 <NEWLINE> topRot = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> } <NEWLINE> self . rotate ( topRot [ iTop ] ) <NEWLINE> <NL> iFront = self . label . index ( front ) + 1 <NEWLINE> frontRot = { 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } <NEWLINE> self . rotate ( frontRot [ iFront ] ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> face1 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> face2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if set ( face1 ) != set ( face2 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> d1 = Dice ( face1 ) <NEWLINE> d2 = Dice ( face2 ) <NEWLINE> d1Top = d1 . getLabel ( 1 ) <NEWLINE> d1Front = d1 . getLabel ( 2 ) <NEWLINE> d2 . matchTopFront ( d1Top , d1Front ) <NEWLINE> print <STRING> if d1 . label == d2 . label else <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> class Dice ( ) : <NEWLINE> <NL> <INDENT> mask = { <STRING> : ( 1 , 5 , 2 , 3 , 0 , 4 ) , <STRING> : ( 3 , 1 , 0 , 5 , 4 , 2 ) , <NEWLINE> <INDENT> <STRING> : ( 2 , 1 , 5 , 0 , 4 , 3 ) , <STRING> : ( 4 , 0 , 2 , 3 , 5 , 1 ) , <STRING> : ( 0 , 2 , 4 , 1 , 3 , 5 ) } <NEWLINE> <NL> <DEDENT> way = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> def __init__ ( self , data ) : <NEWLINE> <INDENT> self . label = data <NEWLINE> <NL> <DEDENT> def move ( self , data ) : <NEWLINE> <INDENT> if data == <STRING> <NEWLINE> <INDENT> return <NEWLINE> <DEDENT> self . label = [ self . label [ idx ] for idx in self . mask [ data ] ] <NEWLINE> <NL> <DEDENT> def get_up ( self ) : <NEWLINE> <INDENT> return self . label [ 0 ] <NEWLINE> <NL> <DEDENT> def compare_6sq ( self , dice2 ) : <NEWLINE> <INDENT> check = True <NEWLINE> for i in range ( 6 ) : <NEWLINE> <INDENT> if self . label [ i ] == dice2 . label [ i ] : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> check = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> return check <NEWLINE> <NL> <DEDENT> def compare_4rot ( self , dice2 ) : <NEWLINE> <INDENT> ok = False <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> self . move ( <STRING> ) <NEWLINE> if self . compare_6sq ( dice2 ) : <NEWLINE> <INDENT> ok = True <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <DEDENT> def compare ( self , dice2 ) <NEWLINE> <INDENT> ok = False <NEWLINE> orderway = ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) <NEWLINE> <NL> for s in orderway : <NEWLINE> <INDENT> self . move ( s ) <NEWLINE> if self . compare_4rot ( dice2 ) : <NEWLINE> <INDENT> ok = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> return ok <NEWLINE> <NL> <NL> <NL> <NL> <NL> <DEDENT> <DEDENT> dice1 = Dice ( input ( ) . split ( ) ) <NEWLINE> dice2 = Dice ( input ( ) . split ( ) ) <NEWLINE> <NL> if dice1 . compare ( dice2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
import random <NEWLINE> <NL> <NL> class Dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . t = 1 <NEWLINE> self . s = 2 <NEWLINE> self . e = 3 <NEWLINE> self . w = 4 <NEWLINE> self . n = 5 <NEWLINE> self . b = 6 <NEWLINE> <NL> <DEDENT> def __init__ ( self , faces ) : <NEWLINE> <INDENT> self . t = faces [ 0 ] <NEWLINE> self . s = faces [ 1 ] <NEWLINE> self . e = faces [ 2 ] <NEWLINE> self . w = faces [ 3 ] <NEWLINE> self . n = faces [ 4 ] <NEWLINE> self . b = faces [ 5 ] <NEWLINE> <NL> <DEDENT> def roll ( self , direct ) : <NEWLINE> <INDENT> if direct == 0 : <NEWLINE> <INDENT> self . t , self . s , self . b , self . n = self . n , self . t , self . s , self . b <NEWLINE> <DEDENT> elif direct == 1 : <NEWLINE> <INDENT> self . t , self . w , self . b , self . e = self . e , self . t , self . w , self . b <NEWLINE> <DEDENT> elif direct == 2 : <NEWLINE> <INDENT> self . n , self . w , self . s , self . e = self . w , self . s , self . e , self . n <NEWLINE> <NL> <DEDENT> <DEDENT> def is_equal ( dice ) : <NEWLINE> <INDENT> if self . t == dice . t and self . s == dice . s and self . e == dice . e and self . w == dice . w and self . n == dice . n and self . b == dice . b : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> faces1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice1 = Dice ( faces1 ) <NEWLINE> faces2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice2 = Dice ( faces2 ) <NEWLINE> <NL> flag = False <NEWLINE> <NL> for i in range ( 10000 ) : <NEWLINE> <INDENT> dice2 . roll ( random . randint ( 0 , 3 ) ) <NEWLINE> if dice1 . is_equal ( dice2 ) : <NEWLINE> <INDENT> flag = True <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
d1 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> d2 = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> class dice ( object ) : <NEWLINE> <INDENT> def __init__ ( self , d ) : <NEWLINE> <INDENT> self . d = d <NEWLINE> <NL> <DEDENT> def roll ( self , com ) : <NEWLINE> <INDENT> a1 , a2 , a3 , a4 , a5 , a6 = self . d <NEWLINE> if com == <STRING> : <NEWLINE> <INDENT> self . d = [ a4 , a2 , a1 , a6 , a5 , a3 ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . d = [ a3 , a2 , a6 , a1 , a5 , a4 ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . d = [ a5 , a1 , a3 , a4 , a6 , a2 ] <NEWLINE> <DEDENT> elif com == <STRING> : <NEWLINE> <INDENT> self . d = [ a2 , a6 , a3 , a4 , a1 , a5 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> dice1 = dice ( d1 ) <NEWLINE> dice2 = dice ( d2 ) <NEWLINE> <NL> if sorted ( d1 ) != sorted ( d2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> c = [ <STRING> , <STRING> , <STRING> , <STRING> ] <NEWLINE> import random <NEWLINE> for i in l : <NEWLINE> <INDENT> n = 0 <NEWLINE> while n < 10 ** 5 : <NEWLINE> <INDENT> if dice1 . d == dice2 . d : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice1 . roll ( c [ random . randint ( 1 , 2 ) ] ) <NEWLINE> <DEDENT> n += 1 <NEWLINE> <DEDENT> if n > 10 ** 5 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT>
class Dice : <NEWLINE> <INDENT> index_list_map = [ [ [ - 1 ] , [ 2 , 3 , 4 , 5 ] , [ 4 , 1 , 3 , 5 ] , [ 1 , 4 , 2 , 5 ] , [ 3 , 2 , 1 , 5 ] , [ - 1 ] ] , <NEWLINE> <INDENT> [ [ 3 , 2 , 5 , 4 ] , [ - 1 ] , [ 0 , 5 , 3 , 4 ] , [ 5 , 0 , 2 , 4 ] , [ - 1 ] , [ 2 , 3 , 0 , 4 ] ] , <NEWLINE> [ [ 1 , 4 , 5 , 3 ] , [ 5 , 0 , 4 , 3 ] , [ - 1 ] , [ - 1 ] , [ 0 , 5 , 1 , 3 ] , [ 4 , 1 , 0 , 3 ] ] , <NEWLINE> [ [ 4 , 1 , 5 , 2 ] , [ 0 , 5 , 4 , 2 ] , [ - 1 ] , [ - 1 ] , [ 5 , 0 , 1 , 2 ] , [ 1 , 4 , 0 , 2 ] ] , <NEWLINE> [ [ 2 , 3 , 5 , 1 ] , [ - 1 ] , [ 5 , 0 , 3 , 1 ] , [ 0 , 5 , 2 , 1 ] , [ - 1 ] , [ 3 , 2 , 0 , 1 ] ] , <NEWLINE> [ [ - 1 ] , [ 3 , 2 , 4 , 0 ] , [ 1 , 4 , 3 , 0 ] , [ 4 , 1 , 2 , 0 ] , [ 2 , 3 , 1 , 0 ] , [ - 1 ] ] ] <NEWLINE> <NL> <DEDENT> def __init__ ( self , list ) : <NEWLINE> <INDENT> self . num = list <NEWLINE> <NL> <DEDENT> def lookup_east_side ( self , u , s ) : <NEWLINE> <INDENT> index_upside = u <NEWLINE> index_sside = s <NEWLINE> return self . num [ self . index_list_map [ index_upside ] [ index_sside ] [ 0 ] ] <NEWLINE> <NL> <NL> <DEDENT> def lookup_west_side ( self , u , s ) : <NEWLINE> <INDENT> index_upside = u <NEWLINE> index_sside = s <NEWLINE> return self . num [ self . index_list_map [ index_upside ] [ index_sside ] [ 1 ] ] <NEWLINE> <NL> <DEDENT> def lookup_north_side ( self , u , s ) : <NEWLINE> <INDENT> index_upside = u <NEWLINE> index_sside = s <NEWLINE> return self . num [ self . index_list_map [ index_upside ] [ index_sside ] [ 2 ] ] <NEWLINE> <NL> <DEDENT> def lookup_down_side ( self , u , s ) : <NEWLINE> <INDENT> index_upside = u <NEWLINE> index_sside = s <NEWLINE> return self . num [ self . index_list_map [ index_upside ] [ index_sside ] [ 3 ] ] <NEWLINE> <NL> <DEDENT> <DEDENT> spots1 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> spots2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> s2_index_u = [ i for i , x in enumerate ( spots2 ) if x == spots1 [ 0 ] ] <NEWLINE> s2_index_s = [ i for i , x in enumerate ( spots2 ) if x == spots1 [ 1 ] ] <NEWLINE> <NL> combinations_u_s = [ [ x , y ] for x in s2_index_u for y in s2_index_s if x != y ] <NEWLINE> <NL> dice2 = Dice ( spots2 ) <NEWLINE> <NL> for comb in combinations_u_s : <NEWLINE> <INDENT> e = dice2 . lookup_east_side ( comb [ 0 ] , comb [ 1 ] ) <NEWLINE> w = dice2 . lookup_west_side ( comb [ 0 ] , comb [ 1 ] ) <NEWLINE> n = dice2 . lookup_north_side ( comb [ 0 ] , comb [ 1 ] ) <NEWLINE> d = dice2 . lookup_down_side ( comb [ 0 ] , comb [ 1 ] ) <NEWLINE> <NL> if e == spots1 [ 2 ] and w == spots1 [ 3 ] and n == spots1 [ 4 ] and d == spots1 [ 5 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> quit ( ) <NEWLINE> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
import sys <NEWLINE> class Dice : <NEWLINE> <INDENT> def __init__ ( self , f ) : <NEWLINE> <INDENT> self . f = f [ : ] <NEWLINE> <NL> <DEDENT> def to_top ( self , index ) : <NEWLINE> <INDENT> if index == 1 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif index == 2 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif index == 3 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif index == 4 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> elif index == 5 : <NEWLINE> <INDENT> self . roll ( <STRING> ) <NEWLINE> <DEDENT> return self <NEWLINE> <NL> <DEDENT> def side_roll ( self ) : <NEWLINE> <INDENT> t = self . f [ 1 ] <NEWLINE> self . f [ 1 ] = self . f [ 2 ] <NEWLINE> self . f [ 2 ] = self . f [ 4 ] <NEWLINE> self . f [ 4 ] = self . f [ 3 ] <NEWLINE> self . f [ 3 ] = t <NEWLINE> return self <NEWLINE> <NL> <DEDENT> def all_face ( self ) : <NEWLINE> <INDENT> faces = [ ] <NEWLINE> for i in range ( 0 , 6 ) : <NEWLINE> <INDENT> t = Dice ( self . f [ : ] ) <NEWLINE> faces . append ( t . to_top ( i ) . f ) <NEWLINE> for j in range ( 3 ) : <NEWLINE> <INDENT> faces . append ( t . side_roll ( ) . f ) <NEWLINE> <DEDENT> <DEDENT> return faces <NEWLINE> <NL> <DEDENT> <DEDENT> d1 , d2 = ( Dice ( list ( input ( ) . split ( ) ) ) for _ in range ( 2 ) ) <NEWLINE> fs = d1 . all_face ( ) <NEWLINE> print ( <STRING> if d2 . f in fs else <STRING> ) <NEWLINE>
<COMMENT> <NL> <NL> <COMMENT> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . top = 1 <NEWLINE> self . front = 2 <NEWLINE> self . right = 3 <NEWLINE> self . left = 4 <NEWLINE> self . back = 5 <NEWLINE> self . bottom = 6 <NEWLINE> <COMMENT> <NL> <DEDENT> def turnSouth ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . back <NEWLINE> self . back = self . bottom <NEWLINE> self . bottom = self . front <NEWLINE> self . front = temp <NEWLINE> return self <NEWLINE> <COMMENT> <NL> <DEDENT> def turnEast ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . left <NEWLINE> self . left = self . bottom <NEWLINE> self . bottom = self . right <NEWLINE> self . right = temp <NEWLINE> return self <NEWLINE> <COMMENT> <NL> <DEDENT> def turnWest ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . right <NEWLINE> self . right = self . bottom <NEWLINE> self . bottom = self . left <NEWLINE> self . left = temp <NEWLINE> return self <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def turnNorth ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . front <NEWLINE> self . front = self . bottom <NEWLINE> self . bottom = self . back <NEWLINE> self . back = temp <NEWLINE> return self <NEWLINE> <COMMENT> <NL> <DEDENT> def turnRight ( self ) : <NEWLINE> <INDENT> temp = self . front <NEWLINE> self . front = self . right <NEWLINE> self . right = self . back <NEWLINE> self . back = self . left <NEWLINE> self . left = temp <NEWLINE> return self <NEWLINE> <COMMENT> <NL> <DEDENT> def turnLeft ( self ) : <NEWLINE> <INDENT> temp = self . front <NEWLINE> self . front = self . left <NEWLINE> self . left = self . back <NEWLINE> self . back = self . right <NEWLINE> self . right = temp <NEWLINE> return self <NEWLINE> <DEDENT> def equals ( self , Dice ) : <NEWLINE> <INDENT> if ( self . top == Dice . top and self . front == Dice . front and self . bottom == Dice . bottom and <NEWLINE> <INDENT> self . back == Dice . back and self . right == Dice . right and self . left == Dice . left ) : <NEWLINE> return True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> <DEDENT> Dice1 = Dice ( ) <NEWLINE> Dice2 = Dice ( ) <NEWLINE> <COMMENT> <NL> Dice1 . top , Dice1 . front , Dice1 . right , Dice1 . left , Dice1 . back , Dice1 . bottom = int ( input ( ) . split ( ) ) <NEWLINE> Dice2 . top , Dice2 . front , Dice2 . right , Dice2 . left , Dice2 . back , Dice2 . bottom = int ( input ( ) . split ( ) ) <NEWLINE> <NL> <COMMENT> <NL> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> if Dice1 . top == Dice2 . top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Dice2 . turnNorth ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> if Dice1 . top == Dice2 . top : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Dice2 . turnEast ( ) <NEWLINE> <COMMENT> <NL> <DEDENT> for j in range ( 0 , 3 ) : <NEWLINE> <INDENT> if Dice1 . front == Dice2 . front : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> Dice2 . turnRight ( ) <NEWLINE> <DEDENT> if Dice1 . equals ( Dice2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> from random import * <NEWLINE> import copy <NEWLINE> <NL> def command ( hougaku , label ) : <NEWLINE> <INDENT> temp = { } <NEWLINE> temp = copy . deepcopy ( label ) <NEWLINE> if ( hougaku == <STRING> ) : <NEWLINE> <INDENT> label [ 1 ] = temp [ 4 ] <NEWLINE> label [ 3 ] = temp [ 1 ] <NEWLINE> label [ 4 ] = temp [ 6 ] <NEWLINE> label [ 6 ] = temp [ 3 ] <NEWLINE> <DEDENT> elif ( hougaku == <STRING> ) : <NEWLINE> <INDENT> label [ 1 ] = temp [ 3 ] <NEWLINE> label [ 3 ] = temp [ 6 ] <NEWLINE> label [ 4 ] = temp [ 1 ] <NEWLINE> label [ 6 ] = temp [ 4 ] <NEWLINE> <DEDENT> elif ( hougaku == <STRING> ) : <NEWLINE> <INDENT> label [ 1 ] = temp [ 2 ] <NEWLINE> label [ 2 ] = temp [ 6 ] <NEWLINE> label [ 5 ] = temp [ 1 ] <NEWLINE> label [ 6 ] = temp [ 5 ] <NEWLINE> <DEDENT> elif ( hougaku == <STRING> ) : <NEWLINE> <INDENT> label [ 1 ] = temp [ 5 ] <NEWLINE> label [ 2 ] = temp [ 1 ] <NEWLINE> label [ 5 ] = temp [ 6 ] <NEWLINE> label [ 6 ] = temp [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> label = { } <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> label [ i ] = { } <NEWLINE> temp = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> for j in range ( 6 ) : <NEWLINE> <INDENT> label [ i ] [ j + 1 ] = temp [ j ] <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> flag = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <COMMENT> <NL> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> count = 0 <NEWLINE> <COMMENT> <NL> while True : <NEWLINE> <INDENT> if ( label [ i ] == label [ j ] ) : <NEWLINE> <INDENT> flag = 1 <NEWLINE> break <NEWLINE> <DEDENT> x = random ( ) <NEWLINE> if ( x < 0.25 ) : <NEWLINE> <INDENT> command ( <STRING> , label [ j ] ) <NEWLINE> <DEDENT> elif ( x < 0.50 ) : <NEWLINE> <INDENT> command ( <STRING> , label [ j ] ) <NEWLINE> <DEDENT> elif ( x < 0.75 ) : <NEWLINE> <INDENT> command ( <STRING> , label [ j ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> command ( <STRING> , label [ j ] ) <NEWLINE> <DEDENT> count += 1 <NEWLINE> if ( count > 100 ) : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if flag == 1 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if ( flag == 0 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
import random <NEWLINE> <NL> class Dice : <NEWLINE> <INDENT> def __init__ ( self , list = map ( str , range ( 1 , 7 ) ) ) : <NEWLINE> <INDENT> self . top = list [ 0 ] <NEWLINE> self . front = list [ 1 ] <NEWLINE> self . right = list [ 2 ] <NEWLINE> self . left = list [ 3 ] <NEWLINE> self . back = list [ 4 ] <NEWLINE> self . bottom = list [ 5 ] <NEWLINE> <NL> self . dic = { } <NEWLINE> for i in xrange ( 6 ) : <NEWLINE> <INDENT> if list [ i ] in self . dic : <NEWLINE> <INDENT> self . dic [ list [ i ] ] += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . dic [ list [ i ] ] = 1 <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def print_all ( self ) : <NEWLINE> <INDENT> print <STRING> + self . top + <STRING> + self . front + <STRING> + self . right + <STRING> + self . left + <STRING> + self . back + <STRING> + self . bottom <NEWLINE> <NL> <DEDENT> def roll_N ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . front <NEWLINE> self . front = self . bottom <NEWLINE> self . bottom = self . back <NEWLINE> self . back = temp <NEWLINE> <NL> <DEDENT> def roll_S ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . back <NEWLINE> self . back = self . bottom <NEWLINE> self . bottom = self . front <NEWLINE> self . front = temp <NEWLINE> <NL> <DEDENT> def roll_W ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . right <NEWLINE> self . right = self . bottom <NEWLINE> self . bottom = self . left <NEWLINE> self . left = temp <NEWLINE> <NL> <DEDENT> def roll_E ( self ) : <NEWLINE> <INDENT> temp = self . top <NEWLINE> self . top = self . left <NEWLINE> self . left = self . bottom <NEWLINE> self . bottom = self . right <NEWLINE> self . right = temp <NEWLINE> <NL> <DEDENT> def roll_C ( self ) : <NEWLINE> <INDENT> temp = self . front <NEWLINE> self . front = self . right <NEWLINE> self . right = self . back <NEWLINE> self . back = self . left <NEWLINE> self . left = temp <NEWLINE> <NL> <DEDENT> def random_roll ( self ) : <NEWLINE> <INDENT> ram = random . randint ( 1 , 4 ) <NEWLINE> if ram == 1 : <NEWLINE> <INDENT> self . roll_E ( ) <NEWLINE> <DEDENT> elif ram == 2 : <NEWLINE> <INDENT> self . roll_N ( ) <NEWLINE> <DEDENT> elif ram == 3 : <NEWLINE> <INDENT> self . roll_S ( ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> self . roll_W ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> def getDifference ( self , dice ) : <NEWLINE> <INDENT> same_list = [ ] <NEWLINE> different_list = [ ] <NEWLINE> if self . top == dice . top : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . front == dice . front : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . left == dice . left : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . back == dice . back : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . right == dice . right : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <DEDENT> if self . bottom == dice . bottom : <NEWLINE> <INDENT> same_list . append ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> different_list . append ( <STRING> ) <NEWLINE> <NL> <DEDENT> result_list = [ same_list , different_list ] <NEWLINE> return result_list <NEWLINE> <NL> <DEDENT> def getList ( self ) : <NEWLINE> <INDENT> list = [ self . top , self . front , self . right , self . left , self . back , self . bottom ] <NEWLINE> return list <NEWLINE> <NL> <DEDENT> <DEDENT> def print_dices ( ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> first_dice . print_all ( ) <NEWLINE> print <STRING> <NEWLINE> second_dice . print_all ( ) <NEWLINE> print first_dice . dic <NEWLINE> <NL> <DEDENT> line = <STRING> <NEWLINE> <NL> <NL> def judgeDices ( first_dice , second_dice ) : <NEWLINE> <INDENT> flag = False <NEWLINE> num = 0 <NEWLINE> debug = 0 <NEWLINE> while num < 4 : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <INDENT> dic1_keys = first_dice . dic . keys ( ) <NEWLINE> for i in xrange ( len ( dic1_keys ) ) : <NEWLINE> <INDENT> if first_dice . dic [ dic1_keys [ i ] ] != second_dice . dic [ dic1_keys [ i ] ] : <NEWLINE> <INDENT> num = 4 <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in xrange ( len ( dic1_keys ) ) : <NEWLINE> <INDENT> if first_dice . dic [ dic1_keys [ i ] ] == 6 or first_dice . dic [ dic1_keys [ i ] ] == 5 : <NEWLINE> <INDENT> num = 4 <NEWLINE> flag = True <NEWLINE> break <NEWLINE> <NL> <COMMENT> <NL> <NL> <DEDENT> <DEDENT> diferece = first_dice . getDifference ( second_dice ) <NEWLINE> <COMMENT> <NL> <NL> same_num = len ( diferece [ 0 ] ) <NEWLINE> if same_num == 6 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> elif same_num == 5 : <NEWLINE> <INDENT> num = 4 <NEWLINE> break <NEWLINE> <NL> <DEDENT> if <STRING> in diferece [ 0 ] or <STRING> in diferece [ 0 ] : <NEWLINE> <INDENT> first_dice . roll_W ( ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> elif <STRING> in diferece [ 0 ] or <STRING> in diferece [ 0 ] : <NEWLINE> <INDENT> first_dice . roll_S ( ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> elif <STRING> in diferece [ 0 ] or <STRING> in diferece [ 0 ] : <NEWLINE> <INDENT> first_dice . roll_C ( ) <NEWLINE> num += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> first_dice . random_roll ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> if flag == True : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> elif num == 4 : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> dices = [ ] <NEWLINE> for i in xrange ( n ) : <NEWLINE> <INDENT> dices . append ( Dice ( raw_input ( ) . split ( <STRING> ) ) ) <NEWLINE> <DEDENT> result = False <NEWLINE> for i in xrange ( n - 1 ) : <NEWLINE> <INDENT> for j in xrange ( i + 1 , n ) : <NEWLINE> <INDENT> first_dice = dices [ i ] <NEWLINE> second_dice = dices [ j ] <NEWLINE> result = judgeDices ( first_dice , second_dice ) <NEWLINE> <COMMENT> <NL> if result : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> <DEDENT> if result : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> if result : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<NL> ans = chk = 0 <NEWLINE> a = [ 0 , 2 , 5 , 3 ] <NEWLINE> b = [ 0 , 1 , 5 , 4 ] <NEWLINE> c = [ 1 , 2 , 4 , 3 ] <NEWLINE> <NL> def sortdice ( dice1 , dice2 , p , q , r ) : <NEWLINE> <INDENT> for i in range ( 4 ) : <NEWLINE> <INDENT> dice1 [ p [ 0 ] ] , dice1 [ p [ 1 ] ] , dice1 [ p [ 2 ] ] , dice1 [ p [ 3 ] ] = dice1 [ p [ 1 ] ] , dice1 [ p [ 2 ] ] , dice1 [ p [ 3 ] ] , dice1 [ p [ 0 ] ] <NEWLINE> for j in range ( 4 ) : <NEWLINE> <INDENT> dice1 [ q [ 0 ] ] , dice1 [ q [ 1 ] ] , dice1 [ q [ 2 ] ] , dice1 [ q [ 3 ] ] = dice1 [ q [ 1 ] ] , dice1 [ q [ 2 ] ] , dice1 [ q [ 3 ] ] , dice1 [ q [ 0 ] ] <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> dice1 [ r [ 0 ] ] , dice1 [ r [ 1 ] ] , dice1 [ r [ 2 ] ] , dice1 [ r [ 3 ] ] = dice1 [ r [ 1 ] ] , dice1 [ r [ 2 ] ] , dice1 [ r [ 3 ] ] , dice1 [ r [ 0 ] ] <NEWLINE> if dice1 == dice2 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return 0 <NEWLINE> <NL> <DEDENT> l1 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> l2 = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> sortdice ( l1 , l2 , a , b , c ) <NEWLINE> print <STRING> <NEWLINE> <NL>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , a1 , a2 , a3 , a4 , a5 , a6 ) : <NEWLINE> <COMMENT> <NL> <INDENT> self . face = [ a1 , a2 , a3 , a4 , a5 , a6 ] <NEWLINE> self . v = [ a5 , a1 , a2 , a6 ] <COMMENT> <NEWLINE> self . h = [ a4 , a1 , a3 , a6 ] <COMMENT> <NEWLINE> self . det = 1 <NEWLINE> <COMMENT> <NL> <NL> <COMMENT> <NL> <DEDENT> def top ( self ) : <NEWLINE> <INDENT> return self . v [ 1 ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def north ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 1 ] , self . v [ 2 ] , self . v [ 3 ] , self . v [ 0 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def south ( self ) : <NEWLINE> <INDENT> newV = [ self . v [ 3 ] , self . v [ 0 ] , self . v [ 1 ] , self . v [ 2 ] ] <NEWLINE> self . v = newV <NEWLINE> self . h [ 1 ] = self . v [ 1 ] <NEWLINE> self . h [ 3 ] = self . v [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def east ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 3 ] , self . h [ 0 ] , self . h [ 1 ] , self . h [ 2 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> def west ( self ) : <NEWLINE> <INDENT> newH = [ self . h [ 1 ] , self . h [ 2 ] , self . h [ 3 ] , self . h [ 0 ] ] <NEWLINE> self . h = newH <NEWLINE> self . v [ 1 ] = self . h [ 1 ] <NEWLINE> self . v [ 3 ] = self . h [ 3 ] <NEWLINE> return self . v , self . h <NEWLINE> <NL> <DEDENT> <DEDENT> diceAmount = int ( input ( ) ) <NEWLINE> dices = [ ] <NEWLINE> for i in range ( diceAmount ) : <NEWLINE> <INDENT> d = [ int ( j ) for j in input ( ) . rstrip ( ) . split ( ) ] <NEWLINE> dice = Dice ( d [ 0 ] , d [ 1 ] , d [ 2 ] , d [ 3 ] , d [ 4 ] , d [ 5 ] ) <NEWLINE> dices . append ( dice ) <NEWLINE> <DEDENT> Dice IV <NEWLINE> import random <NEWLINE> match = 0 <NEWLINE> diceCount = 1 <NEWLINE> while match == 0 and diceCount < diceAmount : <NEWLINE> <INDENT> for d2 in range ( 1 , diceAmount ) : <NEWLINE> <COMMENT> <NL> <INDENT> i = 0 <NEWLINE> while match == 0 and i < 24 : <NEWLINE> <INDENT> j = random . randint ( 0 , 3 ) <NEWLINE> if j == 0 : <NEWLINE> <INDENT> dices [ d2 ] . north ( ) <NEWLINE> <DEDENT> elif j == 1 : <NEWLINE> <INDENT> dices [ d2 ] . south ( ) <NEWLINE> <DEDENT> elif j == 2 : <NEWLINE> <INDENT> dices [ d2 ] . east ( ) <NEWLINE> <DEDENT> elif j == 3 : <NEWLINE> <INDENT> dices [ d2 ] . west ( ) <NEWLINE> <DEDENT> for d1 in range ( d2 ) : <NEWLINE> <INDENT> if ( dices [ d1 ] . v == dices [ d2 ] . v and dices [ d1 ] . h == dices [ d2 ] . h ) : <NEWLINE> <INDENT> match += 1 <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> i += 1 <NEWLINE> <DEDENT> <DEDENT> diceCount += 1 <NEWLINE> <DEDENT> if match >= 1 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , men ) : <NEWLINE> <INDENT> self . men = men <NEWLINE> <NL> <DEDENT> def throw ( self , direction ) : <NEWLINE> <INDENT> if direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 3 ] <NEWLINE> men [ 1 ] = pmen [ 1 ] <NEWLINE> men [ 2 ] = pmen [ 0 ] <NEWLINE> men [ 3 ] = pmen [ 5 ] <NEWLINE> men [ 4 ] = pmen [ 4 ] <NEWLINE> men [ 5 ] = pmen [ 2 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 2 ] <NEWLINE> men [ 1 ] = pmen [ 1 ] <NEWLINE> men [ 2 ] = pmen [ 5 ] <NEWLINE> men [ 3 ] = pmen [ 0 ] <NEWLINE> men [ 4 ] = pmen [ 4 ] <NEWLINE> men [ 5 ] = pmen [ 3 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 4 ] <NEWLINE> men [ 1 ] = pmen [ 0 ] <NEWLINE> men [ 2 ] = pmen [ 2 ] <NEWLINE> men [ 3 ] = pmen [ 3 ] <NEWLINE> men [ 4 ] = pmen [ 5 ] <NEWLINE> men [ 5 ] = pmen [ 1 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 1 ] <NEWLINE> men [ 1 ] = pmen [ 5 ] <NEWLINE> men [ 2 ] = pmen [ 2 ] <NEWLINE> men [ 3 ] = pmen [ 3 ] <NEWLINE> men [ 4 ] = pmen [ 0 ] <NEWLINE> men [ 5 ] = pmen [ 4 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 0 ] <NEWLINE> men [ 1 ] = pmen [ 2 ] <NEWLINE> men [ 2 ] = pmen [ 4 ] <NEWLINE> men [ 3 ] = pmen [ 1 ] <NEWLINE> men [ 4 ] = pmen [ 3 ] <NEWLINE> men [ 5 ] = pmen [ 5 ] <NEWLINE> <DEDENT> elif direction == <STRING> : <NEWLINE> <INDENT> pmen = men [ : ] <NEWLINE> men [ 0 ] = pmen [ 0 ] <NEWLINE> men [ 1 ] = pmen [ 3 ] <NEWLINE> men [ 2 ] = pmen [ 1 ] <NEWLINE> men [ 3 ] = pmen [ 4 ] <NEWLINE> men [ 4 ] = pmen [ 2 ] <NEWLINE> men [ 5 ] = pmen [ 5 ] <NEWLINE> <NL> <DEDENT> <DEDENT> def makeUe ( self , ue ) : <NEWLINE> <INDENT> if ( self . men [ 2 ] == ue or self . men [ 3 ] == ue ) : <NEWLINE> <INDENT> self . throw ( <STRING> ) <NEWLINE> <NL> <DEDENT> while ( self . men [ 0 ] != ue ) : <NEWLINE> <INDENT> self . throw ( <STRING> ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> n = int ( raw_input ( ) ) <NEWLINE> anti2 = [ ] <NEWLINE> antiNot2 = [ ] <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> men = map ( int , ( raw_input ( ) ) . split ( <STRING> ) ) <NEWLINE> d = Dice ( men ) <NEWLINE> d . makeUe ( 1 ) <NEWLINE> if d . men [ 5 ] == 2 : <NEWLINE> <INDENT> while ( d . men [ 1 ] != 3 ) : <NEWLINE> <INDENT> d . throw ( <STRING> ) <NEWLINE> <DEDENT> S = d . men [ 2 : 5 ] <NEWLINE> anti2 . append ( S ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> while ( d . men [ 1 ] != 2 ) : <NEWLINE> <INDENT> d . throw ( <STRING> ) <NEWLINE> <DEDENT> S = d . men [ 2 : 6 ] <NEWLINE> antiNot2 . append ( S ) <NEWLINE> <NL> <DEDENT> <DEDENT> flag = False <NEWLINE> for i in range ( len ( anti2 ) - 1 ) : <NEWLINE> <INDENT> if anti2 [ i ] == anti2 [ i + 1 ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( antiNot2 ) - 1 ) : <NEWLINE> <INDENT> if antiNot2 [ i ] == antiNot2 [ i + 1 ] : <NEWLINE> <INDENT> flag = True <NEWLINE> <NL> <DEDENT> <DEDENT> if flag : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
def g ( ) : <NEWLINE> <INDENT> from itertools import * <NEWLINE> n = int ( input ( ) ) <NEWLINE> a = [ input ( ) . split ( ) for _ in [ 0 ] * n ] <NEWLINE> for b in a : <NEWLINE> <INDENT> b [ 3 : 5 ] = b [ 4 ] , b [ 3 ] <NEWLINE> <DEDENT> for d , e in combinations ( a , 2 ) : <NEWLINE> <INDENT> for p in ( [ 0 , 1 , 2 , 3 , 4 , 5 ] , [ 1 , 5 , 2 , 0 , 4 , 3 ] , [ 2 , 1 , 5 , 3 , 0 , 4 ] , [ 3 , 0 , 2 , 5 , 4 , 1 ] , [ 4 , 1 , 0 , 3 , 5 , 2 ] , [ 5 , 1 , 4 , 3 , 2 , 0 ] ) : <NEWLINE> <INDENT> f = [ d [ i ] for i in p ] <NEWLINE> if f [ 0 ] == e [ 0 ] and f [ 5 ] == e [ 5 ] : <NEWLINE> <INDENT> f = f [ 1 : 5 ] * 2 <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> if f [ k : k + 4 ] == e [ 1 : 5 ] : return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT> print ( g ( ) ) <NEWLINE>
<COMMENT> <NL> from itertools import combinations <NEWLINE> <NL> <NL> class Dice ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , list_ ) : <NEWLINE> <INDENT> self . label = list_ <NEWLINE> <NL> <DEDENT> def getLabel ( self , i ) : <NEWLINE> <INDENT> return self . label [ i - 1 ] <NEWLINE> <NL> <DEDENT> def _rotateS ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 5 , 1 , 3 , 4 , 6 , 2 ] ] <NEWLINE> <NL> <DEDENT> def _rotateN ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 2 , 6 , 3 , 4 , 1 , 5 ] ] <NEWLINE> <NL> <DEDENT> def _rotateE ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 4 , 2 , 1 , 6 , 5 , 3 ] ] <NEWLINE> <NL> <DEDENT> def _rotateW ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 3 , 2 , 6 , 1 , 5 , 4 ] ] <NEWLINE> <NL> <DEDENT> def _spinPos ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 1 , 4 , 2 , 5 , 3 , 6 ] ] <NEWLINE> <NL> <DEDENT> def _spinNeg ( self ) : <NEWLINE> <INDENT> self . label = [ self . getLabel ( i ) for i in [ 1 , 3 , 5 , 2 , 4 , 6 ] ] <NEWLINE> <NL> <DEDENT> def rotate ( self , rotates ) : <NEWLINE> <INDENT> for r in rotates : <NEWLINE> <INDENT> if r == <STRING> : <NEWLINE> <INDENT> self . _rotateS ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateN ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateE ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _rotateW ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _spinPos ( ) <NEWLINE> <DEDENT> elif r == <STRING> : <NEWLINE> <INDENT> self . _spinNeg ( ) <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> def matchTopFront ( self , top , front ) : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> iTop = self . label . index ( top ) + 1 <NEWLINE> topRot = { 1 : <STRING> , 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> , 6 : <STRING> } <NEWLINE> self . rotate ( topRot [ iTop ] ) <NEWLINE> <NL> iFront = self . label . index ( front ) + 1 <NEWLINE> frontRot = { 2 : <STRING> , 3 : <STRING> , 4 : <STRING> , 5 : <STRING> } <NEWLINE> self . rotate ( frontRot [ iFront ] ) <NEWLINE> return True <NEWLINE> <DEDENT> except KeyError : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def copy ( self ) : <NEWLINE> <INDENT> return Dice ( self . label [ : ] ) <NEWLINE> <NL> <DEDENT> def _equalWithOverlap ( self , other ) : <NEWLINE> <COMMENT> <NL> <INDENT> for rs in [ <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ] : <NEWLINE> <INDENT> tmp = self . copy ( ) <NEWLINE> for r in rs : <NEWLINE> <INDENT> tmp . rotate ( r ) <NEWLINE> <COMMENT> <NL> <DEDENT> top = tmp . getLabel ( 1 ) == other . getLabel ( 1 ) <NEWLINE> bottom = tmp . getLabel ( 6 ) == other . getLabel ( 6 ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> def _side ( ) : <NEWLINE> <INDENT> result , n = False , 3 <NEWLINE> while not result and n > 0 : <NEWLINE> <INDENT> if tmp . label [ 1 : 5 ] == other . label [ 1 : 5 ] : <NEWLINE> <INDENT> result = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp . rotate ( <STRING> ) <NEWLINE> n -= 1 <NEWLINE> <DEDENT> <DEDENT> return result <NEWLINE> <NL> <DEDENT> if top and bottom and _side ( ) : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <NL> <DEDENT> <DEDENT> def __eq__ ( self , other ) : <NEWLINE> <COMMENT> <NL> <INDENT> if set ( self . label ) != set ( other . label ) : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <DEDENT> elif len ( self . label ) == len ( set ( self . label ) ) : <NEWLINE> <INDENT> if other . matchTopFront ( self . getLabel ( 1 ) , self . getLabel ( 2 ) ) : <NEWLINE> <INDENT> return True if self . label == other . label else False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return False <NEWLINE> <COMMENT> <NL> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> d1 = Dice ( face1 ) <NEWLINE> d2 = Dice ( face2 ) <NEWLINE> return True if d1 . _equalWithOverlap ( d2 ) else False <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = input ( ) <NEWLINE> faces = [ map ( int , raw_input ( ) . split ( ) ) for _ in xrange ( n ) ] <NEWLINE> for f1 , f2 in combinations ( faces , 2 ) : <NEWLINE> <INDENT> if f1 == f2 or Dice ( f1 ) == Dice ( f2 ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
class Dice ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , d ) : <NEWLINE> <NL> <INDENT> self . rows = [ d [ 0 ] , d [ 4 ] , d [ 5 ] , d [ 1 ] ] <NEWLINE> self . cols = [ d [ 0 ] , d [ 2 ] , d [ 5 ] , d [ 3 ] ] <NEWLINE> <NL> <DEDENT> def move_next_rows ( self ) : <NEWLINE> <INDENT> temp = self . rows . pop ( 0 ) <NEWLINE> self . rows . append ( temp ) <NEWLINE> self . __update ( self . cols , self . rows ) <NEWLINE> <NL> <DEDENT> def move_prev_rows ( self ) : <NEWLINE> <INDENT> temp = self . rows . pop ( 3 ) <NEWLINE> self . rows . insert ( 0 , temp ) <NEWLINE> self . __update ( self . cols , self . rows ) <NEWLINE> <NL> <DEDENT> def move_next_cols ( self ) : <NEWLINE> <INDENT> temp = self . cols . pop ( 0 ) <NEWLINE> self . cols . append ( temp ) <NEWLINE> self . __update ( self . rows , self . cols ) <NEWLINE> <NL> <DEDENT> def move_prev_cols ( self ) : <NEWLINE> <INDENT> temp = self . cols . pop ( 3 ) <NEWLINE> self . cols . insert ( 0 , temp ) <NEWLINE> self . __update ( self . rows , self . cols ) <NEWLINE> <NL> <DEDENT> def __update ( self , x , y ) : <NEWLINE> <INDENT> x [ 0 ] = y [ 0 ] <NEWLINE> x [ 2 ] = y [ 2 ] <NEWLINE> <NL> <DEDENT> <DEDENT> class DiceChecker ( object ) : <NEWLINE> <NL> <INDENT> def __init__ ( self , dice1 , dice2 ) : <NEWLINE> <INDENT> self . dice1 = dice1 <NEWLINE> self . dice2 = dice2 <NEWLINE> self . dice1_top = self . dice1 . rows [ 0 ] <NEWLINE> self . dice1_front = self . dice1 . rows [ 3 ] <NEWLINE> <NL> <DEDENT> def check_same_dice ( self ) : <NEWLINE> <NL> <INDENT> is_same = False <NEWLINE> for _ in range ( 4 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> for _ in range ( 4 ) : <NEWLINE> <INDENT> is_same_element = self . dice1 . rows == self . dice2 . rows and self . dice1 . cols == self . dice2 . cols <NEWLINE> if is_same_element : <NEWLINE> <INDENT> is_same = True <NEWLINE> <DEDENT> self . __rot ( self . dice2 ) <NEWLINE> <DEDENT> self . dice2 . move_next_rows ( ) <NEWLINE> <DEDENT> self . dice2 . move_next_cols ( ) <NEWLINE> <NL> <DEDENT> if is_same : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> def __rot ( self , dice ) : <NEWLINE> <INDENT> temp = dice . rows [ 1 ] <NEWLINE> dice . rows [ 1 ] = dice . cols [ 3 ] <NEWLINE> dice . cols [ 3 ] = dice . rows [ 3 ] <NEWLINE> dice . rows [ 3 ] = dice . cols [ 1 ] <NEWLINE> dice . cols [ 1 ] = temp <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> j = int ( input ( ) ) <NEWLINE> dice_list = [ ] <NEWLINE> src = [ ] <NEWLINE> for _ in range ( j ) : <NEWLINE> <INDENT> d = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> dice_list . append ( Dice ( d ) ) <NEWLINE> src . append ( Dice ( d ) <NEWLINE> <NL> <DEDENT> is_diff = False <NEWLINE> for dice1 in dice_list : <NEWLINE> <INDENT> src . pop ( 0 ) <NEWLINE> for dice in src : <NEWLINE> <INDENT> dice_checker = DiceChecker ( dice1 , dice ) <NEWLINE> if ( dice_checker . check_same_dice ( ) ) : <NEWLINE> <INDENT> is_diff = True <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if is_diff : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <STRING> <NEWLINE> <NL> class Dice : <NEWLINE> <INDENT> T = 0 <NEWLINE> S = 1 <NEWLINE> E = 2 <NEWLINE> W = 3 <NEWLINE> N = 4 <NEWLINE> B = 5 <NEWLINE> <NL> <STRING> <NEWLINE> def __init__ ( self ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . side = [ 1 , 2 , 3 , 4 , 5 , 6 ] <NEWLINE> self . top = 0 <NEWLINE> <NL> <DEDENT> def setDice ( self , arr ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> self . side = arr [ 0 : 6 ] <NEWLINE> <NL> <DEDENT> def Turn ( self , dir ) : <NEWLINE> <INDENT> <STRING> <NEWLINE> s = self . side <NEWLINE> <NL> if dir == <STRING> : <COMMENT> <NEWLINE> <COMMENT> <NL> <INDENT> t = [ s [ Dice . S ] , s [ Dice . B ] , s [ Dice . E ] , s [ Dice . W ] , s [ Dice . T ] , s [ Dice . N ] ] <NEWLINE> <DEDENT> elif dir == <STRING> : <COMMENT> <NEWLINE> <INDENT> t = [ s [ Dice . N ] , s [ Dice . T ] , s [ Dice . E ] , s [ Dice . W ] , s [ Dice . B ] , s [ Dice . S ] ] <NEWLINE> <DEDENT> elif dir == <STRING> : <COMMENT> <NEWLINE> <INDENT> t = [ s [ Dice . W ] , s [ Dice . S ] , s [ Dice . T ] , s [ Dice . B ] , s [ Dice . N ] , s [ Dice . E ] ] <NEWLINE> <DEDENT> elif dir == <STRING> : <COMMENT> <NEWLINE> <INDENT> t = [ s [ Dice . E ] , s [ Dice . S ] , s [ Dice . B ] , s [ Dice . T ] , s [ Dice . N ] , s [ Dice . W ] ] <NEWLINE> <DEDENT> elif dir == <STRING> : <COMMENT> <NEWLINE> <INDENT> t = [ s [ Dice . T ] , s [ Dice . W ] , s [ Dice . S ] , s [ Dice . N ] , s [ Dice . E ] , s [ Dice . B ] ] <NEWLINE> <DEDENT> elif dir == <STRING> : <COMMENT> <NEWLINE> <INDENT> t = [ s [ Dice . T ] , s [ Dice . E ] , s [ Dice . N ] , s [ Dice . S ] , s [ Dice . W ] , s [ Dice . B ] ] <NEWLINE> <NL> <DEDENT> self . side = t <NEWLINE> <COMMENT> <NL> <NL> <DEDENT> def Search ( self , tval , sval , dir ) : <NEWLINE> <STRING> <NEWLINE> <NL> <COMMENT> <NL> <NL> <INDENT> if self . side [ Dice . E ] == tval : <NEWLINE> <INDENT> self . Turn ( <STRING> ) <NEWLINE> <DEDENT> elif self . side [ Dice . W ] == tval : <NEWLINE> <INDENT> self . Turn ( <STRING> ) <NEWLINE> <DEDENT> elif self . side [ Dice . N ] == tval : <NEWLINE> <INDENT> self . Turn ( <STRING> ) <NEWLINE> <DEDENT> elif self . side [ Dice . S ] == tval : <NEWLINE> <INDENT> self . Turn ( <STRING> ) <NEWLINE> <DEDENT> elif self . side [ Dice . B ] == tval : <NEWLINE> <INDENT> self . Turn ( <STRING> ) <NEWLINE> self . Turn ( <STRING> ) <NEWLINE> <NL> <DEDENT> for i in range ( 3 ) : <COMMENT> <NEWLINE> <INDENT> if self . side [ Dice . S ] == sval : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> self . Turn ( <STRING> ) <NEWLINE> <NL> <DEDENT> return self . side [ dir ] <NEWLINE> <NL> <COMMENT> <NL> <DEDENT> <DEDENT> d = [ ] <NEWLINE> num = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> for i in range ( num ) : <COMMENT> <NEWLINE> <INDENT> tmp = Dice ( ) <NEWLINE> tmp . setDice ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) ) <NEWLINE> d . append ( tmp ) <NEWLINE> <NL> <DEDENT> ret = <STRING> <NEWLINE> <NL> for i in range ( num - 1 ) : <NEWLINE> <INDENT> for j in range ( i + 1 , num ) : <NEWLINE> <INDENT> v1 = d [ i ] . Search ( d [ i ] . side [ Dice . T ] , d [ i ] . side [ Dice . S ] , Dice . E ) <NEWLINE> v2 = d [ j ] . Search ( d [ i ] . side [ Dice . T ] , d [ i ] . side [ Dice . S ] , Dice . E ) <NEWLINE> <COMMENT> <NL> if v1 == v2 : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if ret == <STRING> : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( ret ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> n = input ( ) <NEWLINE> rolls = [ ] <NEWLINE> for x in xrange ( n ) : <NEWLINE> <INDENT> rolls . append ( raw_input ( ) . split ( ) ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> for l1 in xrange ( n ) : <NEWLINE> <INDENT> for l2 in xrange ( n ) : <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <INDENT> if l1 == l2 : <NEWLINE> <INDENT> break <NEWLINE> <DEDENT> rolls_copy = rolls <NEWLINE> testpare = ( rolls_copy [ l1 ] [ 0 ] , rolls_copy [ l1 ] [ 5 ] ) <NEWLINE> testparerev = ( rolls_copy [ l1 ] [ 5 ] , rolls_copy [ l1 ] [ 0 ] ) <NEWLINE> rolls2pare = [ ( rolls_copy [ l2 ] [ 0 ] , rolls_copy [ l2 ] [ 5 ] ) , ( rolls_copy [ l2 ] [ 2 ] , rolls_copy [ l2 ] [ 3 ] ) , ( rolls_copy [ l2 ] [ 1 ] , rolls_copy [ l2 ] [ 4 ] ) ] <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> if testpare in rolls2pare : <NEWLINE> <INDENT> pareps = rolls2pare . index ( testpare ) <NEWLINE> revflag = False <NEWLINE> <DEDENT> elif testparerev in rolls2pare : <NEWLINE> <INDENT> pareps = rolls2pare . index ( testparerev ) <NEWLINE> revflag = True <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> li1 = [ rolls_copy [ l1 ] [ 1 ] , rolls_copy [ l1 ] [ 2 ] , rolls_copy [ l1 ] [ 4 ] , rolls_copy [ l1 ] [ 3 ] ] <NEWLINE> <COMMENT> <NL> if pareps == 0 : <NEWLINE> <INDENT> if revflag : <NEWLINE> <INDENT> tmp = rolls_copy [ l2 ] [ 2 ] <NEWLINE> rolls_copy [ l2 ] [ 2 ] = rolls_copy [ l2 ] [ 3 ] <NEWLINE> rolls_copy [ l2 ] [ 3 ] = tmp <NEWLINE> <DEDENT> li2 = [ rolls_copy [ l2 ] [ 1 ] , rolls_copy [ l2 ] [ 2 ] , rolls_copy [ l2 ] [ 4 ] , rolls_copy [ l2 ] [ 3 ] ] <NEWLINE> <DEDENT> elif pareps == 1 : <NEWLINE> <INDENT> if revflag : <NEWLINE> <INDENT> tmp = rolls_copy [ l2 ] [ 1 ] <NEWLINE> rolls_copy [ l2 ] [ 1 ] = rolls_copy [ l2 ] [ 4 ] <NEWLINE> rolls_copy [ l2 ] [ 4 ] = tmp <NEWLINE> <DEDENT> li2 = [ rolls_copy [ l2 ] [ 0 ] , rolls_copy [ l2 ] [ 1 ] , rolls_copy [ l2 ] [ 5 ] , rolls_copy [ l2 ] [ 4 ] ] <NEWLINE> <DEDENT> elif pareps == 2 : <NEWLINE> <INDENT> if revflag : <NEWLINE> <INDENT> tmp = rolls_copy [ l2 ] [ 0 ] <NEWLINE> rolls_copy [ l2 ] [ 0 ] = rolls_copy [ l2 ] [ 5 ] <NEWLINE> rolls_copy [ l2 ] [ 5 ] = tmp <NEWLINE> <DEDENT> li2 = [ rolls_copy [ l2 ] [ 0 ] , rolls_copy [ l2 ] [ 3 ] , rolls_copy [ l2 ] [ 5 ] , rolls_copy [ l2 ] [ 2 ] ] <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> break <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <DEDENT> i = 0 <NEWLINE> j = li2 . index ( li1 [ 0 ] ) <NEWLINE> matchflag = True <COMMENT> <NEWLINE> for x in xrange ( 4 ) : <NEWLINE> <COMMENT> <NL> <INDENT> if li1 [ i ] == li2 [ j ] : <NEWLINE> <INDENT> j += 1 <NEWLINE> i += 1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> matchflag = False <NEWLINE> break <NEWLINE> <DEDENT> if i > 3 : <NEWLINE> <INDENT> i = 0 <NEWLINE> <DEDENT> if j > 3 : <NEWLINE> <INDENT> j = 0 <NEWLINE> <DEDENT> <DEDENT> if matchflag : <NEWLINE> <INDENT> print <STRING> <NEWLINE> sys . exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print <STRING> <NEWLINE>
class Dice ( ) : <NEWLINE> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . number = [ _ for _ in range ( 6 ) ] <NEWLINE> self . work = [ _ for _ in range ( 6 ) ] <NEWLINE> self . order = <STRING> <NEWLINE> <DEDENT> def setNumber ( self , n0 , n1 , n2 , n3 , n4 , n5 ) : <NEWLINE> <INDENT> self . number [ 0 ] = n0 <NEWLINE> self . number [ 1 ] = n1 <NEWLINE> self . number [ 2 ] = n2 <NEWLINE> self . number [ 3 ] = n3 <NEWLINE> self . number [ 4 ] = n4 <NEWLINE> self . number [ 5 ] = n5 <NEWLINE> <NL> <DEDENT> def roll ( self , loc ) : <NEWLINE> <INDENT> for _ in range ( 6 ) : <NEWLINE> <INDENT> self . work [ _ ] = self . number [ _ ] <NEWLINE> <DEDENT> if loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 3 ] , self . work [ 1 ] , self . work [ 0 ] , self . work [ 5 ] , self . work [ 4 ] , self . work [ 2 ] ) <NEWLINE> <DEDENT> elif loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 1 ] , self . work [ 5 ] , self . work [ 2 ] , self . work [ 3 ] , self . work [ 0 ] , self . work [ 4 ] ) <NEWLINE> <DEDENT> elif loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 4 ] , self . work [ 0 ] , self . work [ 2 ] , self . work [ 3 ] , self . work [ 5 ] , self . work [ 1 ] ) <NEWLINE> <DEDENT> elif loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 2 ] , self . work [ 1 ] , self . work [ 5 ] , self . work [ 0 ] , self . work [ 4 ] , self . work [ 3 ] ) <NEWLINE> <DEDENT> <DEDENT> def get_top ( self ) : <NEWLINE> <INDENT> return self . number [ 0 ] <NEWLINE> <DEDENT> def get_right ( self , n1 , n2 ) : <NEWLINE> <INDENT> if ( n1 == self . number [ 0 ] ) : <NEWLINE> <INDENT> if ( n2 == self . number [ 1 ] ) : return ( self . number [ 2 ] ) <NEWLINE> elif ( n2 == self . number [ 2 ] ) : return ( self . number [ 4 ] ) <NEWLINE> elif ( n2 == self . number [ 3 ] ) : return ( self . number [ 1 ] ) <NEWLINE> elif ( n2 == self . number [ 4 ] ) : return ( self . number [ 3 ] ) <NEWLINE> <DEDENT> elif ( n1 == self . number [ 1 ] ) : <NEWLINE> <INDENT> if ( n2 == self . number [ 0 ] ) : return ( self . number [ 3 ] ) <NEWLINE> elif ( n2 == self . number [ 2 ] ) : return ( self . number [ 0 ] ) <NEWLINE> elif ( n2 == self . number [ 3 ] ) : return ( self . number [ 5 ] ) <NEWLINE> elif ( n2 == self . number [ 5 ] ) : return ( self . number [ 2 ] ) <NEWLINE> <DEDENT> elif ( n1 == self . number [ 2 ] ) : <NEWLINE> <INDENT> if ( n2 == self . number [ 0 ] ) : return ( self . number [ 1 ] ) <NEWLINE> elif ( n2 == self . number [ 1 ] ) : return ( self . number [ 5 ] ) <NEWLINE> elif ( n2 == self . number [ 4 ] ) : return ( self . number [ 0 ] ) <NEWLINE> elif ( n2 == self . number [ 5 ] ) : return ( self . number [ 4 ] ) <NEWLINE> <DEDENT> elif ( n1 == self . number [ 3 ] ) : <NEWLINE> <INDENT> if ( n2 == self . number [ 0 ] ) : return ( self . number [ 4 ] ) <NEWLINE> elif ( n2 == self . number [ 1 ] ) : return ( self . number [ 0 ] ) <NEWLINE> elif ( n2 == self . number [ 4 ] ) : return ( self . number [ 5 ] ) <NEWLINE> elif ( n2 == self . number [ 5 ] ) : return ( self . number [ 1 ] ) <NEWLINE> <DEDENT> elif ( n1 == self . number [ 4 ] ) : <NEWLINE> <INDENT> if ( n2 == self . number [ 0 ] ) : return ( self . number [ 2 ] ) <NEWLINE> elif ( n2 == self . number [ 2 ] ) : return ( self . number [ 5 ] ) <NEWLINE> elif ( n2 == self . number [ 3 ] ) : return ( self . number [ 0 ] ) <NEWLINE> elif ( n2 == self . number [ 5 ] ) : return ( self . number [ 3 ] ) <NEWLINE> <DEDENT> elif ( n1 == self . number [ 5 ] ) : <NEWLINE> <INDENT> if ( n2 == self . number [ 1 ] ) : return ( self . number [ 3 ] ) <NEWLINE> elif ( n2 == self . number [ 2 ] ) : return ( self . number [ 1 ] ) <NEWLINE> elif ( n2 == self . number [ 3 ] ) : return ( self . number [ 4 ] ) <NEWLINE> elif ( n2 == self . number [ 4 ] ) : return ( self . number [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def equals ( self , another ) : <NEWLINE> <INDENT> ret = False <NEWLINE> for i in range ( len ( self . order ) ) : <NEWLINE> <INDENT> self . roll ( self . order [ i ] ) <NEWLINE> flg = True <NEWLINE> for k in range ( 6 ) : <NEWLINE> <INDENT> if self . number [ k ] != another . number [ k ] : <NEWLINE> <INDENT> flg = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if flg == True : <NEWLINE> <INDENT> return True <NEWLINE> <DEDENT> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> dice = [ ] <NEWLINE> for _ in range ( n ) : <NEWLINE> <INDENT> data = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice . append ( Dice ( ) ) <NEWLINE> dice [ _ ] . setNumber ( data [ 0 ] , data [ 1 ] , data [ 2 ] , data [ 3 ] , data [ 4 ] , data [ 5 ] ) <NEWLINE> <NL> <DEDENT> flag = True <NEWLINE> for _ in range ( n - 1 ) : <NEWLINE> <INDENT> for i in range ( i + 1 , n ) : <NEWLINE> <INDENT> if ( dice [ _ ] . equals ( dice [ i ] ) ) : <NEWLINE> <INDENT> flag = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> if flag else <STRING> ) <NEWLINE> <NL>
n = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for k in range ( n ) : <NEWLINE> b = a [ k ] ; b [ 3 ] , b [ 4 ] = b [ 4 ] , b [ 3 ] <NEWLINE> def f ( ) : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d = a [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> e = a [ j ] <NEWLINE> for p in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> f = [ d [ int ( k ) ] for k in p ] <NEWLINE> if f [ 0 ] == e [ 0 ] and f [ 5 ] == e [ 5 ] : <NEWLINE> <INDENT> f = f [ 1 : 5 ] * 2 <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> if f [ k : k + 4 ] == e [ 1 : 5 ] : return <STRING> <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> return <STRING> <NEWLINE> <DEDENT> print ( f ( ) ) <NEWLINE>
class Dice : <NEWLINE> <NL> <INDENT> def __init__ ( self , faces ) : <NEWLINE> <INDENT> self . faces = tuple ( faces ) <NEWLINE> <NL> <DEDENT> def roll_north ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 1 ] , self . faces [ 5 ] , self . faces [ 2 ] , <NEWLINE> <INDENT> self . faces [ 3 ] , self . faces [ 0 ] , self . faces [ 4 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_south ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 4 ] , self . faces [ 0 ] , self . faces [ 2 ] , <NEWLINE> <INDENT> self . faces [ 3 ] , self . faces [ 5 ] , self . faces [ 1 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_west ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 2 ] , self . faces [ 1 ] , self . faces [ 5 ] , <NEWLINE> <INDENT> self . faces [ 0 ] , self . faces [ 4 ] , self . faces [ 3 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def roll_east ( self ) : <NEWLINE> <INDENT> self . faces = ( self . faces [ 3 ] , self . faces [ 1 ] , self . faces [ 0 ] , <NEWLINE> <INDENT> self . faces [ 5 ] , self . faces [ 4 ] , self . faces [ 2 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def number ( self , face_id ) : <NEWLINE> <INDENT> return self . faces [ face_id - 1 ] <NEWLINE> <NL> <DEDENT> def checksame ( self , other_dice ) : <NEWLINE> <INDENT> self_opposite_face = dict ( zip ( [ self . number ( i ) for i in range ( 1 , 7 ) ] , <NEWLINE> <INDENT> [ self . number ( i ) for i in range ( 6 , 0 , - 1 ) ] ) ) <NEWLINE> <DEDENT> other_opposite_face = dict ( zip ( [ other_dice . number ( i ) for i in range ( 1 , 7 ) ] , <NEWLINE> <INDENT> [ other_dice . number ( i ) for i in range ( 6 , 0 , - 1 ) ] ) ) <NEWLINE> <DEDENT> if self_opposite_face != other_opposite_face : <NEWLINE> <INDENT> return False <NEWLINE> <DEDENT> if self . number ( 2 ) in ( other_dice . number ( 3 ) , other_dice . number ( 4 ) ) : <NEWLINE> <INDENT> other_dice . roll_west ( ) <NEWLINE> <DEDENT> while self . number ( 2 ) != other_dice . number ( 2 ) : <NEWLINE> <INDENT> other_dice . roll_north ( ) <NEWLINE> <DEDENT> while self . number ( 1 ) != other_dice . number ( 1 ) : <NEWLINE> <INDENT> other_dice . roll_west ( ) <NEWLINE> <DEDENT> print ( self . faces , other_dice . faces ) <NEWLINE> return self . number ( 3 ) == other_dice . number ( 3 ) <NEWLINE> <NL> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> dice_list = [ input ( ) . split ( ) for i in range ( n ) ] <NEWLINE> <NL> for i in range ( n ) : <NEWLINE> <INDENT> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> if dice_list [ i ] . checksame ( dice_list [ j ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( 0 ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
class Dice : <NEWLINE> <INDENT> def __init__ ( self , t , f , r , l , b , u ) : <NEWLINE> <INDENT> self . a = [ [ t , f , r , l , b , u ] ] <NEWLINE> self . direction = { <STRING> : ( 4 , 0 , 2 , 3 , 5 , 1 ) , <STRING> : ( 1 , 5 , 2 , 3 , 0 , 4 ) , <STRING> : ( 3 , 1 , 0 , 5 , 4 , 2 ) , <STRING> : ( 2 , 1 , 5 , 0 , 4 , 3 ) , <STRING> : ( 0 , 3 , 1 , 4 , 2 , 5 ) } <NEWLINE> <DEDENT> def roll ( self , d , n ) : <NEWLINE> <INDENT> self . a [ n ] = [ self . a [ n ] [ i ] for i in self . direction [ d ] ] <NEWLINE> self . t = self . a [ 0 ] <NEWLINE> self . f = self . a [ 1 ] <NEWLINE> self . r = self . a [ 2 ] <NEWLINE> self . l = self . a [ 3 ] <NEWLINE> self . b = self . a [ 4 ] <NEWLINE> self . u = self . a [ 5 ] <NEWLINE> <DEDENT> <DEDENT> n = int ( input ( ) ) <NEWLINE> for i in range ( n ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> t , f , r , l , b , u = map ( int , input ( ) . split ( ) ) <NEWLINE> dice = Dice ( t , f , r , l , b , u ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> a = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> dice . a . append ( a ) <NEWLINE> <DEDENT> <DEDENT> s = <STRING> <NEWLINE> w = <STRING> <NEWLINE> ans = <STRING> <NEWLINE> for u in range ( n - 1 ) : <NEWLINE> <INDENT> for t in range ( u + 1 , n ) : <NEWLINE> <INDENT> for j in s : <NEWLINE> <INDENT> for r in w : <NEWLINE> <INDENT> if dice . a [ t ] == dice . a [ u ] : <NEWLINE> <INDENT> ans = <STRING> <NEWLINE> break <NEWLINE> <DEDENT> dice . roll ( r , t ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> dice . roll ( j , t ) <NEWLINE> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> break <NEWLINE> <DEDENT> print ( ans ) <NEWLINE> <NL>
from enum import Enum <NEWLINE> import sys <NEWLINE> import math <NEWLINE> <NL> <COMMENT> <NL> class Dice ( ) : <NEWLINE> <NL> <INDENT> def __init__ ( self ) : <NEWLINE> <INDENT> self . number = [ i for i in range ( 6 ) ] <NEWLINE> self . work = [ i for i in range ( 6 ) ] <NEWLINE> self . order = <STRING> <NEWLINE> <NL> <DEDENT> def setNumber ( self , n0 , n1 , n2 , n3 , n4 , n5 ) : <NEWLINE> <INDENT> self . number [ 0 ] = n0 <NEWLINE> self . number [ 1 ] = n1 <NEWLINE> self . number [ 2 ] = n2 <NEWLINE> self . number [ 3 ] = n3 <NEWLINE> self . number [ 4 ] = n4 <NEWLINE> self . number [ 5 ] = n5 <NEWLINE> <NL> <DEDENT> def roll ( self , loc ) : <NEWLINE> <INDENT> for i in range ( 6 ) : <NEWLINE> <INDENT> self . work [ i ] = self . number [ i ] <NEWLINE> <NL> <DEDENT> if loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 3 ] , self . work [ 1 ] , self . work [ 0 ] , self . work [ 5 ] , self . work [ 4 ] , self . work [ 2 ] ) <NEWLINE> <DEDENT> elif loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 1 ] , self . work [ 5 ] , self . work [ 2 ] , self . work [ 3 ] , self . work [ 0 ] , self . work [ 4 ] ) <NEWLINE> <DEDENT> elif loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 4 ] , self . work [ 0 ] , self . work [ 2 ] , self . work [ 3 ] , self . work [ 5 ] , self . work [ 1 ] ) <NEWLINE> <DEDENT> elif loc == <STRING> : <NEWLINE> <INDENT> self . setNumber ( self . work [ 2 ] , self . work [ 1 ] , self . work [ 5 ] , self . work [ 0 ] , self . work [ 4 ] , self . work [ 3 ] ) <NEWLINE> <NL> <DEDENT> <DEDENT> def query ( self , top_num , front_num ) : <NEWLINE> <INDENT> self . save_data = [ i for i in range ( 6 ) ] <NEWLINE> for i in range ( len ( self . number ) ) : <NEWLINE> <INDENT> self . save_data [ i ] = self . number [ i ] <NEWLINE> <DEDENT> ret = - 1 <NEWLINE> <NL> for i in range ( len ( self . order ) ) : <NEWLINE> <INDENT> self . roll ( self . order [ i ] ) <NEWLINE> if self . number [ 0 ] == top_num and self . number [ 1 ] == front_num : <NEWLINE> <INDENT> ret = self . number [ 2 ] <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> for i in range ( len ( self . number ) ) : <NEWLINE> <INDENT> self . number [ i ] = self . save_data [ i ] <NEWLINE> <NL> <DEDENT> <DEDENT> def equal ( self , another ) : <NEWLINE> <INDENT> ret = False ; <NEWLINE> <NL> for i in range ( len ( self . order ) ) : <NEWLINE> <INDENT> self . roll ( self . order [ i ] ) <NEWLINE> FLG = True <NEWLINE> for k in range ( 6 ) : <NEWLINE> <INDENT> if self . number [ k ] != another . number [ k ] : <NEWLINE> <INDENT> FLG = False <NEWLINE> break <NEWLINE> <DEDENT> <DEDENT> if FLG == True : <NEWLINE> <INDENT> return True <NEWLINE> <NL> <DEDENT> <DEDENT> return ret ; <NEWLINE> <NL> <DEDENT> <DEDENT> num_dice = int ( input ( ) ) <NEWLINE> DICE = [ ] <NEWLINE> <NL> for i in range ( num_dice ) : <NEWLINE> <INDENT> table = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> tmp_dice = Dice ( ) <NEWLINE> tmp_dice . setNumber ( table [ 0 ] , table [ 1 ] , table [ 2 ] , table [ 3 ] , table [ 4 ] , table [ 5 ] ) <NEWLINE> DICE . append ( tmp_dice ) <NEWLINE> <NL> <DEDENT> FLG = True <NEWLINE> <NL> for i in range ( num_dice - 1 ) : <NEWLINE> <INDENT> for k in range ( i + 1 , num_dice ) : <NEWLINE> <INDENT> if Dice [ i ] . equal ( Dice [ k ] ) == True : <NEWLINE> <INDENT> FLG = False <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> if FLG == True : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> b = a [ k ] ; b [ 3 ] , b [ 4 ] = b [ 4 ] , b [ 3 ] <NEWLINE> <DEDENT> t = 0 <NEWLINE> while 1 : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d = a [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> e = a [ j ] <NEWLINE> for p in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> f = [ d [ int ( k ) ] for k in p ] <NEWLINE> if f [ 0 ] == e [ 0 ] and f [ 5 ] == e [ 5 ] : <NEWLINE> <INDENT> f = f [ 1 : 5 ] * 2 <NEWLINE> for k in range ( 4 ) : <NEWLINE> <INDENT> if f [ k : k + 4 ] == e [ 1 : 5 ] : t = 1 ; raise Exception <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> <DEDENT> finally : <NEWLINE> <INDENT> print ( ( <STRING> , <STRING> ) [ t ] ) <NEWLINE> <DEDENT> <DEDENT>
n = int ( input ( ) ) <NEWLINE> a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ] <NEWLINE> for k in range ( n ) : <NEWLINE> <INDENT> b = a [ k ] ; b [ 3 ] , b [ 4 ] = b [ 4 ] , b [ 3 ] <NEWLINE> <DEDENT> t = 0 <NEWLINE> for i in range ( n - 1 ) : <NEWLINE> <INDENT> d = a [ i ] <NEWLINE> for j in range ( i + 1 , n ) : <NEWLINE> <INDENT> e = a [ j ] <NEWLINE> for p in ( <STRING> , <STRING> , <STRING> , <STRING> , <STRING> , <STRING> ) : <NEWLINE> <INDENT> f = [ d [ int ( k ) ] for k in p ] <NEWLINE> if f [ 0 ] == e [ 0 ] and f [ 5 ] == e [ 5 ] : <NEWLINE> <INDENT> f = f [ 1 : 5 ] * 2 <NEWLINE> [ t = 1 for k in range ( 4 ) if f [ k : k + 4 ] == e [ 1 : 5 ] ] <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( ( <STRING> , <STRING> ) [ t ] ) <NEWLINE>
import math <NEWLINE> a , b , C = map ( float , input ( ) . split ( ) ) <NEWLINE> C_rad = math . pi * C / 180 <NEWLINE> print ( <STRING> . format ( math . sin ( C_rad ) * a * b / 2 ) ) <NEWLINE> print ( <STRING> . format ( a + b + math . sqrt ( a ** 2 + b ** 2 - 2 * a * b * math . cos ( C_rad ) ) ) ) <NEWLINE> print ( <STRING> . format ( b * math . sin ( C_rad ) ) ) <NEWLINE>
import itertools <NEWLINE> <NL> <NL> def roll ( dice , commands ) : <NEWLINE> <INDENT> for command in commands : <NEWLINE> <INDENT> if command == <STRING> : <NEWLINE> <INDENT> dice [ 0 ] , dice [ 1 ] , dice [ 5 ] , dice [ 4 ] = dice [ 1 ] , dice [ 5 ] , dice [ 4 ] , dice [ 0 ] <NEWLINE> <DEDENT> elif command == <STRING> : <NEWLINE> <INDENT> dice [ 0 ] , dice [ 3 ] , dice [ 5 ] , dice [ 2 ] = dice [ 2 ] , dice [ 0 ] , dice [ 3 ] , dice [ 5 ] <NEWLINE> <NL> <DEDENT> <DEDENT> <DEDENT> A = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> B = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> for i in range ( 4 ) : <NEWLINE> <INDENT> for j in range ( 4 ) : <NEWLINE> <INDENT> for commands in itertools . permutations ( <STRING> * i + <STRING> * j ) : <NEWLINE> <INDENT> a = A [ : : ] <NEWLINE> roll ( a , commands ) <NEWLINE> if B == a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> exit ( ) <NEWLINE> <DEDENT> <DEDENT> <DEDENT> <DEDENT> print ( <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
n = input ( ) ; <NEWLINE> <NL> return n * n * n ; <NEWLINE>
x = input ( <STRING> ) <NEWLINE> print ( x * x * x ) <NEWLINE> <NL>
print ( input ( ) ** 3 ) <NEWLINE>
s = input ( <STRING> ) <NEWLINE> ans = s * s * s <NEWLINE> print ( ans ) <NEWLINE>
print raw_input ( ) ** 3 <NEWLINE>
def sample ( n ) : <NEWLINE> <INDENT> return n * n * n <NEWLINE> <NL> <DEDENT> n = input ( ) <NEWLINE> x = sample ( n ) <NEWLINE> print x <NEWLINE>
x = input ( ) <NEWLINE> print ( <STRING> % ( x ** 3 ) ) <NEWLINE>
x = int ( input ( 3 ) ) <NEWLINE> x ** 3 = y <NEWLINE> print <NEWLINE>
no = input ( ) <NEWLINE> answer = no ** 3 <NEWLINE> <NL> print ( answer ) <NEWLINE>
input = input ( <STRING> ) <NEWLINE> ans = pow ( input , 3 ) <NEWLINE> print ( ans ) <NEWLINE>
n = int ( raw_input ) <NEWLINE> <NL> print n ** 3 <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <INDENT> print ( x ** 3 ) <NEWLINE> <DEDENT>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> for line in sys . stdout : <NEWLINE> <INDENT> print ( int ( line . strip ( ) ) ** 3 ) <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = int ( input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print ( str ( int ( x ) ** 3 ) ) <NEWLINE>
x = ( input ( ) ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x ** 3 <NEWLINE>
num = raw_input ( ) <NEWLINE> <NL> print ( num * num * num ) <NEWLINE>
s = input ( ) <NEWLINE> if s . isdecimal ( ) == true : <NEWLINE> <INDENT> x = int ( s ) <NEWLINE> if x >= 1 and x <= 100 : <NEWLINE> <INDENT> print ( x ** 3 ) <NEWLINE> <DEDENT> <DEDENT>
x = input ( ) <NEWLINE> result = x * x <NEWLINE> print ( result ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> y = int ( x ) <NEWLINE> return ( y ** 3 ) <NEWLINE> <NL>
x = x ** * <NEWLINE> print ( x ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> ans = x * x * x <NEWLINE> <NL> print ( ans ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
x = input ( int ( ) ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( x * x * x ) <NEWLINE>
input ( x ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> <NL> print x ^ 3 <NEWLINE>
input_lines = input ( ) <NEWLINE> print ( input_lines ** 3 ) <NEWLINE>
x = input <NEWLINE> <NL> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> print ( int ( x ** 3 ) ) <NEWLINE>
def sample ( n ) : <NEWLINE> <INDENT> return n * n * n <NEWLINE> <NL> <DEDENT> n = row_input ( ) <NEWLINE> x = sample ( n ) <NEWLINE> print x <NEWLINE>
<NL> x = input ( ) <NEWLINE> y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
x = int ( print ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE> <NL>
x = raw . input ( <STRING> ) <NEWLINE> print <STRING> <NEWLINE>
for x range ( 1 , 101 ) : <NEWLINE> <INDENT> print x ** 2 <NEWLINE> <DEDENT>
print ( x * x * x ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> x = int ( nums [ 3 ] ) <NEWLINE> <INDENT> x ** 3 <NEWLINE> <DEDENT>
int ( x ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
int x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> y = x ** 3 <NEWLINE> <NL> print ( int ( y ) ) <NEWLINE>
num = sys . stdin . readlines ( ) <NEWLINE> print ( int ( num ) ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> return ( a ** 3 ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> s = int ( input ( ) ) <NEWLINE> <NL> def fact ( s ) : <NEWLINE> <INDENT> if s == 0 : return 1 <NEWLINE> return n * fact ( s - 1 ) <NEWLINE> <NL> <DEDENT> print ( fact ( s ) ) <NEWLINE>
int ( x ) = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = getchar ( ) <NEWLINE> <NL> x = x * x * x <NEWLINE> <NL> print ( x ) <NEWLINE>
y = input ( ) <NEWLINE> x = y ** 3 <NEWLINE> print ( x ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
value = input ( ) <NEWLINE> print ( value ** 3 ) <NEWLINE>
int ( i ) = input ( ) <NEWLINE> print ( i ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE> <NL> <NL> <NL>
input ( x ) <NEWLINE> cube = x * x * x <NEWLINE> print cube <NEWLINE>
print ( int ( input ) ** 3 ) <NEWLINE>
a = int ( raw_input ( ) ) <NEWLINE> print ( pow ( a , 3 ) ) <NEWLINE>
num = input ( ) <NEWLINE> print ( num * num * num ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print ( pow ( x , 3 ) ) <NEWLINE>
print ( int ( input ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> ans = x <NEWLINE> for i in range ( 1 , 3 ) : <NEWLINE> <INDENT> ans = ans * x <NEWLINE> <DEDENT> print ans <NEWLINE> <NL>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
import sys <NEWLINE> <NL> x = sys . stdin . readline ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
n = ( int ) input ( ) <NEWLINE> print ( n ** 3 ) <NEWLINE>
import fileinput <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> val = fileinput . input ( ) <NEWLINE> ans = val ** 3 <NEWLINE> print ( ans ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> for i in range ( 2 ) : <NEWLINE> <INDENT> if i == 0 : <NEWLINE> <INDENT> y = x <NEWLINE> <NL> <DEDENT> y = x * y <NEWLINE> <NL> <DEDENT> print ( y ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
print x ** 3 <NEWLINE>
print ( int ( input ( ) ) ** 3 ) ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = input <NEWLINE> print x * x * x <NEWLINE>
x = ( int ) input ( ) . strip ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> fp = open ( sys . argv [ 1 ] , <STRING> ) <NEWLINE> for i in fp . readline : <NEWLINE> <INDENT> print i * 3 <NEWLINE> <DEDENT>
print ( x ** 3 ) <NEWLINE>
x = int ( input ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x / n ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a * a * a ) <NEWLINE>
a = input ( ) <NEWLINE> b = int ( <STRING> ) <NEWLINE> c = b ** 3 <NEWLINE> print c <NEWLINE>
<NL> x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print x * x * x <NEWLINE>
x = input <NEWLINE> <NL> print x ^ 3 <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ^ 3 <NEWLINE>
input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
X = input ( ) <NEWLINE> Y = X ** 3 <NEWLINE> print ( Y ) <NEWLINE>
print raw_input ( ) ** 3 <NEWLINE>
a = input ( ) <NEWLINE> b = a ** 3 <NEWLINE> print ( b ) <NEWLINE>
print ( x = int ( input ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<COMMENT> <NL> x = raw_input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<INDENT> x = int ( input ( ) ) <NEWLINE> print ( x * x * x ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> print ( x ** 3 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <INDENT> print ( x * x * x ) <NEWLINE> <DEDENT>
x ** 3 <NEWLINE>
x = row_input ( ) <NEWLINE> x = int ( x ) <NEWLINE> x = x ** 3 <NEWLINE> print ( x ) <NEWLINE>
x = input ( <STRING> ) <NEWLINE> num = x * x * x <NEWLINE> print ( num , end = <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> x ^ 3 = x * x * x ; <NEWLINE> <NL> print x ^ 3 <NEWLINE>
def main ( ) : <NEWLINE> x = imput ( ) <NEWLINE> y = pow ( x , 3 ) <NEWLINE> print ( y ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE> <NL>
import sys <NEWLINE> <NL> print ( int ( sys . argv [ 1 ] ) ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE>
<NL> s = input ( ) <NEWLINE> <NL> print ( s * s * s ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
def sanjou ( x ) : <NEWLINE> <INDENT> reeturn x * x * x <NEWLINE> <DEDENT>
x = import ( ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> x = x ** 3 <NEWLINE> <NL> print int ( x ) <NEWLINE>
x = int ( input ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
input_num = raw_input ( ) <NEWLINE> <NL> print input_num ** 3 <NEWLINE>
print ( int ( input ( ) ** 3 ) ) <NEWLINE>
1 < x < 100 <NEWLINE> x = int ( input ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x * x * x ) <NEWLINE>
import sys <NEWLINE> <NL> print ( sys . arg [ 1 ] ) <NEWLINE>
<NL> x = x ** 3 <NEWLINE> print ( x ) <NEWLINE> <NL>
x = int ( raw_input ( ) ) <NEWLINE> x = x ** 3 <NEWLINE> print <STRING> % x <NEWLINE>
print ( int ( <STRING> ) * 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
if 1 <= x and x <= 100 : <NEWLINE> <INDENT> print ( x ** * 3 ) <NEWLINE> <DEDENT>
print ( x ** 3 ) <NEWLINE>
print ( pow ( int ( x ) , 3 ) ) <NEWLINE>
x = input ( ) <NEWLINE> if x == 1 print ( 1 ) <NEWLINE> <INDENT> else print ( x ** 3 ) <NEWLINE> <NL> <DEDENT>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
int x , y ; <NEWLINE> x = input ( ) ; <NEWLINE> y = x ^ 3 ; <NEWLINE> print y ; <NEWLINE>
num = int ( input ( ) ) <NEWLINE> res = num ** 3 <NEWLINE> <NL> print ( <STRING> . format ( res ) ) <NEWLINE>
input_line1 = raw_input ( ) <NEWLINE> print ( input_line1 ^ 3 ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
n = raw_input ( ) <NEWLINE> print ( n ** 3 ) <NEWLINE>
import sys <NEWLINE> <NL> x = sys . argv [ 1 ] <NEWLINE> <NL> x3 = int ( x ) * int ( x ) * int ( x ) <NEWLINE> <NL> print x3 <NEWLINE>
x = raw_input ( ) <NEWLINE> print x * x * x <NEWLINE>
x = long ( input ( ) ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( x * x * x * ) <NEWLINE>
import sys <NEWLINE> input_number = int ( raw_input ( ) ) <NEWLINE> <NL> if __name__ == <STRING> : <NEWLINE> <INDENT> print ( str ( input_number ** 3 ) ) <NEWLINE> <NL> <DEDENT>
x = input ( ) <NEWLINE> print x = ^ 3 <NEWLINE>
x = raw_imput ( ) <NEWLINE> x = int ( x ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = int ( input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
input ( ) ** 3 <NEWLINE>
x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
import sys <NEWLINE> <NL> x = int ( sys . stdin [ 0 ] ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x ** 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
if __name__ == <STRING> : <NEWLINE> <INDENT> print ( x ** 3 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = raw_input ( <STRING> ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> x = x ** 3 <NEWLINE> print ( x ) <NEWLINE>
def x_cube : <NEWLINE> <INDENT> A = x * x * x <NEWLINE> print A <NEWLINE> <DEDENT>
raw_input ( ) <NEWLINE> <INDENT> print ( ( x ) * 3 ) <NEWLINE> <DEDENT>
print ( x ^ 3 ) <NEWLINE>
input = input ( ) <NEWLINE> print ( input * input * input ) <NEWLINE>
n = raw_input ( ) <NEWLINE> <NL> print ( int ( n ) ** 3 ) <NEWLINE>
x = int ( raw_input ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
int ( x ) * 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
n = input ( ) <NEWLINE> print ( n * n * n ) <NEWLINE>
a = input ( ) <NEWLINE> a = a * a * a <NEWLINE> print ( a ) <NEWLINE>
a = input ( ) <NEWLINE> int ( a ) <NEWLINE> print ( <STRING> . a ** 3 ) <NEWLINE>
x = input <NEWLINE> print x ** 3 <NEWLINE>
param = sys . argv <NEWLINE> <NL> if ( len ( param ) > 1 ) : <NEWLINE> <INDENT> print ( int ( param [ 1 ] ) ** 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> <NL> print ( x ** 3 ) <NEWLINE>
print ( <STRING> . fomat ( x * x * x ) ) <NEWLINE>
a = raw_input ( ) <NEWLINE> print a * a * a <NEWLINE>
x = input ( ) <NEWLINE> a = x ** 3 <NEWLINE> print int ( a ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a * a * a ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
num = raw_input ( ) <NEWLINE> print num ** 3 <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
print ( <STRING> ) <NEWLINE> x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE> <NL>
<COMMENT> <NL> <NL> int main ( ) { <NEWLINE> <INDENT> int x ; <NEWLINE> <NL> scanf ( <STRING> , & x ) ; <NEWLINE> <NL> printf ( <STRING> , x * x * x ) ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) ; <NEWLINE> y = x * x * x ; <NEWLINE> print y ; <NEWLINE> return 0 ; <NEWLINE>
x = int ( raw_input ( <STRING> ) ) <NEWLINE> print int ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ^ 3 ) <NEWLINE>
def aaa ( x ) : <NEWLINE> <INDENT> x = x ** 3 <NEWLINE> <NL> <DEDENT> print aaa ( x ) <NEWLINE>
x = int ( raw_input ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
i = readInt ( ) <NEWLINE> print i * i * i <NEWLINE>
int x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
a = raw_input ( ) <NEWLINE> <NL> print ( a * a * a ) <NEWLINE>
x = raw_input ( ) <NEWLINE> x = x ** 3 <NEWLINE> print x <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
number = input ( int ( ) ) <NEWLINE> print ( number ** 3 ) <NEWLINE>
x = row_input ( ) <NEWLINE> x = int ( x ) <NEWLINE> print x * x * x <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x * x * x ) <NEWLINE>
import sys <NEWLINE> <NL> a = int ( sys . argv [ 1 ] ) <NEWLINE> print ( <STRING> . format ( a ** 3 ) ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = raw_int ( input ( <STRING> ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<NL> x = input ( ) <NEWLINE> <NL> print ( x ^ 3 ) <NEWLINE>
import sys <NEWLINE> <NL> argvs = sys . argv <NEWLINE> <NL> x = int ( argvs [ 1 ] ) <NEWLINE> print str ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( x * x * x ) <NEWLINE>
x = input ( <STRING> ) <NEWLINE> if 1 <= x <= 100 <NEWLINE> <INDENT> print ( x * x * x ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
import sys <NEWLINE> <NL> i = int ( raw_input ( ) ) <NEWLINE> <NL> print ( i ** 3 ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> if 1 <= x <= 100 : <NEWLINE> <INDENT> print ( a ** 3 ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
int x <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( <STRING> ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> pritn str ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x * x * x ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE> sys . exit ( ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def calculate ( x ) : <NEWLINE> <INDENT> X = int ( x ) <NEWLINE> return X * X * X <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <NL> <INDENT> param = sys . argv <NEWLINE> <NL> print ( calculate ( param [ 1 ] ) ) <NEWLINE> <DEDENT>
input = input ( ) <NEWLINE> print ( input ** 3 ) <NEWLINE>
while True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> if int ( x ) > 100 or int ( x ) < 1 : <NEWLINE> <INDENT> continue <NEWLINE> <DEDENT> print ( int ( x ) ** 3 ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
print ( x ^ 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print <STRING> % x ^ 3 <NEWLINE>
x = STDIN <NEWLINE> print x ** 3 <NEWLINE>
<COMMENT> <NL> x = input ( ) <NEWLINE> x = x ** 3 <NEWLINE> print ( x ) <NEWLINE>
input ( x ) <NEWLINE> print ( int ( x ** 3 ) ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
y = int ( input ( x ** 3 ) ) <NEWLINE>
import sys <NEWLINE> print ( sys . argv [ 0 ] ** 3 ) <NEWLINE>
<NL> x = input ( ( ) ) <NEWLINE> <NL> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
num = int ( sys . stdin . readline ( ) ) <NEWLINE> ans = num ** 3 <NEWLINE> print ans <NEWLINE>
import sys <NEWLINE> x = sys . argv [ 1 ] <NEWLINE> x = x ** 3 <NEWLINE> print ( x ) <NEWLINE>
<COMMENT> <NL> x = raw_input ( ) <NEWLINE> print ( int ( x ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
print x ** 3 <NEWLINE>
x = input ( ) . rstrip ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> x = x * x * x <NEWLINE> print ( x ) <NEWLINE>
x = ( int ) input ( ) <NEWLINE> printt ( x * x * x ) <NEWLINE>
<COMMENT> <NL> <NL> n = raw_input ( ) <NEWLINE> <NL> x = int ( n ) ** 3 <NEWLINE> <NL> print ( x ) <NEWLINE> print <STRING> <NEWLINE>
int ( input ( x ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
input x <NEWLINE> <NL> print x ** 3 <NEWLINE>
n = input ( ) <NEWLINE> print ( n * n * n ) <NEWLINE>
print ( pow ( int ( input ( x ) ) ) ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
a = 3 <NEWLINE> return a * a * a <NEWLINE>
i = input_raw ( ) <NEWLINE> print int ( i ) ** 3 <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> import sys <NEWLINE> <NL> def init ( ) : <NEWLINE> <INDENT> data = [ ] <NEWLINE> while ( True ) : <NEWLINE> <INDENT> line = raw_input ( ) <NEWLINE> if not line : break <NEWLINE> data . append ( line ) <NEWLINE> <DEDENT> return data <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> n = int ( init ( ) . pop ) <NEWLINE> if 1 <= n <= 100 : <NEWLINE> <INDENT> print n ** 3 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> % n <NEWLINE> <NL> <DEDENT> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
N = input ( ) <NEWLINE> N = N * N * N <NEWLINE> print ( N ) <NEWLINE>
print ( x * x * x ) <NEWLINE>
x ** 3 <NEWLINE>
import sys <NEWLINE> <NL> data = sys . stdin . readline ( ) <NEWLINE> print ( data * data * data ) <NEWLINE>
x = input ( ) <NEWLINE> x_int = int ( x ) <NEWLINE> print x_int ** 3 <NEWLINE>
print ( int ( input ( ) ) ** * 3 ) <NEWLINE>
N = input ( ) <NEWLINE> print ( N * N * N ) <NEWLINE>
x ** 3 <NEWLINE>
x = ( int ( import ( ) ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<COMMENT> <NL> <NL> n = input ( ) <NEWLINE> print ( n ** 3 ) <NEWLINE>
print ( x * x * x ) <NEWLINE>
x = int ( raw_input ( ) ) <NEWLINE> print Math . pow ( x , 3 ) <NEWLINE>
x = int ( input ( x ) ) <NEWLINE> x = x ** 3 <NEWLINE> print ( x ) <NEWLINE>
pow ( input ( ) , 3 ) <NEWLINE>
import sys <NEWLINE> <NL> args = sys . argv <NEWLINE> num = int ( args [ 1 ] ) <NEWLINE> print ( num * num * num ) <NEWLINE>
x = input ( ) <NEWLINE> print x * x * x <NEWLINE>
num = int ( input ( ) ) <NEWLINE> num ** *= num <NEWLINE> print ( num ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
input = int ( x ) <NEWLINE> x = 3 <NEWLINE> print ( x ** 3 ) <NEWLINE>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a ** 3 <NEWLINE>
print ( pow ( int ( raw_input ( ) ) , 3 ) ) <NEWLINE>
def triple ( n ) : <NEWLINE> <INDENT> if n >= 1 : <NEWLINE> <INDENT> if n <= 100 : <NEWLINE> <INDENT> n = n * 3 <NEWLINE> <DEDENT> return n <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> print ( triple ( x ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE>
def f ( x ) : <NEWLINE> <INDENT> return x ** 3 <NEWLINE> <DEDENT> print <STRING> <NEWLINE>
x = raw_input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = int ( input ) : <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( int ( input ) ** 3 ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> <NL> h1 = int ( input ( ) ) <NEWLINE> a = h1 ** 3 <NEWLINE> print ( a ) <NEWLINE> <NL> h2 = int ( input ( ) ) <NEWLINE> b = h2 ** 3 <NEWLINE> print ( b ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> print ( n ** ) <NEWLINE>
input_x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> out = x ** 3 <NEWLINE> print ( out ) <NEWLINE>
n = input ( ) <NEWLINE> print ( n ** 3 ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE> <NL>
x = int ( input ( ) ) <NEWLINE> y = x ** * <NEWLINE> print y <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
import sys <NEWLINE> x = sys . stdin . read ( ) <NEWLINE> print x ** 3 <NEWLINE>
var = input ( ) <NEWLINE> print ( var * var * var ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
input ( x ) <NEWLINE> print <STRING> % ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> y = x ** 3 <NEWLINE> <NL> print int ( y ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
a = int ( raw_input ( ) ) <NEWLINE> print ( a * a * a ) <NEWLINE>
number = input ( x = : ) <NEWLINE> <NL> x = int ( number ) <NEWLINE> <NL> print ( x ** * ) <NEWLINE>
x ** 3 <NEWLINE>
cube = input ( ) <NEWLINE> print ( cube ** 3 ) <NEWLINE> <NL>
int x <NEWLINE> x = 3 <NEWLINE> print x ** 3 <NEWLINE>
x = int ( inut ( ) ) <NEWLINE> print ( x * x * x ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
print ( int ( raw_input ( ) ) ** 3 ) <NEWLINE>
x = int <NEWLINE> print ( x ^ 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * ) <NEWLINE>
<INDENT> N = int ( input ( ) ) <NEWLINE> <DEDENT> print ( pow ( N , 3 ) ) <NEWLINE>
x = input ( ) <NEWLINE> printf x ** 3 <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a = x ** 3 <NEWLINE> print ( a ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> y = x * x * x <NEWLINE> print ( y ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
input ( x ) <NEWLINE> x ** 3 <NEWLINE>
import sys <NEWLINE> <NL> x = sys . argv [ 1 ] <NEWLINE> <NL> x3 = int ( x ) ** 3 <NEWLINE> <NL> print x3 <NEWLINE>
N = input ( ) <NEWLINE> print ( N ** 3 ) <NEWLINE>
import sys <NEWLINE> n = sys . argv [ 1 ] <NEWLINE> print ( n * n * n ) <NEWLINE>
print ( x * x * x ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print X ** 3 <NEWLINE>
number = input ( ) <NEWLINE> print ( <STRING> , number ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> return a ** 3 <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
N = input ( ) <NEWLINE> print ( N ** 3 ) <NEWLINE>
import sys <NEWLINE> num = sys . stdin . readline ( ) <NEWLINE> ans = num * num * num <NEWLINE> print ans <NEWLINE>
s = input ( ) <NEWLINE> a = s ** 3 <NEWLINE> print ( a ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = ( input ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> ans = x ** 3 <NEWLINE> print ( ans ) <NEWLINE>
input ( num ) <NEWLINE> <NL> multiple = num * num * num <NEWLINE> <NL> print ( multiple ) <NEWLINE>
import sys <NEWLINE> <NL> x = sys . stdin <NEWLINE> print x ** 3 <NEWLINE>
if __name__ = <STRING> : <NEWLINE> <INDENT> print ( x ** 3 ) <NEWLINE> <DEDENT>
n = int ( input ( ) ) <NEWLINE> <NL> print ( <STRING> . format ( pow ( n , 3 ) ) <NEWLINE>
num = input ( ) <NEWLINE> <NL> print ( num ** 3 ) <NEWLINE>
<INDENT> print ( int ( input ( ) ) ** 3 ) <NEWLINE> <DEDENT>
def main ( ) ; <NEWLINE> <INDENT> num = int ( input ( ) ) <NEWLINE> print ( num ** 3 ) <NEWLINE> return <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE>
v = input ( ) <NEWLINE> v = int ( v ) <NEWLINE> print ( v ** i ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> y = x ** 3 <NEWLINE> <NL> print int ( y ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> cube = x * x * x <NEWLINE> print ( cube ) <NEWLINE> <NL>
s = get_input ( ) <NEWLINE> v = int ( s ) <NEWLINE> print ( v * v * v ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = a * a * a <NEWLINE> output ( b ) <NEWLINE>
input = int ( input ( ) ) <NEWLINE> output = input ** 3 <NEWLINE> return output <NEWLINE>
x = int <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = ( input ( ) ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> x = x ** 3 <NEWLINE> print ( x ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> x = ( x ^ 3 ) <NEWLINE> print ( x ) <NEWLINE>
print ( x * x * x ) <NEWLINE>
white True : <NEWLINE> <INDENT> x = input ( ) <NEWLINE> print x ** 3 <NEWLINE> <DEDENT>
x = raw_input ( ) <NEWLINE> print = int ( x ) ^ 3 <NEWLINE>
x ** 3 <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> var = raw_input ( ) <NEWLINE> sum = var * var * var <NEWLINE> <NL> print sum <NEWLINE>
num = int ( raw_input ( ) ) <NEWLINE> print ( num * num * num ) <NEWLINE>
x = map ( input ( ) , int ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
num = int ( raw_input ( ) ) <NEWLINE> num = num * num * num <NEWLINE> print ( num ) <NEWLINE>
int ( input ( ) ) <NEWLINE> print ( x * x * x ) <NEWLINE> <NL> <NL>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> <INDENT> return x * x * x <NEWLINE> <DEDENT>
x = raw_input ( ) <NEWLINE> x = x * x * x <NEWLINE> print x <NEWLINE>
a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE>
import sys <NEWLINE> <NL> args = sys . argv <NEWLINE> <NL> num = int ( args [ 1 ] ) <NEWLINE> print ( str ( num ** 3 ) ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> print ( n ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print a * a * a <NEWLINE>
<INDENT> num = int ( input ( ) ) <NEWLINE> <DEDENT> print ( num ** 3 ) <NEWLINE>
if ( <STRING> ) : <NEWLINE> <INDENT> print ( x * x * x ) <NEWLINE> <DEDENT>
print ( x ** 3 ) <NEWLINE>
<COMMENT> <NL> <NL> import sys <NEWLINE> <NL> def p3 ( v ) : <NEWLINE> <INDENT> return v * v * v <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> in = sys . stdin . read ( ) <NEWLINE> print ( <STRING> . format ( p3 ( int ( in ) ) ) ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b * b * b <NEWLINE>
print ( <STRING> ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> while x < 1 | x > 100 <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> x = int ( input ( ) ) <NEWLINE> <NL> <DEDENT> print ( x ** 3 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print x ** 3 <NEWLINE>
a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x ** 3 ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print x * x * x <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
print ( x ** 3 ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<NL> def cub ( ) : <NEWLINE> <INDENT> x = raw_input ( <STRING> ) <NEWLINE> return x ** 3 <NEWLINE> <DEDENT>
a = 0 <NEWLINE> a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> x3 = x * x * x <NEWLINE> print ( x3 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = x ** 3 <NEWLINE> print ( y <NEWLINE>
print ( X * X * X ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a * a * a ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
int = x <NEWLINE> y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
x = input ( ) <NEWLINE> return x ^ 3 <NEWLINE>
print int ( raw_imput ( ) ) ** 3 <NEWLINE>
S288C_reference_genome_R64 - 1 - 1_20110203 <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
n = input ( ) <NEWLINE> print ( n * n * n ) <NEWLINE>
print ( math . pow ( x , 3 ) ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
i = inputraw ( ) <NEWLINE> cubic = i * i * i <NEWLINE> print cubic <NEWLINE>
x = 2 <NEWLINE> print ( X ** 3 ) <NEWLINE>
n = raw_input ( ) <NEWLINE> <NL> print n ** 3 <NEWLINE>
<COMMENT> <NL> import sys <NEWLINE> <NL> print ( int ( sys . argv [ 1 ] ) ** 3 ) <NEWLINE> print ( <STRING> ) <NEWLINE>
print ( int ( input ( ) ) ** int ( input ( ) ) ) <NEWLINE>
num = int ( imput ( ) ) <NEWLINE> <NL> print ( num ** 3 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print x ** 3 <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
input ( x ) <NEWLINE> <NL> y = 0 <NEWLINE> <NL> y = x * x * x <NEWLINE> <NL> print ( y ) <NEWLINE> <NL> <NL>
input_line = input ( ) <NEWLINE> input_line_cubic = input_line ** 3 <NEWLINE> print input_line_cubic + <STRING> <NEWLINE>
import numpy as np <NEWLINE> <NL> N = input ( ) <NEWLINE> print N ** 3 <NEWLINE>
<COMMENT> <NL> <NL> x = raw_input ( ) . split ( ) <NEWLINE> <NL> y = map ( int , x ) <NEWLINE> <NL> a = y [ 0 ] <NEWLINE> b = y [ 1 ] <NEWLINE> <NL> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> <NL> print c , d <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x ** 3 ) <NEWLINE>
import sys <NEWLINE> <NL> x = int ( sys . argv [ 1 ] ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
print ( int ( input ( ) ) ** * 3 ) <NEWLINE>
<NL> a = int ( raw_input ( ) ) <NEWLINE> <COMMENT> <NL> print a * a * a <NEWLINE>
x = int ( input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
<INDENT> import sys <NEWLINE> <NL> <DEDENT> x = int ( sys . argv [ 1 ] ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE> <NL>
def get_cubic ( x ) : <NEWLINE> <INDENT> return x ** 3 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> x = int ( input ( ) ) <NEWLINE> print ( x_cubic ( x ) ) <NEWLINE> <NL> <DEDENT>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
x = input ( ) <NEWLINE> print ( <STRING> % x * x * x ) <NEWLINE>
num = input ( ) <NEWLINE> print ( num * num * num ) <NEWLINE>
print ( type ( int ( input ( ) ) ) ** 3 ) <NEWLINE>
x = int ( raw_input ( ) ) <NEWLINE> print ( <STRING> . format ( x ^ 3 ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( str ( x ) + <STRING> + str ( x * x * x ) ) <NEWLINE> <NL> <INDENT> print ( eval ( input ( ) ) ** 3 ) <NEWLINE> <DEDENT>
Print ( 2 ** 3 ) <NEWLINE>
def Cubic ( x ) : <NEWLINE> <INDENT> return x * x * x <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> Cubic ( ) <NEWLINE> <DEDENT>
number = int ( x ) <NEWLINE> print ( number ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = int ( imput ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<COMMENT> <NL> <STRING> <NEWLINE> aa = input ( ) <NEWLINE> print aa ** 3 <NEWLINE>
i = gets <NEWLINE> i = i . to_i <NEWLINE> print i * i * i , <STRING> <NEWLINE>
input = raw_input ( ) <NEWLINE> print input * input * input <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> y = x * x * X <NEWLINE> print ( int ( y ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( x ** 3 ) <NEWLINE> input ( ) <NEWLINE>
n = input ( <STRING> ) <NEWLINE> <NL> a = pow ( n , 3 ) <NEWLINE> print ( a ) <NEWLINE> <NL>
x ** 3 <NEWLINE>
x = input ( ) <NEWLINE> y = x * x * x <NEWLINE> print ( y ) <NEWLINE> print ( <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
print ( x ** 3 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print int ( x ** 3 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<INDENT> x = import ( ) <NEWLINE> ans = int ( x ) ** 3 <NEWLINE> print ans <NEWLINE> <DEDENT>
print x ** 3 <NEWLINE>
x ^ 3 <NEWLINE>
print ( x * x * x ) <NEWLINE>
inputa = input ( ) <NEWLINE> <NL> inputa3 = inputa ** 3 <NEWLINE> <NL> print ( inputa3 ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> y = x ** 3 <NEWLINE> <NL> print ( int ( y ) ) <NEWLINE>
import sys <NEWLINE> t = sys . argv [ 1 ] <NEWLINE>
import sys <NEWLINE> <NL> n = int ( sys . argv [ 1 ] ) <NEWLINE> n = n * n * n <NEWLINE> print ( n ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> if 1 <= x <= 100 : <NEWLINE> <INDENT> print ( x ** 2 ) <NEWLINE> <NL> <DEDENT>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<COMMENT> <NL> 2 x = input ( ) <NEWLINE> 3 print x ** 3 <NEWLINE>
s = input ( ) <NEWLINE> print ( s ** 3 ) <NEWLINE> <NL>
x = int ( input ( ) ) <NEWLINE> <INDENT> print ( x ** 3 ) <NEWLINE> <DEDENT>
print ( input ( ) ** 3 ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a ** 3 ) <NEWLINE> <NL>
input ( i ) <NEWLINE> print ( i ** 3 ) <NEWLINE>
print str ( x * x * x ) <NEWLINE>
input ( x ) <NEWLINE> a = x * x * x <NEWLINE> print ( a ) <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> orint ( int ( x ) ** 3 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> print x ** 3 <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( ** 3 ) <NEWLINE>
print ( float ( input ( ) ) ** EXPONENT ) <NEWLINE>
int ( input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s ** 3 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = b ** 3 <NEWLINE> print ( b ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
input ( x ) <NEWLINE> print ( x ^ 3 ) <NEWLINE>
x = input ( ) <NEWLINE> answer = x ** 3 <NEWLINE> print ( answer ) <NEWLINE>
x = input ( ) <NEWLINE> y = x * x * x <NEWLINE> print ( y ) <NEWLINE>
print ( int ( input ( ) ) * int ( input ( ) ) * int ( input ( ) ) ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
<NL> x = input ( <STRING> ) <NEWLINE> y = int ( x ) <NEWLINE> print ( x ** 3 + <STRING> ) <NEWLINE> <NL>
x = imput ( ) <NEWLINE> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> Pow = x * x * x <NEWLINE> <NL> print ( Pow ) <NEWLINE>
x = int ( input ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
x = imput ( ) <NEWLINE> print x ** 3 <NEWLINE> <NL>
x = input ( ) <NEWLINE> <NL> print ( x ** 3 ) <NEWLINE>
y = x ** 3 <NEWLINE> print y <NEWLINE>
s = raw_input ( ) <NEWLINE> print str ( pow ( int ( s ) , 3 ) ) + <STRING> <NEWLINE>
print ( input ( ) ** 3 ) <NEWLINE>
x = input ( ) <NEWLINE> <NL> print ( x * x * x ) <NEWLINE>
x = input ( ) <NEWLINE> y = x ** 3 <NEWLINE> print ( y ) <NEWLINE>
x = input ( ) <NEWLINE> print ( x ** 3 ) <NEWLINE>
n = int ( raw_input ( ) ) <NEWLINE> <NL> print <STRING> . format ( n ** 3 ) <NEWLINE>
x = raw_input ( ) <NEWLINE> x = int ( x ) <NEWLINE> print x = x * x * x <NEWLINE>
a = x ** 3 <NEWLINE> print ( a ) <NEWLINE>
for x in raw_input : <NEWLINE> <INDENT> print int ( x ) ** 3 <NEWLINE> <DEDENT>
print ( x ** 3 ) <NEWLINE>
x == 2 <NEWLINE> print ( x ** 3 ) <NEWLINE>
X = raw_input ( ) <NEWLINE> print X * X * X <NEWLINE>
print ( x ** 3 ) <NEWLINE>
( a , b ) = map ( int , input ( ) . split ( ) ) <NEWLINE> print a * b , 2 * ( a + b ) <NEWLINE>
( a , b ) = input ( ) . sprit ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
import sys <NEWLINE> <NL> a , b = map ( int , sys . stdin . readline ( ) . rstrip ( ) . split ( <STRING> ) ) <NEWLINE> print ( <STRING> . format ( a * b , ( a + b ) * 2 ) <NEWLINE>
def Area ( a , b ) : <NEWLINE> <INDENT> return a * b <NEWLINE> <NL> <DEDENT> def Lap ( a , b ) : <NEWLINE> <INDENT> return 2 * ( a + b ) <NEWLINE> <NL> <DEDENT> num = input ( ) <NEWLINE> a , b = int ( num . split ( ) ) <NEWLINE> print ( <STRING> . format ( Area ( a , b ) , Lap ( a , b ) ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b , 2 a + 2 b ) <NEWLINE>
n = input ( ) . split ( ) <NEWLINE> print ( str ( n [ 0 ] * n [ 1 ] ) + <STRING> + str ( ( n [ 0 ] * 2 ) + ( n [ 1 ] * 2 ) ) ) <NEWLINE> <NL>
n = input ( ) <NEWLINE> a , b = int ( n . split ( ) ) <NEWLINE> x = a * b <NEWLINE> y = 2 * ( a + b ) <NEWLINE> print ( x , y ) <NEWLINE>
nums = input ( a ) . split ( b ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> d = 2 * ( a + b ) <NEWLINE> print ( str ( c ) <STRING> str ( d ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> a * b <NEWLINE> ( a + b ) * 2 <NEWLINE>
numbers = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( ( numbers [ 0 ] * numbers [ 1 ] ) + <STRING> + ( numbers [ 0 ] + numbers [ 1 ] ) * 2 ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> s = a * b <NEWLINE> l = 2 * a + 2 * b <NEWLINE> print ( s , l ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> e = a * b <NEWLINE> c = a * 2 + b * 2 <NEWLINE> print ( e , c ) <NEWLINE>
area_input = input ( ) <NEWLINE> vertical = 0 <NEWLINE> side = 0 <NEWLINE> area_list = area_input . split ( <STRING> ) <NEWLINE> <NL> if 1 <= vertical & & side <= 100 : <NEWLINE> <INDENT> for i in area_list : <NEWLINE> <INDENT> vertical = area_list [ 0 ] <NEWLINE> side = area_list [ 1 ] <NEWLINE> <NL> <DEDENT> area = int ( vertical ) * int ( side ) <NEWLINE> langth = 2 * ( int ( vertical ) + int ( vertical ) ) <NEWLINE> <NL> print ( str ( area ) + <STRING> + str ( langth ) ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> menseki = a * b <NEWLINE> syu = a * 2 + b * 2 <NEWLINE> print ( menseki , syu ) <NEWLINE>
a = int ( raw_input ( <STRING> ) ) <NEWLINE> b = int ( raw_input ( <STRING> ) ) <NEWLINE> print a * b , 2 * a + 2 * b <NEWLINE>
num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print num [ 0 ] * num [ 1 ] 2 * num [ 0 ] + 2 * num [ 1 ] <NEWLINE>
a = input ( ) . split ( ) <NEWLINE> b = int ( a [ 0 ] ) * int ( a [ 1 ] ) <NEWLINE> c = ( int ( a [ 0 ] ) + int ( a [ 1 ] ) ) * 2 <NEWLINE> print ( b + <STRING> + c ) <NEWLINE>
import sys <NEWLINE> <NL> a , b = map ( int ( x ) , sys . stdin . readline ( ) . split ( ) ) <NEWLINE> area = a * b <NEWLINE> surround = 2 * ( a + b ) <NEWLINE> print ( <STRING> % ( area , surround ) ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> area = a * b <NEWLINE> pm = 2 * a + 2 * b <NEWLINE> print ( area , pm ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> s = l [ 0 ] * l [ 1 ] <NEWLINE> r = l [ 0 ] + l [ 0 ] + l [ 1 ] + l [ 1 ] <NEWLINE> <NL> print s + <STRING> + r <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> print a * a , b * b <NEWLINE>
<COMMENT> <NL> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print a * b , 2 * a + 2 * b <NEWLINE>
list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = list [ 0 ] <NEWLINE> b = list [ 1 ] <NEWLINE> print a * b + <STRING> + ( a + b ) * 2 <NEWLINE>
x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a , b = x [ 0 ] , x [ 1 ] <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE> <NL>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> x = a * b <NEWLINE> y = 2 * ( a + b ) <NEWLINE> print ( x , y ) <NEWLINE>
[ a , b ] = input ( ) <NEWLINE> print a * b 2 * ( a + b ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = int ( a ) * int ( b ) <NEWLINE> d = ( int ( a ) * 2 ) + ( int ( b ) * 2 ) <NEWLINE> print ( <STRING> % ( c , d ) ) <NEWLINE>
( a , b ) : <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
data = input ( ) . split ( ) <NEWLINE> a = data [ 0 ] <NEWLINE> b = data [ 1 ] <NEWLINE> print ( int ( a ) * int ( b ) , 2 * ( int ( a ) + int ( b ) ) <NEWLINE>
input_lines = input ( ) <NEWLINE> input_i = input_lines . sprit ( ) <NEWLINE> <NL> print ( input_i [ 0 ] * input_ [ 1 ] ) <NEWLINE> print ( input_i [ 0 ] * 2 + input_ [ 1 ] * 2 ) <NEWLINE>
a , b = [ temp for temp in input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x = ( ) <NEWLINE> y = ( ) <NEWLINE> z = int ( x ) * int ( y ) <NEWLINE> l = int ( x ) + int ( y ) <NEWLINE> print ( z l ) <NEWLINE>
a , b = [ int ( elem ) for elem in input ( ) . split ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( num [ 0 ] + <STRING> + num [ 1 ] ) <NEWLINE>
w , h = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print w * h , w * 2 + h * 2 <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( a * b , 2 a + 2 b ) <NEWLINE>
a , b = map ( int , input ( ) . splot ( ) ) <NEWLINE> print ( str ( a * b ) + str ( 2 * a + 2 * b ) ) <NEWLINE>
ab = input ( ) . split ( ) <NEWLINE> print ( ab [ 0 ] * ab [ 1 ] ) <NEWLINE>
a , b = ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x = list ( input ( ) . split ( ) ) <NEWLINE> s = x [ 0 ] * x [ 1 ] <NEWLINE> l = 2 * ( x [ 0 ] + x [ 1 ] ) <NEWLINE> print ( s , l ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> x = nums [ 0 ] * nums [ 1 ] <NEWLINE> y = nums [ 0 ] * 2 + nums [ 1 ] * 2 <NEWLINE> print ( str ( x ) + <STRING> + str ( y ) ) <NEWLINE>
deglist = raw_input . split ( <STRING> ) <NEWLINE> height = int ( deglist [ 0 ] ) <NEWLINE> width = int ( deglist [ 1 ] ) <NEWLINE> menseki = height * width <NEWLINE> nagasa = 2 * ( height + width ) <NEWLINE> print menseki , nagasa <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print a * b , 2 * a + 2 * b <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b 2 * ( a + b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b , <STRING> , 2 * a + 2 * b ) <NEWLINE>
A , B = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( A * B ) + <STRING> + ( 2 * A + 2 * B ) ) <NEWLINE>
[ a , b ] = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b + <STRING> + ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 ( a + b ) ) <NEWLINE>
l = input ( ) . split <NEWLINE> a , b = list ( map ( int , l ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
inp = input ( ) <NEWLINE> abl = inp . split ( ) <NEWLINE> map ( int , abl ) <NEWLINE> a , b = list ( map ( int , abl ) ) <NEWLINE> <NL> print ( a * b , 2 ( a + b ) ) <NEWLINE>
<NL> <COMMENT> <NL> <NL> int main ( ) { <NEWLINE> <INDENT> int a , b ; <NEWLINE> std : : cin >> a >> b ; <NEWLINE> if ( a >= 1 & & b <= 100 ) { <NEWLINE> <INDENT> std : : cout << a * b << <STRING> << 2 * ( a + b ) ; <NEWLINE> <DEDENT> } <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> result = [ a * b , a * ( a + b ) ] <NEWLINE> print ( result ) <NEWLINE>
x = raw_input ( ) <NEWLINE> y = raw_input ( ) <NEWLINE> <NL> x = int ( x ) <NEWLINE> y = int ( y ) <NEWLINE> <NL> print x * y 2 * x + 2 * y <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> <NL> y = map ( int , x ) <NEWLINE> <NL> a = y [ 0 ] <NEWLINE> b = y [ 1 ] <NEWLINE> <NL> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> <NL> print ( <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> <INDENT> a = int ( x . split [ 0 ] ) <NEWLINE> b = int ( x . split [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> def P ( x , y ) : <NEWLINE> <INDENT> print ( x * y , 2 * ( x + y ) ) <NEWLINE> return 0 <NEWLINE> <NL> <DEDENT> P ( a , b ) <NEWLINE>
x = raw_input ( ) <NEWLINE> a = int ( x [ 0 : 1 ] ) <NEWLINE> b = int ( x [ 2 : 3 ] ) <NEWLINE> aa = a * 2 + b * 2 <NEWLINE> bb = a * b <NEWLINE> print str ( bb ) + <STRING> + str ( aa ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x , y ) <NEWLINE> x = a * b <NEWLINE> y = a + a + b + b <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = a * b <NEWLINE> d = 2 * ( a + b ) <NEWLINE> print ( c , d ) <NEWLINE> <NL>
a , b = ( int [ input . split ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
data = input ( ) <NEWLINE> len = data . split ( ) <NEWLINE> ans = int ( data [ 0 ] ) * int ( data [ 1 ] ) <NEWLINE> print ( <STRING> . format ( ans ) ) <NEWLINE>
a , b = eval ( input ( ) . replace ( <STRING> , <STRING> ) ) <NEWLINE> print ( <STRING> . format ( a * b , 2 ( a + b ) ) ) <NEWLINE>
list = input ( ) . split ( <STRING> ) <NEWLINE> <NL> x = int ( list [ 0 ] ) * int ( list [ 1 ] ) <NEWLINE> y = ( int ( list [ 0 ] ) + int ( list [ 1 ] ) ) * 2 <NEWLINE> <NL> print ( <STRING> ) . format ( x , y ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( num [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> S = X * y <NEWLINE> L = 2 * ( x + y ) <NEWLINE> print ( S + <STRING> + L ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> c = a * b <NEWLINE> d = 2 * ( a + b ) <NEWLINE> print <STRING> % ( c , d <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> area = a * b <NEWLINE> <NL> longht = 2 * a + 2 * b <NEWLINE> <NL> print ( str ( area ) + <STRING> + str ( longht ) ) <NEWLINE>
list = input ( ) . split ( ) <NEWLINE> print ( list [ 0 ] * list [ 1 ] , list [ 0 ] * 2 + list [ 1 ] * 2 ) <NEWLINE>
a , b = map ( int , raw_input . split ( ) ) <NEWLINE> print a * b ( a + b ) * 2 <NEWLINE>
a = input ( <STRING> ) <NEWLINE> b = input ( <STRING> ) <NEWLINE> print ( a * b ) , ( 2 * a + 2 * b ) <NEWLINE>
line = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> x = int ( line [ 0 ] ) <NEWLINE> y = int ( line [ 1 ] ) <NEWLINE> print ( str ( x * y ) + <STRING> + str ( 2 * x + 2 * y ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> <NL> print ( x * y end = <STRING> 2 * ( x * y ) ) <NEWLINE>
a_b = input ( ) . split ( ) <NEWLINE> a = int ( a_b [ 0 ] ) <NEWLINE> b = int ( a_b [ 1 ] ) <NEWLINE> print ( a * b ( a + b ) * 2 ) <NEWLINE>
<INDENT> l = map ( int , input ( ) . split ( ) ) <NEWLINE> <DEDENT> print ( str ( l [ 0 ] * l [ 1 ] ) + <STRING> + str ( l [ 0 ] * 2 + l [ 1 ] * 2 ) ) <NEWLINE>
values = input ( ) <NEWLINE> height , width = [ int ( x ) for x in values . split ( ) ] <NEWLINE> print ( <STRING> . join ( height * width , height * 2 + width * 2 ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> s = int ( a ) * int ( b ) <NEWLINE> t = ( int ( a ) + int ( b ) ) * 2 <NEWLINE> print ( s , t ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> <NL> print ( c d ) <NEWLINE>
import sys <NEWLINE> <NL> data = int ( input ( ) ) <NEWLINE> data2 = int ( input ( ) ) <NEWLINE> <NL> print ( ( data * data2 ) , 2 * ( data + data2 ) ) <NEWLINE>
a , b = [ int ( i ) for i input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ) <NEWLINE> print ( a * b , 2 * a + 2 * b ) <NEWLINE>
a , b = input ( ) , input ( ) <NEWLINE> print a * b , <NEWLINE> print 2 * a + 2 * b <NEWLINE>
a , b = input . split ( ) <NEWLINE> print str ( a * b ) , str ( ( a + b ) * 2 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> print ( x * y ) <NEWLINE>
( a b ) = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a + b ) * 2 <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> s = a * b <NEWLINE> l = 2 * a + 2 * b <NEWLINE> print ( s , l ) <NEWLINE>
<COMMENT> <NL> <NL> x = input ( ) . split ( ) <NEWLINE> <NL> y = map ( int , x ) <NEWLINE> <NL> a = y [ 0 ] <NEWLINE> b = y [ 1 ] <NEWLINE> <NL> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> <NL> print ( c , d ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> print ( int ( a ) * int ( b ) , <STRING> , int ( a ) * 2 + int ( b ) * 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 a + 2 b ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( a * b , 2 * ( a + b ) ) ) <NEWLINE>
line = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 1 ] ) <NEWLINE> <NL> print ( a * b2 * ( a + b ) ) <NEWLINE>
x , y = map ( int , read ( ) . split ( ) ) <NEWLINE> print ( x * y , 2 * ( x + y ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> var = raw_input ( ) . split ( ) <NEWLINE> rect = int ( var [ 0 ] ) * int ( var [ 1 ] ) <NEWLINE> length = int ( var [ 0 ] ) * 2 + int ( var [ 1 ] ) * 2 <NEWLINE> <NL> print rect + <STRING> + length <NEWLINE>
a , b = map ( int , raw_input ( ) , split ( ) ) <NEWLINE> print a * b , ( a + b ) * 2 <NEWLINE>
A , B = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( A * B , A * 2 + B * 2 ) <NEWLINE>
a , b = [ int ( x ) for x in input ( ) . split ( <STRING> ) ] <NEWLINE> print ( <STRING> ) . format ( a * b , ( a + b ) * 2 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> print ( x * y , 2 * ( x + y ) ) <NEWLINE>
list = ( input ( . split ( <STRING> ) ) <NEWLINE> a = int ( list [ 0 ] ) <NEWLINE> b = int ( list [ 1 ] ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
def temp ( val ) : <NEWLINE> <INDENT> [ a , b ] = val . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( <STRING> . format ( a * b , 2 * a + 2 * b ) ) <NEWLINE> <NL> <DEDENT> temp ( input ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> <NL> <NL> print ( ( x * y ) , ( 2 * x + 2 * y ) ) <NEWLINE> <NL>
<INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <DEDENT> print a * b <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> c = a * b <NEWLINE> d = a * 2 + b * 2 <NEWLINE> <NL> print ( c ) print ( d ) <NEWLINE>
a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> <NL> s = a * b <NEWLINE> <NL> p = 2 * a + 2 * b <NEWLINE> <NL> print ( s , p ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if ( a >= 1 ) or ( b <= 100 ) : <NEWLINE> <INDENT> num = a * b <NEWLINE> length = ( a * 2 ) + ( b * 2 ) <NEWLINE> print ( num + <STRING> + length , end = <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( a , b ) javascript : void ( 0 ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x , y = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> area = x * y <NEWLINE> length = ( x * 2 ) + ( y * 2 ) <NEWLINE> print ( area + <STRING> + length ) <NEWLINE>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> b = [ 0 for i in range ( 2 ) ] <NEWLINE> b [ 0 ] = a [ 0 ] * a [ 1 ] <NEWLINE> b [ 1 ] = ( a [ 0 ] + a [ 1 ] ) * 2 <NEWLINE> print ( * b ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a * b .2 * ( a + b ) <NEWLINE>
input = list ( map ( lambda n : int ( n ) , input ( ) . split ( <STRING> ) ) <NEWLINE> a = input [ 0 ] <NEWLINE> b = input [ 1 ] <NEWLINE> x = a * b <NEWLINE> y = ( a + b ) * 2 <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE>
l = raw_input ( ) . split ( ) <NEWLINE> a = int ( l [ 0 ] ) * int ( l [ 1 ] ) <NEWLINE> b = int ( l [ 0 ] ) * 2 + int ( l [ 1 ] ) * 2 <NEWLINE> print a , b <NEWLINE> <NL> l = raw_input ( ) . split ( ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) <NEWLINE> <NL> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b , end = <STRING> ) <NEWLINE> print ( ( a + b ) * 2 ) <NEWLINE>
x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> <NL> print ( ( a * b ) , ( a + b ) * 2 ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> print ( <STRING> . format ( a * b , 2 * ( a + b ) ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print a * b ( a + b ) * 2 <NEWLINE>
a = int ( iput ( ) ) <NEWLINE> print ( <STRING> ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b + <STRING> + a * 2 + b * 2 ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
n = input ( ) . split ( <STRING> ) <NEWLINE> print ( n [ 0 ] * n [ 1 ] , 2 * ( n [ 0 ] + n [ 1 ] ) ) <NEWLINE>
print ( <STRING> ) <NEWLINE> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b , a * 2 + b * 2 ) <NEWLINE> <NL>
x = int ( input ( ) ) . split <NEWLINE> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> print c , d <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
hj <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> mennseki = a * b <NEWLINE> syuu = ( a + b ) * 2 <NEWLINE> print mennseki , syuu <NEWLINE>
<NL> line = int ( input ( ) . split ) <NEWLINE> <NL> area = line [ 0 ] * line [ 1 ] % 2 <NEWLINE> <NL> peri = line [ 0 ] * 2 + line [ 1 ] * 2 <NEWLINE> <NL> print ( area + <STRING> + peri ) <NEWLINE>
a , b = [ input ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( a , b ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> print ( <STRING> % ( x * y , 2 * ( x + y ) ) ) <NEWLINE>
( a , b ) = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 ( a + b ) ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> s = a * b <NEWLINE> l = 2 * ( a + b ) <NEWLINE> <NL> print s , l <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a * b <NEWLINE> y = ( a + b ) * 2 <NEWLINE> <NL> print ( x , y ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( l [ 0 ] * l [ 1 ] , ( l [ 0 ] + l [ 1 ] ) * 2 ) <NEWLINE>
inputStr = input ( ) <NEWLINE> for i in range ( 0 , len ( in ) ) : <NEWLINE> <INDENT> if ( inputStr [ i ] == <STRING> ) : <NEWLINE> <INDENT> surface = int ( inputStr [ : i ] ) * int ( inputStr [ i + 1 : ] ) <NEWLINE> edge = ( int ( inputStr [ : i ] ) + int ( inputStr [ i + 1 : ] ) ) * 2 <NEWLINE> print ( str ( surface ) + <STRING> + str ( edge ) ) <NEWLINE> <DEDENT> <DEDENT>
x = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( x [ 0 ] * x [ 1 ] x [ 0 ] * 2 + x [ 1 ] * 2 ) <NEWLINE>
x , y = int ( input ( ) . split ( ) ) <NEWLINE> <NL> a = x * y <NEWLINE> b = x ** 2 + y ** 2 <NEWLINE> print ( <STRING> . format ( a , b ) ) <NEWLINE>
A , B = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> print ( A * B , ( A + B ) * 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> c = a * b <NEWLINE> d = 2 * ( a + b ) <NEWLINE> print ( int ( c ) int ( d ) ) <NEWLINE>
x , y = input ( ) . split ( ) <NEWLINE> print ( x * y , x + y * 2 ) <NEWLINE>
x , y = raw_input ( ) . split ( <STRING> ) <NEWLINE> print <STRING> . format ( x * y , ( x + y ) * 2 ) <NEWLINE>
<COMMENT> <NL> a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
print ( ( int ( input ( ) ) + int ( input ( ) ) ) * 2 ) <NEWLINE>
i = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = i [ 0 ] <NEWLINE> b = i [ 1 ] <NEWLINE> print ( <STRING> % ( a * b , ( a + b ) * 2 ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print a * b <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> print ( a * b , 2 ( a + b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a b ) <NEWLINE>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> <NL> a = x * y <NEWLINE> b = 2 * x + 2 * y <NEWLINE> <NL> print a <NEWLINE> print b <NEWLINE>
data = int ( input ( ) . split ( ) ) <NEWLINE> S = data [ 0 ] * data [ 1 ] <NEWLINE> L = 2 * ( data [ 0 ] + data [ 1 ] ) <NEWLINE> print ( int ( S , L ) ) <NEWLINE>
ab = input ( ) <NEWLINE> print ( ab [ 0 ] * ab [ 1 ] , ab [ 0 ] * 2 + ab [ 1 ] * 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE> print ( a * 2 + b * 2 ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> <NL> print ( a * b ) , ( a * 2 + b * 2 ) <NEWLINE>
a = int ( raw_input ( ) ) <NEWLINE> b = int ( raw_input ( ) ) <NEWLINE> print ( str ( a * b ) + <STRING> + str ( ( a + b ) * 2 ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> s = a * b <NEWLINE> shu = a * 2 + b * 2 <NEWLINE> fmt = <STRING> <NEWLINE> s = fmt . format ( s = s , shu = shu ) <NEWLINE> print ( s ) <NEWLINE>
x = input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a - int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
print ( float ( input ( ) ) * float ( input ( ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> x = a * b <NEWLINE> y = 2 a + 2 b <NEWLINE>
m = map ( int , input ( ) . split ( ) ) <NEWLINE> print m [ 0 ] * m [ 1 ] , 2 * ( m [ 0 ] + m [ 1 ] ) <NEWLINE>
cond = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = cond [ 0 ] <NEWLINE> b = cond [ 1 ] <NEWLINE> <NL> print <STRING> <NEWLINE>
a , b = int ( input ( ) ) <NEWLINE> print ( ( a + b ) * 2 , a * b ) <NEWLINE>
import sys <NEWLINE> <NL> input = sys . stdin . read ( ) <NEWLINE> ( a , b ) = [ int ( x ) for x in input . split ( <STRING> ) ] <NEWLINE> <NL> x = a * b <NEWLINE> y = 2 * ( a + b ) <NEWLINE> <NL> print x + <STRING> + y <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
<INDENT> i = input ( ) <NEWLINE> <NL> a , b = i . split ( <STRING> ) <NEWLINE> v , h = int ( a ) , int ( b ) <NEWLINE> <NL> area = v * h <NEWLINE> div = 2 * ( v + h ) <NEWLINE> <NL> print ( <STRING> . join ( [ str ( area ) , str ( div ) ] ) ) <NEWLINE> <DEDENT>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print ( l [ 0 ] * l [ 1 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( l [ 0 ] * 2 + [ 1 ] * 2 ) <NEWLINE>
<INDENT> h , w = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> print ( h * w , 2 * h + 2 * w ) <NEWLINE> <NL>
nums = list ( map ( int , input ( ) . split ( <STRING> ) ) ) <NEWLINE> area = nums [ 0 ] * nums [ 1 ] <NEWLINE> perimeter = nums [ 0 ] * 2 + nums [ 1 ] * 2 <NEWLINE> print ( area + <STRING> + perimeter ) <NEWLINE>
s = int ( input ( ) . split ( ) ) <NEWLINE> print ( int ( s [ 0 ] ) * int ( s [ 1 ] ) , <STRING> , int ( s [ 0 ] * 2 ) + int ( s [ 1 ] * 2 ) ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> <NL> s = a * b <NEWLINE> l = 2 * a + 2 * b <NEWLINE> print ( s , l ) <NEWLINE> <NL> <NL>
x = int ( raw_input ( ) ) <NEWLINE> y = int ( raw_input ( ) ) <NEWLINE> <NL> print x * y , <NEWLINE> print 2 * x + 2 * y <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) <NEWLINE> print a * b , 2 * ( a + b ) <NEWLINE>
<COMMENT> <NL> <NL> def Rectangle ( a , b ) : <NEWLINE> <INDENT> return a * b , 2 * ( a + b ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> area , length = Rectangle ( int ( a ) , int ( b ) ) <NEWLINE> print ( area , length ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> <NL> a , b = input ( ) <NEWLINE> print <STRING> % ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b ( a + b ) * 2 ) <NEWLINE>
s = raw_input ( ) . rstrip . split ( <STRING> ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> print a * b , a * 2 + b * 2 <NEWLINE>
inputRaw = input ( ) <NEWLINE> inputData = inputRaw . split ( <STRING> ) <NEWLINE> <NL> s = inputData [ 0 ] * inputData [ 1 ] <NEWLINE> x = ( inputData [ 0 ] + inputData [ 1 ] ) * 2 <NEWLINE> <NL> print ( str ( s ) & <STRING> & str ( x ) ) <NEWLINE>
ab = input ( ) <NEWLINE> a = ab . split ( <STRING> ) [ 0 ] <NEWLINE> b = ab . split ( <STRING> ) [ 1 ] <NEWLINE> s = a * b <NEWLINE> l = ( a + b ) * 2 <NEWLINE> print ( <STRING> . format ( s , l ) ) <NEWLINE>
a = input ( ) <NEWLINE> a = a . split ( <STRING> ) <NEWLINE> print ( int ( a [ 0 ] ) * int ( a [ 1 ] ) , 2 * ( int ( a [ 0 ] ) + int ( b [ 0 ] ) ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> print ( a * b , 2 * a + 2 * b ) <NEWLINE>
list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print list [ 0 ] * list [ 1 ] 2 * ( list [ 0 ] + list [ 1 ] ) <NEWLINE>
a = raw_input ( ) <NEWLINE> b = raw_input ( ) <NEWLINE> print int ( a ) * int ( b ) <NEWLINE> <NL> print 2 * ( int ( a ) + int ( b ) ) <NEWLINE>
a = int ( input ( ) . split ( <STRING> ) ) <NEWLINE> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE>
<INDENT> n = raw_input ( ) <NEWLINE> a = n . split ( <STRING> ) <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> c = int ( a [ 1 ] ) <NEWLINE> print b * c , ( b + c ) * 2 <NEWLINE> <DEDENT>
<INDENT> 1 x = input ( ) . split ( ) <NEWLINE> 2 a = int ( x [ 0 ] ) <NEWLINE> 3 b = int ( x [ 1 ] ) <NEWLINE> 4 <NEWLINE> 5 print ( a * b , a * 2 + b * 2 ) <NEWLINE> 6 <NEWLINE> <DEDENT>
print ( <STRING> . format ( * ( lambda a : lambda b : [ a * b , a + b ] ) ( int ( input ( ) ) ) ( int ( input ( ) ) ) ) ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( a * b ) <NEWLINE> print ( ( a * 2 + b * 2 ) <NEWLINE>
i = j = 0 <NEWLINE> n = <STRING> <NEWLINE> m = <STRING> <NEWLINE> <NL> <NL> line = input ( ) <NEWLINE> <NL> while line [ i ] != <STRING> : <NEWLINE> <INDENT> n = n + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> while i < len ( line ) : <NEWLINE> <INDENT> m = m + line [ i ] <NEWLINE> i += 1 <NEWLINE> <NL> <DEDENT> n = int ( n ) <NEWLINE> m = int ( m ) <NEWLINE> <NL> print ( n * m 2 * n + 2 * m ) <NEWLINE>
import sys <NEWLINE> argvs = sys . argv <NEWLINE> a = int ( argvs [ 1 ] ) <NEWLINE> b = int ( argvs [ 2 ] ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
lis = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( str ( lis [ 0 ] * lis [ 1 ] ) + <STRING> + str ( ( lis [ 0 ] + lis [ 1 ] ) * 2 ) <NEWLINE>
x = input ( <STRING> ) <NEWLINE> x2 = x . split ( ) <NEWLINE> result = x2 [ 0 ] * x2 [ 1 ] <NEWLINE> result2 = x2 [ 0 ] * 2 + x2 [ 1 ] * 2 <NEWLINE> print ( result , result2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( <STRING> . format ( a * b , 2 ( a + b ) ) ) <NEWLINE>
a , b = map [ int , input ( ) . split ( ) ] <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b , <STRING> , 2 * ( a + b ) ) <NEWLINE>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print , a [ 0 ] * a [ 1 ] , 2 * a [ 0 ] + 2 * a [ 1 ] <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE> <NL> <NL>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) : ) <NEWLINE> <NL> print a * b , a * 2 + b * 2 <NEWLINE>
a , b = map ( int , input ( ) . split ( ) <NEWLINE> area = a * b <NEWLINE> perimeter = 2 * ( a + b ) <NEWLINE> print ( area , perimeter ) <NEWLINE>
import re <NEWLINE> <NL> t = re . search ( <STRING> , input ( <STRING> ) ) <NEWLINE> <NL> a = t . group ( 1 ) <NEWLINE> b = t . group ( 2 ) <NEWLINE> <NL> x = a * b <NEWLINE> y = a * 2 + b * 2 <NEWLINE> <NL> print ( x , y ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( a * b , ( a + b ) * 2 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> M = a * b <NEWLINE> print ( M ) <NEWLINE>
print int ( a * b ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a * b , ( a + b ) * 2 <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * a + 2 * b ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print a * b <NEWLINE> print a * 2 + b * 2 <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <COMMENT> <NEWLINE> print a * b , 2 * ( a + b ) <NEWLINE>
import sys <NEWLINE> a , b = map ( int ( sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> print ( a * b , 2 ( a + b ) ) <NEWLINE>
s = split ( input ( ) ) <NEWLINE> a = int ( s [ 0 ] ) <NEWLINE> b = int ( s [ 1 ] ) <NEWLINE> x = a * b <NEWLINE> y = 2 * ( a + b ) <NEWLINE> print ( x , y ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> S = a * b <NEWLINE> L = 2 * ( a + b ) <NEWLINE> print ( S , end = <STRING> ) <NEWLINE> print ( L ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> a = l [ 0 ] * l [ 1 ] <NEWLINE> b = ( l [ 0 ] + l [ 1 ] ) * 2 <NEWLINE> <NL> print ( a b ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> def main ( ) : <NEWLINE> <INDENT> a = int ( raw_input ( ) ) <NEWLINE> b = int ( raw_input ( ) ) <NEWLINE> <NL> print a * b , ( a + b ) * 2 <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = raw_input ( ) . split ( ) <NEWLINE> y = map ( int , x ) <NEWLINE> a = y [ 0 ] <NEWLINE> b = y [ 1 ] <NEWLINE> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> print c , d <NEWLINE>
a = ( int , input ( ) . split ( ) ) <NEWLINE> b = ( int , input ( ) . split ( ) ) <NEWLINE> print ( ( a * b ) , ( a + b ) * 2 ) <NEWLINE>
data_str = input ( ) <NEWLINE> data = data_str . split ( <STRING> ) <NEWLINE> print ( int ( data [ 0 ] ) * int ( data [ 1 ] ) + <STRING> + 2 * ( int ( data [ 0 ] ) + int ( data [ 1 ] ) ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( str ( a * b ) + <STRING> + str ( ( a + b ) * 2 ) ) <NEWLINE>
inport sys <NEWLINE> <NL> x = sys . stdin . readline ( ) <NEWLINE> <NL> a , b = x . split ( <STRING> ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> S = a * b <NEWLINE> l = 2 * ( a + b ) <NEWLINE> <NL> print <STRING> % ( S , l ) <NEWLINE>
a = int ( input ( <STRING> ) ) b = int ( input ( <STRING> ) ) <NEWLINE> area = a * b <NEWLINE> lenght = 2 * a + 2 * b <NEWLINE> print ( area ) print ( lenght ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print a * b , 2 * a + 2 * b <NEWLINE>
a , b = input ( ) , input ( ) <NEWLINE> print str ( a * b ) + <STRING> + str ( ( a + b ) * 2 ) <NEWLINE>
<COMMENT> <NL> int main ( void ) { <NEWLINE> <INDENT> int x ; <NEWLINE> <NL> <INDENT> scanf ( <STRING> , & x ) ; <NEWLINE> printf ( <STRING> , x * x * x ) ; <NEWLINE> <NL> return 0 ; <NEWLINE> <NL> <DEDENT> <DEDENT> } <NEWLINE>
input = raw_input ( ) <NEWLINE> s = int ( input . split ( ) [ 0 ] ) <NEWLINE> l = int ( input . split ( ) [ 1 ] ) <NEWLINE> ans_1 = s * l <NEWLINE> ans_2 = 2 * ( s + l ) <NEWLINE> <NL> print src ( ans_1 ) + <STRING> + src ( ans_2 ) <NEWLINE>
lis = 0 <NEWLINE> S = 0 <NEWLINE> L = 0 <NEWLINE> lis = input ( ) . split ( ) <NEWLINE> S = int ( lis [ 0 ] ) * int ( lis [ 1 ] ) <NEWLINE> L = int ( lis [ 0 ] ) * 2 + int ( lis [ 1 ] * 2 ) <NEWLINE> print ( S L ) <NEWLINE>
a , b = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
x = int ( input ( x , y ) ) <NEWLINE> print ( x * y ) <NEWLINE>
nums = input ( ) . sprit ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> print ( int ( a ) * int ( b ) 2 * ( int ( a ) + int ( b ) ) ) <NEWLINE>
x_y = raw_input ( ) . split ( <STRING> ) <NEWLINE> print int ( x_y [ 0 ] ) * int ( x_y [ 1 ] ) , <NEWLINE> print <STRING> , <NEWLINE> print int ( x_y [ 0 ] ) * 2 + int ( x_y [ 1 ] ) * 2 <NEWLINE>
a , b = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print str ( a * b ) + <STRING> str ( 2 * a + 2 * b ) <NEWLINE>
a , b = [ int ( x ) for x in input . split ( ) ] <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a = raw_input ( ) <NEWLINE> x , y = a . split ( <STRING> ) <NEWLINE> n = int ( a [ 0 ] ) <NEWLINE> m = int ( a [ 1 ] ) <NEWLINE> S = n * m <NEWLINE> SUM = n * 2 + m * 2 <NEWLINE> print S + <STRING> + SUM <NEWLINE>
x = int ( input ( ) ) <NEWLINE> y = int ( input ( ) ) <NEWLINE> print ( x * y ) <NEWLINE>
x = int ( input ( ) . split ( <STRING> ) ) <NEWLINE> a = x [ 0 ] * x [ 1 ] <NEWLINE> b = x [ 0 ] + x [ 1 ] + x [ 0 ] + x [ 1 ] <NEWLINE> print ( str ( a ) + str ( b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if ( 3 <= a <= 5 ) and ( 3 <= b <= 5 ) : <NEWLINE> <INDENT> print ( a * b ) <NEWLINE> <DEDENT>
a , b = ( raw_input ( ) . split ( ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( <STRING> , % ( a * b , ( a + b ) * 2 ) ) <NEWLINE>
<COMMENT> <NL> <NL> x = map ( int , raw_input ( ) , split ( ) ) <NEWLINE> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> <NL> R = a * b <NEWLINE> P = 2 * a + 2 * b <NEWLINE> A = str ( R ) + <STRING> + str ( P ) <NEWLINE> <NL> print ( A ) <NEWLINE>
import sys <NEWLINE> a , b = sys . stdin . split ( <STRING> ) <NEWLINE> a , b = int ( a ) , int ( b ) <NEWLINE> print <STRING> % ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a * b .2 * ( a + b ) ) <NEWLINE>
a , b = map ( int , [ i for i in input ( ) . split ( <STRING> ) ] ) <NEWLINE> print a * b , ( a + b ) * 2 <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> s = a * b <NEWLINE> l = 2 * ( a + b ) <NEWLINE> <NL> print <STRING> % ( s , l ) <NEWLINE>
s = input ( ) <NEWLINE> ss = s . plit ( <STRING> ) <NEWLINE> a = int ( ss [ 0 ] ) <NEWLINE> b = int ( ss [ 1 ] ) <NEWLINE> print ( <STRING> . format ( a * b , 2 * ( a + b ) ) <NEWLINE> <NL>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> 3 5 <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a * b , 2 * ( a + b ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> <NL> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> <NL> print ( ( a * b ) , ( a + b ) * 2 ) ) <NEWLINE>
a . b = int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( a * b . a + a + b + b ) <NEWLINE>
row = input ( ) . split ( ) <NEWLINE> print ( row [ 0 ] * row [ 1 ] , 2 * ( row [ 0 ] + row [ 1 ] ) ) <NEWLINE> <NL>
InputData = [ ] <NEWLINE> while True : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> in1 , in2 = map ( int , raw_input ( ) . split ( <STRING> ) ) <COMMENT> <NEWLINE> if in1 == 0 and in2 == 0 : break <NEWLINE> InputData . append ( [ in1 , in2 ] ) <NEWLINE> <DEDENT> except EOFError : <NEWLINE> <INDENT> break <NEWLINE> <NL> <DEDENT> <DEDENT> for i in range ( len ( InputData ) ) : <NEWLINE> <INDENT> in1 , in2 = InputData [ i ] <NEWLINE> x = int ( in1 ) * int ( in2 ) <NEWLINE> y = int ( in1 ) + int ( in2 ) + int ( in1 ) + int ( in2 ) <NEWLINE> ) <NEWLINE> print ( x y ) <NEWLINE> <DEDENT>
x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <NL> print x * y , ( x + y ) * 2 <NEWLINE>
import fileinput <NEWLINE> <NL> for line in fileinput . input ( ) : <NEWLINE> <INDENT> a , b = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( a * b , 2 a + 2 b ) ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
z = input ( ) <NEWLINE> m , l = z . split ( ) <NEWLINE> s = int ( m ) * int ( l ) <NEWLINE> n = int ( m ) * 2 + int ( l ) * 2 <NEWLINE> <NL> print ( { } { } . format ( str ( s ) , str ( n ) ) ) <NEWLINE>
x = raw_input ( ) . split ( ) <NEWLINE> <NL> y = map ( int , x ) <NEWLINE> <NL> a = y [ 0 ] <NEWLINE> b = y [ 1 ] <NEWLINE> <NL> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> <NL> print c , d <NEWLINE>
input = input ( ) <NEWLINE> a , b = input . split ( ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
<INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( a * b , 2 * a + 2 * b ) ) <NEWLINE> <NL> <DEDENT>
n = input ( ) <NEWLINE> k = n . split ( <STRING> ) <NEWLINE> a = int ( k [ 0 ] ) <NEWLINE> b = int ( k [ 1 ] ) <NEWLINE> print a * b , <NEWLINE> print ( a + b ) * 2 <NEWLINE>
<COMMENT> <NL> <NL> line = input ( ) <NEWLINE> lines = line . split ( <STRING> ) <NEWLINE> <NL> a = lines [ 0 ] <NEWLINE> b = lines [ 1 ] <NEWLINE> <NL> print ( <STRING> , ( a + b ) * 2 , a * b ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( ab [ 0 ] ) <NEWLINE> b = int ( ab [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( ( a * b ) , 2 * ( a + b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE> print ( 2 * ( a + b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + B ) ) <NEWLINE>
print a * b , <NEWLINE> print a + a + b + b <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> c = a * b <NEWLINE> d = ( a * 2 ) + ( b * 2 ) <NEWLINE> print ( c , d ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> square = int ( a ) * int ( b ) <NEWLINE> length = int ( a ) * 2 + int ( b ) * 2 <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> print ( square , length ) <NEWLINE>
n = raw_input ( ) <NEWLINE> a = n . split ( <STRING> ) <NEWLINE> b = int ( a [ 0 ] ) <NEWLINE> c = int ( a [ 1 ] ) <NEWLINE> print b * c ( b + c ) * 2 <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( l [ 0 ] * l [ 1 ] ) , ( ( l [ 0 ] + l [ 1 ] ) * 2 ) <NEWLINE>
a , b = list ( map ( int , split . ( ) ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> area = a * b <NEWLINE> mawari_length = ( a + b ) * 2 <NEWLINE> print ( area , mawari_length ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> x = a * b <NEWLINE> y = 2 * a + 2 * b <NEWLINE> print ( x ) <NEWLINE> print ( y ) <NEWLINE>
a = raw_input ( ) <NEWLINE> b = raw_input ( ) <NEWLINE> print int ( a ) * int ( b ) , 2 * ( int ( a ) + int ( b ) ) <NEWLINE>
x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> <NL> print ( ( a * b ) , ( ( a + b ) * 2 ) ) <NEWLINE>
def numinput ( ) : <NEWLINE> <INDENT> a = input ( ) . split ( ) <NEWLINE> for i in range ( len ( a ) ) : <NEWLINE> <INDENT> a [ i ] = int ( a [ i ] ) <NEWLINE> <DEDENT> return a <NEWLINE> <NL> <DEDENT> def main ( ) : <NEWLINE> <INDENT> a = numinput ( ) <NEWLINE> print ( <STRING> % ( a [ 0 ] * a [ 1 ] , 2 * ( a [ 0 ] + a [ 1 ] ) ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
x = input ( ) <NEWLINE> x = x . split ( ) <NEWLINE> x [ 0 ] = int ( x [ 0 ] ) <NEWLINE> x [ 1 ] = int ( x [ 1 ] ) <NEWLINE> <INDENT> print ( x [ 0 ] * x [ 1 ] , x [ 0 ] * 2 + x [ 1 ] * 2 ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> m = a * b <NEWLINE> s = a * 2 + b * 2 <NEWLINE> print ( s , m ) <NEWLINE>
input_str = input ( ) <NEWLINE> <NL> split_list = input_str . split ( ) <NEWLINE> <NL> print ( ( int ( split_list [ 0 ] ) * int ( split_list [ 1 ] ) , ( int ( split_list [ 0 ] ) * 2 + int ( split_list [ 1 ] ) * 2 ) ) <NEWLINE>
a = float ( input ( ) ) <NEWLINE> b = float ( input ( ) ) <NEWLINE> print ( a * b , <STRING> , 2 * ( a + b ) ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) . strip ( ) ) <NEWLINE> s = x * y <NEWLINE> p = 2 * ( x + y ) <NEWLINE> print ( <STRING> % ( s , p ) ) <NEWLINE>
x = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( str ( x [ 0 ] * x [ 1 ] ) + <STRING> + str ( 2 * x [ 0 ] + 2 * x [ 1 ] ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b + <STRING> + 2 * ( a + b ) ) <NEWLINE>
a , b = raw_input ( ) . sprit ( ) . split ( <STRING> ) <NEWLINE> print int ( a ) * int ( b ) <NEWLINE>
item = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( item [ 0 ] * item [ 1 ] + <STRING> + 2 * ( item [ 0 ] + item [ 1 ] ) ) <NEWLINE>
a = int ( raw_input ( ) ) <NEWLINE> b = int ( raw_input ( ) ) <NEWLINE> <NL> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) , print ( 2 * ( a + b ) ) <NEWLINE> <NL>
a , b = input ( ) . split ( ) ) <NEWLINE> area = a * b <NEWLINE> circumference = 2 * a + 2 * b <NEWLINE> print ( area + <STRING> + circumference ) <NEWLINE>
[ a , b ] = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * ) <NEWLINE>
s = input ( ) <NEWLINE> x = s . split ( ) <NEWLINE> <NL> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> <NL> print ( a * b , 2 * ( a + b ) <NEWLINE>
data = input ( ) . split ( ) <NEWLINE> a = data [ 0 ] <NEWLINE> b = data [ 1 ] <NEWLINE> print ( int ( a ) * int ( b ) , 2 * ( int ( a ) + int ( b ) ) <NEWLINE>
w = input ( ) <NEWLINE> h = input ( ) <NEWLINE> w = int ( w ) <NEWLINE> h = int ( h ) <NEWLINE> print ( w * h , 2 * w + 2 * h ) <NEWLINE>
a , b = [ int ( x ) for i in input ( ) . split ( ) ] <NEWLINE> m = a * b <NEWLINE> n = a * 2 + b * 2 <NEWLINE> print ( m , n ) <NEWLINE>
l = raw_input ( ) . split ( ) <NEWLINE> print l [ 0 ] * l [ 1 ] , 2 * l [ 0 ] + 2 * l [ 1 ] <NEWLINE>
a = input ( ) <NEWLINE> b = split ( a ) <NEWLINE> d = list ( ) <NEWLINE> for c in b : <NEWLINE> <INDENT> d . append ( int ( c ) ) <NEWLINE> <DEDENT> print ( d [ 0 ] * d [ 1 ] , 2 * d [ 0 ] + 2 * d [ 1 ] ) <NEWLINE>
a , b = map ( int , ( input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
n = raw_input ( ) <NEWLINE> k = n . split ( <STRING> ) <NEWLINE> a = int ( k [ 0 ] ) <NEWLINE> b = int ( k [ 1 ] ) <NEWLINE> print a * b , print ( a + b ) * 2 <NEWLINE>
num = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( num [ 0 ] * num [ 1 ] end = <STRING> ) <NEWLINE> print ( num [ 0 ] * 2 + num [ 1 ] * 2 ) <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> <NL> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( ( a * b ) , 2 * ( a + b ) ) <NEWLINE>
a = raw_input ( ) . split ( ) <NEWLINE> area = a [ 0 ] * a [ 1 ] <NEWLINE> length = 2 * ( a [ 0 ] + a [ 1 ] ) <NEWLINE> print area , length <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a * b 2 * ( a + b ) <NEWLINE>
data = int ( input ( ) . split ( ) ) <NEWLINE> a = data [ 0 ] <NEWLINE> b = data [ 1 ] <NEWLINE> print ( a * b , end = <STRING> ) <NEWLINE> print ( a * 2 + b * 2 , end = <STRING> ) <NEWLINE>
x , y = [ int ( i ) for i in input ( num ) . split ( ) ] <NEWLINE> print ( x * y , ( x + y ) * 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 <NEWLINE>
a , b = map ( int , split ( ) ) <NEWLINE> print ( str ( a * b ) + str ( a * 2 + b * 2 ) ) <NEWLINE>
n = raw_input ( ) <NEWLINE> <NL> a = int ( n . split ( ) ) <NEWLINE> <NL> b = a [ 0 ] * a [ 1 ] <NEWLINE> <NL> c = ( a [ 0 ] + a [ 1 ] ) * 2 <NEWLINE> <NL> print b , c <NEWLINE>
a , b [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , input ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
params = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> square = int ( params [ 0 ] ) * int ( params [ 1 ] ) <NEWLINE> length = ( int ( params [ 0 ] ) + int ( params [ 1 ] ) ) * 2 <NEWLINE> <NL> print ( square , length ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> men = l [ 0 ] * l [ 1 ] <NEWLINE> shu = ( l [ 0 ] + l [ 1 ] ) * 2 <NEWLINE> <NL> print ( str ( men ) + <STRING> + str ( shu ) <NEWLINE>
a , b = map ( int , raw_input ( ) , split ( ) ) <NEWLINE> print a * b , ( a + b ) * 2 <NEWLINE>
input ( a , b ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
a = nums [ 0 ] <NEWLINE> b = nums [ 1 ] <NEWLINE> print a * b 2 * ( a + b ) <NEWLINE>
a , b = [ int x for in input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a * b ) * 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE> print ( 2 * a + 2 * b ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 ( a + b ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b + <STRING> + ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b , 2 a + 2 b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( r , l ) <NEWLINE> r = a * b <NEWLINE> l = 2 * ( a + b ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> area = a * b <NEWLINE> perimeter = 2 * ( a + b ) <NEWLINE> print ( area & <STRING> & perimeter ) <NEWLINE>
a , b = map ( input ( ) , input ( ) . split ( ) ) <NEWLINE> <NL> ans1 = a * b <NEWLINE> ans2 = 2 * ( a + b ) <NEWLINE> <NL> print ans1 , ans2 <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) ; <NEWLINE> <NL> print <STRING> % ( 2 * ( a + b ) , a * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print a * b , 2 * ( a + b ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( ( int ( a ) * int ( b ) , ( int ( a ) * 2 ) + ( int ( b ) * 2 ) ) ) <NEWLINE>
n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print n [ 0 ] * n [ 1 ] <STRING> n [ 0 ] * 2 + n [ 1 ] * 2 <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> return a * b , 2 * ( a + b ) <NEWLINE>
x = int ( raw_input ( ) ) <NEWLINE> y = int ( raw_input ( ) ) <NEWLINE> print x * y <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a * b <NEWLINE> t = a * 2 + b * 2 <NEWLINE> print ( s t ) <NEWLINE>
print ( a * b , 2 * ( a + b ) , <STRING> ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> S = l [ 0 ] * l [ 1 ] <NEWLINE> N = l [ 0 ] * 2 + l [ 1 ] * 2 <NEWLINE> <NL> print ( str ( S ) + str ( N ) ) <NEWLINE>
<COMMENT> <NL> <NL> a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> x = a * b <NEWLINE> y = 2 * ( a + b ) <NEWLINE> <NL> print int ( x ) <NEWLINE> print int ( y ) <NEWLINE> <NL>
line = raw_input ( ) <NEWLINE> a = line . split ( ) <NEWLINE> s = a [ 0 ] * a [ 1 ] <NEWLINE> len = 2 * ( a [ 0 ] + a [ 1 ] ) <NEWLINE> print str ( s ) + <STRING> + str ( len ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print a * b + 2 * ( a + b ) <NEWLINE>
import sys <NEWLINE> <NL> a , b = list ( map ( int , sys . stdin . readline ( ) , split ( ) ) ) <NEWLINE> <NL> print ( a * b , 2 * a + 2 * b ) <NEWLINE>
a , b = list ( map ( int , input ( ) ) ) <NEWLINE> c = a * b <NEWLINE> d = 2 * ( a + b ) <NEWLINE> print ( <STRING> . format ( c , d ) ) <NEWLINE>
a = input ( ) . split ( <STRING> ) <NEWLINE> print ( int ( a [ 0 ] ) * int ( a [ 1 ] ) , end = <STRING> ) <NEWLINE> print ( int ( a [ 0 ] ) * 2 + int ( a [ 1 ] ) * 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> c = a * b <NEWLINE> d = 2 * a + 2 * b <NEWLINE> <NL> print ( str ( c ) + <STRING> + str ( d ) ) <NEWLINE> <NL>
x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> z = x [ 0 ] * x [ 1 ] <NEWLINE> a = ( x [ 0 ] + x [ 1 ] ) * 2 <NEWLINE> print ( z , a ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b 2 * a + 2 * b ) <NEWLINE>
x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> <NL> print x * y , ( x + y ) * 2 <NEWLINE>
atai = input ( ) . split ( ) <NEWLINE> a = ( atai [ 0 ] ) <NEWLINE> b = ( atai [ 1 ] ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
import math <NEWLINE> <NL> data = input ( ) <NEWLINE> data1 = input ( ) <NEWLINE> <NL> data = int ( data ) <NEWLINE> data1 = int ( data1 ) <NEWLINE> print ( data * data1 , <STRING> , data * 2 + data1 * 2 ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE> <NL> <NL>
z = input ( ) <NEWLINE> <NL> z = z . split ( ) <NEWLINE> <NL> a = z [ 0 ] * z [ 1 ] <NEWLINE> b = z [ 0 ] * 2 + z [ 1 ] * 2 <NEWLINE> print ( a + <STRING> + b ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> m = a * b <NEWLINE> l = 2 * a + 2 * b <NEWLINE> <NL> print ( m l ) <NEWLINE>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a [ 0 ] * a [ 1 ] ) <NEWLINE> print ( <STRING> ) <NEWLINE> print ( a [ 0 ] * 2 + a [ 1 ] * 2 ) <NEWLINE>
input_a = input ( ) <NEWLINE> input_b = input ( ) <NEWLINE> <NL> print ( input_a * input_b , <STRING> , 2 * input_a + 2 * input_b ) <NEWLINE>
<COMMENT> <NL> a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> S = a * b <NEWLINE> L = 2 * ( a + b ) <NEWLINE> print ( s , l ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ) <NEWLINE> print a * b , 2 * a + 2 * b <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> print ( str ( a * b ) + <STRING> + str ( 2 * ( a + b ) ) ) <NEWLINE>
a , b = map ( int , input ( ) . sep ( ) ) <NEWLINE> <NL> men = a * b <NEWLINE> hen = ( a + b ) * 2 <NEWLINE> <NL> print ( int ( men ) , int ( hen ) ) <NEWLINE>
A , B = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> print ( str ( w * h ) + <STRING> + str ( ( w + h ) * 2 ) ) <NEWLINE>
a = input ( ) ; <NEWLINE> b = input ( ) ; <NEWLINE> d = a * b ; <NEWLINE> l = 2 * ( a + b ) ; <NEWLINE> print d l ; <NEWLINE>
l = raw_input ( ) . split ( <STRING> ) <NEWLINE> a , b = int ( l [ 0 ] ) , int ( l [ 1 ] ) <NEWLINE> print a * b + <STRING> + 2 * a + 2 * b <NEWLINE>
a . b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
<COMMENT> <NL> a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> menseki = a * b <NEWLINE> <NL> print ( menseki , a * 2 + b * 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
a = input ( ) <NEWLINE> ptint ( a ) <NEWLINE>
data = list ( map ( int , input . split ( ) ) ) <NEWLINE> print data [ 0 ] * data [ 1 ] <NEWLINE>
a , b = map ( int , input ( ) , split ) <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print a * b <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a * b ( a + b ) * b <NEWLINE>
a , b = [ int ( i ) for i in input . split ( ) ] <NEWLINE> print ( a * b , a * 2 + b * 2 ) <NEWLINE>
x = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> print a * b , 2 * ( a + b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> area = a * b <NEWLINE> perimeter = ( a + b ) * 2 <NEWLINE> ptint ( str ( area ) + <STRING> + str ( perimeter ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> s = int ( ( a + b ) * 2 ) <NEWLINE> m = int ( a * b ) <NEWLINE> print ( m , s ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> s = a * b <NEWLINE> l = 2 * ( a + b ) <NEWLINE> <NL> return s , l <NEWLINE>
num = raw_input ( ) <NEWLINE> num = numbers . split ( ) <NEWLINE> a = int ( num [ 0 ] ) <NEWLINE> b = int ( num [ 1 ] ) <NEWLINE> <NL> print a * b , 2 * ( a + b ) <NEWLINE>
h , w = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( <STRING> % ( h * w , h * 2 + w * 2 ) ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print a * b , ( a + b ) * 2 <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = a * b <NEWLINE> l = a * 2 + b * 2 <NEWLINE> print ( s + <STRING> + l ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( a * b ) <NEWLINE> print ( 2 * a + 2 * b ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( <STRING> . format ( a * b , 2 * ( a + b ) ) <NEWLINE>
i = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = i [ 0 ] * i [ 1 ] <NEWLINE> b = 2 * ( i [ 0 ] + i [ 1 ] ) <NEWLINE> print ( <STRING> . format ( a . b ) ) <NEWLINE>
params = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> square = int ( params [ 0 ] ) * int ( params [ 1 ] ) <NEWLINE> length = ( int ( params [ 0 ] ) + int ( params [ 1 ] ) ) * 2 <NEWLINE> <NL> print ( square , length ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> men = a * b <NEWLINE> hen = 2 * ( a + b ) <NEWLINE> <NL> print ( men + <STRING> + hen ) <NEWLINE>
x , y = input ( ) . split ( ) <NEWLINE> print ( x * y , x * 2 + y * 2 ) <NEWLINE>
import sys <NEWLINE> argv = sys . argv <NEWLINE> x = int ( argv [ 1 ] ) <NEWLINE> y = int ( argv [ 2 ] ) <NEWLINE> print x * y , <NEWLINE> print <STRING> , <NEWLINE> print 2 * x + 2 * y <NEWLINE>
a , b = raw_input ( ) . split ( ) <NEWLINE> S = a * b <NEWLINE> O = 2 * a + 2 * b <NEWLINE> <NL> print str ( S ) + <STRING> + str ( O ) <NEWLINE>
import sys <NEWLINE> <NL> ( a , b ) = [ int ( i ) for i in sys . readline ( ) . split ( ) ] <NEWLINE> print ( <STRING> % ( a * b , ( a + b ) * 2 ) ) <NEWLINE>
A , B = map ( int , input ( ) . sprit ( ) ) <NEWLINE> print ( A * B , 2 * ( A + B ) ) <NEWLINE>
a = int ( input ( ) . split ( ) ) <NEWLINE> print ( a [ 1 ] * a [ 0 ] , ( a [ 1 ] + a [ 0 ] ) * 2 ) <NEWLINE>
a = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print a [ 0 ] * a [ 1 ] 2 * a [ 0 ] + 2 * a [ 1 ] <NEWLINE>
a = [ int ( item ) for item in input ( ) . split ( ) ] <NEWLINE> <NL> print ( 2 * ( a [ 0 ] + a [ 1 ] ) + <STRING> + a [ 0 ] * a [ 1 ] ) <NEWLINE>
l = raw_input ( ) . split ( ) <NEWLINE> s = l [ 0 ] * l [ 1 ] <NEWLINE> y = ( l [ 0 ] + l [ 1 ] ) * 2 <NEWLINE> print s , <NEWLINE> print <STRING> y <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
l = input ( ) . split ( ) <NEWLINE> print ( int ( l [ 0 ] ) * int ( l [ 1 ] ) , 2 * int ( l [ 0 ] ) + 2 * int ( l [ 1 ] ) <NEWLINE>
a , b = int ( input ( ) ) . split ( ) <NEWLINE> print ( a * b + <STRING> + ( a * 2 + b * 2 ) ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> print ( <STRING> % ( int ( a ) * int ( b ) , 2 * int ( a ) + 2 * int ( b ) ) ) <NEWLINE>
line = input ( ) . split ( ) <NEWLINE> a = int ( line [ 0 ] ) <NEWLINE> b = int ( line [ 1 ] ) <NEWLINE> print ( srt ( a * b ) + <STRING> + str ( ( a + b ) * 2 ) ) <NEWLINE>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> c = a * b <NEWLINE> d = ( a + b ) * 2 <NEWLINE> print c + <STRING> + d <NEWLINE>
a , b = raw_input . split . map <NEWLINE> print a * b <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> area = a * b <NEWLINE> line = 2 * ( a + b ) <NEWLINE> ptint ( area , line ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( str ( a * b ) + <STRING> + ( a + b ) * 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( str ( a * b ) + <STRING> , end = <STRING> ) <NEWLINE> print ( a * 2 + b * 2 ) <NEWLINE>
a , b = map ( int , input ( ) , split ( ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int ( input ( ) . split ( ) ) ) <NEWLINE> print a * b + <STRING> + 2 ( * ( a + b ) <NEWLINE>
spam = input ( ) . split ( <STRING> ) <NEWLINE> print ( <STRING> . join ( spam [ 0 ] * spam [ 1 ] , 2 * ( spam [ 0 ] + spam [ 1 ] ) ) ) <NEWLINE>
ab = int ( input ( ) . split ( ) ) <NEWLINE> print ( ab [ 0 ] * ab [ 1 ] , ab [ 0 ] * 2 + ab [ 1 ] * 2 , sep = <STRING> ) <NEWLINE>
x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> print ( x * b , x * 2 + y * 2 ) <NEWLINE>
using namespace std ; <NEWLINE> <NL> main ( ) { <NEWLINE> <INDENT> int a , b ; <NEWLINE> int area , length ; <NEWLINE> <NL> <INDENT> cin >> a >> b ; <NEWLINE> <NL> <DEDENT> area = a * b ; <NEWLINE> length = 2 * ( a + b ) ; <NEWLINE> <NL> <INDENT> cout << area << <STRING> << length << endl ; <NEWLINE> <NL> <NL> <NL> <DEDENT> <DEDENT> } <NEWLINE>
ab = [ int ( n ) for n in input ( ) . split ( ) ] <NEWLINE> <NL> S = ab [ 0 ] * ab [ 1 ] <NEWLINE> L = 2 * ab [ 0 ] + 2 * ab [ 1 ] <NEWLINE> <NL> print ( <STRING> . join ( str , map ( [ S , L ] ) ) ) <NEWLINE> <NL>
n = input ( ) . split ( ) <NEWLINE> a = int ( n [ 0 ] ) <NEWLINE> b = int ( n [ 1 ] ) <NEWLINE> print ( a * b ( a + b ) * 2 ) <NEWLINE>
a , b = int ( input ( x ) for x in input ( ) . split ( ) ) <NEWLINE> print ( ( a * b ) / 2 , ( a + b ) * 2 ) <NEWLINE> <NL>
a , b = input ( ) . split ( ) <NEWLINE> s = a * b <NEWLINE> shu = a * 2 + b * 2 <NEWLINE> fmt = <STRING> <NEWLINE> s = fmt . format ( s = s , shu = shu ) <NEWLINE> print ( s ) <NEWLINE>
x = int ( input ( ) . split ( ) ) <NEWLINE> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> print ( str ( a * b ) + <STRING> + str ( 2 * ( a + b ) ) ) <NEWLINE>
a = raw_input ( ) <NEWLINE> x = int ( a [ 0 ] ) <NEWLINE> y = int ( a [ 2 ] ) <NEWLINE> s = x * y <NEWLINE> l = 2 * x + 2 * y <NEWLINE> print s , l <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> area = a * b <NEWLINE> shu = 2 ( a + b ) <NEWLINE> print ( area , shu ) <NEWLINE>
x = raw_input ( ) . split ( ) <NEWLINE> print x [ 0 ] * x [ 1 ] , ( x [ 0 ] + x [ 1 ] ) * 2 <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> pritn ( a * b 2 ( a + b ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> print ( ( a * b ) ( a + b ) * 2 ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> print ( str ( a * b ) + <STRING> + str ( a * 2 + b * 2 ) ) <NEWLINE>
n , k = int ( raw_input ( ) ) , int ( raw_input ( ) ) <NEWLINE> s = n * k <NEWLINE> l = 2 * ( n + k ) <NEWLINE> print s , l <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <COMMENT> <NEWLINE> <NL> print a * b , 2 * ( a + b ) <NEWLINE>
l = map ( int , input ( ) . split ( ) ) <NEWLINE> print l [ 0 ] <NEWLINE> print l [ 1 ] <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> S = a * b <NEWLINE> C = 2 * ( a + b ) <NEWLINE> <NL> print ( S + <STRING> + C ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> print ( a * b ( a * 2 ) + ( b * 2 ) ) <NEWLINE>
import sys <NEWLINE> param = input ( ) . split ( ) <NEWLINE> menseki = int ( param [ 0 ] ) * int ( param [ 1 ] ) <NEWLINE> nagasa = int ( param [ 0 ] ) * 2 + int ( param [ 1 ] ) * 2 <NEWLINE> print ( menseki nagasa ) <NEWLINE>
<COMMENT> <NL> <NL> x , y = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> w = x * y <NEWLINE> z = 2 * x + 2 * y <NEWLINE> <NL> print ( w , z ) <NEWLINE> <NL>
x1 = input ( ) <NEWLINE> x2 = input ( ) <NEWLINE> x1 = int ( x1 ) <NEWLINE> x2 = int ( x2 ) <NEWLINE> x3 = x1 + x2 <NEWLINE> print ( x3 ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a * b ) <NEWLINE>
x = str ( input ( ) ) <NEWLINE> n = x . split ( <STRING> , 2 ) <NEWLINE> a = n [ 0 ] <NEWLINE> b = n [ 1 ] <NEWLINE> ab = a * b <NEWLINE> a_b = ( a + b ) * 2 <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) , split ( ) ] <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
print ( str ( a * b ) + <STRING> str ( ( a + b ) * 2 ) ) <NEWLINE>
width = float ( input ( <STRING> ) ) <NEWLINE> height = float ( input ( <STRING> ) ) <NEWLINE> <COMMENT> <NL> Area = width * height <NEWLINE> <NL> <COMMENT> <NL> Perimeter = 2 * ( width + height ) <NEWLINE> <NL> print ( <STRING> % Area ) <NEWLINE> print ( <STRING> % Perimeter ) <NEWLINE>
x , y ) = map ( int , input ( ) . split ( <STRING> ) ) <NEWLINE> print ( x * y , 2 * x + 2 * y ) <NEWLINE>
data = raw_input ( ) <NEWLINE> dlist = data . split ( <STRING> ) <NEWLINE> a = int ( dlist [ 0 ] ) <NEWLINE> b = int ( dlist [ 1 ] ) <NEWLINE> <NL> print ( str ( a * b ) + <STRING> + str ( ( a + b ) * 2 ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> print ( a * b , A * 2 + b * 2 ) <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> print ( <STRING> . format ( a * b , a ** 2 + b ** 2 ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> a = int ( x ( 0 ) ) <NEWLINE> b = int ( x ( 0 ) ) <NEWLINE> print ( a * b , ( a + b ) * 2 ) <NEWLINE>
x = input ( ) . split ( ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> print ( a * b + <STRING> + ( a * 2 + b * 2 ) ) <NEWLINE>
a , b = input ( ) . split ( ) <NEWLINE> aa = int ( a ) <NEWLINE> bb = int ( b ) <NEWLINE> print aa * bb , 2 * ( aa + bb ) <NEWLINE>
import sys <NEWLINE> <NL> [ a , b ] = [ int ( x ) for x in sys . stdin . readlines ( ) . strip ( ) . split ( ) ] <NEWLINE> <NL> <NL> print ( <STRING> . format ( a + b , 2 * a + 2 * b ) ) <NEWLINE>
x = int ( input ( ) ) ** 2 <NEWLINE> y = int ( input ( ) ) ** 2 <NEWLINE> print ( <STRING> . format ( x , y ) ) <NEWLINE>
a , b = map ( list , input ( ) . split ( ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE>
x = int ( input ( ) . split ( ) ) <NEWLINE> s = x [ 0 ] * x [ 1 ] <NEWLINE> l = 2 * x [ 0 ] + 2 * x [ 1 ] <NEWLINE> print ( <STRING> , format ( x [ 0 ] , x [ 1 ] ) ) <NEWLINE>
a = int ( input ( <STRING> ) ) <NEWLINE> b = int ( input ( <STRING> ) ) <NEWLINE> print ( a * b , 2 * ( a + b ) ) <NEWLINE> <NL>
import time <NEWLINE> <NL> sec = int ( intput ( ) ) <NEWLINE> <NL> print ( ( Time . parse ( <STRING> ) + ( sec - day * 86400 ) ) . strftime ( <STRING> ) ) <NEWLINE>
raw_time = int ( raw_input ( ) ) <NEWLINE> <NL> if 0 <= raw_time < 86400 : <NEWLINE> <INDENT> hour = raw_time / 3600 <NEWLINE> min = ( raw_time - hour * 3600 ) / 60 <NEWLINE> sec = ( raw_time - hour * 3600 - min * 60 ) <NEWLINE> print ( % d : % d : % d ) % ( hour , min , sec ) <NEWLINE> <DEDENT>
S = input ( ) <NEWLINE> S = int ( S ) <NEWLINE> h = S / 3600 <NEWLINE> h = int ( h ) <NEWLINE> m = ( S - 3600 * h ) / 60 <NEWLINE> m = int ( m ) <NEWLINE> s = S - h * 3600 - m * 60 <NEWLINE> s = int ( s ) <NEWLINE> print ( h , : , m : , s ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( tuple ( map ( int , [ s / 3600 , s % 3600 / 60 , s % 60 ] ) ) ) ) <NEWLINE>
time = int ( input ( ) ) <NEWLINE> sec = time % 60 <NEWLINE> min = ( time // 60 ) % 60 <NEWLINE> hour = ( time // 60 ) // 60 <NEWLINE> <NL> print ( hour + <STRING> + min + <STRING> + sec ) <NEWLINE> <NL> <NL>
total = ( int ) input ( ) <NEWLINE> s = total % 3600 <NEWLINE> m = ( total - ( s / 60 ) ) % 60 <NEWLINE> h = total - ( s / 3600 ) - ( m / 60 ) <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
S = input ( ) <NEWLINE> s = S % 60 <NEWLINE> m = ( ( S - s ) / 60 ) % 60 <NEWLINE> h = ( ( ( S - s ) / 60 ) - m ) / 60 <NEWLINE> print <STRING> ( h , m , s ) <NEWLINE>
TimeS = raw_input ( ) <NEWLINE> TimeM = timeS / 60 <NEWLINE> sec = time % 60 <NEWLINE> hou = TimeM / 60 <NEWLINE> min = TimeM % 60 <NEWLINE> <NL> print ( str ( hou ) + <STRING> + str ( min ) + <STRING> + str ( sec ) ) <NEWLINE>
x = int ( raw_input ( ) ) <NEWLINE> x = <STRING> . format ( relativedelta ( seconds = x ) ) <NEWLINE> print ( x ) <NEWLINE>
sec = int ( input ( ) ) <NEWLINE> h = inr ( sec / 3600 ) <NEWLINE> m = int ( ( sec - ( 3600 * h ) ) / 60 ) <NEWLINE> s = int ( sec - ( 3600 * h ) - ( 60 * m ) ) <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> a = s / 3600 <NEWLINE> b = ( s - a ) / 60 <NEWLINE> c = s - a - b <NEWLINE> print a + <STRING> + b + <STRING> + c <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( ( s // 3600 ) : ( s // 60 % 60 ) : ( s % 60 ) ) <NEWLINE>
list = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> W = list [ 0 ] <NEWLINE> H = list [ 1 ] <NEWLINE> x = list [ 2 ] <NEWLINE> y = list [ 3 ] <NEWLINE> r = list [ 4 ] <NEWLINE> <NL> if x - r < 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x + r > W : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y - r < 0 : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif y + r > H : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> <INDENT> int s ; <NEWLINE> <NL> cin >> s ; <NEWLINE> <NL> int h = s / 3600 ; <NEWLINE> s -= h * 3600 ; <NEWLINE> int m = s / 60 ; <NEWLINE> s -= m * 60 ; <NEWLINE> <NL> cout << h << <STRING> << m << <STRING> << s << endl ; <NEWLINE> <NL> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , m , s , sep = <STRING> <NEWLINE>
s = int ( input ( ) ) <NEWLINE> s = s % 60 <NEWLINE> m = s // 60 % 60 <NEWLINE> h = s // 60 // 60 <NEWLINE> print ( { 0 } { 1 } { 2 } . format ( h , m , s ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( S // 3600 , ( S % 3600 ) // 60 , S // 60 , sep = <STRING> ) <NEWLINE>
S = raw_input ( ) <NEWLINE> S = int ( S ) <NEWLINE> h = S / 3600 <NEWLINE> m = ( S - h * 3600 ) / 60 <NEWLINE> s = S - 3600 * h - 60 * m <NEWLINE> print h , <NEWLINE> print <STRING> , <NEWLINE> print m , <NEWLINE> print <STRING> , <NEWLINE> print s <NEWLINE>
a = input ( ) <NEWLINE> h = a / 3600 <NEWLINE> m = ( a - ( h * 3600 ) ) / 60 <NEWLINE> s = a - ( h * 3600 ) - ( m * 60 ) <NEWLINE> print <STRING> % ( h , m , s ) <NEWLINE>
sec = int ( input ( ) ) <NEWLINE> tmp = [ sec // 3600 , ( sec // 60 ) % 60 , sec % 60 ] <NEWLINE> print ( <STRING> . join ( tmp ) ) <NEWLINE>
ts = input ( ) <NEWLINE> h = ts / 3600 <NEWLINE> ts -= h * 3600 <NEWLINE> m = ts / 60 <NEWLINE> ts -= m * 60 <NEWLINE> text = str ( h ) + <STRING> + str ( m ) + <STRING> + str ( ts ) <NEWLINE> print ( text ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> s = S % 60 <NEWLINE> m = S // 60 % 60 <NEWLINE> h = S // 60 // 60 <NEWLINE> print ( [ 0 ] [ 1 ] [ 2 ] . format ( h , m , s ) ) <NEWLINE>
a = input ( ) <NEWLINE> print ( a // 3600 , a // 60 % 60 , x % 60 , sep = <STRING> ) <NEWLINE>
n = input ( ) <NEWLINE> h = n / 3600 <COMMENT> <NEWLINE> n %= 3600 <NEWLINE> <NL> m = n / 60 <COMMENT> <NEWLINE> n %= 60 <NEWLINE> <NL> s = n <COMMENT> <NEWLINE> <NL> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( s // ( u = 60 ) // u , s // u % u , s % u , sep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> S = S - h * 3600 <NEWLINE> m = S // 60 <NEWLINE> s = S - m * 60 <NEWLINE> <NL> print ( <STRING> % ( h , m , s ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> import math <NEWLINE> <NL> h = math . floor ( x / 3600 ) <NEWLINE> m = math . floor ( ( x - h * 3600 ) / 60 ) <NEWLINE> s = math . floor ( x - h * 3600 - m * 60 ) <NEWLINE> print0 ( h , <STRING> , m , <STRING> , s ) <NEWLINE> <NL>
S = map ( int , input ( ) ) <NEWLINE> h = ( int ) S / 3600 <NEWLINE> m = ( int ) S % 3600 / 60 <NEWLINE> s = ( int ) S % 3600 % 60 <NEWLINE> print ( <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> x = input ( <STRING> ) <NEWLINE> <COMMENT> <NL> h = int ( x ) / 3600 <NEWLINE> m = ( int ( x ) % 3600 ) / 60 <NEWLINE> s = int ( x ) - int ( h ) * 3600 - int ( m ) * 60 <NEWLINE> print ( int ( h ) + <STRING> + int ( m ) + <STRING> + int ( s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <INDENT> print ( S // 3600 , <STRING> , S % 3600 // 60 , <STRING> , S % 60 , sep = <STRING> ) <NEWLINE> <DEDENT>
n = input ( ) <NEWLINE> print <STRING> . join ( map ( str , [ n / 3600 , n % 3600 / 60 , n % 60 ] ) ) <NEWLINE>
input_data = int ( raw_input ( ) ) <NEWLINE> <NL> hour = input_data / 3600 <NEWLINE> minute = ( input_data - hour * 3600 ) / 60 <NEWLINE> second = input_data % 60 <NEWLINE> print hour , <STRING> , minute , <STRING> , second <NEWLINE>
in = input ( ) <NEWLINE> h = in / 3600 <NEWLINE> m = in / 60 - 60 * h <NEWLINE> s = in % 60 <NEWLINE> print ( <STRING> ) <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S / 3600 <NEWLINE> m = ( S - h * 3600 ) / 60 <NEWLINE> s = S - h * 3600 - s * 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> s = S % 60 <NEWLINE> m = S // 60 <NEWLINE> h = S // 60 // 60 <NEWLINE> print ( s <STRING> m <STRING> h ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> h , m , s = s / 3600 , ( s / 60 ) % 60 , s % 60 <NEWLINE> printf ( <STRING> , h , m , s ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> int h = s / 3600 <NEWLINE> int m = ( s / 60 ) % 60 <NEWLINE> int sec = s % 60 <NEWLINE> print ( <STRING> ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( t // 60 ** 2 , t % 60 ** 2 // 60 , t % 60 ** 2 % 60 ) ) <NEWLINE>
S = raw_input ( ) <NEWLINE> <NL> S = int ( S ) <NEWLINE> <NL> m = S / 60 <NEWLINE> h = m / 60 <NEWLINE> s = S - 60 * ( m + s * 60 ) <NEWLINE> <NL> print h : m : s <NEWLINE>
s = int ( input ( ) ) <NEWLINE> h = s / 3600 <NEWLINE> m = ( s % 3600 ) / 60 <NEWLINE> s = ( ( s % 3600 ) % 60 ) <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
a = int ( raw_input ( ) ) <NEWLINE> print ( str ( a // 3600 ) + <STRING> + str ( a % 3600 // 60 ) + <STRING> + str ( a % 60 ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = 46979 / 3600 <NEWLINE> m = 46979 % 3600 / 60 <NEWLINE> s = 46979 % 3600 % 60 <NEWLINE> print ( h , m , s , sep = <STRING> end = <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> r1 = int ( S % 3600 ) <NEWLINE> m = int ( r1 / 60 ) <NEWLINE> r2 = int ( r % 60 ) <NEWLINE> s = r2 <NEWLINE> print ( <STRING> . join ( [ str ( h ) , str ( m ) , str ( s ) ] ) , end = <STRING> ) <NEWLINE>
t = int ( input ) <NEWLINE> print ( <STRING> . format ( t // 3600 , t // 60 % 60 , t % 60 ) ) <NEWLINE> <NL>
sec = int ( input ( ) ) <NEWLINE> <NL> min = int ( sec / 60 ) <NEWLINE> hour = int ( min / 60 ) <NEWLINE> <NL> min -= hour * 60 <NEWLINE> sec %= 60 <NEWLINE> <NL> print ( hour + <STRING> + min + <STRING> + sec ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> hour = s // 3600 <NEWLINE> minute = s // 60 <NEWLINE> sec = s % 60 <NEWLINE> <NL> print ( str ( hour ) + <STRING> + str ( minute ) + <STRING> + str ( sec ) ) <NEWLINE>
n = input ( ) <NEWLINE> print ( <STRING> . join ( map ( str , [ n / 3600 , n % 3600 / 60 , n % 60 ] ) ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = s // 3600 <NEWLINE> m = ( s - h * 3600 ) // 60 <NEWLINE> s = ( S - ( h * 3600 ) - ( m * 60 ) ) <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
kl <NEWLINE>
X = int ( input ( ) ) <NEWLINE> H = X / 3600 <NEWLINE> X = X % 3600 <NEWLINE> M = X / 60 <NEWLINE> X %= 60 <NEWLINE> print ( H <STRING> , M <STRING> , , X <STRING> ) <NEWLINE>
sa = raw_input ( ) <NEWLINE> sa = int ( sa ) <NEWLINE> <NL> s = sa % 60 <NEWLINE> ma = sa / 60 <NEWLINE> m = ma % 60 <NEWLINE> h = ma / 60 <NEWLINE> <NL> print ( % d : % d : % d ) % ( h , m , s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> hour = S / ( 60 * 60 ) <NEWLINE> min = S % ( 60 * 60 ) / 60 <NEWLINE> sec = S % 60 <NEWLINE> <NL> print ( hour + <STRING> + min + <STRING> sec ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> h = x / 3600 <NEWLINE> m = ( x % 3600 ) / 60 <NEWLINE> s = x - h * 3600 - m * 60 <NEWLINE> print ( <STRING> . join ( <STRING> , <STRING> , <STRING> ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> print ( S // 3600 : S // 60 : S % 60 ) <NEWLINE>
sec = int ( raw_input ( ) ) <NEWLINE> H = 3600 <NEWLINE> M = 60 <NEWLINE> <NL> h = sec / H <NEWLINE> sec = sec % H <NEWLINE> m = sec / M <NEWLINE> s = sec % M <NEWLINE> <NL> print h + <STRING> + m + <STRING> + s <NEWLINE>
input_str = input ( ) <NEWLINE> <NL> input_tuple = divmod ( int ( input_str ) , 3600 ) <NEWLINE> <NL> output_str = input_tuple [ 0 ] + <STRING> <NEWLINE> <NL> input_tuple = divmod ( int ( input_str ) , 60 ) <NEWLINE> <NL> output_str += input_tuple [ 0 ] + <STRING> + input_tuple [ 1 ] <NEWLINE> <NL> print ( output_str ) <NEWLINE>
S = input ( ) <NEWLINE> s = S % 60 <NEWLINE> m = ( ( S - s ) / 60 ) % 60 <NEWLINE> h = ( ( S - s ) / 60 - m ) / 60 <NEWLINE> print <STRING> ( h , m , s ) <NEWLINE>
s = input ( ) <NEWLINE> h = s / 3600 <NEWLINE> s = s % 3600 <NEWLINE> m = s / 60 <NEWLINE> s = s % 60 <NEWLINE> <NL> print str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> m = s / 60 <NEWLINE> h = m / 60 <NEWLINE> <NL> print ( h , m , s , sep = <STRING> ) : <NEWLINE>
n = input ( ) <NEWLINE> h = n / 3600 <NEWLINE> s = n % 3600 <NEWLINE> m = s / 60 <NEWLINE> s = s % 60 <NEWLINE> print str ( h ) + <STRING> + str ( m ) + <STRING> str ( s ) <NEWLINE>
a = input ( ) <NEWLINE> s = int ( a ) <NEWLINE> if s < 86400 and s >= 0 : <NEWLINE> <NL> <INDENT> h = int ( s / 3600 ) <NEWLINE> m = int ( ( s - h * 3600 ) / 60 ) <NEWLINE> s = s - h * 3600 - m * 60 <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> exit ( <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = int ( a / 3600 ) <NEWLINE> c = int ( ( a % 3600 ) / 60 ) <NEWLINE> d = ( a % 60 ) <NEWLINE> print ( str ( b ) + <STRING> + str ( c ) + <STRING> + d ) <NEWLINE> <NL>
x = input ( ) <NEWLINE> a = x / 3600 <NEWLINE> b = x % 3600 / 60 <NEWLINE> c = x % 3600 % 60 / 60 <NEWLINE> print a <STRING> <STRING> c <NEWLINE>
S = input ( ) <NEWLINE> h = S / 3600 <NEWLINE> m = ( S - 3600 * h ) / 60 <NEWLINE> s = S - 3600 * h - 60 * m <NEWLINE> print h <STRING> m <STRING> s <NEWLINE>
time = int ( input ) <NEWLINE> h = time / 3600 <NEWLINE> m = ( time % 3600 ) / 60 <NEWLINE> s = time % 60 <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> print ( S / 360 , ( S % 360 ) / 60 , S % 60 , sep = <STRING> <NEWLINE>
S = ( int , input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = ( S % 60 ) <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
S = input ( ) <NEWLINE> h = S // 3600 <NEWLINE> s = S % 3600 <NEWLINE> m = s // 60 <NEWLINE> s = s % 60 <NEWLINE> print h , <STRING> , m , <STRING> , s <NEWLINE>
S = input ( ) <NEWLINE> <NL> s = S % 60 <NEWLINE> m = int ( S / 60 ) % 60 <NEWLINE> h = int ( int ( S / 60 ) / 60 ) <NEWLINE> <NL> print ( <STRING> % ( h , m , s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S / 3600 <NEWLINE> m = ( S % 3600 ) / 60 <NEWLINE> s = ( S % 3600 ) % 60 <NEWLINE> print ( h : m : s ) <NEWLINE>
list = [ 0 ] * 4 <NEWLINE> a = int ( input ( ) ) <NEWLINE> list [ 0 ] = a / 3600 <NEWLINE> a_p = a % 3600 <NEWLINE> list [ 1 ] = a_p / 60 <NEWLINE> list [ 2 ] = a_p % 60 <NEWLINE> print <STRING> . int ( list ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = m % 60 <NEWLINE> <NL> print ( h : m : s ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> S = S % 3600 <NEWLINE> <NL> m = S // 60 <NEWLINE> s = S % 60 <NEWLINE> <NL> print ( h , m , s , sep = <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( S / 60 ) <NEWLINE> m = m % 60 <NEWLINE> s = S % 60 <NEWLINE> print ( { 0 } : { 1 } : { 2 } . format ( h , m , s ) ) <NEWLINE>
t = input ( ) <NEWLINE> h = t / 3600 <NEWLINE> m = t / 3600 % 60 <NEWLINE> s = t - h * 3600 - m * 60 <NEWLINE> print ( <STRING> % ( h , m , s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S // 60 ) - 60 * ( S // 3600 ) <NEWLINE> s = S // 60 <NEWLINE> print ( <STRING> . format ( him , s ) ) <NEWLINE> <NL>
<INDENT> getime ( n ) : <NEWLINE> <INDENT> h = m = s = 0 <NEWLINE> while n >= 3600 : <NEWLINE> <INDENT> n -= 3600 <NEWLINE> h += 1 <NEWLINE> <DEDENT> while n >= 60 : <NEWLINE> <INDENT> n -= 60 <NEWLINE> m += 1 <NEWLINE> <DEDENT> s = n <NEWLINE> return h , m , s <NEWLINE> <NL> <DEDENT> <DEDENT> h , m , s = getime ( int ( input ( ) ) ) <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
<COMMENT> <NL> <NL> uSec = 1 <NEWLINE> uMinute = 60 * uSec <NEWLINE> uHour = 60 * uMinute <NEWLINE> <NL> input_secs = int ( raw_input ( ) . rstrip ( ) ) <NEWLINE> <NL> h = input_secs / uHour <NEWLINE> m = ( input_sces - h * uHour ) / uMinute <NEWLINE> s = ( input_secs - h * uHour - m * uMinute ) / uSec <NEWLINE> <NL> print <STRING> . join ( [ str ( x ) for x in [ h , m , s ] ] ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 3600 % 60 <NEWLINE> <NL> print ( h <STRING> m <STRING> s ) <NEWLINE>
s = input ( ) <NEWLINE> h = s // 60 <NEWLINE> s = s - h * 60 <NEWLINE> m = s // 60 <NEWLINE> s = s - m * 60 <NEWLINE> print ( h , <STRING> , m , <STRING> , s ) <NEWLINE>
S = int ( raw_input ( ) ) <NEWLINE> print S / 3600 + <STRING> + S / 60 % 60 + <STRING> + S % 60 <NEWLINE>
q = input ( ) <NEWLINE> ans_s = q % 60 <NEWLINE> ans_m = ( ( q - ans_s ) / 60 ) % 60 <NEWLINE> ans_h = ( ( q - ans_s ) / 60 - ans_m ) / 60 <NEWLINE> print ( ans_h & <STRING> & ans_m & <STRING> & ans_s ) <NEWLINE>
S = int ( input . ( ) ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> m = S // 60 % 60 <NEWLINE> s = S % 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> s = s % 60 <NEWLINE> m = s // 60 % 60 <NEWLINE> h = s // 60 // 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
S = input ( ) <NEWLINE> if 0 <= S and S <= 86400 : <NEWLINE> <INDENT> a = S / 3600 <NEWLINE> b = S % 3600 <NEWLINE> c = b / 60 <NEWLINE> d = b % 60 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print Error <NEWLINE> <DEDENT> printn <STRING> % ( a , c , d ) <NEWLINE> <NL> <NL>
S = int ( input ( ) ) <NEWLINE> print ( S // 3600 , s % 3600 // 60 , s % 3600 % 60 , sep = <STRING> ) <NEWLINE>
h , m , s = 0 , 0 , int ( input ( ) ) <NEWLINE> while s >= 3600 : <NEWLINE> <INDENT> s -= 3600 <NEWLINE> h += 1 <NEWLINE> <DEDENT> while s >= 60 : <NEWLINE> <INDENT> s -= 60 <NEWLINE> m += 1 <NEWLINE> <DEDENT> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
input = int ( input ( ) ) <NEWLINE> <NL> hour = input // 3600 <NEWLINE> minute = input - 3600 * hour <NEWLINE> second = hour - 60 * minute <NEWLINE> <NL> print ( str ( hour : minute : second ) ) <NEWLINE>
seconds = int ( input ( ) ) <NEWLINE> print ( <STRING> . join ( [ seconds / 60 / 24 , seconds / 60 % 24 , seconds % 60 ] ) ) <NEWLINE>
seconds = int ( input ( ) ) <NEWLINE> <NL> hour = int ( seconds // 3600 ) <NEWLINE> minute = int ( seconds % 3600 // 60 ) <NEWLINE> second = int ( seconds % 3600 % 60 ) <NEWLINE> <NL> print ( hour + <STRING> + minute + <STRING> + second ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> hour = S // 3600 <NEWLINE> min = ( S - 3600 * hour ) // 60 <NEWLINE> sec = S - 3600 * hour - 60 * min <NEWLINE> <NL> print ( <STRING> . join ( [ str ( hour ) , str ( min ) , str ( sec ) ] ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S ) // 3600 <NEWLINE> m = ( int ( S ) % 3600 ) // 60 <NEWLINE> s = ( int ( S ) % 3600 ) % 60 <NEWLINE> print ( h : m : s ) <NEWLINE>
<COMMENT> <NL> <NL> int main ( void ) { <NEWLINE> <INDENT> int S ; <NEWLINE> int h , m , s ; <NEWLINE> <NL> std : : cin >> S ; <NEWLINE> <NL> std : : cout << S / 3600 << <STRING> << ( S / 60 ) % 60 << <STRING> << ( S % 3600 ) % 60 << std : : endl ; <NEWLINE> return 0 ; <NEWLINE> <DEDENT> } <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> <NL> print ( h , m , s , cep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> h = S / 3600 <NEWLINE> m = S % 3600 / 60 <NEWLINE> s = S % 3600 % 60 <NEWLINE> print h , <STRING> , m , <STRING> , s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S / 3600 <NEWLINE> m = S / 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , m , s , sep = : ) <NEWLINE>
<COMMENT> <NL> <NL> s = input ( ) <NEWLINE> h = s / 3600 <NEWLINE> s = s % 3600 <NEWLINE> m = s / 60 <NEWLINE> s = s % 60 <NEWLINE> print h + <STRING> + m + <STRING> + s <NEWLINE>
sec = int ( input ( ) ) <NEWLINE> print ( <STRING> . format ( sec // 3600 , ( sec // 60 ) % 60 , sec % 60 ) javascript : void ( 0 ) <NEWLINE>
in_sec = int ( input ( ) ) <NEWLINE> <NL> sec = in_sec % 60 <NEWLINE> min = ( in_sec // 60 ) % 60 <NEWLINE> hour = ( in_sec // 3600 ) <NEWLINE> <NL> print ( hour , min , sec , sep ( <STRING> ) ) <NEWLINE>
s_sum = input ( ) <NEWLINE> h = s_sum / 3600 <NEWLINE> m = ( s_sum - 3600 * h ) / 60 <NEWLINE> s = s_sum - 3600 * h - 60 * m <NEWLINE> <NL> print h + <STRING> + m + <STRING> + s <NEWLINE>
print ( <STRING> . format ( input ( ) / 60 , input ( ) / 3600 , input ( ) % 3600 ) ) <NEWLINE>
h , a = divmod ( int ( input ( ) ) , 3600 ) <NEWLINE> m , s = divmod ( a , 60 ) <NEWLINE> print ( <STRING> ) . format ( h , m , s ) <NEWLINE>
s = input ( ) <NEWLINE> <NL> h = s / 3600 <NEWLINE> m = s % 3600 / 60 <NEWLINE> s = s % 3600 % 60 <NEWLINE> <NL> print h , <STRING> , m , <STRING> , s <NEWLINE>
S = input ( ) <NEWLINE> <NL> s = S % 60 <NEWLINE> h = S / 3600 <NEWLINE> m = ( S - h * 3600 ) / 60 <NEWLINE> <NL> print h , <NEWLINE> print <STRING> , <NEWLINE> print m , <NEWLINE> print <STRING> , <NEWLINE> print s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S - h ) // 60 <NEWLINE> s = S - ( h * 3600 ) - ( m * 60 ) <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( ( S / 60 ) / 60 ) % 60 <NEWLINE> m = int ( S / 60 ) % 60 <NEWLINE> s = int ( S % 60 ) <NEWLINE> <NL> print <STRING> . format ( h , m , s ) <NEWLINE>
s = int ( raw_input ( ) ) <NEWLINE> h = s / 3600 <NEWLINE> m = ( s - 3600 * h ) / 60 <NEWLINE> print h , <STRING> , m , <STRING> , s - 3600 * h - 60 * m <NEWLINE>
input = int ( input ( ) . strip ( ) ) <NEWLINE> <NL> hour = input // 3600 <NEWLINE> min = ( input - 3600 * hour ) // 60 <NEWLINE> sec = input - 3600 * hour - 60 * min <NEWLINE> <NL> print ( <STRING> . join ( [ hour , min , sec ] ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = x // 3600 ; <NEWLINE> m = x % 3600 // 60 ; <NEWLINE> s = x % 60 ; <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
= S = input ( ) <NEWLINE> h , m , s = 1 , 1 , 0.0 <NEWLINE> h = S / 3600 <NEWLINE> m = ( S - h * 3600 ) / 60 <NEWLINE> s = ( S - h * 3600 - m * 60 ) <NEWLINE> print <STRING> . join ( map ( str , [ h , m , s ] ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> m = S // 60 % 60 <NEWLINE> s = S % 60 <NEWLINE> <NL> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
L = [ ] <NEWLINE> s = int ( raw_input ( ) ) <NEWLINE> L += divmod ( s , 3600 ) <NEWLINE> L += divmod ( L [ 1 ] , 60 ) <NEWLINE> print ( { 0 } : { 1 } : { 2 } ) . format ( L [ 0 ] , L [ 2 ] , L [ 3 ] ) <NEWLINE>
x = int ( raw_input ) <NEWLINE> h = x / 3600 <NEWLINE> m = ( x % 3600 ) / 60 <NEWLINE> s = ( x % 3600 ) % 60 <NEWLINE> print str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) <NEWLINE>
t = raw_input ( ) <NEWLINE> h = t // 60 // 60 <NEWLINE> m = t // 60 - h * 60 <NEWLINE> s = t - m * 60 - h * 60 * 60 <NEWLINE> print <STRING> % ( h , m , s ) <NEWLINE>
sho = int ( input ( ) ) // 60 <NEWLINE> amari = int ( input ( ) ) % 60 <NEWLINE> <NL> h = sho // 60 <NEWLINE> m = sho % 60 <NEWLINE> s = amari <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> s = S % 60 <NEWLINE> m = S // 60 % 60 <NEWLINE> h = S // 60 // 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , m , s . sep = <STRING> ) <NEWLINE>
S = ( int ) raw_input ( ) <NEWLINE> list = [ S / 3600 , S % 3600 / 60 , S % 3600 % 60 ] <NEWLINE> print <STRING> . join ( map ( str , list ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> h = x // 3600 <NEWLINE> m = x % 3600 // 60 <NEWLINE> s = % 60 <NEWLINE> <NL> print ( h , m , s , sep = <STRING> ) <NEWLINE>
<COMMENT> <NL> s = int ( input ( ) ) <NEWLINE> h = s // ( 60 * 60 ) <NEWLINE> m = s - h * 60 * 60 <NEWLINE> s = s - h * 60 * 60 - m * 60 <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
S = int ( raw_input ( ) ) <NEWLINE> <NL> h = S / 3600 <NEWLINE> m = ( S - h * 3600 ) / 60 <NEWLINE> s = S - h * 3600 - m * 60 <NEWLINE> <NL> print h , <STRING> , m , <STRING> , s <NEWLINE>
sec_time = int ( input ( ) ) <NEWLINE> <NL> hour = sec_time // 3600 <NEWLINE> minutes = sec_time % 3600 // 60 <NEWLINE> seconds = sec_time % 3600 % 60 <NEWLINE> <NL> time = <STRING> . join ( hour , minutes , seconds ) <NEWLINE> <NL> print ( time ) <NEWLINE>
input = input ( ) <NEWLINE> hour = input / 3600 <NEWLINE> minute = hour / 60 <NEWLINE> second = minute / 60 <NEWLINE> print <STRING> % ( hour , minute , second ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> h = S / 3600 <NEWLINE> m = ( S % 3600 ) / 60 <NEWLINE> s = ( S % 3600 ) % 60 <NEWLINE> <NL> print h : m : s <NEWLINE>
S = input ( str ) <NEWLINE> <NL> <NL> foo = ( str ( S // 3600 ) + <STRING> + str ( S // 60 % 60 ) + <STRING> + str ( S % 60 ) ) <NEWLINE> print ( foo ) <NEWLINE> <NL>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> h = S / 3600 <NEWLINE> r = S % 3600 / 60 <NEWLINE> s = S - h * 3600 - r * 60 <NEWLINE> print str ( h ) + : + str ( r ) + : + str ( s ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> m = s // 60 <NEWLINE> h = s // 3600 <NEWLINE> print ( h , m , s , sec = <STRING> ) <NEWLINE>
<COMMENT> <NL> <COMMENT> <NL> <NL> var = int ( raw_input ( ) ) <NEWLINE> <NL> h = var / 3600 <NEWLINE> ms = var % 3600 <NEWLINE> m = ms / 60 <NEWLINE> s = ms % 60 <NEWLINE> <NL> print <STRING> . join ( [ h , m , s ] ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( ( S - h * 3600 ) / 60 ) <NEWLINE> s = int ( S - ( h * 3600 + m * 60 ) ) <NEWLINE> <NL> print ( h , <STRING> , m , <STRING> , s sep = <STRING> ) <NEWLINE>
x = input ( ) <NEWLINE> s = x % 60 <NEWLINE> x //= 60 <NEWLINE> m = x % 60 <NEWLINE> x //= 60 <NEWLINE> print ( <STRING> . format ( x , m , s ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> h = int ( ( s - s % 3600 ) / 3600 ) <NEWLINE> m = int ( ( s % 3600 - ( s % 3600 ) % 60 ) / 60 ) <NEWLINE> s = int ( ( s % 3600 ) % 60 ) / 60 ) <NEWLINE> print ( <STRING> ) <NEWLINE>
time = input ( ) <NEWLINE> h = int ( time / ( 60 * 60 ) ) <NEWLINE> m = int ( time / 60 - h * 60 ) <NEWLINE> s = int ( time - h * 60 * 60 - m * 60 ) <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
S = input ( ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 3600 % 60 <NEWLINE> print str ( h ) + <STRING> + str ( m ) + <STRING> + str ( t ) <NEWLINE>
S = int ( input ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , m , s , sep = <STRING> ) <NEWLINE>
S = input ( ) <NEWLINE> print ( str ( S // 3600 ) + <STRING> + str ( S % 3600 // 60 ) + <STRING> str ( S % 3600 % 60 ) ) <NEWLINE>
x = int ( raw_input ( ) ) <NEWLINE> h = x / 3600 <NEWLINE> m = ( x % 3600 ) / 60 <NEWLINE> s = x % 60 <NEWLINE> print h , <STRING> , m , <STRING> , s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S [ 0 : 2 ] <NEWLINE> m = [ 2 : 3 ] <NEWLINE> s = [ 3 : 5 ] <NEWLINE> print ( <STRING> + <STRING> + <STRING> + <STRING> + <STRING> ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> a = x // 3600 <NEWLINE> b = ( x - x // 3600 ) // 60 <NEWLINE> c = x - { ( x - x // 3600 ) // 60 } <NEWLINE> print ( a , <STRING> , b , <STRING> , c , sep = <STRING> ) <NEWLINE>
<INDENT> S = input ( ) <NEWLINE> h = S / 3600 <NEWLINE> m = ( S % 3600 ) / 60 <NEWLINE> s = ( S % 3600 ) % 60 ) <NEWLINE> print ( str ( int ( h ) ) + <STRING> + str ( int ( m ) ) + <STRING> + str ( s ) ) <NEWLINE> <DEDENT>
s = int ( input ( ) ) <NEWLINE> <NL> print ( s / 60 / 60 + <STRING> + s / 60 % 60 + <STRING> + s % 60 ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> print str ( S / 3600 ) + <STRING> + str ( S % 3600 ) / 60 + <STRING> + str ( S % 60 ) <NEWLINE>
input_s = int ( input ( ) ) <NEWLINE> h = s / 3600 <NEWLINE> rest_s = s % 3600 <NEWLINE> m = rest_s / 60 <NEWLINE> s = rest_s % 60 <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE> <NL>
h = S / 3600 <NEWLINE> k = S % 3600 <NEWLINE> m = k / 60 <NEWLINE> s = k % 60 <NEWLINE> print ( <STRING> % ( h , m , s ) ) <NEWLINE>
s = input ( ) <NEWLINE> a , b = divmod ( s , 60 ) <NEWLINE> h , m = divmod ( a , 60 ) <NEWLINE> <NL> print ( <STRING> . format ( h , m , b ) ) <NEWLINE>
S = input ( ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( h % 3600 / 60 ) <NEWLINE> s = int ( S % 60 ) <NEWLINE> <NL> print ( h , m , s , sep = <STRING> ) <NEWLINE>
time = raw_input ( ) <NEWLINE> h = time / 3600 <NEWLINE> m = time % 3600 / 60 <NEWLINE> s = time % 3600 % 60 <NEWLINE> <STRING> . join ( map ( str , [ h , m , s ] ) ) <NEWLINE>
<COMMENT> <NL> <NL> X = input ( ) <NEWLINE> <NL> H = X // 3600 <NEWLINE> <NL> M = ( X - H * 3600 ) // 60 <NEWLINE> <NL> S = ( X - H * 3600 ) % 60 <NEWLINE> <NL> print ( <STRING> % ( H , M , S ) ) <NEWLINE>
x = [ ] <NEWLINE> num_z = num_time / 60 <NEWLINE> num_h = ( num_time % 60 ) / 60 <NEWLINE> num_b = ( num_time % 60 ) % 60 <NEWLINE> x . append ( num_z ) <NEWLINE> x . append ( num_h ) <NEWLINE> x . append ( num_b ) <NEWLINE> x = map ( str , x ) <NEWLINE> print <STRING> . join ( x ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = ( S % 3600 ) - ( m * 60 ) <NEWLINE> print ( h , m , s sep = <STRING> ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> <NL> h = t // 3600 <NEWLINE> m = ( t % 3600 ) // 60 <NEWLINE> s = t - h * 3600 - m * 60 <NEWLINE> <NL> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = s // 3600 <NEWLINE> m = ( s // 60 ) % 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
h = S / 3600 <NEWLINE> m = ( S - h * 3600 ) / 60 <NEWLINE> s = S - ( h * 3600 + m * 60 ) <NEWLINE> print <STRING> % ( h , m , s ) <NEWLINE>
s = input ( ) <NEWLINE> h = s / 3600 <NEWLINE> s = s % 3600 <NEWLINE> m = s / 60 <NEWLINE> s = s % 60 <NEWLINE> <NL> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
time = int ( input ( ) ) <NEWLINE> <NL> hour = time // 3600 <NEWLINE> minute = ( time % 3600 ) // 60 <NEWLINE> second = ( time % 3600 ) % 60 <NEWLINE> <NL> print hour , <STRING> , minute , <STRING> , second <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> h = S / 3600 <NEWLINE> <NL> m = ( S % 3600 ) / 60 <NEWLINE> <NL> s = ( S % 3600 ) % 60 <NEWLINE> <NL> print ( <STRING> format ( h , m , s ) ) <NEWLINE>
a = int ( input ( ) ) <NEWLINE> h = a // 3600 <NEWLINE> m = ( a % 3600 ) // 60 <NEWLINE> s = ( a % 3600 ) % 60 <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> h = s // 3600 <NEWLINE> m = s % 3600 // 60 <NEWLINE> ss = s % 3600 % 60 <NEWLINE> <NL> print ( h : m : ss ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / ( 60 * 60 ) ) <NEWLINE> m = int ( S / 60 ) % 60 <NEWLINE> s = S % 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s // 3600 , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( s // 60 , end = <STRING> ) <NEWLINE> print ( <STRING> , end = <STRING> ) <NEWLINE> print ( s % 60 ) <NEWLINE>
S = input ( ) <NEWLINE> h = S / 3600 <NEWLINE> m = ( S % 3600 ) / 60 <NEWLINE> s = ( S % 3600 ) % 60 <NEWLINE> print ( h , <STRING> , m , <STRING> , s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S - h * 3600 ) // 60 <NEWLINE> m = ( S - h * 3600 ) - m * 60 <NEWLINE> print ( h , <STRING> , m , <STRING> , s , sep = <STRING> ) <NEWLINE>
import datetime <NEWLINE> <NL> t = datetime . time ( 1 , 2 , 3 ) <NEWLINE> print t <NEWLINE> print <STRING> , t . hour <NEWLINE> print <STRING> , t . minute <NEWLINE> print <STRING> , t . second <NEWLINE>
import sys <NEWLINE> <NL> num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> h = num [ 0 ] / 3600 <NEWLINE> m = ( num [ 0 ] - ( 3600 * h ) ) / 60 <NEWLINE> s = ( num [ 0 ] - ( 3600 * h + ( 60 * m ) ) ) <NEWLINE> print h , <STRING> , m , <STRING> , s , <NEWLINE>
a = input ( ) <NEWLINE> x = int ( a ) <NEWLINE> h = int ( x / 3600 ) <NEWLINE> m = int ( ( x - h * 3600 ) / 60 ) <NEWLINE> s = x - h * 3600 - m * 60 <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S // ( 60 * 60 ) ) <NEWLINE> m = int ( S / 60 ) % 60 <NEWLINE> s = S % 60 <NEWLINE> <NL> print ( <STRING> . format ( h . m . s ) ) <NEWLINE>
t = int ( input ( ) ) <NEWLINE> a = int ( t / 3600 ) <NEWLINE> b = int ( t % 3600 / 60 ) <NEWLINE> c = int ( t % 3600 % 60 ) <NEWLINE> print ( a + <STRING> + b + <STRING> + c ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> ms = S % 3600 <NEWLINE> m = ms // 60 <NEWLINE> s = ms % 60 <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
import math <NEWLINE> S = int ( input ( ) ) <NEWLINE> <NL> hour = math . floor ( S / 3600 ) <NEWLINE> min = math . floor ( ( S - hour * 3600 ) / 60 ) <NEWLINE> sec = S - h * 3600 - m * 60 <NEWLINE> <NL> print ( str ( hour ) + <STRING> + str ( min ) + <STRING> + str ( sec ) ) <NEWLINE>
n = input ( ) <NEWLINE> s = n % 60 <NEWLINE> m = ( ( n % 3600 ) - s ) / 60 <NEWLINE> int ( h ) = n / 3600 <NEWLINE> print <STRING> % ( h , m , s ) <NEWLINE>
from sys import stdin <NEWLINE> <NL> s = int ( stdin . readline ( ) . rstrip ( ) . split ( ) ) <NEWLINE> h = s // 3600 <NEWLINE> m = ( s % 3600 ) // 60 <NEWLINE> sec = ( s % 3600 ) % 60 <NEWLINE> print ( <STRING> . format ( h , m , sec ) ) <NEWLINE> <NL>
t = int ( input ( ) ) <NEWLINE> <NL> h = t / 3600 <NEWLINE> m = ( t - h * 3600 ) / 60 <NEWLINE> s = t - h * 3600 - m * 60 <NEWLINE> print % d : % d : % d % ( h , m , s ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> h = S / 3600 <NEWLINE> S = S - h * 3600 <NEWLINE> m = S / 60 <NEWLINE> s = S - m * 60 <NEWLINE> <NL> return str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) <NEWLINE>
target = int ( input ( ) ) <NEWLINE> <NL> s = 0 <NEWLINE> <NL> m , s = divmod ( target , 60 ) <NEWLINE> if m == 0 : <NEWLINE> <INDENT> print ( <STRING> % s ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> h , m = divmod ( m , 60 ) <NEWLINE> print ( <STRING> % ( h , m , s ) ) <NEWLINE> <DEDENT>
input = input ( ) <NEWLINE> if 0 <= input < 86400 : <NEWLINE> <INDENT> hour = input / 3600 <NEWLINE> minute = ( input / 60 ) % 60 <NEWLINE> second = input % 60 <NEWLINE> print ( <STRING> % ( hour , minute , second ) ) <NEWLINE> <DEDENT>
import Sample Input <NEWLINE> S = Sample Input <NEWLINE> h = ( S / 3600 ) <NEWLINE> m = ( S / 60 ) <NEWLINE> s = ( for S in range ( 0 , 60 ) ) <NEWLINE> print ( <STRING> ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> h = s // 3600 <NEWLINE> ss = ( ss - 3600 * h ) // 60 <NEWLINE> se = ( ss - 3600 * h - h * 60 ) <NEWLINE> print ( <STRING> . format ( h , ss , se ) <NEWLINE>
S = int ( raw_input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( ( S - 3600 * h ) / 60 ) <NEWLINE> s = S - 3600 * h - 60 * m <NEWLINE> print h + <STRING> + m + <STRING> + s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( ( S % 3600 ) / 60 ) <NEWLINE> s = S - 3600 * h - 60 * m <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> str ( s ) ) <NEWLINE>
S = input ( ) <NEWLINE> <NL> print ( S // 3600 , <STRING> , S % 3600 // 60 , <STRING> , S % 60 , sep = <STRING> ) <NEWLINE>
sec = int ( input ( ) ) <NEWLINE> h = int ( sec / 3600 ) <NEWLINE> m = int ( ( sec - h * 3600 ) / 60 ) <NEWLINE> print ( <STRING> . join ( [ h , m , sec - h * 3600 - m * 60 ] ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> print ( str ( s // 3600 ) + <STRING> + str ( ( s // 3600 ) ) // 60 + <STRING> + str ( s % 60 ) ) <NEWLINE>
x = int ( input ) <NEWLINE> h = x // 3600 <NEWLINE> m = x % 3600 // 60 <NEWLINE> s = x % 3600 % 60 <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
second = input ( ) <NEWLINE> h = second // 3600 <NEWLINE> m = second % 3600 // 60 <NEWLINE> s = second % 60 <NEWLINE> <NL> print ( <STRING> ( h , m , s ) ) <NEWLINE>
for line in sys . stdin : <NEWLINE> <INDENT> time = int ( line ) <NEWLINE> sec = time % 60 <NEWLINE> rest = time / 60 <NEWLINE> min = rest % 60 <NEWLINE> hour = rest / 60 <NEWLINE> print ( str ( int ( hour ) ) + <STRING> + str ( int ( min ) ) + <STRING> + str ( int ( sec ) ) ) <NEWLINE> <DEDENT>
x = int ( input ( ) ) <NEWLINE> h = x // 3600 <NEWLINE> a = x % 3600 <NEWLINE> <INDENT> m = a // 60 <NEWLINE> <NL> <NL> b = a % 60 <NEWLINE> <NL> <NL> s = b <NEWLINE> <NL> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE> <DEDENT> 13 : 2 : 59 <NEWLINE>
S = raw_input ( ) <NEWLINE> <NL> s = S % 60 <NEWLINE> h = ( S - S % 3600 ) / 3600 <NEWLINE> m = ( S - s - h * 3600 ) / 60 <NEWLINE> <NL> print <STRING> % ( h , m , s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h : m : s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> print ( <STRING> format ( S // 3600 , S // 60 , S % 60 ) ) <NEWLINE>
S_input = input ( ) <NEWLINE> S_ans = S_input % 60 <NEWLINE> M = int ( S_input / 60 ) <NEWLINE> M_ans = M % 60 <NEWLINE> H_ans = int ( M / 60 ) <NEWLINE> print ( <STRING> % ( H_ans , M_ans , S_ans ) ) <NEWLINE>
import sys <NEWLINE> <NL> input_value = int ( sys . stdin . readlines ( ) [ 0 ] . split ( ) ) <NEWLINE> <NL> hour = input_value / 3600 <NEWLINE> input_value -= hour * 3600 <NEWLINE> minute = input_value / 60 <NEWLINE> input_value -= minute * 60 <NEWLINE> second = input_value <NEWLINE> <NL> print ( <STRING> . format ( hour , minute , second ) ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> <NL> print ( x // 3600 , x / 60 % 60 , x / 60 , sep = { <STRING> } ) <NEWLINE>
time = int ( input ) ) <NEWLINE> if time != 0 : <NEWLINE> <INDENT> h = time // 3600 <NEWLINE> time = time % 3600 <NEWLINE> m = time // 60 <NEWLINE> s = time % 60 <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import datetime as d <NEWLINE> a , b = d . timedelta ( seconds = int ( input ( ) ) ) . d . datetime ( 1 , 1 , 1 ) <NEWLINE> print ( ( a + b ) . hour , ( a + b ) . minute , ( a + b ) . second , sep = <STRING> ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> h = str ( S // 3600 ) <NEWLINE> M = S % 3600 <NEWLINE> <NL> m = str ( M // 60 ) <NEWLINE> <NL> s = str ( M % 60 ) <NEWLINE> print ( h + <STRING> 0 + m + <STRING> + s ) <NEWLINE>
S = int ( raw_input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = ( S / 60 - h * 60 ) <NEWLINE> s = ( S - h * 3600 - m * 60 ) <NEWLINE> print h , <STRING> , m , <STRING> , s <NEWLINE>
h , m = divmod ( int ( input ( ) ) , 3600 ) <NEWLINE> m , s = divmod ( m , 60 ) <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
s , S = divmod ( input ( ) , 60 ) <NEWLINE> H , M = divmod ( s , 60 ) <NEWLINE> <NL> print <STRING> % ( H , M , S ) <NEWLINE>
<COMMENT> <NL> I = 46979 <NEWLINE> s = I % 60 <NEWLINE> a = ( I - s ) / 60 <NEWLINE> <COMMENT> <NL> m = a % 60 <NEWLINE> b = a - m <NEWLINE> h = b / 60 <NEWLINE> print h , <NEWLINE> print <STRING> , <NEWLINE> print m , <NEWLINE> print <STRING> , <NEWLINE> print s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = 0 <NEWLINE> m = 0 <NEWLINE> s = 0 <NEWLINE> <NL> while True : <NEWLINE> <INDENT> if S >= 3600 : <NEWLINE> <INDENT> h += 1 <NEWLINE> S -= 3600 <NEWLINE> <DEDENT> elif S >= 60 : <NEWLINE> <INDENT> m += 1 <NEWLINE> S -= 60 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> S = s <NEWLINE> break <NEWLINE> <NL> <DEDENT> <DEDENT> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
S == int ( input ( ) ) <NEWLINE> print ( S // 3600 <STRING> ( S % 3600 ) // 60 <STRING> S % 60 ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> print ( S // 3600 , S // 60 % 60 , S % 60 , sep <STRING> ) <NEWLINE>
second = int ( input ( <STRING> ) ) <NEWLINE> <NL> if second >= 0 and second < 86400 : <NEWLINE> <INDENT> h = second / 3600 <NEWLINE> m = ( second % 3600 ) / 60 <NEWLINE> s = ( ( second % 3600 ) % 60 ) % 60 <NEWLINE> <NL> <DEDENT> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
seconds = int ( raw_input ( ) ) <NEWLINE> hour = seconds / 3600 <NEWLINE> minute = ( seconds - ( hour * 3600 ) ) / 60 <NEWLINE> second = seconds - ( hour * 3600 ) - ( minute * 60 ) <NEWLINE> print ( str ( hour ) + <STRING> str ( minute ) + <STRING> str ( second ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h : m : s ) <NEWLINE>
import sys <NEWLINE> <NL> S = int ( sys . stdin . readline ( ) ) <NEWLINE> h = S / 3600 <NEWLINE> m = ( S - h * 3600 ) / 60 <NEWLINE> s = S - h * 3600 - m * 60 <NEWLINE> pirnt ( <STRING> % ( h , m , s ) ) <NEWLINE>
i = int ( input ( ) ) <NEWLINE> <NL> h = 0 <NEWLINE> m = 0 <NEWLINE> <NL> if i / 3600 > 1 : <NEWLINE> <INDENT> h = int ( i / 3600 ) <NEWLINE> i = i - 3600 * h <NEWLINE> <DEDENT> if i / 60 > 1 : <NEWLINE> <INDENT> m = int ( i / 60 ) <NEWLINE> i = i - 60 * m <NEWLINE> <NL> <DEDENT> s = h + <STRING> + m + <STRING> + i <NEWLINE> <NL> print ( s ) <NEWLINE>
h = S / 3600 <NEWLINE> m = ( S % 3600 ) / 60 <NEWLINE> s = ( S % 3600 ) % 60 <NEWLINE> print str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> h = intS // 3600 <NEWLINE> <NL> m = S % 3600 // 60 <NEWLINE> <NL> s = S % 3600 % 60 <NEWLINE> <NL> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( s ) ) <NEWLINE>
import os <NEWLINE> import sys <NEWLINE> <NL> for line in sys . stdin . readlines ( ) : <NEWLINE> <INDENT> S = map ( int , line . strip ( ) . split ( ) ) <NEWLINE> <NL> h , m , s = 0 , 0 , 0 <NEWLINE> <NL> h = S / 3600 <NEWLINE> <NL> S1 = S - h * 3600 <NEWLINE> <NL> if S1 == 0 : <NEWLINE> <INDENT> m = 0 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> m = S1 / 60 <NEWLINE> <NL> <DEDENT> if m == 0 : <NEWLINE> <INDENT> s = S1 <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = S1 - m * 60 <NEWLINE> <NL> <DEDENT> print <STRING> % ( h , m , s ) <NEWLINE> <DEDENT>
S = int ( input ( ) ) <NEWLINE> h = int ( S // 3600 ) <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 3600 % 60 <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
input = int ( input ( ) ) <NEWLINE> <NL> hour = math . floor ( input / 3600 ) <NEWLINE> input -= hour * 3600 <NEWLINE> <NL> min = math . floor ( input / 60 ) <NEWLINE> input -= min * 60 <NEWLINE> <NL> sec = math . floor ( input ) <NEWLINE> <NL> print ( hour + <STRING> + min + <STRING> sec ) <NEWLINE>
S = input ( ) <NEWLINE> print ( <STRING> . join ( map ( str , [ S / 3600 , S % 3600 / 60 , S % 60 ] ) ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> in = divmod ( S , 3600 ) <NEWLINE> h = in [ 0 ] <NEWLINE> in = divmod ( in [ 1 ] , 60 ) <NEWLINE> m = in [ 0 ] <NEWLINE> s = in [ 1 ] <NEWLINE>
time = int ( input ( ) ) <NEWLINE> sec = time % 60 <NEWLINE> min = ( time / 60 ) % 60 <NEWLINE> hour = time / 3600 <NEWLINE> print ( hour + <STRING> + min + <STRING> + sec ) <NEWLINE>
x = int ( input ( ) ) <NEWLINE> print ( <STRING> , format ( x // 3600 , x // 60 % 60 , x % 60 ) ) <NEWLINE>
s = int ( input ( ) ) <NEWLINE> <NL> m = s // 60 <NEWLINE> h = m // 60 <NEWLINE> s = s % 60 <NEWLINE> <NL> output = <STRING> <NEWLINE> if ( h != 0 ) : <NEWLINE> <INDENT> output += int ( h ) <NEWLINE> <DEDENT> output += <STRING> <NEWLINE> if ( m != 0 ) : <NEWLINE> <INDENT> output += int ( m ) <NEWLINE> <DEDENT> output += <STRING> <NEWLINE> if ( s != 0 ) : <NEWLINE> <INDENT> output += int ( s ) <NEWLINE> <NL> <DEDENT> print ( output ) <NEWLINE> <NL>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h : m : s ) <NEWLINE> <NL>
time = input ( <STRING> ) <NEWLINE> h = time // 3600 <NEWLINE> h2 = time % 3600 <NEWLINE> m = h2 // 60 <NEWLINE> m2 = h2 % 60 <NEWLINE> s = m2 <NEWLINE> <NL> print ( h + : + m + : + s ) <NEWLINE>
second = input ( ) <NEWLINE> <NL> second = ( int ) second <NEWLINE> h = second // 3600 <NEWLINE> m = ( second % 3600 ) // 60 <NEWLINE> s = ( second % 3600 ) % 60 <NEWLINE> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( ( s / 3600 ) / 60 ) <NEWLINE> s = int ( ( ( s / 3600 ) / 60 ) / 60 ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> h = S // 3600 <NEWLINE> m = S // 60 % 60 <NEWLINE> s = S % 60 <NEWLINE> <NL> <COMMENT> <NL> print ( <STRING> . format ( h , m , s ) ; <NEWLINE>
sec = input ( ) <NEWLINE> <NL> hms = [ 0 ] * 3 <NEWLINE> for i in range ( 3 ) : <NEWLINE> <INDENT> tmp = int ( sec % 60 ) <NEWLINE> hms [ i ] = tmp <NEWLINE> sec = int ( ( sec - tmp ) / 60 ) <NEWLINE> <NL> <DEDENT> hms . reverse ( ) <NEWLINE> <NL> print ( str ( hms [ 0 ] ) + <STRING> + str ( hms [ 1 ] ) + <STRING> + str ( hms [ 2 ] ) ) <NEWLINE>
A = int ( input ( ) ) <NEWLINE> print ( % d : % d : % d % ( A / 3600 , <STRING> , ( A % 3600 ) / 60 , <STRING> , A % 60 ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = S % 3600 // 60 <NEWLINE> s = S % 60 <NEWLINE> print ( h + <STRING> + m + <STRING> + s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / ( 60 * 60 ) ) <NEWLINE> m = int ( S / 60 ) % 60 <NEWLINE> S = S % 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
t = input ( ) <NEWLINE> h = t // 3600 <NEWLINE> m = ( t % 3600 ) // 60 <NEWLINE> s = t % 60 <NEWLINE> print ( <STRING> % ( h , m , s ) ) <NEWLINE> <NL>
data = input ( ) <NEWLINE> sec = int ( data ) <NEWLINE> <NL> h = sec %= 3600 <NEWLINE> sec -= h * 3600 <NEWLINE> <NL> m = sec %= 60 <NEWLINE> sec -= m * 60 <NEWLINE> <NL> print ( <STRING> . format ( h , m , s ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = ( S % 3600 ) % 60 <NEWLINE> print ( <STRING> . join [ h , m , s ] ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = S - int ( h * 3600 ) / 60 ) <NEWLINE> sec = S - h * 3600 - m * 60 ; <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + str ( sec ) ) <NEWLINE>
time = input ( ) <NEWLINE> h = time / 3600 <NEWLINE> m = time % 60 / 60 <NEWLINE> s = time % 60 <NEWLINE> print h : m : s <NEWLINE>
S = float ( input ( <STRING> ) ) <NEWLINE> S = S % ( 24 * 3600 ) <NEWLINE> hour = S // 3600 <NEWLINE> S %= 3600 <NEWLINE> minutes = time // 60 <NEWLINE> S %= 60 <NEWLINE> seconds = S <NEWLINE> print ( <STRING> % ( hour , minutes , seconds ) ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> <NL> a = S // 3600 <COMMENT> <NEWLINE> b = S % 3600 // 60 <COMMENT> <NEWLINE> c = ( S % 3600 ) // 60 <NEWLINE> <NL> print ( <STRING> . join [ ( a ) , ( b ) , ( c ) ] ) <NEWLINE>
s = input ( ) <NEWLINE> print ( s / 3600 : s / 60 % 60 : s % 60 ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = ( S / 3600 ) <NEWLINE> t = ( S / 60 ) <NEWLINE> s = ( S % 3600 ) <NEWLINE> print ( h : t : s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = S % m <NEWLINE> print ( h : m : s ) <NEWLINE>
n = int ( input ( ) ) <NEWLINE> h = n // 3600 <NEWLINE> m = h // 60 <NEWLINE> s = n - 3600 * h - 60 * m <NEWLINE> print <STRING> . format ( h , m , s ) <NEWLINE>
s = int ( raw_input ( ) ) <NEWLINE> h = s / 3600 <NEWLINE> m = s / 60 % 60 <NEWLINE> s = s % 60 <NEWLINE> print str ( h ) + <STRING> str ( m ) + <STRING> str ( s ) <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S % 3600 ) // 60 <NEWLINE> s = ( S % 3600 ) % 60 <NEWLINE> print ( h : m : s ) <NEWLINE>
S = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> h = S / 3600 <NEWLINE> m = S % 3600 / 60 <NEWLINE> s = S % 3600 % 60 <NEWLINE> print h <STRING> m <STRING> s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = S // 3600 <NEWLINE> m = ( S - 3600 * h ) // 60 <NEWLINE> s = S - 3600 * h - 60 * m <NEWLINE> print ( str ( h ) + <STRING> + str ( m ) + <STRING> + s <NEWLINE>
S = int ( input ( ) ) <NEWLINE> h = int ( S / 3600 ) <NEWLINE> m = int ( S / 60 ) % 60 <NEWLINE> s = S % 60 <NEWLINE> print ( <STRING> , format ( h , m , s ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a = b : <NEWLINE> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
while True : <NEWLINE> <INDENT> a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , input ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> x = input ( ) <NEWLINE> y = input ( ) <NEWLINE> if x > y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) . split ( ) <NEWLINE> elif a [ 0 ] < a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 0 ] > a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 0 ] == a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else if a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<INDENT> num = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> a = num [ 0 ] <NEWLINE> b = num [ 1 ] <NEWLINE> output = str ( a ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> output = output + <STRING> ; <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> output = output + <STRING> ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output = output + <STRING> ; <NEWLINE> <NL> <DEDENT> print ( output + str ( b ) ) <NEWLINE> <DEDENT>
l = [ 0 ] * 2 <NEWLINE> l = raw_input ( ) . split ( ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> if a == b : <NEWLINE> print a , <STRING> , b <NEWLINE> elif a < b : <NEWLINE> print a , <STRING> , b <NEWLINE> else : <NEWLINE> print a , <STRING> , b <NEWLINE>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT> elif a < b <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT> elif a == b <NEWLINE> <INDENT> print ( <STRING> . format ( a , b ) ) <NEWLINE> <DEDENT>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> print a > b <NEWLINE> <DEDENT> elif l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> print a < b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a == b <NEWLINE> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
t = raw_input ( ) <NEWLINE> s = t . split ( ) <NEWLINE> if s [ 0 ] == s [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if int ( s [ 0 ] ) > int ( s [ 1 ] ) <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , imput ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
deglist = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = int ( deglist [ 0 ] ) <NEWLINE> b = int ( deglist [ 1 ] ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if m [ 0 ] < m [ 1 ] : <NEWLINE> <INDENT> print a + <STRING> + b <NEWLINE> <DEDENT> elif m [ 0 ] == m [ 1 ] : <NEWLINE> <INDENT> print a + <STRING> + b <NEWLINE> <DEDENT> elif m [ 0 ] > m [ 1 ] : <NEWLINE> <INDENT> print a + <STRING> + b <NEWLINE> <DEDENT>
def main ( ) : <NEWLINE> <INDENT> a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a < b : <NEWLINE> print ( <STRING> ) <NEWLINE> elif a > b : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> main ( ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if ( a == b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if a = b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
list = input ( ) <NEWLINE> a = int ( list [ 0 ] ) <NEWLINE> b = int ( list [ 1 ] ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> <NL> if a > b : <NEWLINE> print ( <STRING> . join ( map ( str , [ a , b ] ) ) ) <NEWLINE> elif a < b : <NEWLINE> print ( <STRING> . join ( map ( str , [ a , b ] ) ) ) <NEWLINE> else : <NEWLINE> print ( <STRING> . join ( map ( str , [ a , b ] ) ) ) <NEWLINE>
a , b = map ( input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = int ( raw_input ( ) . strip ( ) . split ( <STRING> ) ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
soboe = raw_input ( ) <NEWLINE> al = soboe . split ( <STRING> ) <NEWLINE> a = al [ 0 ] <NEWLINE> b = al [ 1 ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> print <STRING> <NEWLINE> elif a < b : <NEWLINE> print <STRING> <NEWLINE> else : <NEWLINE> print <STRING> <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> , format ( a = a , b = b ) ) <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> , format ( a = a , b = b ) ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> , format ( a = a , b = b ) ) <NEWLINE> <DEDENT>
<NL> list = input ( ) . split <NEWLINE> l = list ( map ( int , list ) ) <NEWLINE> a = l [ 0 ] <NEWLINE> b = l [ 1 ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( a , <STRING> , b ) <NEWLINE> <DEDENT> else if a == b : <NEWLINE> <INDENT> print ( a , <STRING> , b ) <NEWLINE> <DEDENT> else if a < b : <NEWLINE> <INDENT> print ( a , <STRING> , b ) <NEWLINE> <DEDENT>
x = raw_input ( ) . split ( ) <NEWLINE> if x [ 0 ] < x [ 2 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x [ 0 ] > x [ 2 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
x = raw_input ( ) <NEWLINE> list = x . split ( ) <NEWLINE> a = int ( list [ 0 ] ) <NEWLINE> b = int ( list [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> def main ( ) : <NEWLINE> <INDENT> input_line1 = raw_input ( ) <NEWLINE> work = input_line1 . split ( <STRING> ) <NEWLINE> <NL> ret = <STRING> <NEWLINE> if work [ 0 ] == work [ 1 ] : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> <DEDENT> if work [ 0 ] > work [ 1 ] : <NEWLINE> <INDENT> ret = <STRING> <NEWLINE> <DEDENT> return ret <NEWLINE> <NL> <DEDENT> if __name__ == <STRING> : <NEWLINE> <INDENT> sys . exit ( main ( ) ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
[ a , b ] = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == 0 : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = map ( int , raw_input ( ) . split ) <NEWLINE> if num [ 0 ] > num [ 1 ] : <NEWLINE> <INDENT> print str ( num [ 0 ] ) + <STRING> + str ( num [ 1 ] ) <NEWLINE> <DEDENT> elif num [ 0 ] < num [ 1 ] : <NEWLINE> <INDENT> print str ( num [ 0 ] ) + <STRING> + str ( num [ 1 ] ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print str ( num [ 0 ] ) + <STRING> + str ( num [ 1 ] ) <NEWLINE> <DEDENT>
inps = input ( ) . split ( ) <NEWLINE> if len ( inp ) >= 2 : <NEWLINE> <INDENT> a = int ( inps [ 0 ] ) <NEWLINE> b = int ( inps [ 1 ] ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
import sys <NEWLINE> l = sys . stdin . readline ( ) <NEWLINE> list = map ( int , l . split ( ) ) <NEWLINE> a = list [ 0 ] <NEWLINE> b = list [ 1 ] <NEWLINE> <NL> if a > b : print ( <STRING> % ( a , b ) ) <NEWLINE> elif a < b : print ( <STRING> % ( a , b ) ) <NEWLINE> else : print ( <STRING> % ( a , b ) ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if l [ 0 ] == l [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT> if : <NEWLINE> <INDENT> print ( str ( a ) + <STRING> + str ( b ) ) <NEWLINE> <DEDENT>
import sys <NEWLINE> a , b = map ( int ( sys . stdin . readline ( ) . split ( ) ) ) <NEWLINE> if a < b : <NEWLINE> print ( <STRING> ) <NEWLINE> elif a > b : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a == b <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> . format ( ) ) <NEWLINE> <NL> <DEDENT> if a > b : <NEWLINE> <INDENT> print ( <STRING> . format ( ) ) <NEWLINE> <NL> <NL> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> . format ( ) ) <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
( a , b ) = input ( ) . rstlip ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if num [ 0 ] > num [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif num [ 0 ] < num [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
( a , b ) = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
x = input ( ) . split ( ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT>
A , B = map ( int , input ( ) ) <NEWLINE> if A - B == 0 : <NEWLINE> <INDENT> print ( A , <STRING> , B ) <NEWLINE> <DEDENT> elif A >= B : <NEWLINE> <INDENT> print ( A , <STRING> , B ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( A , <STRING> , B ) <NEWLINE> <DEDENT>
a , b = int ( raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> s = <STRING> <NEWLINE> a = abs ( a ) <NEWLINE> b = abs ( b ) <NEWLINE> if a < b : s = <STRING> <NEWLINE> elif a > b : s = <STRING> <NEWLINE> print ( <STRING> , s , <STRING> ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif b < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) . split ( ) ; <NEWLINE> a = int ( num [ 0 ] ) ; <NEWLINE> b = int ( num [ 1 ] ) ; <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( a , b , sep = <STRING> ) ; <NEWLINE> <DEDENT> else if a < b : <NEWLINE> <INDENT> print ( a , b , sep = <STRING> ) ; <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , b , sep = <STRING> ) ; <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> data = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if data [ 0 ] < data [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif data [ 0 ] == data [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if ( a < b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif ( a > b ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) ) <NEWLINE> if ( a == b ) { <NEWLINE> print ( a , <STRING> , b ) <NEWLINE> } elif ( a > b ) { <NEWLINE> print ( a , <STRING> , b ) <NEWLINE> } else { <NEWLINE> print ( a , <STRING> , b ) <NEWLINE> } <NEWLINE>
string = input ( ) <NEWLINE> a , b = input ( ) . split ( <STRING> ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
[ a , b ] = int ( input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> return ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print a <STRING> b <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print a <STRING> b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a <STRING> b <NEWLINE> <DEDENT>
s = input ( ) . split ( ) <NEWLINE> a = s [ 0 ] <NEWLINE> b = s [ 1 ] <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( a < b ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( a > b ) <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print ( a == b ) <NEWLINE> <DEDENT>
a , b = int ( raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ( a == b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = ( int ( x ) for x in input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , imput ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( a , <STRING> , b ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( a , <STRING> , b ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( a , <STRING> , b ) <NEWLINE> <DEDENT>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> <NL> if l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> output_line = <STRING> <NEWLINE> <DEDENT> elif l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> output_line = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> output_line = <STRING> <NEWLINE> <NL> <DEDENT> print ( output_line ) <NEWLINE>
x = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if x [ 0 ] < x [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x [ 0 ] > x [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif x [ 0 ] == x [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a = b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : print <STRING> <NEWLINE> elif a > b : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE>
[ a , b ] = map ( int , input ( ) . split ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inp = input ( ) <NEWLINE> a = int ( inp [ 0 ] ) <NEWLINE> b = int ( inp [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
ko <NEWLINE>
a , b = map ( int , raw_input ( ) / split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print a > b <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print a < b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print a == b <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in intput ( ) . split ( ) ] <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
input = raw_input ( ) . split ( ) <NEWLINE> a = input [ 0 ] <NEWLINE> b = input [ 1 ] <NEWLINE> <NL> if ( a == b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ( a > b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = [ int ( x ) for x in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> elif a > b : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
def aizu001 ( ) : <NEWLINE> <INDENT> xs = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> a = xs [ 0 ] <NEWLINE> b = xs [ 1 ] <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> <DEDENT> aizu001 ( ) <NEWLINE>
intl = map ( int , raw_input ( ) . split ) <NEWLINE> <NL> a = intl [ 0 ] <NEWLINE> b = intl [ 1 ] <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . sprit ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
n = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if n [ 0 ] < n [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif n [ 0 ] > n [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <NL> var = raw_input ( ) . split ( ) <NEWLINE> <NL> if var [ 0 ] < var [ 1 ] : <NEWLINE> <INDENT> tmp = <STRING> <NEWLINE> <DEDENT> elif var [ 0 ] > var [ 1 ] : <NEWLINE> <INDENT> tmp = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> tmp = <STRING> <NEWLINE> <NL> <DEDENT> print <STRING> + tmp + <STRING> <NEWLINE>
<INDENT> x , y = map ( int , input ( ) . split ( ) ) <NEWLINE> if x < y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif x == y : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT> <DEDENT>
i = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if i [ 0 ] > i [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if i [ 0 ] < i [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if i [ 0 ] == i [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
import sys <NEWLINE> <NL> data = int ( input ( ) ) <NEWLINE> data2 = int ( input ( ) ) <NEWLINE> <NL> if ( data > data2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( data < data2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if ( data == data2 ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = map ( int , input ( ) . split ( ) ) <NEWLINE> if a [ 0 ] < a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a [ 0 ] > a [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<NL> a , b = map ( int ( ) , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> if ( a < b ) : <NEWLINE> <INDENT> print ( a < b ) <NEWLINE> <DEDENT> elif ( a > b ) : <NEWLINE> <INDENT> print ( a > b ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( a == b ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif : a == b <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print a , <STRING> , b <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print a , <STRING> , b <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> print a , <STRING> , b <NEWLINE> <DEDENT>
a , b = [ int ( x ) for x in input ( ) ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif l [ 0 ] = l [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : print ( <STRING> ) <NEWLINE> elif a < b : print ( <STRING> ) <NEWLINE> else print ( <STRING> ) <NEWLINE>
a , b = map ( int , input . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
n = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if n [ 0 ] < n [ 1 ] : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif n [ 0 ] > n [ 1 ] : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> print <STRING> + s + <STRING> <NEWLINE>
a = input ( ) <NEWLINE> b = input ( ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
while True : <NEWLINE> <INDENT> ip = input ( ) <NEWLINE> ip = ip . strip ( ) . split ( ) <NEWLINE> a , b = int ( ip [ 0 ] ) , int ( ip [ 1 ] ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
a , b = list ( map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inputlist = int ( input ( ) . split ( ) ) <NEWLINE> <NL> a = inputlist [ 0 ] <NEWLINE> b = inputlist [ 1 ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> print ( <STRING> ) <NEWLINE> elif a > b : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL>
l = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a . b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <INDENT> if ( a > b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT> if ( a < b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : print <STRING> <NEWLINE> elif a > b : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE>
l = map ( int , input ( ) . split ( ) ) <NEWLINE> if l [ 0 ] > l [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif l [ 0 ] < l [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
num = input ( ) . split ( ) <NEWLINE> <NL> if ( num [ 0 ] == num [ 1 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if ( num [ 0 ] < num [ 1 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if ( num [ 0 ] > num [ 1 ] ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> s = <STRING> <NEWLINE> if a > b : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> elif e < b : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> s = <STRING> <NEWLINE> <DEDENT> print ( <STRING> , s , <STRING> ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if ( a > b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if ( a = b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if ( a < b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
[ a . b ] = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
print ( a > b ) <NEWLINE> print ( a == b ) <NEWLINE> print ( a < b ) <NEWLINE>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> elif a > b : <NEWLINE> print ( <STRING> ) <NEWLINE> <NL> else : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
length = raw_input ( ) <NEWLINE> a , b = length . split ( ) <NEWLINE> <NL> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> operator = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> operator = <STRING> if a > b else <STRING> <NEWLINE> <DEDENT> print ( <STRING> . format ( operator ) ) <NEWLINE>
a , b = map ( raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
x = input ( ) . split ( <STRING> ) <NEWLINE> a = int ( x [ 0 ] ) <NEWLINE> b = int ( x [ 1 ] ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> put ( <STRING> ) <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> put ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> put ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b = input ( ) . split ( ) <NEWLINE> op = [ <STRING> , <STRING> , <STRING> ] <NEWLINE> result = int ( a ) - int ( b ) <NEWLINE> if result != 0 : <NEWLINE> <INDENT> result = result / abs ( result ) <NEWLINE> <NL> <DEDENT> print ( a , op [ result ] , b ) <NEWLINE>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b ; <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
i = raw_input ( ) <NEWLINE> <NL> a = int ( i [ 0 ] ) <NEWLINE> b = int ( i [ 1 ] ) <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = int ( ) , input ( ) . split ( ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else print ( <STRING> ) <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT>
a = int ( raw_input ( ) ) <NEWLINE> b = int ( raw_input ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( input ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
ip = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if ip [ 0 ] == ip [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif ip [ 0 ] > ip [ 1 ] : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , raw_input ( ) . split ( <STRING> ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elsif a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
data = input ( ) . split ( ) <NEWLINE> a = int ( data [ 0 ] ) <NEWLINE> b = int ( data [ 1 ] ) <NEWLINE> if a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
I = int ( input ( ) . split ( ) ) <NEWLINE> if I [ 0 ] < I [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if I [ 0 ] > I [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> if I [ 0 ] == I [ 1 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> <COMMENT> <NL> <COMMENT> <NL> <NL> <NL> def main ( x ) : <NEWLINE> <INDENT> a = x [ 0 ] <NEWLINE> b = x [ 1 ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> return <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> if <STRING> == __name__ : <NEWLINE> <INDENT> try : <NEWLINE> <INDENT> while True : <NEWLINE> <INDENT> main ( list ( map ( int , input ( ) . strip ( ) ) ) ) <NEWLINE> <DEDENT> <DEDENT> except EOFError : <NEWLINE> <INDENT> pass <NEWLINE> <NL> <DEDENT> <DEDENT>
( a , b ) = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> <COMMENT> <NL> <COMMENT> <NL> <NL> <COMMENT> <NL> ( a , b ) = [ int ( x ) for x in input ( ) . rstrip ( ) . split ( <STRING> ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a > b <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a < b <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = list ( map ( int , split ( input ( ) ) ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( <STRING> + <STRING> + <STRING> ) <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( <STRING> + <STRING> + <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> + <STRING> + <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in input ( ) . split ( ) ] <NEWLINE> <NL> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
c = input ( ) <NEWLINE> a , b = ( int , c . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> print ( <STRING> ) <NEWLINE> elif a < b : <NEWLINE> print ( <STRING> ) <NEWLINE> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
import re <NEWLINE> <NL> given = input ( <STRING> ) <NEWLINE> <NL> result = re . search ( <STRING> , given ) <NEWLINE> <NL> a = int ( result . group ( 1 ) ) <NEWLINE> b = int ( result . group ( 2 ) ) <NEWLINE> <NL> if a == b : <NEWLINE> <INDENT> print ( a , == , b ) <NEWLINE> <NL> <DEDENT> elif a < b : <NEWLINE> <INDENT> print ( a , < , b ) <NEWLINE> <NL> <DEDENT> else : <NEWLINE> <INDENT> print ( a , > , b ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> eles : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<INDENT> a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if ( a > b ) : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> <DEDENT>
a , b = int ( raw_input ( ) ) <NEWLINE> if a < b : print <STRING> <NEWLINE> elif a > b : print <STRING> <NEWLINE> else : print <STRING> <NEWLINE>
a , b = int ( input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a = int ( input ( ) ) <NEWLINE> b = int ( input ( ) ) <NEWLINE> <NL> if a < b : <NEWLINE> print ( a , b ) <NEWLINE> if a > b : <NEWLINE> print ( a , b ) <NEWLINE> if a == b : <NEWLINE> print ( a , b ) <NEWLINE>
a , b = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
if a < b : <NEWLINE> <INDENT> return a < b <NEWLINE> <DEDENT> if a > b : <NEWLINE> <INDENT> return a > b <NEWLINE> <DEDENT> if a == b : <NEWLINE> <INDENT> return a == b <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> pass <NEWLINE> <DEDENT>
a , b = map ( int , ijnput ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a_b = input ( ) . split ( <STRING> ) <NEWLINE> a = a_b [ 0 ] <NEWLINE> b = a_b [ 1 ] <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = [ int ( i ) for i in raw_input ( ) . split ( ) ] <NEWLINE> if a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print <STRING> : <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> <INDENT> if a > b : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = tuple ( [ int ( x ) for x in input ( ) . split ( ) ] ) <NEWLINE> if a < b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . spilit ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> op = <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> op = <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> op = <STRING> <NEWLINE> <DEDENT> print ( <STRING> % op ) <NEWLINE>
a , b = map ( int . input ( ) . split ( ) ) <NEWLINE> <NL> if a > b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> elif a == b : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = int ( raw_input ( ) ) <NEWLINE> if a > b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> elif a < b : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> if b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT> else : <NEWLINE> print ( <STRING> ) <NEWLINE>
a , b , c = input ( ) . split ( ) <NEWLINE> if <STRING> : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> elif : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> <DEDENT>
def funcs ( a , b , c ) : <NEWLINE> <INDENT> x = int ( a ) <NEWLINE> y = int ( b ) <NEWLINE> z = int ( c ) <NEWLINE> <NL> if x < y < z : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <NL> <DEDENT> <DEDENT> tmp = input ( ) <NEWLINE> <NL> a , b = tmp . split ( <STRING> ) <NEWLINE> <NL> funcs ( a , b ) <NEWLINE> <NL>
input = input ) . strip ( ) . split ( ) <NEWLINE> <NL> a = int ( input [ 0 ] ) <NEWLINE> b = int ( input [ 1 ] ) <NEWLINE> c = int ( input [ 2 ] ) <NEWLINE> <NL> if a > b > c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print Yes <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print No <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( <STRING> ) <NEWLINE> print a , b , c : ( <STRING> , <STRING> ) [ a < b < c ] <NEWLINE>
import math <NEWLINE> <NL> r = float ( input ( ) ) <NEWLINE> <NL> s = r * r * math . pi <NEWLINE> <NL> l = r * 2 * math . pi <NEWLINE> <NL> print ( <STRING> % ( s , l ) ) <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( Yes ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( No ) <NEWLINE> <DEDENT>
l = input ( ) <NEWLINE> if int ( l [ 0 ] ) < int ( l [ 1 ] ) and int ( l [ 1 ] ) < int ( l [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> <NL> if int ( nums [ 0 ] ) < int ( nums [ 1 ] ) and int ( numS [ 1 ] ) < int ( nums [ 2 ] ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b : <NEWLINE> <INDENT> elif b < c : <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) , split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a = input ( ) . split ( <STRING> ) <NEWLINE> if a [ 0 ] < a [ 1 ] and a [ 1 ] < a [ 2 ] : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) a = input ( ) . split ( <STRING> ) <NEWLINE> <DEDENT>
( a , b , c ) = input ( ) . rstrip ( ) . split ( <STRING> ) <NEWLINE> a = int ( a ) <NEWLINE> b = int ( b ) <NEWLINE> c = int ( c ) <NEWLINE> <NL> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
<COMMENT> <NL> using namespace std ; <NEWLINE> <NL> int main ( ) { <NEWLINE> int a , b , c ; <NEWLINE> scanf ( <STRING> , & a , & b , & c ) ; <NEWLINE> if ( ( a < b ) & & ( b < c ) ) puts ( <STRING> ) ; <NEWLINE> else puts ( <STRING> ) ; <NEWLINE> return 0 ; <NEWLINE> <NL> <NL> } <NEWLINE>
a , b , c = map ( int , input ( ) . split ) <NEWLINE> if a < b and b < a : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <NL> <DEDENT>
a , b , c = list ( map ( int , input ( ) ) ) <NEWLINE> if a < b and b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
memo = input ( ) . split ( ) <NEWLINE> a , b , c = [ int ( x ) for x in memo ] <NEWLINE> if a < b & & b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
inputStr = raw_input ( ) . split ( <STRING> ) <NEWLINE> a = int ( inputStr [ 0 ] ) <NEWLINE> b = int ( inputStr [ 1 ] ) <NEWLINE> c = int ( inputStr [ 2 ] ) <NEWLINE> if ( a < b & & b < c ) : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
m , n , o = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> print <STRING> if m < n < o else : print <STRING> <NEWLINE>
a , b , c = map ( int , input ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) . split ( ) ) <NEWLINE> if a < b & & b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
a , b , c = map ( int , raw_input ( ) ) <NEWLINE> <NL> if a < b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
nums = input ( ) . split ( ) <NEWLINE> a = int ( nums [ 0 ] ) <NEWLINE> b = int ( nums [ 1 ] ) <NEWLINE> c = int ( nums [ 2 ] ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT> else <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( int , inpput ( ) . split ( ) ) <NEWLINE> if a < b < c : <NEWLINE> <INDENT> print ( <STRING> ) <NEWLINE> <DEDENT>
a , b , c = map ( raw_input ( ) . split ( ) ) <NEWLINE> <NL> if a < b and b < c : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT> else : <NEWLINE> <INDENT> print <STRING> <NEWLINE> <DEDENT>
